<!DOCTYPE HTML>
<html><head><title>Adjunctions in the wild: foldl · in Code</title><meta name="description" content="Weblog of Justin Le, covering various adventures in programming and explorations in the worlds of computation physics, and knowledge.
"><meta http-equiv="Content-Type" content="text/html;charset=utf-8"><meta name="viewport" content="width=device-width,initial-scale=1.0"><meta name="flattr:id" content="3p9jqr"><meta property="og:site_name" content="in Code"><meta property="og:description" content="I recently made a few connections that linked some different concepts in Haskell that I hadn’t realized before. They deal with one of my favorite “practical” libraries in Haskell, and also one of the more “profound” category theory-inspired abstractions in Haskell. In the process, it made the library a bit more useful to me, and also made the concept a bit more concrete and understandable to me. This post mainly goes through my thought process in finding this out — it’s very much a “how I think through this” sort of thing — in the end, the goal is to show how much this example made me further appreciate the conceptual idea of adjunctions and how they can pop up in interesting places in practical libraries. Unlike most of my other posts, it’s not about necessarily about how practically useful an abstraction is, but rather what insight it gives us to understanding its instances. The audience of this post is Haskellers with an understanding/appreciation of abstractions like Applicative, but be aware that the final section is separately considered as a fun aside for those familiar with some of Haskell’s more esoteric types. The code samples used here (along with exercise solutions) are available on github."><meta property="og:type" content="article"><meta property="og:title" content="Adjunctions in the wild: foldl"><meta property="og:image" content="https://blog.jle.im/img/site_logo.jpg"><meta property="og:locale" content="en_US"><meta property="og:url" content="https://blog.jle.im/entry/foldl-adjunction.html"><meta name="twitter:card" content="summary"><meta name="twitter:creator:id" content="mstk"><link rel="author" href="https://plus.google.com/107705320197444500140"><link rel="alternate" type="application/rss+xml" title="in Code (RSS Feed)" href="http://feeds.feedburner.com/incodeblog"><link rel="canonical" href="https://blog.jle.im/entry/foldl-adjunction.html"><link href="https://blog.jle.im/favicon.ico" rel="shortcut icon"><link href="https://blog.jle.im/css/toast.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/font.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/main.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/page/entry.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/pygments.css" rel="stylesheet" type="text/css"><script type="text/javascript">var page_data = {};
var disqus_shortname='incode';
</script><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-443711-8', 'jle.im');
ga('send', 'pageview');
</script><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script id="MathJax-script" async="" src="https://cdn.jsdelivr.net/npm/mathjax@3.0.1/es5/tex-mml-chtml.js"></script><script type="text/javascript" src="//ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script><script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5234d67a6b68dcd4"></script><script type="text/javascript" src="https://blog.jle.im/js/page/entry_toc.js"></script><script type="text/javascript" src="https://blog.jle.im/js/disqus_count.js"></script><script type="text/javascript" src="https://blog.jle.im/js/social.js"></script><script type="text/javascript" src="https://blog.jle.im/js/jquery/jquery.toc.js"></script><script type="text/javascript" src="https://blog.jle.im/purescript/entry.js"></script></head><body><div id="fb-root"><script>(function(d, s, id) {
 var js, fjs = d.getElementsByTagName(s)[0];
 if (d.getElementById(id)) return;
 js = d.createElement(s); js.id = id;
 js.src = "//connect.facebook.net/en_US/all.js#xfbml=1&appId=641852699171929";
 fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));
</script></div><div id="header-container"><div id="navbar-container" class="tile"><nav id="navbar-content"><div class="nav-info"><h1 class="site-title"><a href="https://blog.jle.im/" class="nav-title">in Code</a></h1><span class="nav-author">Justin Le</span></div><ul class="nav-links"><li><a href="https://blog.jle.im/">home</a></li><li><a href="https://blog.jle.im/entries.html">archives</a></li><li><a href="https://cv.jle.im">cv</a></li><div class="clear"></div></ul></nav></div><div id="header-content"></div></div><div id="body-container" class="container"><div id="main-container" class="grid"><div class="entry-section unit span-grid" role="main"><article class="tile article"><header><h1 id="title">Adjunctions in the wild: foldl</h1><p class="entry-info">by <a class="author" href="https://blog.jle.im/">Justin Le</a><span class="info-separator"> &diams; </span><time datetime="2020-01-13T13:04:16Z" pubdate="" class="pubdate">Monday January 13, 2020</time></p><p><span class="source-info"><a class="source-link" href="https://github.com/mstksg/inCode/tree/master/copy/entries/foldl-adjunction.md">Source</a><span class="info-separator"> &diams; </span><a class="source-link" href="https://github.com/mstksg/inCode/tree/gh-pages/entry/foldl-adjunction.md">Markdown</a><span class="info-separator"> &diams; </span><a class="source-link" href="https://blog.jle.im/entry/foldl-adjunction.tex">LaTeX</a><span class="info-separator"> &diams; </span></span>Posted in <a href="https://blog.jle.im/entries/category/@haskell.html" class="tag-a-category" title="Functional, pure, non-strict, statically and strongly typed, natively
compiled...really just the king of great languages.
">Haskell</a>, <a href="https://blog.jle.im/entries/category/@math.html" class="tag-a-category" title="@MATH">Math</a><span class="info-separator"> &diams; </span><a class="comment-link" href="#disqus_thread">Comments</a></p></header><hr><aside class="contents-container"><h5 id="contents-header">Contents</h5><div id="toc"></div></aside><div class="main-content copy-content"><p>I recently made a few connections that linked some different concepts in Haskell that I hadn’t realized before. They deal with one of my favorite “practical” libraries in Haskell, and also one of the more “profound” category theory-inspired abstractions in Haskell. In the process, it made the library a bit more useful to me, and also made the concept a bit more concrete and understandable to me.</p>
<p>This post mainly goes through my thought process in finding this out — it’s very much a “how I think through this” sort of thing — in the end, the goal is to show how much this example made me further appreciate the conceptual idea of adjunctions and how they can pop up in interesting places in practical libraries. Unlike most of my other posts, it’s not about necessarily about how practically useful an abstraction is, but rather what insight it gives us to understanding its instances.</p>
<p>The audience of this post is Haskellers with an understanding/appreciation of abstractions like <code>Applicative</code>, but be aware that the final section is separately considered as a fun aside for those familiar with some of Haskell’s more esoteric types. The code samples used here (along with exercise solutions) are <a href="https://github.com/mstksg/inCode/tree/master/code-samples/adjunctions/foldl.hs">available on github</a>.</p>
<h2 id="foldl">foldl</h2>
<p>The first concept is the great <em><a href="http://hackage.haskell.org/package/foldl">foldl</a></em> library, which provides a nice “stream processor” type called <code>Fold</code>, where <code>Fold r a</code> is a stream processor that takes a stream of <code>r</code>s and produces an <code>a</code>:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span>           <span class="dt">Control.Foldl</span>   (<span class="dt">Fold</span>(..))</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Control.Foldl</span>   <span class="kw">as</span> <span class="dt">F</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>F.sum<span class="ot">  ::</span> <span class="dt">Num</span> a        <span class="ot">=&gt;</span> <span class="dt">Fold</span> a a</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>F.mean<span class="ot"> ::</span> <span class="dt">Fractional</span> a <span class="ot">=&gt;</span> <span class="dt">Fold</span> a a</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>F.elem<span class="ot"> ::</span> <span class="dt">Eq</span> a         <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Fold</span> a <span class="dt">Bool</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>F.fold F.sum  [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>]</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="pp">#   =&gt; 10</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>F.fold F.mean [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>]</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a><span class="pp">#   =&gt; 2.5</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>F.fold (F.elem <span class="dv">3</span>) [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>]</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a><span class="pp">#   =&gt; True</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>F.fold (F.elem <span class="dv">5</span>) [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>]</span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a><span class="pp">#   =&gt; False</span></span></code></pre></div>
<p>The most useful thing about the library is that it treats the folds as first-class objects, so you can create more complex folds by combining simpler folds (for example, with <code>-XApplicativeDo</code>)</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/adjunctions/foldl.hs#L22-L29</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="ot">variance ::</span> <span class="dt">Fractional</span> a <span class="ot">=&gt;</span> <span class="dt">Fold</span> a a</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>variance <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>    x  <span class="ot">&lt;-</span> F.mean</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>    x2 <span class="ot">&lt;-</span> lmap (<span class="op">^</span><span class="dv">2</span>) F.mean     <span class="co">-- the mean of squared items</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>    <span class="fu">pure</span> (x2 <span class="op">-</span> x<span class="op">*</span>x)</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a><span class="ot">varianceTooBig ::</span> (<span class="dt">Fractional</span> a, <span class="dt">Ord</span> a) <span class="ot">=&gt;</span> <span class="dt">Fold</span> a <span class="dt">Bool</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>varianceTooBig <span class="ot">=</span> (<span class="op">&gt;</span> <span class="dv">3</span>) <span class="op">&lt;$&gt;</span> variance</span></code></pre></div>
<p>Most importantly, <code>Fold r</code> is an instance of both <code>Functor</code> and <code>Applicative</code>, so you can map over and combine the results of different folds.</p>
<p>To me, <em>foldl</em> is one of the shining examples of how well Haskell works for data and stream processing, and a library I often show to people when they ask what the big deal is about Haskell abstractions like <code>Applicative</code>, purity, and lists — this technique is often described as “<a href="https://www.google.com/search?q=beautiful+folds">beautiful folds</a>”.</p>
<h2 id="adjunctions">Adjunctions</h2>
<p>The second concept is the idea of <em><a href="https://en.wikipedia.org/wiki/Adjoint_functors">adjoint functors</a></em> (see also <a href="https://bartoszmilewski.com/2016/04/18/adjunctions/">Bartosz Milewski’s introduction</a> and <a href="https://ncatlab.org/nlab/show/adjoint+functor">nlab</a>’s description, as well as <a href="https://www.math3ma.com/blog/what-is-an-adjunction-part-1">Tai-Danae Bradley’s motivation</a>), represented in Haskell by the <em><a href="https://hackage.haskell.org/package/adjunctions/docs/Data-Functor-Adjunction.html">adjunctions library and typeclass</a></em> (<a href="https://chrispenner.ca/posts/adjunction-battleship">Chris Penner</a> has a nice article with an example of using the typeclass’s utility functions to simplify programs).</p>
<p>For some functors, we can think of a “conceptual inverse”. We can ask “I have a nice functor <code>F</code>. Conceptually, what functor represents the opposite idea/spirit of <code>F</code>?” The concept of an adjunction is one way to formalize what this means.</p>
<p>In Haskell<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>, with the <code>Adjunctions</code> typeclass (specifically, <code>Functor</code> functors), this manifests as this: if <code>F -| U</code> (<code>F</code> is left adjoint to <code>U</code>, and <code>U</code> is right adjoint to <code>F</code>), then all the ways of going “out of” <code>F a</code> to <code>b</code> are the same as all the ways of going “into” <code>U b</code> from <code>a</code>. Ways of going out can be encoded as ways of going in, and vice versa. They represent opposite ideas.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- | The class saying you can always convert between:</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="co">--</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="co">-- * `f a -&gt; b` (the ways to go out of `f`)</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="co">-- * `a -&gt; u b` (the ways to go into `g`)</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Adjunction</span> f u <span class="kw">where</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>    leftAdjunct</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a><span class="ot">        ::</span> (f a <span class="ot">-&gt;</span> b)       <span class="co">-- ^ the ways of going &quot;out of&quot; `f`</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>        <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> u b)       <span class="co">-- ^ the ways of going &quot;into&quot; `u`</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>    rightAdjunct</span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a><span class="ot">        ::</span> (a <span class="ot">-&gt;</span> u b)       <span class="co">-- ^ the ways of going &quot;into&quot; u</span></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>        <span class="ot">-&gt;</span> (f a <span class="ot">-&gt;</span> b)       <span class="co">-- ^ the ways of going &quot;out of&quot; f</span></span></code></pre></div>
<h3 id="examples">Examples</h3>
<p>For example, one of the more famous adjunctions in Haskell is the adjunction between <code>(,) r</code> and <code>(-&gt;) r</code>. “Tupling” represents some sort of “opposite” idea to “parameterizing”.</p>
<p>The ways to get “out” of a tuple is <code>(r, a) -&gt; b</code>. The ways to go “into” a function is <code>a -&gt; (r -&gt; b)</code>. Haskellers will recognize that these two types are the “same” (isomorphic) — any <code>(a, b) -&gt; c</code> can be re-written as <code>a -&gt; (b -&gt; c)</code> (currying), and vice versa (uncurrying).</p>
<p>Another common pair is with same-typed either and tuple:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/adjunctions/foldl.hs#L31-L34</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">SameEither</span> a <span class="ot">=</span> <span class="dt">SE</span> (<span class="dt">Either</span> a a)</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">SameTuple</span>  a <span class="ot">=</span> <span class="dt">ST</span> (a, a)</span></code></pre></div>
<p>People familiar with <code>Either</code> (sums) and <code>(,)</code> (products) in Haskell will recognize them as “opposite” ideas — one is “or”, and the other is “and” (depending on if you are talking about using them or making them).</p>
<p>We can formalize this idea of opposites using adjunctions: Going “out of” <code>Either a a</code> into <code>b</code> can be encoded as going “into” <code>(b, b)</code> from <code>a</code>, and vice versa: <code>Either a a -&gt; b</code> can be encoded as <code>a -&gt; (b, b)</code>, which can be encoded as <code>Either a a -&gt; b</code> — the two types are isomorphic. This is because to go out of <code>Either a a</code>, you have to handle the situation of getting a <code>Left</code> and the situation of getting a <code>Right</code>. To go into <code>(b, b)</code>, you have to able to ask what goes in the first field, and what goes in the right field. Both <code>Either a a -&gt; b</code> and <code>a -&gt; (b, b)</code> have to answer the same questions. (A fun exercise would be to write the functions to convert between the two — <a href="https://github.com/mstksg/inCode/tree/master/code-samples/adjunctions/foldl.hs#L55-L56">one solution is here</a>)</p>
<h3 id="big-picture">Big Picture</h3>
<p>Aside from being an interesting curiosity (formalizing the idea of “opposite idea” is pretty neat), hunting for adjunctions can be useful in figuring out “why” a functor is useful, what you can do with it, and also what functors are intimately connected with it. There’s also the helper functions in the <a href="https://hackage.haskell.org/package/adjunctions/docs/Data-Functor-Adjunction.html">Data.Functor.Adjunction</a> module that implement some nice helper functions on your types if an adjoint happens to exist — you can do some neat things by going “back and forth” between adjoint functors.</p>
<h2 id="hunting-for-adjunctions">Hunting for Adjunctions</h2>
<p>So, from the build-up, you’ve probably guessed what we’re going to do next: find a functor that is adjoint to <code>Fold r</code>. What’s the “conceptual opposite” of <code>Fold r</code>? Let’s go adjunction hunting!</p>
<p>Important note — the rest of this section is not a set of hard rules, but rather an intuitive process of heuristics to search for candidates that would be adjoint to a given functor of interest. There are no hard and fast rules, and the adjoint might not always exist (it usually doesn’t). But when it does, it can be a pleasant surprise.</p>
<h3 id="patterns-to-look-for">Patterns to look for</h3>
<p>Now, on to the hunting. Let’s say we have functor <code>Q</code> and we want to identify any adjoints. We want to spot functions that use both <code>Q a</code> and <code>a</code> with some other value, in <a href="https://www.foldl.io/posts/pos-neg-functions/">opposite positions</a>.</p>
<p>(Of course, this is only the case if we are using a functor that comes from a library. If we are writing our own functor from scratch, and want to hunt for adjunctions there, we have to instead <em>think</em> of ways to use <code>Q a</code> and <code>a</code>)</p>
<p>One common pattern is functions for “converting between” the going-in and going-out functions. In <a href="https://hackage.haskell.org/package/adjunctions/docs/Data-Functor-Adjunction.html">Data.Functor.Adjunctions</a>, these are called <code>leftAdjunct</code> and <code>rightAdjunct</code>:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="ot">leftAdjunct  ::</span> <span class="dt">Adjunction</span> f u <span class="ot">=&gt;</span> (f a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> u b)</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="ot">rightAdjunct ::</span> <span class="dt">Adjunction</span> f u <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> u b) <span class="ot">-&gt;</span> (f a <span class="ot">-&gt;</span> b)</span></code></pre></div>
<p>This pair is significant because it is the adjunctions “in practice”: Sure, an <code>(r, a) -&gt; b</code> is useful, but “using” the adjunction means that you can convert <em>between</em> <code>(r, a) -&gt; b</code> and <code>a -&gt; r -&gt; b</code></p>
<p>Another common pattern that you can spot are “indexing” and “tabulating” functions, in the case that you have a right-adjoint:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="ot">indexAdjunction    ::</span> <span class="dt">Adjunction</span> f u <span class="ot">=&gt;</span> u b <span class="ot">-&gt;</span> f () <span class="ot">-&gt;</span> b</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="ot">tabulateAdjunction ::</span> <span class="dt">Adjunction</span> f u <span class="ot">=&gt;</span> (f () <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> u b</span></code></pre></div>
<p><code>indexAdjunction</code> means: if it’s possible to “extract” from <code>u b</code> to <code>b</code> using only an <code>f ()</code> as extra information, then <code>u</code> might be right-adjoint to <code>f</code>.</p>
<p><code>tabulateAdjunction</code> means: if it’s possible to “generate” a <code>u b</code> based on a function that “builds” a <code>b</code> from <code>f ()</code>, then <code>u</code> might right-adjoint to <code>f</code>.</p>
<p>This pair is equivalent in power — you can implement <code>rightAdjunct</code> in terms of <code>indexAdjunction</code> and <code>leftAdjunct</code> in terms of <code>tabulateAdjunction</code> and vice versa. This comes from the fact that all Adjunctions in Haskell <code>Functor</code>s arise from some idea of “indexability”. We’ll go into more detail later, but this is the general intuition.</p>
<h3 id="adjoints-to-fold">Adjoints to <code>Fold</code></h3>
<p>Now, let’s look out for examples of these functions for <code>Fold</code>! In the case of <code>Fold</code>, there is actually only one function I can find that directly takes a <code>Fold r a</code> and returns an <code>a</code>:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="ot">fold ::</span> <span class="dt">Fold</span> r b <span class="ot">-&gt;</span> [r] <span class="ot">-&gt;</span> b</span></code></pre></div>
<p>(the type has been simplified and re-labeled, for illustration’s sake)</p>
<p>You “give” a <code>Fold r b</code> and “get” an <code>b</code> (and so they have opposite polarities/positions). This sort of function would make <code>Fold r</code> a <em>right adjoint</em>, since the naked type <code>b</code> (the final parameter of <code>Fold r b</code>) is the final result, not the input.</p>
<p>Of our common patterns, this one looks a looooot like <code>indexAdjunction</code>.<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a></p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="ot">fold            ::</span> <span class="dt">Fold</span> r b <span class="ot">-&gt;</span> [r]  <span class="ot">-&gt;</span> b</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="ot">indexAdjunction ::</span> <span class="dt">Fold</span> r b <span class="ot">-&gt;</span> f () <span class="ot">-&gt;</span> b</span></code></pre></div>
<p>This means that <code>Fold r b</code> is right-adjoint to some functor <code>f</code> where <code>f () = [r]</code>. A good first guess (just a hunch?) would be to just have <code>f a = ([r], a)</code>:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/adjunctions/foldl.hs#L73-L74</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">EnvList</span> r a <span class="ot">=</span> <span class="dt">EnvList</span> [r] a</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">deriving</span> (<span class="dt">Functor</span>, <span class="dt">Show</span>, <span class="dt">Eq</span>, <span class="dt">Ord</span>)</span></code></pre></div>
<p><code>EnvList r</code><a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a> adds a <em>list</em> of <code>r</code>s to a type. It is now also our suspect for a potential left-adjoint to <code>Fold r</code>: a “conceptual opposite”.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/adjunctions/foldl.hs#L76-L77</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a><span class="ot">indexFold ::</span> <span class="dt">Fold</span> r b <span class="ot">-&gt;</span> <span class="dt">EnvList</span> r () <span class="ot">-&gt;</span> b</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>indexFold fld (<span class="dt">EnvList</span> rs _) <span class="ot">=</span> F.fold fld rs</span></code></pre></div>
<p>To seal the deal, let’s find its pair, <code>tabulateAdjunction</code>. That means we are looking for:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="ot">tabulateFold ::</span> (<span class="dt">EnvList</span> r () <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Fold</span> r b</span></code></pre></div>
<p>Or, to simplify the type by expanding the definition of <code>EnvList r ()</code>:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="ot">tabulateFold ::</span> ([r] <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Fold</span> r b</span></code></pre></div>
<p>This tells us that, given any list processor <code>[r] -&gt; b</code>, we can write a fold <code>Fold r b</code> representing that list processor. Scanning things more, we can see that this actually looks a lot like <code>foldMap</code> from the library:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Control.Foldl</span> <span class="kw">as</span> <span class="dt">F</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>F.foldMap</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a><span class="ot">    ::</span> <span class="dt">Monoid</span> w</span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>    <span class="ot">=&gt;</span> (r <span class="ot">-&gt;</span> w)</span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>    <span class="ot">-&gt;</span> (w <span class="ot">-&gt;</span> b)</span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a>    <span class="ot">-&gt;</span> <span class="dt">Fold</span> r b</span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a><span class="co">-- or</span></span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true" tabindex="-1"></a>F.foldMap (\r <span class="ot">-&gt;</span> [r])</span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true" tabindex="-1"></a><span class="ot">    ::</span> ([r] <span class="ot">-&gt;</span> b)</span>
<span id="cb13-13"><a href="#cb13-13" aria-hidden="true" tabindex="-1"></a>    <span class="ot">-&gt;</span> <span class="dt">Fold</span> r b</span></code></pre></div>
<p>So:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/adjunctions/foldl.hs#L79-L80</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a><span class="ot">tabulateFold ::</span> (<span class="dt">EnvList</span> r () <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Fold</span> r b</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>tabulateFold f <span class="ot">=</span> F.foldMap (<span class="op">:</span>[]) (\rs <span class="ot">-&gt;</span> f (<span class="dt">EnvList</span> rs ()))</span></code></pre></div>
<p>The fact the have <em>both</em> of these gives us a pretty strong footing to claim that <code>EnvList r</code> is the left-adjoint of <code>Fold r</code>. Proof by hunch, for now.</p>
<p>Note that if we had missed <code>fold</code> during our adjunction hunt, we might have also lucked out by noticing <code>F.foldMap (:[])</code> fitting the criteria for a candidate for <code>tabulateAdjunction</code>, instead.</p>
<h2 id="opposite-concepts">Opposite Concepts</h2>
<p>We’ve identified a likely candidate for a left-adjoint to <code>Fold r</code>! But … does any of this make any sense? Does this make sense as a left-adjoint, conceptually … and did we gain anything?</p>
<p>Let’s think about this from the beginning: What is the conceptual opposite of “something that folds a list”?</p>
<p>Well, what other thing is more naturally an opposite than “a list to be folded”!</p>
<ul>
<li><code>EnvList r</code>: A list of <code>r</code></li>
<li><code>Fold r</code>: Consumes a list of <code>r</code></li>
</ul>
<p>Or, in terms of the result of the functor application:</p>
<ul>
<li><code>EnvList r a</code>
<ul>
<li>An <code>a</code></li>
<li>… tupled with a list of <code>r</code></li>
</ul></li>
<li><code>Fold r a</code>
<ul>
<li>An <code>a</code></li>
<li>… parameterized by consumption of a list of <code>r</code></li>
</ul></li>
</ul>
<p>It seems to “flip” the idea of “list vs. list consumer”, and <em>also</em> the idea of “tupled vs. parameterizing” (which was our first example of an adjunction earlier, as well).</p>
<p>In addition, lists seem to be at the heart of how to create and consume a <code>Fold r</code>.</p>
<p><code>fold</code> can be thought of as the fundamental way to <em>consuming</em> a <code>Fold r</code>. This makes the adjunction with <code>EnvList r</code> make sense: what good is the <em>ability</em> to fold … if there is nothing <em>to fold</em>? <code>EnvList r</code> (a list of <code>[r]</code>) is intimately related to <code>Fold r</code>: they are the yin and yang, peanut butter and jelly, night and day. Their fates are intertwined from their very inception. You cannot have one without the other.</p>
<p>In addition, <code>F.foldMap</code> is arguably a fundamental (although maybe inefficient) way to <em>specify</em> a <code>Fold r</code>. A <code>Fold r</code> is, fundamentally, a list processor — which is what <code>EnvList r a -&gt; b</code> literally is (an <code>[r] -&gt; b</code>). <code>Fold r</code> and <code>EnvList r</code> — <a href="https://starwars.fandom.com/wiki/Dyad_in_the_Force">dyads in the force</a>. (Or, well…literally <em>monads</em>, since all adjunctions give rise to monads, as we will see later.)</p>
<p>The fact that <code>EnvList r</code> and <code>Fold r</code> form an adjunction together formalizes the fact that they are conceptually “opposite” concepts, and also that they are bound together by destiny in a close and fundamental way.</p>
<div class="note">
<p><strong>A Note on Representable</strong></p>
<p>Note that in this case, a lot of what we are concluding simply stems from the fact that we can “index” a <code>Fold r a</code> using an <code>[r]</code>. This actually is more fundamentally associated with the concept of a <a href="https://hackage.haskell.org/package/adjunctions/docs/Data-Functor-Rep.html">Representable Functor</a>.</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/adjunctions/foldl.hs#L87-L90</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Representable</span> (<span class="dt">Fold</span> r) <span class="kw">where</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">type</span> <span class="dt">Rep</span> (<span class="dt">Fold</span> r) <span class="ot">=</span> [r]</span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>    tabulate <span class="ot">=</span> F.foldMap (<span class="op">:</span>[])</span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a>    <span class="fu">index</span>    <span class="ot">=</span> F.fold</span></code></pre></div>
<p>As it turns out, in Haskell, a functor being representable is <em>equivalent</em> to it having a left adjoint. So thinking of <code>Fold r</code> as a representable functor and thinking of it as a right adjoint are equivalent ideas. This article chooses to analyze it from the adjunctions perspective because we get to imagine the adjoint <code>Functor</code>, which can sometimes reveal some extra insight over just looking at some index <em>value</em>.</p>
</div>
<h2 id="the-helper-functions">The Helper Functions</h2>
<p>Let’s take a look at some of the useful helper functions that an instance of <code>Adjunction</code> gives us for <code>Fold r</code>, to see how their existence can better help us understand <code>Fold</code>. For all of these, I’m going to write them first as <code>EnvList r a</code>, and then also as <code>([r], a)</code>, to help make things clearer.</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="ot">unit ::</span> a <span class="ot">-&gt;</span> <span class="dt">Fold</span> r (<span class="dt">EnvList</span> r a)</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a><span class="ot">unit ::</span> a <span class="ot">-&gt;</span> <span class="dt">Fold</span> r ([r], a)</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a><span class="ot">counit ::</span> <span class="dt">EnvList</span> r (<span class="dt">Fold</span> r a) <span class="ot">-&gt;</span> a</span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a><span class="ot">counit ::</span> [r] <span class="ot">-&gt;</span> <span class="dt">Fold</span> r a <span class="ot">-&gt;</span> a</span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a><span class="ot">leftAdjunct ::</span> (<span class="dt">EnvList</span> r a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">Fold</span> r b)</span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a><span class="ot">leftAdjunct ::</span> ([r] <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> b   ) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">Fold</span> r b)</span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-10"><a href="#cb16-10" aria-hidden="true" tabindex="-1"></a><span class="ot">rightAdjunct ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Fold</span> r b) <span class="ot">-&gt;</span> (<span class="dt">EnvList</span> r a <span class="ot">-&gt;</span> b)</span>
<span id="cb16-11"><a href="#cb16-11" aria-hidden="true" tabindex="-1"></a><span class="ot">rightAdjunct ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Fold</span> r b) <span class="ot">-&gt;</span> ([r] <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> b   )</span>
<span id="cb16-12"><a href="#cb16-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-13"><a href="#cb16-13" aria-hidden="true" tabindex="-1"></a><span class="ot">tabulateAdjunction ::</span> (<span class="dt">EnvList</span> r () <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Fold</span> r b</span>
<span id="cb16-14"><a href="#cb16-14" aria-hidden="true" tabindex="-1"></a><span class="ot">tabulateAdjunction ::</span> ([r] <span class="ot">-&gt;</span> b)          <span class="ot">-&gt;</span> <span class="dt">Fold</span> r b</span>
<span id="cb16-15"><a href="#cb16-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-16"><a href="#cb16-16" aria-hidden="true" tabindex="-1"></a><span class="ot">indexAdjunction ::</span> <span class="dt">Fold</span> r b <span class="ot">-&gt;</span> <span class="dt">EnvList</span> r a <span class="ot">-&gt;</span> b</span>
<span id="cb16-17"><a href="#cb16-17" aria-hidden="true" tabindex="-1"></a><span class="ot">indexAdjunction ::</span> <span class="dt">Fold</span> r b <span class="ot">-&gt;</span> [r]         <span class="ot">-&gt;</span> b</span>
<span id="cb16-18"><a href="#cb16-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-19"><a href="#cb16-19" aria-hidden="true" tabindex="-1"></a><span class="ot">zipR ::</span> <span class="dt">Fold</span> r a <span class="ot">-&gt;</span> <span class="dt">Fold</span> r b <span class="ot">-&gt;</span> <span class="dt">Fold</span> r (a, b)</span></code></pre></div>
<ol type="1">
<li><p><code>unit :: a -&gt; Fold r ([r], a)</code>, when we specialize <code>a ~ ()</code>, becomes:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="ot">unit ::</span> <span class="dt">Fold</span> r [r]</span></code></pre></div>
<p>This means that <code>unit</code> for <code>Fold r</code> folds a list <code>[r]</code> into “itself”, while also tagging on a value</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>F.fold (unit <span class="dt">True</span>) [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#   =&gt; EnvList [1,2,3] True</span></span></code></pre></div></li>
<li><p><code>counit :: [r] -&gt; Fold r a -&gt; a</code> is essentially just <code>F.fold</code> when we expand it. Neat!</p></li>
<li><p><code>leftAdjunct :: ([r] -&gt; a -&gt; b) -&gt; (a -&gt; Fold r b)</code> … if we write it as <code>leftAdjunct :: a -&gt; (a -&gt; [r] -&gt; b) -&gt; Fold r b</code>, and feed the <code>a</code> into the first function, we get:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="ot">leftAdjunct&#39; ::</span> ([r] <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Fold</span> r b</span></code></pre></div>
<p>which is just <code>tabulateAdjunction</code>, or <code>F.foldMap (:[])</code>! It encodes our list processor <code>[r] -&gt; b</code> into a <code>Fold r b.</code></p></li>
<li><p><code>rightAdjunct :: (a -&gt; Fold r b) -&gt; ([r] -&gt; a -&gt; b)</code> – if we again rewrite as <code>rightAdjunct :: a -&gt; (a -&gt; Fold r b) -&gt; [r] -&gt; b</code>, and again feed the <code>a</code> into the first function, becomes:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="ot">rightAdjunct&#39; ::</span> <span class="dt">Fold</span> r b <span class="ot">-&gt;</span> [r] <span class="ot">-&gt;</span> b</span></code></pre></div>
<p>which happens to just be <code>fold</code>, or <code>counit</code>!</p></li>
<li><p><code>tabulateAdjunction</code> and <code>indexAdjunction</code> we went over earlier, seeing them as <code>F.foldMap (:[])</code> and <code>fold</code></p></li>
<li><p><code>zipR :: Fold r a -&gt; Fold r b -&gt; Fold r (a, b)</code> takes two <code>Fold r</code>s and combines them into a single fold. This is exactly the “combining fold” behavior that makes <code>Fold</code>s so useful! The implementation of <code>zipR</code> is less efficient than the implementation of <code>&lt;*&gt;</code>/<code>liftA2</code> for <code>Fold r</code>, but knowing that <code>zipR</code> exists means that we know <code>Fold r</code>s can be combined.</p></li>
</ol>
<p>Seeing how these functions all fit together, we can write a full instance of <code>Adjunction</code>. We can choose to provide <code>unit</code> and <code>counit</code>, or <code>leftAdjunct</code> and <code>rightAdjunct</code><a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a>; the <code>unit</code>/<code>counit</code> definitions are the easiest to conceptualize, for me, but the other pair isn’t much tricker to write.</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/adjunctions/foldl.hs#L92-L97</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Adjunction</span> (<span class="dt">EnvList</span> r) (<span class="dt">Fold</span> r) <span class="kw">where</span></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a>    unit x <span class="ot">=</span> F.foldMap (<span class="op">:</span>[]) (<span class="ot">`EnvList`</span> x)</span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a>    counit (<span class="dt">EnvList</span> rs fld) <span class="ot">=</span> F.fold fld rs</span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true" tabindex="-1"></a>    leftAdjunct f x <span class="ot">=</span> F.foldMap (<span class="op">:</span>[]) (\rs <span class="ot">-&gt;</span> f (<span class="dt">EnvList</span> rs x))</span>
<span id="cb21-8"><a href="#cb21-8" aria-hidden="true" tabindex="-1"></a>    rightAdjunct f (<span class="dt">EnvList</span> rs x) <span class="ot">=</span> F.fold (f x) rs</span></code></pre></div>
<h3 id="induced-monad-and-comonad">Induced Monad and Comonad</h3>
<p>Another interesting thing we might want to look at is the monad and comonad that our adjunction defines. <a href="https://bartoszmilewski.com/2016/12/27/monads-categorically/">All adjunctions</a> <a href="http://www.stephendiehl.com/posts/adjunctions.html">define a monad</a>, so what does our new knowledge of the <code>Fold r</code> adjunction give us?</p>
<h4 id="induced-monad">Induced Monad</h4>
<p>If we have <code>F -| U</code>, then <code>U . F</code> is a monad. In this case, we have <code>FoldEnv</code>:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/adjunctions/foldl.hs#L99-L100</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">FoldEnv</span> r a <span class="ot">=</span> <span class="dt">FE</span> {<span class="ot"> getFE ::</span> <span class="dt">Fold</span> r (<span class="dt">EnvList</span> r a) }</span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">deriving</span> <span class="dt">Functor</span></span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a><span class="co">-- or</span></span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">FoldEnv</span> r <span class="ot">=</span> <span class="dt">Fold</span> r ([r], a)</span></code></pre></div>
<p>As it turns out, this is essentially equivalent to the famous <a href="https://hackage.haskell.org/package/transformers/docs/Control-Monad-Trans-State-Lazy.html">State Monad</a>! More specifically, it’s the <a href="https://hackage.haskell.org/package/adjunctions/docs/Control-Monad-Representable-State.html"><em>Representable</em> State Monad</a>.</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">FoldEnv</span> r <span class="ot">=</span> <span class="dt">State</span> [r]</span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a><span class="co">-- or, more literally, from Control.Monad.Representable.State</span></span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">FoldEnv</span> r <span class="ot">=</span> <span class="dt">State</span> (<span class="dt">Fold</span> r)</span></code></pre></div>
<p>So the induced monad from the adjunction we just found is essentially the same as the <code>State</code> monad over a list — except with some potentially different performance characteristics.</p>
<p>In the end, finding this adjunction gives us a neat way to represent stateful computations on lists, which is arguably an extension of what <code>Fold</code> was really meant for in the first place.</p>
<h4 id="induced-comonad">Induced Comonad</h4>
<p>If we have <code>F -| U</code>, then <code>F . U</code> is a comonad. In this case, we have <code>EnvFold</code>:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/adjunctions/foldl.hs#L111-L112</span></span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">EnvFold</span> r a <span class="ot">=</span> <span class="dt">EF</span> {<span class="ot"> getEF ::</span> <span class="dt">EnvList</span> r (<span class="dt">Fold</span> r a) }</span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">deriving</span> <span class="dt">Functor</span></span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true" tabindex="-1"></a><span class="co">-- or</span></span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">EnvFold</span> r <span class="ot">=</span> ([r], <span class="dt">Fold</span> r a)</span></code></pre></div>
<p>This one is exactly the <a href="https://hackage.haskell.org/package/adjunctions/docs/Control-Comonad-Representable-Store.html">Representable Store comonad</a>. It’s essentially the normal <a href="https://hackage.haskell.org/package/comonad/docs/Control-Comonad-Store.html"><code>Store</code> comonad</a>:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">EnvFold</span> r <span class="ot">=</span> <span class="dt">Store</span> [r]</span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a><span class="co">-- or, more literally, from Control.Comonad.Representable.Store</span></span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">EnvFold</span> r <span class="ot">=</span> <span class="dt">Store</span> (<span class="dt">Fold</span> r)</span></code></pre></div>
<p>This comonad “stores” an <code>[r]</code> as well as a way to produce an <code>a</code> from an <code>[r]</code>. All of the utility of this induced comonad basically is the same as the utility of <code>Store</code>, except with potentially different performance profiles.</p>
<p>In the end, finding this adjunction gives us a neat way to define a comonadic contextual projection on lists, which I would say is also an extension of the original purpose of <code>Fold</code>.</p>
<h2 id="conclusion">Conclusion</h2>
<p>In the end, in a “practical” sense, we got some nice helper functions, as well as a new way to extend the conceptual idea of <code>Fold</code> using the induced monad and comonad.</p>
<p>Admittedly, the selection of helper functions that <code>Adjunction</code> gives us pales in comparison to abstractions like <code>Monoid</code>, <code>Applicative</code>, <code>Traversable</code>, <code>Monad</code>, etc., which makes <code>Adjunction</code> (in my opinion) nowhere as practical when compared to them. A lot of these helper functions (like the induced state monad and store comonad) actually also just exist if we only talk about <code>Representable</code>.</p>
<p>However, to me (and, as how I’ve seen other people use it), <code>Adjunction</code> is most useful as a conceptual tool in Haskell. The idea of “opposites” or “duals” show up a lot in Haskell, starting from the most basic level – sums and products, products and functions. From day 1, Haskellers are introduced to natural pairs and opposites in concepts. The idea of opposites and how they interact with each other is always on the mind of a Haskeller, and close to their heart.</p>
<p>So, what makes <code>Adjunction</code> so useful to me is that it actually is able to formalize what we mean by “opposite concepts”. The process of identifying a functor’s “opposite concept” (if it exists) will only help is better understand the functor we’re thinking about, in terms of how it works and how it is used.</p>
<p>Hopefully this blog post helps you appreciate both <code>Fold</code> in a new way, and also the fundamental “idea” of adjunctions in Haskell.</p>
<h2 id="the-algebraic-way">The Algebraic Way</h2>
<p>This article is done! Our first guess for an adjunction seems to be morally correct. But as an aside … let’s see if we can take this idea further.</p>
<p>In this section we’re going to get a bit mathy and look at the definition of <code>Fold</code>, to see if we can <em>algebraically</em> find an adjunction of <code>Fold</code>, instead of just trying to hunt for API functions like before. In practice you don’t often have to make algebraic deductions like this, but it’s at least nice to know that something like this possible from a purely algebraic and logical sense. You never <em>need</em> all this fancy math to be able to write Haskell … but many feel like it can make things a lot more fun! :)</p>
<p>Be warned that this method <em>does</em> require some familiarity (or at least awareness) of certain types that appear often in the more … esoteric corners of Haskelldom :)</p>
<p>The game plan here is to start with the definition of <code>Fold</code>, and then rearrange it using algebraic substitutions until it matches something that already has an <code>Adjunction</code> instance in the <em>adjunctions</em> library.</p>
<p>First, the actual definition of <code>Fold</code> in the <em>foldl</em> library itself is:</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Fold</span> r a <span class="ot">=</span> <span class="kw">forall</span> x<span class="op">.</span> <span class="dt">Fold</span> (x <span class="ot">-&gt;</span> r <span class="ot">-&gt;</span> x) x (x <span class="ot">-&gt;</span> a)</span></code></pre></div>
<p>Maybe not the friendliest definition at first! But something in this looks a little familiar, maybe. Let’s do some re-arranging:</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Fold</span> r a <span class="ot">=</span> <span class="kw">forall</span> x<span class="op">.</span> <span class="dt">Fold</span> (x <span class="ot">-&gt;</span> r <span class="ot">-&gt;</span> x) x (x <span class="ot">-&gt;</span> a)</span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a>              <span class="ot">=</span> <span class="kw">forall</span> x<span class="op">.</span> <span class="dt">Fold</span> x (x <span class="ot">-&gt;</span> r <span class="ot">-&gt;</span> x) (x <span class="ot">-&gt;</span> a)</span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a>              <span class="ot">=</span> <span class="kw">forall</span> x<span class="op">.</span> <span class="dt">Fold</span> x (x <span class="ot">-&gt;</span> (r <span class="ot">-&gt;</span> x, a))</span></code></pre></div>
<p>Ah, this looks a <em>lot</em> like the constructor <code>Nu</code> for some <code>f</code>:</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Nu</span> f <span class="ot">=</span> <span class="kw">forall</span> x<span class="op">.</span> <span class="dt">Nu</span> (x <span class="ot">-&gt;</span> f x) x</span></code></pre></div>
<p><code>Nu</code> is one of the three main famous <a href="https://hackage.haskell.org/package/recursion-schemes/docs/Data-Functor-Foldable.html">fixed-point type combinators</a> in Haskell. The other two are <code>Mu</code> and <code>Fix</code>:</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span>    <span class="dt">Nu</span>  f <span class="ot">=</span> <span class="kw">forall</span> x<span class="op">.</span> <span class="dt">Nu</span> (x <span class="ot">-&gt;</span> f x) x</span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">Fix</span> f <span class="ot">=</span> <span class="dt">Fix</span> (f (<span class="dt">Fix</span> f))</span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">Mu</span>  f <span class="ot">=</span> <span class="dt">Mu</span> (<span class="kw">forall</span> x<span class="op">.</span> (f x <span class="ot">-&gt;</span> x) <span class="ot">-&gt;</span> x)</span></code></pre></div>
<p>In Haskell these are all equivalent<a href="#fn5" class="footnote-ref" id="fnref5" role="doc-noteref"><sup>5</sup></a>, but they have very different performance profiles for certain operations. <code>Nu</code> is easy to “build up”, and <code>Mu</code> is easy to “tear down” – and they exist sort of opposite to each other. <code>Fix</code> exists in opposite to … itself. Sorry, <code>Fix</code>.</p>
<p>Anyway, looking at <code>Fold r a</code>:</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Fold</span> r a <span class="ot">=</span> <span class="kw">forall</span> x<span class="op">.</span> <span class="dt">Fold</span> x (x <span class="ot">-&gt;</span> (r <span class="ot">-&gt;</span> x, a))</span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Nu</span>   f   <span class="ot">=</span> <span class="kw">forall</span> x<span class="op">.</span> <span class="dt">Nu</span>   x (x <span class="ot">-&gt;</span> f x)</span></code></pre></div>
<p>it seems like we can pick an <code>F</code> such that <code>Nu (F r a) = Fold r a</code>. Let’s try…</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> (f <span class="op">:.:</span> g) x <span class="ot">=</span> <span class="dt">Comp</span> (f (g x))</span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Fold</span> r a <span class="ot">=</span> <span class="dt">Nu</span> (((,) a) <span class="op">:.:</span> ((<span class="ot">-&gt;</span>) r))</span></code></pre></div>
<p>From here, some might recognize the fixed point of <code>(,) a :.: f</code> as <code>Cofree</code>, from <a href="https://hackage.haskell.org/package/free/docs/Control-Comonad-Cofree.html">Control.Comonad.Cofree</a> — one of the more commonly used fixed points.</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Cofree</span> f a <span class="ot">=</span> <span class="dt">Nu</span> ((,) a <span class="op">:.:</span> f     )</span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Fold</span> r a   <span class="ot">=</span> <span class="dt">Nu</span> ((,) a <span class="op">:.:</span> (<span class="ot">-&gt;</span>) r)</span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Fold</span> r     <span class="ot">=</span> <span class="dt">Cofree</span> ((<span class="ot">-&gt;</span>) r)</span></code></pre></div>
<p>It looks like <code>Fold r</code> is just <code>Cofree ((-&gt;) r)</code> <a href="#fn6" class="footnote-ref" id="fnref6" role="doc-noteref"><sup>6</sup></a> … and now we’ve hit the jackpot! That’s because <code>Cofree f</code> has an instance of <code>Adjunction</code>!</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Adjunction</span> f u <span class="ot">=&gt;</span> <span class="dt">Adjunction</span> (<span class="dt">Free</span> f) (<span class="dt">Cofree</span> u)</span></code></pre></div>
<p>This means that <code>Cofree u</code> is right-adjoint to <code>Free f</code>, if <code>f</code> is right-adjoint to <code>u</code>. Well, our <code>u</code> here is <code>(-&gt;) r</code>, which was actually our very first example of a right-adjoint functor — it’s right-adjoint to <code>(,)</code>. So, <code>Fold r</code> is apparently a right-adjoint, like we guessed previously! More specifically, it looks like like <code>Fold r</code> is right-adjoint to <code>Free ((,) r)</code>.</p>
<p>At least, we’ve reached our goal! We found an adjunction for <code>Fold r</code> in a purely algebraic way, and deduced it to be right-adjunct to <code>Free ((,) r)</code>.</p>
<p>At this point we have our answer, so we can stop here. But it’s possible to go a little further, to find a true “perfect companion” for <code>Fold r</code>. Its perfect match and conceptual opposite, as the adjunction mythos claims.</p>
<p>We know that <code>Free f</code> is, itself, a fixed-point – it’s the fixed point of <code>Sum (Const a) f</code> (from <em><a href="https://hackage.haskell.org/package/base/docs/Data-Functor-Sum.html">Data.Functor.Sum</a></em>). So <code>Free ((,) r) a</code> is the fixed-point of <code>Sum (Const a) ((,) r)</code>. Since we are looking at conceptual opposites, maybe let’s try using the <code>Mu</code> fixed-point operator, to be opposite of the <code>Nu</code> that <code>Fold r</code> is. This also makes sense because this is something we’re going to “tear down” with a <code>Fold</code>, and <code>Mu</code> is good at being torn down.</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">Mu</span> f <span class="ot">=</span> <span class="dt">Mu</span> (<span class="kw">forall</span> x<span class="op">.</span> (f x <span class="ot">-&gt;</span> x) <span class="ot">-&gt;</span> x)</span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">EL</span> r a <span class="ot">=</span> <span class="dt">Mu</span> (<span class="dt">Sum</span> (<span class="dt">Const</span> a) ((,) r))</span>
<span id="cb34-4"><a href="#cb34-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-5"><a href="#cb34-5" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">EL</span> r a <span class="ot">=</span> <span class="dt">EL</span> {</span>
<span id="cb34-6"><a href="#cb34-6" aria-hidden="true" tabindex="-1"></a><span class="ot">    runEL ::</span> <span class="kw">forall</span> x<span class="op">.</span> (<span class="dt">Either</span> a (r, x) <span class="ot">-&gt;</span> x) <span class="ot">-&gt;</span> x</span>
<span id="cb34-7"><a href="#cb34-7" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb34-8"><a href="#cb34-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-9"><a href="#cb34-9" aria-hidden="true" tabindex="-1"></a><span class="co">-- or, with some shuffling around, recognizing that `Either a b -&gt; c` is</span></span>
<span id="cb34-10"><a href="#cb34-10" aria-hidden="true" tabindex="-1"></a><span class="co">-- equivalent to `(a -&gt; c, b -&gt; c)`</span></span>
<span id="cb34-11"><a href="#cb34-11" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">EL</span> r a <span class="ot">=</span> <span class="dt">EL</span> {</span>
<span id="cb34-12"><a href="#cb34-12" aria-hidden="true" tabindex="-1"></a><span class="ot">    runEL ::</span> <span class="kw">forall</span> x<span class="op">.</span> (a <span class="ot">-&gt;</span> x) <span class="ot">-&gt;</span> (x <span class="ot">-&gt;</span> r <span class="ot">-&gt;</span> x) <span class="ot">-&gt;</span> x</span>
<span id="cb34-13"><a href="#cb34-13" aria-hidden="true" tabindex="-1"></a>  }</span></code></pre></div>
<p>The new <code>EL</code> is actually isomorphic to the <code>EnvList</code> one we wrote earlier (as long as the list is finite), meaning that one can encode the other, and they have identical structure. Writing functions to convert between the two can be fun; <a href="https://github.com/mstksg/inCode/tree/master/code-samples/adjunctions/foldl-algebraic.hs#L31-L39">here is one solution</a>, and there’s a <a href="https://github.com/mstksg/inCode/tree/master/code-samples/adjunctions/foldl-algebraic.hs#L73-L79">bonus solution</a> if you can write it using only the <a href="https://github.com/mstksg/inCode/tree/master/code-samples/adjunctions/foldl-algebraic.hs#L58-L71"><em>new</em> instance</a> for <code>Adjunction (EL r) (Fold r)</code> and <code>F.foldMap</code>, since it can be shown that all adjuncts are unique up to isomorphism.</p>
<p>And…this looks pretty neat, I think. In the end we discover that these two types are adjoints to each other:<a href="#fn7" class="footnote-ref" id="fnref7" role="doc-noteref"><sup>7</sup></a></p>
<div class="sourceCode" id="cb35"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Fold</span> r a <span class="ot">=</span> <span class="kw">forall</span> x<span class="op">.</span> <span class="dt">Fold</span>            (x <span class="ot">-&gt;</span> a)    (x <span class="ot">-&gt;</span> r <span class="ot">-&gt;</span> x)    x</span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">EL</span>   r a <span class="ot">=</span>           <span class="dt">EL</span>   (<span class="kw">forall</span> x<span class="op">.</span> (a <span class="ot">-&gt;</span> x) <span class="ot">-&gt;</span> (x <span class="ot">-&gt;</span> r <span class="ot">-&gt;</span> x) <span class="ot">-&gt;</span> x)</span></code></pre></div>
<p>They look superficially syntactically similar and I don’t really know what to make of that … but a lot of “opposites” seem to be paired here. The existential <code>x</code> in <code>Fold</code> becomes a Rank2 universal in <code>EList</code>, and the <code>x -&gt; a</code> in <code>Fold</code> becomes an <code>a -&gt; x</code> in <code>EList</code>. Neat neat.</p>
<p>Adjunctions: take an idea and just make everything opposite.</p>
<p>One nice thing about this representation is that writing the fundamental operation of <code>Fold</code> (that is, <code>fold</code>) becomes really clean:<a href="#fn8" class="footnote-ref" id="fnref8" role="doc-noteref"><sup>8</sup></a></p>
<div class="sourceCode" id="cb36"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/adjunctions/foldl-algebraic.hs#L51-L52</span></span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true" tabindex="-1"></a><span class="ot">foldEL ::</span> <span class="dt">Fold</span> r b <span class="ot">-&gt;</span> <span class="dt">EL</span> r a <span class="ot">-&gt;</span> b</span>
<span id="cb36-4"><a href="#cb36-4" aria-hidden="true" tabindex="-1"></a>foldEL (<span class="dt">Fold</span> step <span class="fu">init</span> extr) el <span class="ot">=</span> extr (runEL el (<span class="fu">const</span> <span class="fu">init</span>) step)</span></code></pre></div>
<p>And this is, maybe, the real treasure all along.</p>
<h2 id="special-thanks">Special Thanks</h2>
<p>I am very humbled to be supported by an amazing community, who make it possible for me to devote time to researching and writing these posts. Very special thanks to my supporter at the “Amazing” level on <a href="https://www.patreon.com/justinle/overview">patreon</a>, Josh Vera! :)</p>
<section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes">
<hr />
<ol>
<li id="fn1"><p>Note that the intuition we are going to be going into is specifically for adjunctions between <code>Functor</code> functors — functors that the <code>Functor</code> typeclass models (aka, endofunctors in Hask). For a more general view of adjunctions in general, see the links above.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p>As it so happens, <code>fold</code> is actually exactly <code>index</code> for <code>Representable (Fold r)</code>, from <em><a href="https://hackage.haskell.org/package/adjunctions/docs/Data-Functor-Rep.html">Data.Functor.Rep</a></em>. Here we are utilizing the fact that a representable Functor gives rise to a left-adjoint for free — the two ideas are equivalent in Haskell. We go into this in more detail in an upcoming aside.<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3"><p>The name here is inspired by the <a href="https://hackage.haskell.org/package/comonad/docs/Control-Comonad-Trans-Env.html"><code>Env</code> comonad</a> — <code>EnvList r</code> is <code>Env [r]</code>.<a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn4"><p>We should also be able to define it using <code>tabulateAdjunction</code> and <code>indexAdjunction</code> … but this isn’t allowed for some reason?<a href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn5"><p>They are only equivalent in Haskell because of laziness — in strict languages, they are different.<a href="#fnref5" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn6"><p>Some might recognize <code>Cofree ((-&gt;) r)</code> as a common way of implementing a <a href="https://en.wikipedia.org/wiki/Moore_machine">Moore machine</a> in Haskell. In fact, our derivation here is basically a backwards version of <a href="https://www.schoolofhaskell.com/user/edwardk/moore/for-less">the process described here by Edward Kmett</a>.<a href="#fnref6" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn7"><p>The instance is <a href="https://github.com/mstksg/inCode/tree/master/code-samples/adjunctions/foldl-algebraic.hs#L58-L71">written out here</a>.<a href="#fnref7" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn8"><p>Implementing a <code>tabulate</code> equivalent (<a href="https://github.com/mstksg/inCode/tree/master/code-samples/adjunctions/foldl-algebraic.hs#L54-L56">solution here</a>) reveals that this refactoring is only really useful for <code>index</code> (to “consume” a <code>Fold</code>) … using <code>tabulate</code> or <code>leftAdjunct</code> to “produce” a <code>Fold</code> reveals how inefficient this is.<a href="#fnref8" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section></div><footer><hr><div class="copy-content"><p>Hi, thanks for reading! You can reach me via email at <a href="mailto:justin@jle.im" class="email">justin@jle.im</a>, or at twitter at <a href="https://twitter.com/mstk">@mstk</a>! This post and all others are published under the <a href="https://creativecommons.org/licenses/by-nc-nd/3.0/">CC-BY-NC-ND 3.0</a> license. Corrections and edits via pull request are welcome and encouraged at <a href="https://github.com/mstksg/inCode">the source repository</a>.</p>
<p>If you feel inclined, or this post was particularly helpful for you, why not consider <a href="https://www.patreon.com/justinle/overview">supporting me on Patreon</a>, or a <a href="bitcoin:3D7rmAYgbDnp4gp4rf22THsGt74fNucPDU">BTC donation</a>? :)</p></div><div class="clear"></div><ul class="entry-series"></ul><ul class="tag-list"><li><a href="https://blog.jle.im/entries/tagged/category-theory.html" class="tag-a-tag">#category theory</a></li><li><a href="https://blog.jle.im/entries/tagged/haskell.html" class="tag-a-tag">#haskell</a></li><li><a href="https://blog.jle.im/entries/category/@haskell.html" class="tag-a-category">@HASKELL</a></li><li><a href="https://blog.jle.im/entries/category/@math.html" class="tag-a-category">@MATH</a></li></ul><aside class="social-buttons"><div class="addthis_toolbox addthis_default_style addthis-buttons"><a class="addthis_button_facebook_like" fb:like:layout="button_count"></a><a class="addthis_button_tweet"></a><a class="addthis_button_google_plusone" g:plusone:size="medium"></a><a class="addthis_counter addthis_pill_style"></a></div><div class="custom-social-buttons"><div class="custom-social-button"><a href="https://www.reddit.com/submit" onclick="window.location = &#39;https://www.reddit.com/submit?url=&#39;+ encodeURIComponent(window.location); return false"><img src="https://www.reddit.com/static/spreddit7.gif" alt="submit to reddit"></a></div></div></aside><nav class="next-prev-links"><ul><li class="prev-entry-link">&larr; <a href="https://blog.jle.im/entry/simple-tcpip-services-servant.html">Dead-simple TCP/IP services using servant</a> (Previous)</li><li class="next-entry-link">(Next) <a href="https://blog.jle.im/entry/introducing-the-mutable-library.html">Introducing the mutable library</a> &rarr;</li></ul></nav></footer></article><div class="post-entry"><div class="tile"><div id="disqus_thread"></div><script type="text/javascript">var disqus_config = function () {
    this.page.url = 'https://blog.jle.im/entry/foldl-adjunction.html';
    this.page.identifier = 'advent-shuffle';
};
(function() {
    var d = document, s = d.createElement('script');
    s.src = '//incode.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
})();
</script><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a><br></noscript><a href="http://disqus.com" class="dsq-brlink">Comments powered by <span class="logo-disqus">Disqus</span></a></div></div></div></div></div><div id="footer-container"><div id="footer-content"><div class="tile"><div class="footer-copyright">&copy; 2020 Justin Le <span class="license-link">(<a href="https://creativecommons.org/licenses/by-nc-nd/3.0/" class="license">CC-BY-NC-ND 3.0</a>)</span></div><div class="footer-follow social-follows"><ul class="social-follows-list"><li><ul class="social-follows-list-social"><li><a class="social-follow-twitter" title="Follow me on Twitter!" href="https://twitter.com/intent/user?user_id=mstk" onclick="window.open(
  &#39;http://twitter.com/intent/user?user_id=907281&#39;,
  &#39;facebook-share-dialog&#39;,
  &#39;width=550,height=520&#39;);
return false;
">Twitter</a></li><li><a class="social-follow-github" title="Fork me on Github!" href="https://github.com/mstksg">Github</a></li><li><a class="social-follow-twitch" title="Watch me on Twitch!" href="https://www.twitch.tv/justin_l">Twitch</a></li><li><a class="social-follow-patreon" title="Support me on Patreon!" href="https://www.patreon.com/justinle/overview">Patreon</a></li><li><a class="social-follow-gplus" title="Add me on Google+!" href="https://plus.google.com/+JustinLe">Google+</a></li><li><a class="social-follow-keybase" title="Track me on Keybase!" href="https://keybase.io/mstksg">Keybase</a></li><li><a class="social-follow-linkedin" title="Connect with me on LinkedIn!" href="https://linkedin.com/in/lejustin">LinkedIn</a></li><li><a class="social-follow-bitcoin" title="Donate via bitcoin!" href="bitcoin:3D7rmAYgbDnp4gp4rf22THsGt74fNucPDU">Bitcoin</a></li></ul></li><li><ul class="social-follows-list-site"><li><a class="social-follow-rss" title="Subscribe to my RSS Feed!" href="http://feeds.feedburner.com/incodeblog">RSS</a></li><li><a class="social-follow-email" title="Subscribe to the mailing list!" href="https://feedburner.google.com/fb/a/mailverify?loc=en_US&amp;uri=incodeblog">Mailing list</a></li></ul></li></ul></div></div></div></div></body></html>