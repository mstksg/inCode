<!DOCTYPE HTML>
<html><head><title>Introducing the mutable library · in Code</title><meta name="description" content="Weblog of Justin Le, covering various adventures in programming and explorations in the worlds of computation physics, and knowledge.
"><meta http-equiv="Content-Type" content="text/html;charset=utf-8"><meta name="viewport" content="width=device-width,initial-scale=1.0"><meta name="flattr:id" content="3p9jqr"><meta property="og:site_name" content="in Code"><meta property="og:description" content="mutable: documentation / reference / github (Note: This post has been heavily revised to reflect mutable-0.2.0.0, as of July 2020. For reference, the original post is available on github.) I’m excited to announce the release of the mutable library! The library offers what I call beautiful mutable values — automatic, composable piecewise-mutable references for your data types. Sort of like an automatically generated MVector, but for all your ADTs. My high-level goal was a composable and overhead-free solution for dealing with mutable values in Haskell in a type-safe and clean way. After all, why do imperative languages have to have all the fun? In Haskell, we can have the best of both worlds: efficient and clean mutable algorithms and type safety. The official documentation and homepage is here, so it’s a good read if you want to be introduced to how to use the library and where it is most effective. But I’m going to use this blog post to talk about why I wrote the library, some of the neat things you can do with it, and the techniques that went into writing it."><meta property="og:type" content="article"><meta property="og:title" content="Introducing the mutable library"><meta property="og:image" content="https://blog.jle.im/img/site_logo.jpg"><meta property="og:locale" content="en_US"><meta property="og:url" content="https://blog.jle.im/entry/introducing-the-mutable-library.html"><meta name="twitter:card" content="summary"><meta name="twitter:creator:id" content="mstk"><link rel="author" href="https://plus.google.com/107705320197444500140"><link rel="alternate" type="application/rss+xml" title="in Code (RSS Feed)" href="http://feeds.feedburner.com/incodeblog"><link rel="canonical" href="https://blog.jle.im/entry/introducing-the-mutable-library.html"><link href="https://blog.jle.im/favicon.ico" rel="shortcut icon"><link href="https://blog.jle.im/css/toast.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/font.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/main.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/page/entry.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/pygments.css" rel="stylesheet" type="text/css"><script type="text/javascript">var page_data = {};
var disqus_shortname='incode';
</script><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-443711-8', 'jle.im');
ga('send', 'pageview');
</script><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script id="MathJax-script" async="" src="https://cdn.jsdelivr.net/npm/mathjax@3.0.1/es5/tex-mml-chtml.js"></script><script type="text/javascript" src="//ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script><script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5234d67a6b68dcd4"></script><script type="text/javascript" src="https://blog.jle.im/js/page/entry_toc.js"></script><script type="text/javascript" src="https://blog.jle.im/js/disqus_count.js"></script><script type="text/javascript" src="https://blog.jle.im/js/social.js"></script><script type="text/javascript" src="https://blog.jle.im/js/jquery/jquery.toc.js"></script><script type="text/javascript" src="https://blog.jle.im/purescript/entry.js"></script></head><body><div id="fb-root"><script>(function(d, s, id) {
 var js, fjs = d.getElementsByTagName(s)[0];
 if (d.getElementById(id)) return;
 js = d.createElement(s); js.id = id;
 js.src = "//connect.facebook.net/en_US/all.js#xfbml=1&appId=641852699171929";
 fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));
</script></div><div id="header-container"><div id="navbar-container" class="tile"><nav id="navbar-content"><div class="nav-info"><h1 class="site-title"><a href="https://blog.jle.im/" class="nav-title">in Code</a></h1><span class="nav-author">Justin Le</span></div><ul class="nav-links"><li><a href="https://blog.jle.im/">home</a></li><li><a href="https://blog.jle.im/entries.html">archives</a></li><li><a href="https://cv.jle.im">cv</a></li><div class="clear"></div></ul></nav></div><div id="header-content"></div></div><div id="body-container" class="container"><div id="main-container" class="grid"><div class="entry-section unit span-grid" role="main"><article class="tile article"><header><h1 id="title">Introducing the mutable library</h1><p class="entry-info">by <a class="author" href="https://blog.jle.im/">Justin Le</a><span class="info-separator"> &diams; </span><time datetime="2020-01-23T18:16:52Z" pubdate="" class="pubdate">Thursday January 23, 2020</time></p><p><span class="source-info"><a class="source-link" href="https://github.com/mstksg/inCode/tree/master/copy/entries/mutable-intro.md">Source</a><span class="info-separator"> &diams; </span><a class="source-link" href="https://github.com/mstksg/inCode/tree/gh-pages/entry/introducing-the-mutable-library.md">Markdown</a><span class="info-separator"> &diams; </span><a class="source-link" href="https://blog.jle.im/entry/introducing-the-mutable-library.tex">LaTeX</a><span class="info-separator"> &diams; </span></span>Posted in <a href="https://blog.jle.im/entries/category/@haskell.html" class="tag-a-category" title="Functional, pure, non-strict, statically and strongly typed, natively
compiled...really just the king of great languages.
">Haskell</a><span class="info-separator"> &diams; </span><a class="comment-link" href="#disqus_thread">Comments</a></p></header><hr><aside class="contents-container"><h5 id="contents-header">Contents</h5><div id="toc"></div></aside><div class="main-content copy-content"><p><strong>mutable</strong>: <a href="https://mutable.jle.im/">documentation</a> / <a href="http://hackage.haskell.org/package/mutable">reference</a> / <a href="https://github.com/mstksg/mutable">github</a></p>
<p>(<em>Note:</em> This post has been heavily revised to reflect <em>mutable-0.2.0.0</em>, as of July 2020. For reference, <a href="https://github.com/mstksg/inCode/blob/7c25dd3798955e8287d31774da6fe34015256b5a/entry/introducing-the-mutable-library.md">the original post</a> is available on github.)</p>
<p>I’m excited to announce the release of the <em><a href="https://mutable.jle.im/">mutable</a></em> library!</p>
<p>The library offers what I call <em>beautiful mutable values</em><a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a> — automatic, composable piecewise-mutable references for your data types. Sort of like an automatically generated <code>MVector</code>, but for all your <code>ADT</code>s.</p>
<p>My high-level goal was a composable and overhead-free solution for dealing with mutable values in Haskell in a type-safe and clean way. After all, why do imperative languages have to have all the fun? In Haskell, we can have the best of both worlds: efficient and clean mutable algorithms <em>and</em> type safety.</p>
<p>The <a href="https://mutable.jle.im/">official documentation and homepage is here</a>, so it’s a good read if you want to be introduced to how to use the library and where it is most effective. But I’m going to use this blog post to talk about <em>why</em> I wrote the library, some of the neat things you can do with it, and the techniques that went into writing it.</p>
<h2 id="motivation">Motivation</h2>
<p>The original motivation for this comes from my development of <em><a href="https://backprop.jle.im/">backprop</a></em> and <em><a href="https://github.com/mstksg/backprop-learn">backprop-learn</a></em>, as I was trying to adapt my <a href="https://blog.jle.im/entries/series/+functional-models.html">Functional Models</a> framework to efficient Haskell code.</p>
<p>To properly train Artificial Neural Networks with Haskell, you need to do a lot of independent piecewise mutations to matrices and vectors. This becomes inefficient, quickly, because you have to do a lot of copying in the process for pure vectors and neural network weights. This problem also comes up for efficient simulations that require mutating many different components independently under a tight loop.</p>
<h3 id="piecewise-mutable">Piecewise-Mutable</h3>
<p>First of all, what do I mean by “piecewise-mutable”? Well, a simple example is the mutable vector type, where piecewise-mutable edits are able to save a lot of time and memory allocation.</p>
<p>If we want to edit the first item in a vector multiple times, this is extremely inefficient with a pure vector:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="ot">addFirst ::</span> <span class="dt">Vector</span> <span class="dt">Double</span> <span class="ot">-&gt;</span> <span class="dt">Vector</span> <span class="dt">Double</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>addFirst xs <span class="ot">=</span> <span class="fu">iterate</span> incr xs <span class="op">!!</span> <span class="dv">1000000</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    incr v <span class="ot">=</span> v <span class="op">V.//</span> [(<span class="dv">0</span>, (v <span class="op">V.!</span> <span class="dv">0</span>) <span class="op">+</span> <span class="dv">1</span>)]</span></code></pre></div>
<p>That’s because <code>addFirst</code> will copy over the entire vector for every step — every single item, even if not modified, will be copied one million times. It is <span class="math inline">\(O(n*l)\)</span> in memory updates — it is very bad for long vectors or large matrices.</p>
<p>However, this is extremely efficient with a mutable vector:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="ot">addFirst ::</span> <span class="dt">Vector</span> <span class="dt">Double</span> <span class="ot">-&gt;</span> <span class="dt">Vector</span> <span class="dt">Double</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>addFirst xs <span class="ot">=</span> runST <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>    v <span class="ot">&lt;-</span> V.thaw xs</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>    replicateM_ <span class="dv">1000000</span> <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>        MV.modify v <span class="dv">0</span> (<span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>    V.freeze v</span></code></pre></div>
<p>(this action is run in <code>ST</code>, the monad for mutable actions that is provided by GHC)</p>
<p>This is because all of the other items in the vector are kept the same and not copied-over over the course of one million updates. It is <span class="math inline">\(O(n+l)\)</span> in memory updates. It is very good even for long vectors or large matrices.</p>
<p>This situation is somewhat contrived, but it isolates a problem that many programs face. A more common situation might be that you have two functions that each modify different items in a vector in sequence, and you want to run them many times interleaved, or one after the other.</p>
<h3 id="composite-datatype">Composite Datatype</h3>
<p>That was an example of using piecewise mutability for vectors, but it’s not exactly scalable. That’s because it always requires having a separate type for the <em>pure</em> type and the <em>value</em> type. We’re lucky enough to have one for <code>Vector</code>…but what about for our own custom types? That’s a lot of headache.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">TwoVec</span> <span class="ot">=</span> <span class="dt">TV</span> {<span class="ot"> tv1 ::</span> <span class="dt">Vector</span> <span class="dt">Double</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>                 ,<span class="ot"> tv2 ::</span> <span class="dt">Vector</span> <span class="dt">Double</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>                 }</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">deriving</span> <span class="dt">Generic</span></span></code></pre></div>
<p>To use this in a “piecewise-mutable” way, we would need a separate “mutable” version:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">TwoVecRef</span> s <span class="ot">=</span> <span class="dt">TVR</span> {<span class="ot"> tvr1 ::</span> <span class="dt">MVector</span> s <span class="dt">Double</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>                       ,<span class="ot"> tvr2 ::</span> <span class="dt">MVector</span> s <span class="dt">Double</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>                       }</span></code></pre></div>
<p>Then we can do things like “mutate only the first item in the first vector” a million times, and be efficient with it.</p>
<p>We’d have to write functions to “thaw” and “freeze”</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="ot">thawTwoVec ::</span> <span class="dt">TwoVec</span> <span class="ot">-&gt;</span> <span class="dt">ST</span> s (<span class="dt">TwoVecRef</span> s)</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>thawTwoVec (<span class="dt">TV</span> x y) <span class="ot">=</span> <span class="dt">TVR</span> <span class="op">&lt;$&gt;</span> V.thaw x <span class="op">&lt;*&gt;</span> V.thaw y</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a><span class="ot">freezeTwoVec ::</span> <span class="dt">TwoVecRef</span> s <span class="ot">-&gt;</span> <span class="dt">ST</span> s <span class="dt">TwoVec</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>freezeTwoVec (<span class="dt">TVR</span> u v) <span class="ot">=</span> <span class="dt">TV</span> <span class="op">&lt;$&gt;</span> V.freeze u <span class="op">&lt;*&gt;</span> V.freze v</span></code></pre></div>
<p>It just doesn’t scale in a composable way. You’d have to create a second version of every data type.</p>
<h3 id="solution">Solution</h3>
<p>The library provides the <code>Mutable</code> typeclass and the <code>GRef</code> type, where <code>GRef s X</code> is the automatically derived piecewise-mutable version of <code>X</code>.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Mutable</span> s <span class="dt">TwoVec</span> <span class="kw">where</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">type</span> <span class="dt">Ref</span> s <span class="dt">TwoVec</span> <span class="ot">=</span> <span class="dt">GRef</span> s <span class="dt">TwoVec</span></span></code></pre></div>
<p>The type <code>GRef s TwoVec</code> is <em>exactly</em> the <code>TwoVecRef</code> that we defined earlier: it is a tuple of two <code>MVector</code>s. It can do this because <code>Vector</code> itself has a <code>Mutable</code> instance, where its mutable version is <code>MVector</code>. <code>GRef s TwoVec</code> is essentially the “MVector” of <code>TwoVec</code>.</p>
<p>This now gives us <code>thawRef :: TwoVec -&gt; ST s (GRef s TwoVec)</code> and <code>freezeRef :: GRef s TwoVec -&gt; ST s TwoVec</code>, for free, so we can write:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="ot">addFirst ::</span> <span class="dt">TwoVec</span> <span class="ot">-&gt;</span> <span class="dt">TwoVec</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>addFirst xs <span class="ot">=</span> runST <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>    v <span class="ot">&lt;-</span> thawRef xs</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>    replicateM_ <span class="dv">1000000</span> <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>      withField <span class="op">#</span>tv1 v <span class="op">$</span> \u <span class="ot">-&gt;</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>        MV.modify u <span class="dv">0</span> (<span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>    freezeRef v</span></code></pre></div>
<p>This will in-place edit only the first item in the <code>tv1</code> field one million times, without ever needing to copy over the contents <code>tv2</code>. Basically, it gives you a version of <code>TwoVec</code> that you can modify in-place piecewise. You can compose two functions that each work piecewise on <code>TwoVec</code>:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="ot">mut1 ::</span> <span class="dt">Ref</span> s <span class="dt">TwoVec</span> <span class="ot">-&gt;</span> <span class="dt">ST</span> s ()</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>mut1 v <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>    withField <span class="op">#</span>tv1 v <span class="op">$</span> \u <span class="ot">-&gt;</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>      MV.modify u <span class="dv">0</span> (<span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>      MV.modify u <span class="dv">1</span> (<span class="op">+</span> <span class="dv">2</span>)</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>    withField <span class="op">#</span>tv2 v <span class="op">$</span> \u <span class="ot">-&gt;</span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>      MV.modify u <span class="dv">2</span> (<span class="op">+</span> <span class="dv">3</span>)</span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>      MV.modify u <span class="dv">3</span> (<span class="op">+</span> <span class="dv">4</span>)</span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a><span class="ot">mut2 ::</span> <span class="dt">Ref</span> s <span class="dt">TwoVec</span> <span class="ot">-&gt;</span> <span class="dt">ST</span> s ()</span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>mut2 v <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a>    withField <span class="op">#</span>tv1 v <span class="op">$</span> \u <span class="ot">-&gt;</span></span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a>      MV.modify u <span class="dv">4</span> (<span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a>      MV.modify u <span class="dv">5</span> (<span class="op">+</span> <span class="dv">2</span>)</span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a>    withField <span class="op">#</span>tv2 v <span class="op">$</span> \u <span class="ot">-&gt;</span></span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true" tabindex="-1"></a>      MV.modify u <span class="dv">6</span> (<span class="op">+</span> <span class="dv">3</span>)</span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true" tabindex="-1"></a>      MV.modify u <span class="dv">7</span> (<span class="op">+</span> <span class="dv">4</span>)</span>
<span id="cb8-18"><a href="#cb8-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-19"><a href="#cb8-19" aria-hidden="true" tabindex="-1"></a><span class="ot">doAMillion ::</span> <span class="dt">TwoVec</span> <span class="ot">-&gt;</span> <span class="dt">TwoVec</span></span>
<span id="cb8-20"><a href="#cb8-20" aria-hidden="true" tabindex="-1"></a>doAMillion xs <span class="ot">=</span> runST <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb8-21"><a href="#cb8-21" aria-hidden="true" tabindex="-1"></a>    v <span class="ot">&lt;-</span> thawRef xs</span>
<span id="cb8-22"><a href="#cb8-22" aria-hidden="true" tabindex="-1"></a>    replicateM_ <span class="dv">1000000</span> <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb8-23"><a href="#cb8-23" aria-hidden="true" tabindex="-1"></a>      mut1 v</span>
<span id="cb8-24"><a href="#cb8-24" aria-hidden="true" tabindex="-1"></a>      mut2 v</span>
<span id="cb8-25"><a href="#cb8-25" aria-hidden="true" tabindex="-1"></a>    freezeRef v</span></code></pre></div>
<p>The end result? You can now modify only a single component of your large composite data type (and even single items in vectors in them) without making nested copies every time.</p>
<h2 id="neat-consequences">Neat Consequences</h2>
<h3 id="mutable-sum-types">Mutable Sum Types</h3>
<p>While developing the library, I accidentally also stumbled into a way of automatically deriving useful mutable sum types and data structures in Haskell. This was more or less a complete accident — I was writing the code to automatically generate <code>GRef</code>, and needed to account for sum types somehow. The result was actually useful!</p>
<p>For example, it is a publicly kept secret that Haskell’s list type — “linked lists”, are actually very different from the <a href="https://en.wikipedia.org/wiki/Linked_list">mutable linked lists</a> encountered as a standard data structure in languages like Java and C++. As it turns out, using <code>GRef m [a]</code> gives us exactly the mutable linked list type … for free!</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">List</span> a <span class="ot">=</span> <span class="dt">Nil</span> <span class="op">|</span> <span class="dt">Cons</span> a (<span class="dt">List</span> a)</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Generic</span>)</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a><span class="kw">infixr</span> <span class="dv">5</span> <span class="ot">`Cons`</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Mutable</span> s a <span class="ot">=&gt;</span> <span class="dt">Mutable</span> m (<span class="dt">List</span> a) <span class="kw">where</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">type</span> <span class="dt">Ref</span> s (<span class="dt">List</span> a) <span class="ot">=</span> <span class="dt">GRef</span> s (<span class="dt">List</span> a)</span></code></pre></div>
<p>Here we are re-implementing the <code>List</code> data structure from scratch just to show that there is nothing arbitrary going on with the default list — it works for any appropriately defined ADT. We could even do binary trees!</p>
<p>Right away we can write functions to flesh out the API for a mutable linked list. For example, a function to check if a linked list is empty:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- | Check if a mutable linked list is currently empty</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>isEmpty</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a><span class="ot">    ::</span> <span class="dt">Mutable</span> s a</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>    <span class="ot">=&gt;</span> <span class="dt">Ref</span> s (<span class="dt">List</span> a)</span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>    <span class="ot">-&gt;</span> <span class="dt">ST</span> s <span class="dt">Bool</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>isEmpty <span class="ot">=</span> hasBranch (constrMB <span class="op">#</span>_Nil)</span></code></pre></div>
<p>Here is a function to “pop” a mutable linked list, giving us the first value and shifting the rest of the list up.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>popStack</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span class="ot">    ::</span> <span class="dt">Mutable</span> s a</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>    <span class="ot">=&gt;</span> <span class="dt">Ref</span> s (<span class="dt">List</span> a)</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>    <span class="ot">-&gt;</span> <span class="dt">ST</span> s (<span class="dt">Maybe</span> a)</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>popStack xs <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>    c <span class="ot">&lt;-</span> projectBranch (constrMB <span class="op">#</span>_Cons) xs</span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>    forM c <span class="op">$</span> \(y, ys) <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>      o <span class="ot">&lt;-</span> freezeRef y</span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a>      moveRef xs ys</span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a>      <span class="fu">pure</span> o</span></code></pre></div>
<p>And a function to concatenate a second linked list to the end of a first one:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>concatLists</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a><span class="ot">    ::</span> <span class="dt">Mutable</span> s a</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>    <span class="ot">=&gt;</span> <span class="dt">Ref</span> s (<span class="dt">List</span> a)</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>    <span class="ot">-&gt;</span> <span class="dt">Ref</span> s (<span class="dt">List</span> a)</span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>    <span class="ot">-&gt;</span> <span class="dt">ST</span> s ()</span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>concatLists l1 l2 <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>    c <span class="ot">&lt;-</span> projectBranch consBranch l1</span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">case</span> c <span class="kw">of</span></span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a>      <span class="dt">Nothing</span>      <span class="ot">-&gt;</span> moveRef l1 l2</span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a>      <span class="dt">Just</span> (_, xs) <span class="ot">-&gt;</span> concatLists xs l2</span></code></pre></div>
<h3 id="higher-kinded-data">Higher-Kinded Data</h3>
<p>I’m rather enamoured by the “<a href="https://reasonablypolymorphic.com/blog/higher-kinded-data/">higher-kinded data</a>” pattern made popular by Sandy Maguire. It essentially eliminates the need for explicit getters and setters by making the data type <em>itself</em> the thing that offers what you want, and you can get at it by just pattern matching.</p>
<p>Because of this, if your data type is written in the “higher-kinded data” pattern, then <code>MyType f</code> doubles as both the pure type <em>and</em> the mutable type, just by choice of <code>f</code>. <code>MyTypeF Identity</code> would be the pure version, and <code>MyTypeF (RefFor m)</code> would be the mutable version.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">MyTypeF</span> f <span class="ot">=</span> <span class="dt">MTF</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>    {<span class="ot"> mtfInt    ::</span> <span class="dt">HKD</span> f <span class="dt">Int</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>    ,<span class="ot"> mtfDouble ::</span> <span class="dt">HKD</span> f <span class="dt">Double</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>    ,<span class="ot"> mtfVec    ::</span> <span class="dt">HKD</span> f (<span class="dt">V.Vector</span> <span class="dt">Double</span>)</span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">deriving</span> <span class="dt">Generic</span></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">MyType&#39;</span> <span class="ot">=</span> <span class="dt">MyTypeF</span> <span class="dt">Identity</span></span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Mutable</span> s <span class="dt">MyType&#39;</span> <span class="kw">where</span></span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">type</span> <span class="dt">Ref</span> s <span class="dt">MyType&#39;</span> <span class="ot">=</span> <span class="dt">MyTypeF</span> (<span class="dt">RefFor</span> s)</span></code></pre></div>
<p>We can directly use it like a normal data type:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="dt">MTF</span> <span class="dv">3</span> <span class="fl">4.5</span> (V.fromList [<span class="dv">1</span><span class="op">..</span><span class="dv">100</span>])</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a><span class="ot">    ::</span> <span class="dt">MyType&#39;</span></span></code></pre></div>
<p>But now, <code>MyTypeF (RefFor s)</code> literally has mutable references as its fields. You can pattern match to get <code>rI :: MutVar s Int</code>, <code>rD :: MutVar s Double</code>, and <code>rV :: MVector s Double</code></p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="dt">MTF</span> rI rD<span class="ot"> rV ::</span> <span class="dt">MyTypeF</span> (<span class="dt">RefFor</span> s)</span></code></pre></div>
<p>and the accessors work as well:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a>mtfVec</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a><span class="ot">    ::</span> <span class="dt">MyTypeF</span> (<span class="dt">RefFor</span> s)</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>    <span class="ot">-&gt;</span> <span class="dt">MVector</span> s <span class="dt">Double</span></span></code></pre></div>
<p>You can use it like:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>runST <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>    r<span class="op">@</span>(<span class="dt">MTF</span> rI rD rV) <span class="ot">&lt;-</span> thawRef <span class="op">$</span> <span class="dt">MTF</span> <span class="dv">0</span> <span class="fl">19.3</span> (V.fromList [<span class="dv">1</span><span class="op">..</span><span class="dv">10</span>])</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>    replicateM_ <span class="dv">1000</span> <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a>        <span class="co">-- rI is just the &#39;Int&#39; ref</span></span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a>        modifyMutVar rI (<span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true" tabindex="-1"></a>        <span class="co">-- rV is the &#39;MVector&#39;</span></span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true" tabindex="-1"></a>        MV.modify rV (<span class="op">+</span><span class="dv">1</span>) <span class="dv">0</span></span>
<span id="cb17-11"><a href="#cb17-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-12"><a href="#cb17-12" aria-hidden="true" tabindex="-1"></a>    freezeRef r</span>
<span id="cb17-13"><a href="#cb17-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-14"><a href="#cb17-14" aria-hidden="true" tabindex="-1"></a><span class="co">-- =&gt; MTF 1000 19.3 [1001.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0]</span></span></code></pre></div>
<p>The “mutable version” of a type literally <em>is</em> the ADT, if you use the higher-kinded data pattern!</p>
<h3 id="a-polymorphic-picture">A Polymorphic Picture</h3>
<p>One important thing to note when looking at the actual library — the examples in this post show the provided actions in <code>ST</code>, the mutable actions monad provided by GHC. However, the library provides these actions polymorphic for all <code>PrimMonad m</code>, an abstraction provided by the <em><a href="https://hackage.haskell.org/package/primitive">primitive</a></em> library to generalize for all “mutable monads” (like <code>IO</code> and monad transformers applied to <code>IO</code> and <code>ST</code>), as long as <code>PrimState m ~ s</code>, so you can run them in whatever useful mutable monads you’d like.</p>
<h2 id="reflections-on-generic">Reflections on Generic</h2>
<p>This library is pretty much powered 95% by GHC Generics, as the name <code>GRef</code> implies. GHC Generics is probably one of the single most powerful tools we have in Hasekll-the-language for writing typesafe abstractions and eliminating all the boilerplate.</p>
<p>The structure of the <code>GRef</code> data type is completely determined by using the <em>GHC.Generics</em> <code>Rep</code> of an algebraic data type with a <code>Generic</code> instance. It breaks apart the products and sums and turns them into the mutable references you <em>would</em> normally write by hand.</p>
<p>Writing <code>GRef</code> itself was actually very pleasant: it just involves matching up generic pieces with the references they represent. “What is the reference for a constant value? What is the reference for a product type? What is the reference for a sum type?” And, in the process of answering those questions, I ended up discovering something new (as shown in the section above about mutable linked lists).</p>
<p>Generics also powers the <em>higher-kinded data</em> based systems, which can add a lot of syntactic niceness to everything if you decide to use it.</p>
<p>Still, I understand not everyone wants to restructure their data types in terms of higher-kinded data … there are a lot of practical issues to doing so, and it doesn’t really work well with nested data types. For that, I turned to <em><a href="https://hackage.haskell.org/package/generic-lens">generic-lens</a></em>.</p>
<p><em>generic-lens</em> is what powers the OverloadedLabels-based field accessor methods that let you work with <code>GRef</code>s in a seamless way, by being able to do <code>withField #blah</code>, etc., instead of having to directly match on the <code>GRef</code> value’s internal contents (which can be messy, admittedly). It also allows you to do <code>withPos @2</code> to get the second item in your <code>GRef</code>, and <code>withTuple</code> to allow you to get the mutable fields in your data type as a tuple.</p>
<p>I was originally going to implement the field accessors myself, looking to <em>generic-lens</em> for inspiration. However, when I looked at the library’s internals, I realized there was a lot more going on than I had originally thought. But, looking at what was exported, I realized that the library was well-designed enough that I could actually directly use its generic implementations for <em>mutable</em>! As a result, the field/position/tuple accessor code actually required no mucking around with generics at all — I could leverage <em>generic-lens</em>, which was powerful enough to allow me to eliminate all of my generics code.</p>
<p>I strongly recommend anyone looking to do things involving generic access to fields to look at <em>generic-lens</em> to see if it can eliminate all your generics code as well!</p>
<p>Unfortunately, I wasn’t able to re-use the code for the “constructor” access (as seen with <code>constrMB #_Cons</code> earlier) — but I could use it as inspiration to write my own. The library offers a very clean and well-written pattern to doing things like this that I probably would have spent a long time trying to figure out, if I had to do it from scratch.</p>
<h2 id="next-steps">Next Steps</h2>
<p>I learned a lot from GHC Generics writing this library — in a sense, the library is pretty much completely an application of GHC Generics, without much new concepts beyond that.</p>
<p>My next step is to equip <em>backprop</em> to use <code>Mutable</code> instead of its <code>Backprop</code> typeclass, so it can do in-place mutation of composite data types for much faster backpropagation.</p>
<p>However, my newly gained experience with generics from writing this library can actually do a lot to improve the ergonomics of <em>backprop</em> as well — in particular, with <code>BVar</code>, which has always been very annoying to work with, even with the lens-based API offered. Working with a <code>BVar</code> as if it were a normal value has always been annoying, especially with product types. There are a lot of ways GHC generics can help this, that I am now only learning about. Check back soon — hopefully I’ll have something to show by then.</p>
<p>Until then, happy mutating! And please let me know if you find any interesting applications of the library :D</p>
<section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes">
<hr />
<ol>
<li id="fn1"><p>Okay so I don’t actually think the library is beautiful, I just like the way that “beautiful mutable values” sounds when you say it out loud.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section></div><footer><hr><div class="copy-content"><p>Hi, thanks for reading! You can reach me via email at <a href="mailto:justin@jle.im" class="email">justin@jle.im</a>, or at twitter at <a href="https://twitter.com/mstk">@mstk</a>! This post and all others are published under the <a href="https://creativecommons.org/licenses/by-nc-nd/3.0/">CC-BY-NC-ND 3.0</a> license. Corrections and edits via pull request are welcome and encouraged at <a href="https://github.com/mstksg/inCode">the source repository</a>.</p>
<p>If you feel inclined, or this post was particularly helpful for you, why not consider <a href="https://www.patreon.com/justinle/overview">supporting me on Patreon</a>, or a <a href="bitcoin:3D7rmAYgbDnp4gp4rf22THsGt74fNucPDU">BTC donation</a>? :)</p></div><div class="clear"></div><ul class="entry-series"></ul><ul class="tag-list"><li><a href="https://blog.jle.im/entries/tagged/functional-programming.html" class="tag-a-tag">#functional programming</a></li><li><a href="https://blog.jle.im/entries/tagged/numerical.html" class="tag-a-tag">#numerical</a></li><li><a href="https://blog.jle.im/entries/category/@haskell.html" class="tag-a-category">@HASKELL</a></li></ul><aside class="social-buttons"><div class="addthis_toolbox addthis_default_style addthis-buttons"><a class="addthis_button_facebook_like" fb:like:layout="button_count"></a><a class="addthis_button_tweet"></a><a class="addthis_button_google_plusone" g:plusone:size="medium"></a><a class="addthis_counter addthis_pill_style"></a></div><div class="custom-social-buttons"><div class="custom-social-button"><a href="https://www.reddit.com/submit" onclick="window.location = &#39;https://www.reddit.com/submit?url=&#39;+ encodeURIComponent(window.location); return false"><img src="https://www.reddit.com/static/spreddit7.gif" alt="submit to reddit"></a></div></div></aside><nav class="next-prev-links"><ul><li class="prev-entry-link">&larr; <a href="https://blog.jle.im/entry/foldl-adjunction.html">Adjunctions in the wild: foldl</a> (Previous)</li><li class="next-entry-link">(Next) <a href="https://blog.jle.im/entry/enhancing-functor-structures-step-by-step-1.html">Enhancing Functor Structures Step-By-Step (Part 1)</a> &rarr;</li></ul></nav></footer></article><div class="post-entry"><div class="tile"><div id="disqus_thread"></div><script type="text/javascript">var disqus_config = function () {
    this.page.url = 'https://blog.jle.im/entry/introducing-the-mutable-library.html';
    this.page.identifier = 'mutable-intro';
};
(function() {
    var d = document, s = d.createElement('script');
    s.src = '//incode.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
})();
</script><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a><br></noscript><a href="http://disqus.com" class="dsq-brlink">Comments powered by <span class="logo-disqus">Disqus</span></a></div></div></div></div></div><div id="footer-container"><div id="footer-content"><div class="tile"><div class="footer-copyright">&copy; 2020 Justin Le <span class="license-link">(<a href="https://creativecommons.org/licenses/by-nc-nd/3.0/" class="license">CC-BY-NC-ND 3.0</a>)</span></div><div class="footer-follow social-follows"><ul class="social-follows-list"><li><ul class="social-follows-list-social"><li><a class="social-follow-twitter" title="Follow me on Twitter!" href="https://twitter.com/intent/user?user_id=mstk" onclick="window.open(
  &#39;http://twitter.com/intent/user?user_id=907281&#39;,
  &#39;facebook-share-dialog&#39;,
  &#39;width=550,height=520&#39;);
return false;
">Twitter</a></li><li><a class="social-follow-github" title="Fork me on Github!" href="https://github.com/mstksg">Github</a></li><li><a class="social-follow-twitch" title="Watch me on Twitch!" href="https://www.twitch.tv/justin_l">Twitch</a></li><li><a class="social-follow-patreon" title="Support me on Patreon!" href="https://www.patreon.com/justinle/overview">Patreon</a></li><li><a class="social-follow-gplus" title="Add me on Google+!" href="https://plus.google.com/+JustinLe">Google+</a></li><li><a class="social-follow-keybase" title="Track me on Keybase!" href="https://keybase.io/mstksg">Keybase</a></li><li><a class="social-follow-linkedin" title="Connect with me on LinkedIn!" href="https://linkedin.com/in/lejustin">LinkedIn</a></li><li><a class="social-follow-bitcoin" title="Donate via bitcoin!" href="bitcoin:3D7rmAYgbDnp4gp4rf22THsGt74fNucPDU">Bitcoin</a></li></ul></li><li><ul class="social-follows-list-site"><li><a class="social-follow-rss" title="Subscribe to my RSS Feed!" href="http://feeds.feedburner.com/incodeblog">RSS</a></li><li><a class="social-follow-email" title="Subscribe to the mailing list!" href="https://feedburner.google.com/fb/a/mailverify?loc=en_US&amp;uri=incodeblog">Mailing list</a></li></ul></li></ul></div></div></div></div></body></html>