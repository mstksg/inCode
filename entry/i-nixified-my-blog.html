<!DOCTYPE HTML>
<html><head><title>I nixified my blog · in Code</title><meta name="description" content="Weblog of Justin Le, covering various adventures in programming and explorations in the worlds of computation physics, and knowledge.
"><meta http-equiv="Content-Type" content="text/html;charset=utf-8"><meta name="viewport" content="width=device-width,initial-scale=1.0"><meta name="flattr:id" content="3p9jqr"><meta property="og:site_name" content="in Code"><meta property="og:description" content="Happy new year! It’s been a while (almost three years) since my last post. But it’s a new year, a new me – and I just recently started working at a new job writing Haskell where everything is built and deployed using nix. Aside from the bliss that comes from being able to write Haskell as a day job, I also enjoyed the push to finally dive into the nix ecosystem for my general personal computing, which many of my friends have been subtly (or not so subtly) pushing me to look into for a long time. And I have to say, I’m hooked! I get a lot of similar joy using nix to organize my projects as I did when I was first learning Haskell. My path to re-organizing all of my personal projects to using nix has lead me back to one of my more “longer-running” pieces of legacy code – my 10 year old blog. So, this is a post from a naive new nix user on how I converted my blog deployment and building from a manual multi-stage build process into an automatic nix-with-cachix deploy – and some future things I would be hoping to investigate! In this post I’ll also be explaining a bit of nix, so hopefully it’s accessible if you are curious like I was too. However, it’s not a tutorial — instead, it’s a high-level overview of the concepts that I put together to achieve the goal."><meta property="og:type" content="article"><meta property="og:title" content="I nixified my blog"><meta property="og:image" content="https://blog.jle.im/img/site_logo.jpg"><meta property="og:locale" content="en_US"><meta property="og:url" content="https://blog.jle.im/entry/i-nixified-my-blog.html"><meta name="twitter:card" content="summary"><meta name="twitter:creator:id" content="mstk"><link rel="author" href="https://plus.google.com/107705320197444500140"><link rel="alternate" type="application/rss+xml" title="in Code (RSS Feed)" href="http://feeds.feedburner.com/incodeblog"><link rel="canonical" href="https://blog.jle.im/entry/i-nixified-my-blog.html"><link href="https://blog.jle.im/favicon.ico" rel="shortcut icon"><link href="https://blog.jle.im/css/toast.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/font.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/main.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/page/entry.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/pygments.css" rel="stylesheet" type="text/css"><script type="text/javascript">var page_data = {};
var disqus_shortname='incode';
</script><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-443711-8', 'jle.im');
ga('send', 'pageview');
</script><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script id="MathJax-script" async="" src="https://cdn.jsdelivr.net/npm/mathjax@3.0.1/es5/tex-mml-chtml.js"></script><script type="text/javascript" src="//ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script><script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5234d67a6b68dcd4"></script><script type="text/javascript" src="https://blog.jle.im/js/page/entry_toc.js"></script><script type="text/javascript" src="https://blog.jle.im/js/disqus_count.js"></script><script type="text/javascript" src="https://blog.jle.im/js/social.js"></script><script type="text/javascript" src="https://blog.jle.im/js/jquery/jquery.toc.js"></script><script type="text/javascript" src="https://blog.jle.im/purescript/entry.js"></script></head><body><div id="fb-root"><script>(function(d, s, id) {
 var js, fjs = d.getElementsByTagName(s)[0];
 if (d.getElementById(id)) return;
 js = d.createElement(s); js.id = id;
 js.src = "//connect.facebook.net/en_US/all.js#xfbml=1&appId=641852699171929";
 fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));
</script></div><div id="header-container"><div id="navbar-container" class="tile"><nav id="navbar-content"><div class="nav-info"><h1 class="site-title"><a href="https://blog.jle.im/" class="nav-title">in Code</a></h1><span class="nav-author">Justin Le</span></div><ul class="nav-links"><li><a href="https://blog.jle.im/">home</a></li><li><a href="https://blog.jle.im/entries.html">archives</a></li><li><a href="https://cv.jle.im">cv</a></li><div class="clear"></div></ul></nav></div><div id="header-content"></div></div><div id="body-container" class="container"><div id="main-container" class="grid"><div class="entry-section unit span-grid" role="main"><article class="tile article"><header><h1 id="title">I nixified my blog</h1><p class="entry-info">by <a class="author" href="https://blog.jle.im/">Justin Le</a><span class="info-separator"> &diams; </span><time datetime="2024-01-01T13:21:32Z" pubdate="" class="pubdate">Monday January 1, 2024</time></p><p><span class="source-info"><a class="source-link" href="https://github.com/mstksg/inCode/tree/master/copy/entries/nixify-blog.md">Source</a><span class="info-separator"> &diams; </span><a class="source-link" href="https://github.com/mstksg/inCode/tree/gh-pages/entry/i-nixified-my-blog.md">Markdown</a><span class="info-separator"> &diams; </span><a class="source-link" href="https://blog.jle.im/entry/i-nixified-my-blog.tex">LaTeX</a><span class="info-separator"> &diams; </span></span>Posted in <a href="https://blog.jle.im/entries/category/@meta.html" class="tag-a-category" title="Posts about this blog or blogging in general. So meta.
">Meta</a><span class="info-separator"> &diams; </span><a class="comment-link" href="#disqus_thread">Comments</a></p></header><hr><aside class="contents-container"><h5 id="contents-header">Contents</h5><div id="toc"></div></aside><div class="main-content copy-content"><p>Happy new year! It’s been a while (almost three years) since my last post. But it’s a new year, a new me – and I just recently started working at <a href="https://github.com/anduril">a new job</a> writing Haskell where everything is built and deployed using <a href="https://nixos.org/">nix</a>. Aside from the bliss that comes from being able to write Haskell as a day job, I also enjoyed the push to finally dive into the nix ecosystem for my general personal computing, which many of my friends have been subtly (or not so subtly) pushing me to look into for a long time. And I have to say, I’m hooked! I get a lot of similar joy using nix to organize my projects as I did when I was first learning Haskell. My path to re-organizing all of my personal projects to using nix has lead me back to one of my more “longer-running” pieces of legacy code – my 10 year old blog. So, this is a post from a naive new nix user on how I converted my blog deployment and building from a manual multi-stage build process into an automatic nix-with-cachix deploy – and some future things I would be hoping to investigate!</p>
<p>In this post I’ll also be explaining a bit of <em>nix</em>, so hopefully it’s accessible if you are curious like I was too. However, it’s <em>not</em> a tutorial — instead, it’s a high-level overview of the concepts that I put together to achieve the goal.</p>
<h2 id="how-did-we-get-here">How Did We Get Here</h2>
<p>The <a href="https://blog.jle.im/entries/category/@meta.html">development history</a> of my blog (which just turned 10 a few months ago, actually) has gone through a few stages: (which you might be able to track <a href="https://github.com/mstksg/inCode">on github</a>)</p>
<ol type="1">
<li>A simple <em><a href="https://hackage.haskell.org/package/scotty">scotty</a></em> server on Heroku backed by a cloud-hosted postgresql database. My first ever non-trivial Haskell project!</li>
<li>Using <em><a href="https://hackage.haskell.org/package/fay">fay</a></em> to compile to javascript for interactivity and post-processing in blog posts.</li>
<li>Converting <em>fay</em> to <em>ghcjs</em>, to write javascript in Haskell.</li>
<li>Switching from “classic cabal” to <em><a href="https://docs.haskellstack.org/en/stable/">stack</a></em> for development and building.</li>
<li>Using <em><a href="https://shakebuild.com/">shake</a></em> for build/deploy scripts.</li>
<li>Converting <em>ghcjs</em> to <em><a href="https://www.purescript.org/">purescript</a></em>, because I didn’t want to bundle 1.5 MB of Haskell Runtime just to generate a table of contents.</li>
<li>The biggest change: moving from <em>scotty</em> to <em><a href="https://jaspervdj.be/hakyll/">hakyll</a></em> (a static site generator), from a simple HTTP server to a static site generation.</li>
<li>Deploying to github pages within a build script, using a custom haskell tool I had written a long time ago. I honestly don’t remember where the site was hosted before github pages, but I remember having to configure my own CDN and https for a my hosted static website and at some point I wondered “why?”.</li>
<li>Moving from yaml for configuration to <em><a href="https://dhall-lang.org/">dhall</a></em>.</li>
</ol>
<p>As you can see, I sort of use my blog as a playground to apply new ideas I’m learning build familiarity with them, and I have some fun refactoring every couple of years because Haskell is so fun to refactor.</p>
<p>However, the current state of things is kind of a monster to build. First, you have to have purescript <em>and</em> npm <em>and</em> bower (for general javascript deployment) installed. Then the build script (the Shakefile) compiles javascript and purescript into the working directory, then calls hakyll which generates the actual site files. It’s a really finicky system that involves having the correct javascript ecosystem dependencies already installed – and also uses a deprecated system for building purescript. At least we had <em>stack</em> to manage having the correct ghc version.</p>
<p>Looking at this in 2023, there are a few things that had to change:</p>
<ol type="1">
<li>The purescript ecosystem has moved onto <em><a href="https://github.com/purescript/spago">spago</a></em> for dependency management.</li>
<li>I have been moving most of my projects from stack back to pure cabal using the new modern tooling</li>
<li>I have moved dev environments a few times and every time it is a huge pain to remember the exact set of things that need to be installed for all stages to build and work correctly. I’d like to move from an ad-hoc build script dependent on the environment into a single tool that manages everything.</li>
<li>I wanted to get automatic deployments to github pages running instead of having to manually deploy.</li>
</ol>
<p>Some of these don’t necessarily require nix, but I figured that this would be a good opportunity to check everything off and seeing what nix had to offer.</p>
<h2 id="the-game-plan">The Game Plan</h2>
<p>Going into this, the general workflow would be:</p>
<ol type="1">
<li>Create a <em>nix derivation</em> for all of the purescript scripts, that generates a single javascript file each.</li>
<li>Create a nix derivation for the <em>hakyll</em> static site generator binary</li>
<li>Create a nix derivation for the full static site itself: it will assemble all of the compiled purescript files from step 1, the source files (markdown, static images, etc.) from the repo, and then run the hakyll binary on it.</li>
<li>Create a github actions workflow to automatically build the full static site generation workflow.</li>
<li>Use <em><a href="https://www.cachix.org/">cachix</a></em> to ensure that all derivations where the dependencies don’t change will not need to be re-built.</li>
<li>If step 4 completes, automatically push the derivation’s outputs to the <em>gh-pages</em> branch.</li>
<li>Establish <em>local development environments</em> that nix can set up for us:
<ol type="1">
<li>Haskell development – with haskell language server, cabal for intermediate building, etc.</li>
<li>Purescript development – I’ve structured each interactive blog post’s purescript source as its own spago project, so we actually need to generate a separate development environment (with purescript language server, etc.) for each project. I don’t expect to be working on more than one at a given time.</li>
<li><em>Writing</em> – with the hakyll binary available for intermediate caching for fast builds and updates and hakyll’s local preview server, and the <em>purescript</em> compiler available for fast compilation for the scripts driving interactive blog posts.</li>
</ol></li>
</ol>
<p>One cool thing about cachix is that you get build caching for free for any derivation you hand-write across all of your environments. You don’t need to register your “package” to any sort of registry or set up custom cloud caching in every situation.</p>
<h3 id="what-is-a-derivation">What is a Derivation?</h3>
<p>The main character in all of these steps is the <em>nix derivation</em>. In my mental model, a nix derivation is a recipe for building “something” – sometimes, it’s a binary, and in our case it’s often just going to be a collection of files. A derivation contains a list of pinned reproducible dependency derivations — so it’s all reproducible down the whole chain. In our case:</p>
<ul>
<li>The final derivation (the static site’s html files and contents) <em>depends</em> on the hakyll binary derivation and the compiled purescript derivation</li>
<li>The hakyll binary derivation depends on a pinned ghc, cabal, and a derivation for every haskell library dependency.</li>
<li>The compiled purescript derivation depends on the purescript compiler (purs), as well as all purescript library dependencies</li>
</ul>
<p>When we say “depends”, it just means that uses what the derivation outputs in one way or another. The final static site derivation uses the <em>binary</em> outputted by the hakyll binary derivation. It also uses the <em>javascript files</em> outputted by the compiled purescript derivation. And its <em>output</em> is just the static pages and contents of the site.</p>
<p>One major leap for me was realizing that derivations just created output files. In my mind, before this, I thought that a derivation was something “executable” — when you first get into nix and nixos, “derivation” and “executable” can sometimes appear synonymous. To install a new executable in nixos (like <em>vim</em> or any other linux program), you installed its derivation. However, this was a misconception. It’s just a <em>convention</em> that if your derivation is meant to provide an executable, you put the binary file in the <code>./bin/</code> subdirectory of your output files. In our case, our output files are sometimes binaries (which we put in <code>./bin/</code>), but they’re also sometimes static files, which we put in <code>./dist/</code> or <code>./js/</code> or wherever we want. It’s just a “convention” that the <code>./bin</code> subdirectory of your output contains a binary that the caller would want in their PATH, and so nix automatically puts the <code>./bin</code> of any dependency derivation in the PATH/execution environment for convenience. At least, that’s my mental model and how I understand it — I am definitely new to this, so if I’m incorrect at any point, feel free to leave a comment.</p>
<h3 id="what-is-a-development-environment">What is a development environment?</h3>
<p>Very important to this system is the local development environment that lets us quickly re-build the site (and also lets us use hakyll’s built-in preview server features). I have a little less refined of a mental model for these than I do for the derivation — but apparently it’s just a derivation that sets up a shell with everything we need in the PATH? In any case, we need to set one up here to drop us in a Haskell development environment to get all of our favorite Haskell development tools – like Haskell Language Server and cabal – and a snapshot of all of our Haskell dependencies. And then we need one that just gives us the hakyll binary, which has interactive development features like directory watching, local servers, and incremental builds/cache invalidation.</p>
<h3 id="prior-art">Prior Art</h3>
<p>While researching this further, I noticed that this approach is similar to that of <em><a href="https://github.com/rpearce/hakyll-nix-template">hakyll-nix-template</a></em>: have a derivation for the hakyll binary, then a derivation for the final website, then push to gh-pages with cachix to ensure caching haskell dependencies. Because of this, I was able to use a lot of code from that repository to help figure things out for my own path. So, a special thanks to <a href="https://github.com/rpearce">Robert Pearce</a>!</p>
<h3 id="shortcomings-static-artifact-caching">Shortcomings: Static Artifact Caching</h3>
<p>There is one shortcoming to this approach that I consider very significant – using nix with <em>cachix</em> ensures that we don’t redo work at the derivation level. So, if the purescript files don’t change, we won’t re-build the compiled javascript. If the haskell files don’t change, we won’t re-build the hakyll binary. But for a static site, we also have to build the site based on the input files — mostly, markdown files. For my blog, this is not trivial – each markdown post gets compiled and outputted into many different formats (latex, pdf, html multiple times), and actually gets re-combined with re-usable code snippets from different folders. In addition, we build a page for each of the many tags, a paginated homepage, a granular history page, and an rss feed. On a whole, a build from scratch takes about five minutes. This is a significant downgrade — in the past, I could build and deploy almost instantaneously (under a minute).</p>
<p>I’m not sure if this can be optimized on the Haskell side, but it’s still kind of wasteful in principle, because <em>hakyll</em> is smart enough to only re-build what is needed, if it’s run in its normal mode of operation. If you update only a single post, hakyll will only update the pages that are effected — the home page, the rss feed, and any tag pages it appears on, etc. It knows not to re-generate any single blog post pages or pdf files for different blog posts that aren’t affected by the new update.</p>
<p>If you’re using github actions in the normal way, you might be able to take advantage of this with github actions caches? It’s unclear to me how change detection interacts with this. However, in the “nix style”, if we really want to view the final generated site as a <em>nix derivation</em> (and not just, ie, a build script), it’s a little more complicated to make this fit into the conceptual model and make sure cache invalidation etc. works correctly.</p>
<p>What would be really ideal is if these units of cached data (individual web pages, etc.) could be managed and invalidated by nix itself — maybe each blog post’s outputs (the html, pdf, post-processed markdown, latex) could be a derivation, and so these derivations won’t have to be re-built if the blog post is not changed. There seems to be a few options in terms of “purely nix” static site generators that could do this I think, but that’s not really an option to me because the blog at this point is pretty huge, logic-wise, and also I would rather write the blog in Haskell in the end still.</p>
<p>Maybe in the future I could figure out how to modify hakyll to use the nix cache for its caching and invalidation, instead of its own bespoke method? I wonder if that’s even a viable option. If anyone has any insight, this newbie would really appreciate hearing!</p>
<p>In any case, for now, we can still have fast local development building (more on that later), so it isn’t super painful to actually write test. However, the deployment lag is still kind of annoying — and the “principal” of it (the wasted work) does still bother me.</p>
<h2 id="assembling-the-pieces">Assembling the pieces</h2>
<p>Again, this isn’t a tutorial — here, I’m going to explain to explain the components I put together at a high level.</p>
<p>We’re going to structure this in terms of a nix flake, which I’m using to:</p>
<ul>
<li>Pin dependencies and package sets</li>
<li>Describe buildable derivations and the development environments in a single file, which we can run with <code>nix build</code> and <code>nix develop</code> commands.</li>
</ul>
<p>For reference, the “final” nix flake described in this post <a href="https://github.com/mstksg/inCode/blob/bf444098b8773b1b47c0b2e66ca1682cdc5f674d/flake.nix">can be found on github</a>.</p>
<h3 id="haskell">Haskell</h3>
<p>For Haskell, I ended up using <em><a href="https://input-output-hk.github.io/haskell.nix/#haskellnix">haskell.nix</a></em>, which is what I also what we use at work. It does this neat thing where it parses a cabal file and uses <em>that</em> to generate the derivation needed — which includes the dependency derivations for all haskell library derivations. In this way, it can cache all external dependencies. It also lets us solve for which version of each dependency we need. And, by freezing it with flake lock, it also allows us to freeze all of the versions of each dependency in a way that works. There might be other tools that allow this, but I went with haskell.nix because I’m already familiar with it. It also has a nice development environment offered that contains haskell language server with all of the right package versions and artifacts.</p>
<p>Armed with this, we can easily generate a derivation for the hakyll binary, by passing the cabal file to the <code>haskell-nix.project'</code> function provided by haskell.nix. Now step 1 is complete!</p>
<p>Note we also get our development environment as well – you get it with the <code>devShell</code> property!</p>
<h3 id="purescript">Purescript</h3>
<p>For Purescript, I ended up using <a href="https://github.com/purifix/purifix">purifix</a>, which does a similar thing with <em>haskell.nix</em> but for the <em>spago.yaml</em> file, which is how modern purescript projects declare their dependencies. Purifix also has this mode of operation where it auto-detects if you’re working in a monorepo-style project with multiple binaries, and gives you a <em>separate derivation</em> for each binary (or, compiled .js file)! And also a separate development environment for each binary, too. This works well for me because I structure the javascript for each interactive blog post as its own project. So, I can export an entire “project” (blog post file) to a bundled file easily, and also lead development environments for specific blog posts as well.</p>
<p>For each project, it provides a <code>bundle-app</code> derivation that is literally just the generated bundled-up single javascript file. This is exactly the derivation we need for the final part where we pull everything together.</p>
<p>However, it also gives us an easy way to access all of the derivations of all of the dependencies (the <code>globs</code> property it adds onto its derivations) — which is very useful for our final integrated development environment which needs to do incremental builds quickly.</p>
<p>A note – finding all of these useful properties and derivations (outside of the main ones) does take a bit of trial and error – digging through <code>nix repl</code> to explore the derivation contents, and the source code of these projects.</p>
<h3 id="static-site-derivation">Static Site derivation</h3>
<p>Putting it all together is the final derivation to generate the actual site:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode nix"><code class="sourceCode nix"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>web = pkgs.stdenv.mkDerivation <span class="op">{</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>  <span class="va">name</span> <span class="op">=</span> <span class="st">&quot;inCode&quot;</span><span class="op">;</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>  <span class="va">buildInputs</span> <span class="op">=</span> <span class="op">[</span> inCode.haskell <span class="op">]</span> <span class="op">++</span> lib.attrValues inCode.purescript<span class="op">;</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>  <span class="va">srcs</span> <span class="op">=</span> <span class="op">[</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    <span class="ss">./code-samples</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>    <span class="ss">./config</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>    <span class="ss">./copy</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>    <span class="ss">./css</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>    <span class="ss">./js</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>    <span class="ss">./latex</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>    <span class="ss">./scss</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>    <span class="ss">./static</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>  <span class="op">];</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>  <span class="va">unpackPhase</span> <span class="op">=</span> <span class="st">&#39;&#39;</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a><span class="st">    for srcFile in $srcs; do</span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a><span class="st">      cp -a $srcFile/. $(stripHash $srcFile)</span></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a><span class="st">    done</span></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a><span class="st">    mkdir _purescript</span></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a><span class="st">    </span><span class="sc">${</span></span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a>      lib.concatStringsSep <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span> <span class="op">(</span>lib.mapAttrsToList</span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a>          <span class="op">(</span><span class="va">name</span><span class="op">:</span> <span class="va">value</span><span class="op">:</span> <span class="st">&#39;&#39;cp </span><span class="sc">${</span>value.bundle<span class="op">-</span>app<span class="sc">}</span><span class="st"> _purescript/</span><span class="sc">${</span>name<span class="sc">}</span><span class="st">.js&#39;&#39;</span><span class="op">)</span></span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a>          inCode.purescript</span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a>        <span class="op">)</span></span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a>     <span class="sc">}</span></span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a><span class="st">  &#39;&#39;</span><span class="op">;</span></span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a>  <span class="va">buildPhase</span> <span class="op">=</span> <span class="st">&#39;&#39;</span></span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a><span class="st">    </span><span class="sc">${</span>inCode.haskell<span class="sc">}</span><span class="st">/bin/inCode-build build --verbose</span></span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true" tabindex="-1"></a><span class="st">  &#39;&#39;</span><span class="op">;</span></span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true" tabindex="-1"></a>  <span class="va">installPhase</span> <span class="op">=</span> <span class="st">&#39;&#39;</span></span>
<span id="cb1-31"><a href="#cb1-31" aria-hidden="true" tabindex="-1"></a><span class="st">    mkdir -p &quot;$out/dist&quot;</span></span>
<span id="cb1-32"><a href="#cb1-32" aria-hidden="true" tabindex="-1"></a><span class="st">    cp -a _site/. &quot;$out/dist&quot;</span></span>
<span id="cb1-33"><a href="#cb1-33" aria-hidden="true" tabindex="-1"></a><span class="st">  &#39;&#39;</span><span class="op">;</span></span>
<span id="cb1-34"><a href="#cb1-34" aria-hidden="true" tabindex="-1"></a><span class="op">}</span>;</span></code></pre></div>
<p>This is the only “hand-built” derivation. Hopefully it’s legible enough:</p>
<ol type="1">
<li>The <code>buildInputs</code> attribute tells us what derivations give us the binaries/generated files in scope for us to do our job.
<ul>
<li><code>inCode.haskell</code> is the derivation that gives us the hakyll binary, from running <em>haskell.nix</em> on the haskell hakyll project.</li>
<li><code>lib.attrValues inCode.purescript</code> gives us each of the derivations of all of the purescript projects, one for each spago sub-project (and each blog post/page that uses purescript). In this case, it gives us the actual compiled javascript bundle that the site generator expects.</li>
</ul></li>
<li><code>srcs</code> is the actual source files that the static site generator uses — in this case, the code samples, configuration files, markdown files for the actual blog posts in <code>./copy</code>, the static files, etc.</li>
<li><code>unpackPhase</code> is the shell script to get things ready for the hakyll site generator to run:
<ul>
<li>First, copy all of the source files into the temporary build directory</li>
<li>Then, copy all of the compiled javascript binaries (from the <code>bundle-app</code> property of each derivation) into the <code>_purescript</code> folder in the temporary build directory, where the static site generator expects to find it.</li>
</ul></li>
<li><code>buildPhase</code> is the shell script to actually run the static site generator on the work directory that we carefully unpacked. Note that we refer to the binary using the derivation variable, <code>${inCode.haskell}</code> and knowing that it is found under the <code>bin</code> folder, as convention states.</li>
<li>The <code>installPhase</code> copies what the site generated (in the <code>_site</code> directory of the temporary work folder) into <code>$out</code>, which is the place we put the “results”.</li>
</ol>
<h3 id="github-action">Github Action</h3>
<p>The final github action is pretty standard — it pulls together the actions:</p>
<ol type="1">
<li><code>cachix/install-nix-action</code>: Install nix</li>
<li><code>cachix/cachix-action</code>: Use the given cachix cache and upload the artifacts to it after building</li>
<li>Actually run <code>nix build</code> on the static site derivation to generate the static files. In the process, it will either re-build (if anything changes) the dependency haskell and purescfript derivations, or pull it straight from cachix if nothing changed.</li>
<li><code>crazy-max/ghaction-github-pages</code> to push the files to the <code>gh-pages</code> branch</li>
</ol>
<p>This was taken pretty much verbatim from <em>hakyll-nix-template</em>.</p>
<h3 id="development-environment-for-writing">Development Environment for Writing</h3>
<p>Now, because we don’t have page-level caching for nix (and hakyll manages its own caching), we have to bite the bullet and create a customized development environment where we can locally deploy hakyll’s cached incremental builds. Again, this will be a hand-written environment, so let’s think about what we want. We need “temporary” directories that hakyll will use to (1) find the source files, (2) store its cache, and (3) output the static site. Because of this, if we make any changes to blog posts while we are in our development environment, hakyll will not do a full re-build — it’ll still have its development-environment-scoped cache. We can also use hakyll’s built in local preview server and filesystem watch-and-rebuild features. We also want to do incremental builds for purescript development as well, and we need to make sure that this temporary environment also has an incremental build cache area for <code>purs</code>. While we <em>could</em> do this without any temporary directories by just using the working directory for this, it is kind of nice to be able to have this all take place in a temporary folder that will go away after we exit the development environment.</p>
<p>Unfortunately, the hakyll binary isn’t aware of <code>purs</code> and purescript — it just receives the compiled bundles. So, we need a way for the user to run a command to re-build the purescript dependencies if they have changed it. There are a few ways we can do this (maybe have nix initiate a “watcher” that automatically incrementally recompiles, or wrap our hakyll binary in a wrapper shell script that triggers a re-build). However, the simplest way I could think of (that also does the job) is for the development environment to provide a command/shell script that just runs <code>purs</code> with the right arguments.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode nix"><code class="sourceCode nix"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>rebuild<span class="op">-</span>js =</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>    <span class="va">buildSingleDep</span> <span class="op">=</span> <span class="va">name</span><span class="op">:</span> <span class="va">value</span><span class="op">:</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>      <span class="kw">let</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>        <span class="va">srcGlob</span> <span class="op">=</span> <span class="st">&quot;purescript/</span><span class="sc">${</span>name<span class="sc">}</span><span class="st">/src/**/*.purs&quot;</span><span class="op">;</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>        <span class="va">buildDir</span> <span class="op">=</span> <span class="st">&quot;$HAKYLL_DIR/_purescript-build/</span><span class="sc">${</span>name<span class="sc">}</span><span class="st">&quot;</span><span class="op">;</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>        <span class="va">mainModule</span> <span class="op">=</span> <span class="st">&quot;</span><span class="sc">${</span>buildDir<span class="sc">}</span><span class="st">/Main/index.js&quot;</span><span class="op">;</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>        <span class="va">outFile</span> <span class="op">=</span> <span class="st">&quot;$HAKYLL_DIR/_purescript/</span><span class="sc">${</span>name<span class="sc">}</span><span class="st">.js&quot;</span><span class="op">;</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>      <span class="kw">in</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>      <span class="st">&#39;&#39;</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a><span class="st">        mkdir -p </span><span class="sc">${</span>buildDir<span class="sc">}</span></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a><span class="st">        purs compile </span><span class="sc">${</span><span class="bu">toString</span> value.globs<span class="sc">}</span><span class="st"> </span><span class="sc">${</span>srcGlob<span class="sc">}</span><span class="st"> -o </span><span class="sc">${</span>buildDir<span class="sc">}</span></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a><span class="st">        chmod -R +w </span><span class="sc">${</span>buildDir<span class="sc">}</span></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a><span class="st">        echo &quot;import {main} from &#39;</span><span class="sc">${</span>mainModule<span class="sc">}</span><span class="st">&#39;; main()&quot; | esbuild --bundle --outfile=</span><span class="sc">${</span>outFile<span class="sc">}</span><span class="st"> --format=iife</span></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a><span class="st">      &#39;&#39;</span><span class="op">;</span></span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a>  <span class="kw">in</span></span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a>  pkgs.writeShellScriptBin</span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a>    <span class="st">&quot;rebuild-js&quot;</span></span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a>    <span class="st">&#39;&#39;</span></span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a><span class="st">      mkdir -p &quot;$HAKYLL_DIR/_purescript&quot;;</span></span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true" tabindex="-1"></a><span class="st">      </span><span class="sc">${</span>lib.concatStringsSep <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span> <span class="op">(</span>lib.mapAttrsToList buildSingleDep inCode.purescript<span class="op">)</span><span class="sc">}</span></span>
<span id="cb2-22"><a href="#cb2-22" aria-hidden="true" tabindex="-1"></a><span class="st">    &#39;&#39;</span>;</span></code></pre></div>
<p><code>writeShellScriptBin</code> is a convenient way to provide a derivation that <em>only</em> contains a single shell script in its <code>bin/</code> subdir. So if we include it as a dependency in our development environment, this shell script will be in scope. Keep in mind that the hakyll binary expects the output bundles in the <code>_purescript</code> directory.</p>
<p>In the script, <code>$HAKYLL_DIR</code> is our temporary working directory. We iterate over each of the derivations in <code>inCode.purescript</code>, and for each one, we create a temporary build directory and use <code>purs</code> to compile all of the source files for the project (using the <code>globs</code> property that <code>purifix</code> gives us, which contains globs of all the source files of the dependencies as well, which are found in the global nix cache). And then we use <code>esbuild</code> to manually generate the final bundle in the output directory.</p>
<p>And, to assemble the initial working directory, we have to:</p>
<ol type="1">
<li>Copy all of the compiled purescript bundles into the temporary directory, from the derivation based on the current state at initialization time.</li>
<li>Simlink all of the source files (markdown, etc.) in the user’s working directory to the temporary working directory, so any changes to the working directory will also be reflected in the temporary directory.</li>
<li>Provide all of the build tools through <code>nativeBuildInputs</code>.</li>
<li>Provide the user-accessible commands through <code>packages</code>.</li>
</ol>
<div class="sourceCode" id="cb3"><pre class="sourceCode nix"><code class="sourceCode nix"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>devShells.default = pkgs.mkShell <span class="op">{</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>  <span class="va">shellHook</span> <span class="op">=</span> <span class="st">&#39;&#39;</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="st">    export HAKYLL_DIR=$(mktemp -d)</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="st">    echo &quot;Available commands: rebuild-js inCode-build&quot;</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a><span class="st">    echo &quot;Hakyll working directory: \$HAKYLL_DIR&quot;</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a><span class="st">    mkdir -p $HAKYLL_DIR/_purescript</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a><span class="st">    </span><span class="sc">${</span>lib.concatStringsSep <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">(</span>lib.mapAttrsToList</span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>      <span class="op">(</span><span class="va">name</span><span class="op">:</span> <span class="va">value</span><span class="op">:</span></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>          <span class="st">&#39;&#39;</span></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a><span class="st">          cp -a </span><span class="sc">${</span>value.deps<span class="sc">}</span><span class="st">/output/. purescript/output</span></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a><span class="st">          chmod -R +w purescript/output</span></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a><span class="st">          cp </span><span class="sc">${</span>value.bundle<span class="op">-</span>app<span class="sc">}</span><span class="st"> $HAKYLL_DIR/_purescript/</span><span class="sc">${</span>name<span class="sc">}</span><span class="st">.js</span></span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a><span class="st">          &#39;&#39;</span></span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a>      <span class="op">)</span></span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a>      inCode.purescript</span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a>    <span class="op">)</span><span class="sc">}</span></span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a><span class="st">    chmod -R +w $HAKYLL_DIR/_purescript</span></span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true" tabindex="-1"></a><span class="st">    for srcDir in code-samples config copy css js latex scss static; do</span></span>
<span id="cb3-22"><a href="#cb3-22" aria-hidden="true" tabindex="-1"></a><span class="st">      ln -s &quot;$PWD/$srcDir&quot; $HAKYLL_DIR</span></span>
<span id="cb3-23"><a href="#cb3-23" aria-hidden="true" tabindex="-1"></a><span class="st">    done</span></span>
<span id="cb3-24"><a href="#cb3-24" aria-hidden="true" tabindex="-1"></a><span class="st">  &#39;&#39;</span><span class="op">;</span></span>
<span id="cb3-25"><a href="#cb3-25" aria-hidden="true" tabindex="-1"></a>  <span class="va">nativeBuildInputs</span> <span class="op">=</span> <span class="op">[</span> pkgs.esbuild pkgs.purescript <span class="op">]</span></span>
<span id="cb3-26"><a href="#cb3-26" aria-hidden="true" tabindex="-1"></a>    <span class="op">++</span> haskellFlake.devShell.nativeBuildInputs</span>
<span id="cb3-27"><a href="#cb3-27" aria-hidden="true" tabindex="-1"></a>    <span class="op">++</span> lib.attrValues inCode.purescript</span>
<span id="cb3-28"><a href="#cb3-28" aria-hidden="true" tabindex="-1"></a>    <span class="op">++</span> <span class="bu">map</span> <span class="op">(</span><span class="va">value</span><span class="op">:</span> value.develop.buildInputs<span class="op">)</span> <span class="op">(</span>lib.attrValues inCode.purescript<span class="op">);</span></span>
<span id="cb3-29"><a href="#cb3-29" aria-hidden="true" tabindex="-1"></a>  <span class="va">packages</span> <span class="op">=</span> <span class="op">[</span></span>
<span id="cb3-30"><a href="#cb3-30" aria-hidden="true" tabindex="-1"></a>    rebuild-js</span>
<span id="cb3-31"><a href="#cb3-31" aria-hidden="true" tabindex="-1"></a>    inCode.haskell</span>
<span id="cb3-32"><a href="#cb3-32" aria-hidden="true" tabindex="-1"></a>  <span class="op">];</span></span>
<span id="cb3-33"><a href="#cb3-33" aria-hidden="true" tabindex="-1"></a><span class="op">}</span>;</span></code></pre></div>
<h2 id="conclusions">Conclusions</h2>
<p>Overall, I still feel like I’m hacking things together and figuring things out as I go. So far, all I have done is automate a set-up that I have been doing manually, in hopefully a way that is better for long-term maintainability. However, hopefully as I learn more, I start to open up new doors and new ways of thinking that enable to me to do things I haven’t been able to do before.</p>
<p>Thank you for reading this — whether you are looking to get started into nix, or are an experienced veteran, I hope you were able to get something out of this post. And, for those with experience, I would definitely appreciate any advice concerning the things described in this post — things I could have done better, alternative approaches, or ways to be more idiomatic/maintainable.</p></div><footer><hr><div class="copy-content"><p>Hi, thanks for reading! You can reach me via email at <a href="mailto:justin@jle.im" class="email">justin@jle.im</a>, or at twitter at <a href="https://twitter.com/mstk">@mstk</a>! This post and all others are published under the <a href="https://creativecommons.org/licenses/by-nc-nd/3.0/">CC-BY-NC-ND 3.0</a> license. Corrections and edits via pull request are welcome and encouraged at <a href="https://github.com/mstksg/inCode">the source repository</a>.</p>
<p>If you feel inclined, or this post was particularly helpful for you, why not consider <a href="https://www.patreon.com/justinle/overview">supporting me on Patreon</a>, or a <a href="bitcoin:3D7rmAYgbDnp4gp4rf22THsGt74fNucPDU">BTC donation</a>? :)</p></div><div class="clear"></div><ul class="entry-series"></ul><ul class="tag-list"><li><a href="https://blog.jle.im/entries/tagged/haskell.html" class="tag-a-tag">#haskell</a></li><li><a href="https://blog.jle.im/entries/tagged/nix.html" class="tag-a-tag">#nix</a></li><li><a href="https://blog.jle.im/entries/tagged/purescript.html" class="tag-a-tag">#purescript</a></li><li><a href="https://blog.jle.im/entries/category/@meta.html" class="tag-a-category">@META</a></li></ul><aside class="social-buttons"><div class="addthis_toolbox addthis_default_style addthis-buttons"><a class="addthis_button_facebook_like" fb:like:layout="button_count"></a><a class="addthis_button_tweet"></a><a class="addthis_button_google_plusone" g:plusone:size="medium"></a><a class="addthis_counter addthis_pill_style"></a></div><div class="custom-social-buttons"><div class="custom-social-button"><a href="https://www.reddit.com/submit" onclick="window.location = &#39;https://www.reddit.com/submit?url=&#39;+ encodeURIComponent(window.location); return false"><img src="https://www.reddit.com/static/spreddit7.gif" alt="submit to reddit"></a></div></div></aside><nav class="next-prev-links"><ul><li class="prev-entry-link">&larr; <a href="https://blog.jle.im/entry/degenerate-hyper-dimensional-game-of-life.html">Breaking a Degenerate Hyper-Dimensional Game of Life</a> (Previous)</li><li class="next-entry-link">(Next) <a href="https://blog.jle.im/entry/haskell-nuggets-kmeans.html">Haskell Nuggets: k-means</a> &rarr;</li></ul></nav></footer></article><div class="post-entry"><div class="tile"><div id="disqus_thread"></div><script type="text/javascript">var disqus_config = function () {
    this.page.url = 'https://blog.jle.im/entry/i-nixified-my-blog.html';
    this.page.identifier = 'nixify-blog';
};
(function() {
    var d = document, s = d.createElement('script');
    s.src = '//incode.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
})();
</script><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a><br></noscript><a href="http://disqus.com" class="dsq-brlink">Comments powered by <span class="logo-disqus">Disqus</span></a></div></div></div></div></div><div id="footer-container"><div id="footer-content"><div class="tile"><div class="footer-copyright">&copy; 2020 Justin Le <span class="license-link">(<a href="https://creativecommons.org/licenses/by-nc-nd/3.0/" class="license">CC-BY-NC-ND 3.0</a>)</span></div><div class="footer-follow social-follows"><ul class="social-follows-list"><li><ul class="social-follows-list-social"><li><a class="social-follow-twitter" title="Follow me on Twitter!" href="https://twitter.com/intent/user?user_id=mstk" onclick="window.open(
  &#39;http://twitter.com/intent/user?user_id=907281&#39;,
  &#39;facebook-share-dialog&#39;,
  &#39;width=550,height=520&#39;);
return false;
">Twitter</a></li><li><a class="social-follow-github" title="Fork me on Github!" href="https://github.com/mstksg">Github</a></li><li><a class="social-follow-twitch" title="Watch me on Twitch!" href="https://www.twitch.tv/justin_l">Twitch</a></li><li><a class="social-follow-patreon" title="Support me on Patreon!" href="https://www.patreon.com/justinle/overview">Patreon</a></li><li><a class="social-follow-gplus" title="Add me on Google+!" href="https://plus.google.com/+JustinLe">Google+</a></li><li><a class="social-follow-keybase" title="Track me on Keybase!" href="https://keybase.io/mstksg">Keybase</a></li><li><a class="social-follow-linkedin" title="Connect with me on LinkedIn!" href="https://linkedin.com/in/lejustin">LinkedIn</a></li><li><a class="social-follow-bitcoin" title="Donate via bitcoin!" href="bitcoin:3D7rmAYgbDnp4gp4rf22THsGt74fNucPDU">Bitcoin</a></li></ul></li><li><ul class="social-follows-list-site"><li><a class="social-follow-rss" title="Subscribe to my RSS Feed!" href="http://feeds.feedburner.com/incodeblog">RSS</a></li><li><a class="social-follow-email" title="Subscribe to the mailing list!" href="https://feedburner.google.com/fb/a/mailverify?loc=en_US&amp;uri=incodeblog">Mailing list</a></li></ul></li></ul></div></div></div></div></body></html>