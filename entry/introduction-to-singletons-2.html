<!DOCTYPE HTML>
<html><head><title>Introduction to Singletons (Part 2) · in Code</title><meta name="description" content="Weblog of Justin Le, covering various adventures in programming and explorations in the worlds of computation physics, and knowledge.
"><meta http-equiv="Content-Type" content="text/html;charset=utf-8"><meta name="viewport" content="width=device-width,initial-scale=1.0"><meta name="flattr:id" content="3p9jqr"><meta property="og:site_name" content="in Code"><meta property="og:description" content="Welcome back to our journey through the singleton design pattern and the great singletons library! This post is a direct continuation of Part 1, so be sure to check that out first if you haven’t already! If you hare just jumping in now, I suggest taking some time to to through the exercises if you haven’t already! Again, code is built on GHC 8.6.1 with the nightly-2018-09-29 snapshot (so, singletons-2.5). However, unless noted, all of the code should still work with GHC 8.4 and singletons-2.4. All of the code is also available here, and you can drop into a ghci session with all of the bindings in scope by executing the file: $ ./Door2.hs"><meta property="og:type" content="article"><meta property="og:title" content="Introduction to Singletons (Part 2)"><meta property="og:image" content="https://blog.jle.im/img/site_logo.jpg"><meta property="og:locale" content="en_US"><meta property="og:url" content="https://blog.jle.im/entry/introduction-to-singletons-2.html"><meta name="twitter:card" content="summary"><meta name="twitter:creator:id" content="mstk"><link rel="author" href="https://plus.google.com/107705320197444500140"><link rel="alternate" type="application/rss+xml" title="in Code (RSS Feed)" href="http://feeds.feedburner.com/incodeblog"><link rel="canonical" href="https://blog.jle.im/entry/introduction-to-singletons-2.html"><link href="https://blog.jle.im/favicon.ico" rel="shortcut icon"><link href="https://blog.jle.im/css/toast.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/font.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/main.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/page/entry.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/pygments.css" rel="stylesheet" type="text/css"><script type="text/javascript">var page_data = {};
var disqus_shortname='incode';
</script><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-443711-8', 'jle.im');
ga('send', 'pageview');
</script><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script id="MathJax-script" async="" src="https://cdn.jsdelivr.net/npm/mathjax@3.0.1/es5/tex-mml-chtml.js"></script><script type="text/javascript" src="//ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script><script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5234d67a6b68dcd4"></script><script type="text/javascript" src="https://blog.jle.im/js/page/entry_toc.js"></script><script type="text/javascript" src="https://blog.jle.im/js/disqus_count.js"></script><script type="text/javascript" src="https://blog.jle.im/js/social.js"></script><script type="text/javascript" src="https://blog.jle.im/js/jquery/jquery.toc.js"></script><script type="text/javascript" src="https://blog.jle.im/purescript/entry.js"></script></head><body><div id="fb-root"><script>(function(d, s, id) {
 var js, fjs = d.getElementsByTagName(s)[0];
 if (d.getElementById(id)) return;
 js = d.createElement(s); js.id = id;
 js.src = "//connect.facebook.net/en_US/all.js#xfbml=1&appId=641852699171929";
 fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));
</script></div><div id="header-container"><div id="navbar-container" class="tile"><nav id="navbar-content"><div class="nav-info"><h1 class="site-title"><a href="https://blog.jle.im/" class="nav-title">in Code</a></h1><span class="nav-author">Justin Le</span></div><ul class="nav-links"><li><a href="https://blog.jle.im/">home</a></li><li><a href="https://blog.jle.im/entries.html">archives</a></li><li><a href="https://cv.jle.im">cv</a></li><div class="clear"></div></ul></nav></div><div id="header-content"></div></div><div id="body-container" class="container"><div id="main-container" class="grid"><div class="entry-section unit span-grid" role="main"><article class="tile article"><header><h1 id="title">Introduction to Singletons (Part 2)</h1><p class="entry-info">by <a class="author" href="https://blog.jle.im/">Justin Le</a><span class="info-separator"> &diams; </span><time datetime="2018-01-09T10:54:27Z" pubdate="" class="pubdate">Tuesday January 9, 2018</time></p><p><span class="source-info"><a class="source-link" href="https://github.com/mstksg/inCode/tree/master/copy/entries/singletons-2.md">Source</a><span class="info-separator"> &diams; </span><a class="source-link" href="https://github.com/mstksg/inCode/tree/gh-pages/entry/introduction-to-singletons-2.md">Markdown</a><span class="info-separator"> &diams; </span><a class="source-link" href="https://blog.jle.im/entry/introduction-to-singletons-2.tex">LaTeX</a><span class="info-separator"> &diams; </span></span>Posted in <a href="https://blog.jle.im/entries/category/@haskell.html" class="tag-a-category" title="Functional, pure, non-strict, statically and strongly typed, natively
compiled...really just the king of great languages.
">Haskell</a>, <a href="https://blog.jle.im/entries/category/@tutorials.html" class="tag-a-category" title="Technical tutorials/walkthroughs on specific programming processes and problems
that I&#39;ve struggled through in the past.
">Tutorials</a><span class="info-separator"> &diams; </span><a class="comment-link" href="#disqus_thread">Comments</a></p></header><hr><aside class="contents-container"><h5 id="contents-header">Contents</h5><div id="toc"></div></aside><div class="main-content copy-content"><p>Welcome back to our journey through the singleton design pattern and the great <em><a href="http://hackage.haskell.org/package/singletons">singletons</a></em> library!</p>
<p>This post is a direct continuation of <a href="https://blog.jle.im/entry/introduction-to-singletons-1.html">Part 1</a>, so be sure to check that out first if you haven’t already! If you hare just jumping in now, I suggest taking some time to to through the exercises if you haven’t already!</p>
<p>Again, code is built on <em>GHC 8.6.1</em> with the <em><a href="https://www.stackage.org/nightly-2018-09-29">nightly-2018-09-29</a></em> snapshot (so, <em>singletons-2.5</em>). However, unless noted, all of the code should still work with <em>GHC 8.4</em> and <em>singletons-2.4</em>. All of the code is also available <a href="https://github.com/mstksg/inCode/tree/master/code-samples/singletons/Door2.hs">here</a>, and you can drop into a ghci session with all of the bindings in scope by executing the file:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> ./Door2.hs</span></code></pre></div>
<h2 id="review">Review</h2>
<p>Let’s return to our <code>Door</code> type:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/singletons/Door2.hs#L23-L29</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="op">$</span>(singletons [d|</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>  data DoorState = Opened | Closed | Locked</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>    deriving (Show, Eq)</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>  |])</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Door</span><span class="ot"> ::</span> <span class="dt">DoorState</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="kw">where</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">UnsafeMkDoor</span><span class="ot"> ::</span> {<span class="ot"> doorMaterial ::</span> <span class="dt">String</span> } <span class="ot">-&gt;</span> <span class="dt">Door</span> s</span></code></pre></div>
<p>First, this derives the <em>type</em> <code>DoorState</code> with the values <code>Opened</code>, <code>Closed</code>, and <code>Locked</code>, and also the <em>kind</em> <code>DoorState</code> with the <em>types</em> <code>'Opened</code>, <code>'Closed</code>, and <code>'Locked</code>. We then also derive the singletons (and implicit-style typeclass instances, reflectors, etc.) with the template haskell.</p>
<p>Then, there’s <code>Door</code>. <code>Door</code> is great! It is an <em>indexed data type</em> (indexed by a type of kind <code>DoorState</code>) in that picking a different type variable gives a different “type” of Door:</p>
<ul>
<li><code>Door 'Opened</code> is a type that represents the type of an opened door</li>
<li><code>Door 'Closed</code> is a <em>different</em> type that represents the type of a <em>closed</em> door</li>
<li><code>Door 'Locked</code> is yet another (third) type that represents the type of a <em>locked</em> door.</li>
</ul>
<p>So, really, when we define <code>Door s</code>, we really are defining <em>three distinct</em> types<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>.</p>
<p>This is great and all, but isn’t Haskell a language with static, compile-time types? Doesn’t that mean that we have to know if our doors are opened, closed, or locked at compile-time?</p>
<p>This is something we can foresee being a big issue. It’s easy enough to create a <code>Door s</code> if you know <code>s</code> at compile-time by just typing in a type annotation (<code>UnsafeMkDoor "Oak" :: Door 'Opened</code>) or by using a monomorphic constructor (<code>mkDoor SOpened "Oak"</code>). But what if we <em>don’t</em> know <code>s</code> at compile-time?</p>
<p>To learn how to do this, we first need to learn how to <em>not care</em>.</p>
<h2 id="ditching-the-phantom">Ditching the Phantom</h2>
<p>Sometimes we don’t <em>actually</em> care about the state of the door in the <em>type</em> of the door. We don’t want <code>Door 'Opened</code> and <code>Door 'Closed</code>…we want a type to just represent a door, without the status in its type.</p>
<p>This might come about a bunch of different ways. Maybe you’re reading a <code>Door</code> data from a serialization format, and you want to be able to parse <em>any</em> door (whatever door is serialized).</p>
<p>To learn how to not care, we can describe a type for a door that does <em>not</em> have its status in its type.</p>
<p>We have a couple of options here. First, we can create a new type <code>SomeDoor</code> that is the same as <code>Door</code>, except instead of keeping its status in its type, it keeps it as a runtime value:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">SomeDoor</span> <span class="ot">=</span> <span class="dt">MkSomeDoor</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>    {<span class="ot"> someDoorState    ::</span> <span class="dt">DoorState</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>    ,<span class="ot"> someDoorMaterial ::</span> <span class="dt">String</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a><span class="co">-- or, in GADT syntax</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">SomeDoor</span><span class="ot"> ::</span> <span class="dt">Type</span> <span class="kw">where</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">MkSomeDoor</span> <span class="ot">::</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>      {<span class="ot"> someDoorState    ::</span> <span class="dt">DoorState</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>      ,<span class="ot"> someDoorMaterial ::</span> <span class="dt">String</span></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>      } <span class="ot">-&gt;</span> <span class="dt">SomeDoor</span></span></code></pre></div>
<p>Note the similarity of <code>SomeDoor</code>’s declaration to <code>Door</code>’s declaration above. It’s mostly the same, except, instead of <code>DoorState</code> being a type parameter, it is instead a runtime value inside <code>SomeDoor</code>.</p>
<p>Now, this is actually a type that we <em>could</em> have been using this entire time, if we didn’t care about type safety. In the real world and in real applications, we actually might have written <code>SomeDoor</code> <em>before</em> we ever thought about <code>Door</code> with a phantom type. It’s definitely the more typical “standard” Haskell thing.</p>
<p><code>SomeDoor</code> is great. But because it’s a completely different type, we can’t re-use any of our <code>Door</code> functions on this <code>SomeDoor</code>. We potentially have to write the same function twice for both <code>Door</code> and <code>SomeDoor</code>, because they have different implementations.</p>
<h3 id="the-existential-datatype">The Existential Datatype</h3>
<p>However, there’s another path we can take. With the power of singletons, we can actually implement <code>SomeDoor</code> <em>in terms of</em> <code>Door</code>, using an <strong>existential data type</strong>:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- using existential constructor syntax</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">SomeDoor</span> <span class="ot">=</span> <span class="kw">forall</span> s<span class="op">.</span> <span class="dt">MkSomeDoor</span> (<span class="dt">Sing</span> s) (<span class="dt">Door</span> s)</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span class="co">-- or, using GADT syntax (preferred)</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/singletons/Door2.hs#L60-L61</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">SomeDoor</span><span class="ot"> ::</span> <span class="dt">Type</span> <span class="kw">where</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">MkSomeDoor</span><span class="ot"> ::</span> <span class="dt">Sing</span> s <span class="ot">-&gt;</span> <span class="dt">Door</span> s <span class="ot">-&gt;</span> <span class="dt">SomeDoor</span></span></code></pre></div>
<p>(Remember that <code>Sing s</code>, when <code>s</code> is a <code>DoorState</code>, is a type “synonym” for our favorite door singleton <code>SDoorState s</code>. We’re going to switch to using <code>Sing s</code> instead of <code>SDoorState s</code> for the rest of this series just to move into a more universal style where we treat the <code>Sing</code> as basically syntactical noise)</p>
<p><code>MkSomeDoor</code> is a constructor for an existential data type, meaning that the data type “hides” a type variable <code>s</code>. Note the type (<code>Sing s -&gt; Door s -&gt; SomeDoor</code>) and how the result type (<code>SomeDoor</code>) <em>forgets</em> the <code>s</code> and hides all traces of it. Think of it like a type variable sponge – type variable goes in, but it’s absorbed opaquely into the result type.</p>
<p>Note the similarities between our original <code>SomeDoor</code> and this one.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- | Re-implementing door</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">SomeDoor</span> <span class="kw">where</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">MkSomeDoor</span><span class="ot"> ::</span> <span class="dt">DoorState</span> <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">SomeDoor</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a><span class="co">-- | Re-using Door, as an existential type</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">SomeDoor</span> <span class="kw">where</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">MkSomeDoor</span><span class="ot">  ::</span> <span class="dt">Sing</span> s  <span class="ot">-&gt;</span> <span class="dt">Door</span> s <span class="ot">-&gt;</span> <span class="dt">SomeDoor</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>                            <span class="co">-- ^ data Door s = UnsafeMkDoor String</span></span></code></pre></div>
<p>Basically, our type before re-implements <code>Door</code>. But the new one actually directly uses the original <code>Door s</code>. This means we can <em>directly</em> re-use our <code>Door</code> functions on <code>SomeDoor</code>s, without needing to write completely new implementations.</p>
<p>In Haskell, existential data types are pretty nice, syntactically, to work with. Let’s write some basic functions to see. First, a function to “make” a <code>SomeDoor</code> from a <code>Door</code>:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/singletons/Door2.hs#L63-L67</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a><span class="ot">fromDoor ::</span> <span class="dt">Sing</span> s <span class="ot">-&gt;</span> <span class="dt">Door</span> s <span class="ot">-&gt;</span> <span class="dt">SomeDoor</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>fromDoor <span class="ot">=</span> <span class="dt">MkSomeDoor</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a><span class="ot">fromDoor_ ::</span> <span class="dt">SingI</span> s <span class="ot">=&gt;</span> <span class="dt">Door</span> s <span class="ot">-&gt;</span> <span class="dt">SomeDoor</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>fromDoor_ <span class="ot">=</span> fromDoor sing</span></code></pre></div>
<p>So that’s how we <em>make</em> one…how do we <em>use</em> it? Let’s port our <code>Door</code> functions to <code>SomeDoor</code>, by re-using our pre-existing functions whenever we can, and <em>pattern matching</em> on <code>MkSomeDoor</code>:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/singletons/Door2.hs#L69-L76</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a><span class="ot">closeSomeOpenedDoor ::</span> <span class="dt">SomeDoor</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">SomeDoor</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>closeSomeOpenedDoor (<span class="dt">MkSomeDoor</span> s d) <span class="ot">=</span> <span class="kw">case</span> s <span class="kw">of</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">SOpened</span> <span class="ot">-&gt;</span> <span class="dt">Just</span> <span class="op">.</span> fromDoor_ <span class="op">$</span> closeDoor d</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">SClosed</span> <span class="ot">-&gt;</span> <span class="dt">Nothing</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">SLocked</span> <span class="ot">-&gt;</span> <span class="dt">Nothing</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a><span class="ot">lockAnySomeDoor ::</span> <span class="dt">SomeDoor</span> <span class="ot">-&gt;</span> <span class="dt">SomeDoor</span></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>lockAnySomeDoor (<span class="dt">MkSomeDoor</span> s d) <span class="ot">=</span> fromDoor_ <span class="op">$</span> lockAnyDoor s d</span></code></pre></div>
<p>Using an existential wrapper with a singleton makes this pretty simple – just a simple unwrapping and re-wrapping! Imagine having to re-implement all of these functions for a completely different type, and having to re-implement all of our previous <code>Door</code> functions.</p>
<p>It’s important to remember that the secret ingredient here is the <code>Sing s</code> we store inside <code>MkSomeDoor</code> – it gives our pattern matchers the ability to deduce the <code>s</code> type. Without it, the <code>s</code> would be lost forever.</p>
<p>If <code>MkSomeDoor</code> did not have the <code>Sing</code>:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">SomeDoor</span> <span class="kw">where</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">MkSomeDoor</span><span class="ot">  ::</span> <span class="dt">Door</span> s <span class="ot">-&gt;</span> <span class="dt">SomeDoor</span>       <span class="co">-- no Sing s ???</span></span></code></pre></div>
<p>It would then be impossible to write <code>closeSomeOpenedDoor</code> in a way that only works on opened doors:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="ot">closeSomeOpenedDoor ::</span> <span class="dt">SomeDoor</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">SomeDoor</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>closeSomeOpenedDoor (<span class="dt">MkSomeDoor</span> d) <span class="ot">=</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>            <span class="co">-- is the door opened, closed, or locked?</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>            <span class="co">-- there&#39;s no way to know!</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>            <span class="co">-- curses, type erasure!</span></span></code></pre></div>
<h3 id="the-link">The Link</h3>
<p>It’s important to remember that our original separate-implementation <code>SomeDoor</code> is, functionally, identical to the new code-reusing <code>Door</code>. All of the contents are isomorphic with each other, and you could write a function converting one to the other. This is because <em>having an existentially quantified singleton is the same as having a value of the corresponding type.</em> Having an existentially quantified <code>SingDS s</code> is <em>the same as</em> having a value of type <code>DoorState</code>.</p>
<p>In fact, the <em>singletons</em> library gives us a direct existential wrapper:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- from singletons (not the actual definition, just psuedo-code to demonstrate</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="co">-- what the constructors look like)</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">SomeSing</span> <span class="dt">DoorState</span><span class="ot"> ::</span> <span class="dt">Type</span> <span class="kw">where</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">SomeSing</span><span class="ot"> ::</span> <span class="dt">Sing</span> s <span class="ot">-&gt;</span> <span class="dt">SomeSing</span> <span class="dt">DoorState</span></span></code></pre></div>
<p>There are three values of type <code>SomeSing DoorState</code>:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="dt">SomeSing</span> <span class="dt">SOpened</span><span class="ot"> ::</span> <span class="dt">SomeSing</span> <span class="dt">DoorState</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span class="dt">SomeSing</span> <span class="dt">SClosed</span><span class="ot"> ::</span> <span class="dt">SomeSing</span> <span class="dt">DoorState</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a><span class="dt">SomeSing</span> <span class="dt">SLocked</span><span class="ot"> ::</span> <span class="dt">SomeSing</span> <span class="dt">DoorState</span></span></code></pre></div>
<p>A value of type <code>SomeSing DoorState</code> (which contains an existentially quantified <code>Sing s</code> – a <code>SingDS</code>) is <em>the same</em> as a value of type <code>DoorState</code>. The two types are identical! (Or, well, isomorphic. As a fun exercise, write out the explicit isomorphism – the <code>SomeSing DoorState -&gt; DoorState</code> and the <code>DoorState -&gt; SomeSing DoorState</code>).</p>
<p>Our new <code>SomeDoor</code> containing an existentially quantified <code>Sing s</code> is the same as our first <code>SomeDoor</code> containing just a <code>DoorState</code>.</p>
<h4 id="why-do-we-sing">Why do we sing?</h4>
<p>If they’re identical, why use a <code>Sing</code> or the new <code>SomeDoor</code> at all? Why not just use a <code>DoorState</code> value?</p>
<p>One main reason (besides allowing code-reuse like we did earlier) is that <em>using the singleton lets us directly recover the type</em>. Essentially, a <code>Sing s</code> not only contains whether it is Opened/Closed/Locked (like a <code>DoorState</code> would), but also it contains it in a way that GHC can use to <em>bring it all back</em> to the type level.</p>
<p>The constructor <code>forall s. MkSomeDoor (Sing s) (Door s)</code> essentially contains <code>s</code> <em>with</em> <code>Door s</code>. When you see this, you <em>should read this as</em> <code>forall s. MkSomeDoor s (Door s)</code> (and, indeed, this is similar to how it is written in dependently typed languages.)</p>
<p>It’s kind of like how, when you’re used to reading Applicative style, you start seeing <code>f &lt;$&gt; x &lt;*&gt; y</code> and reading it like <code>f x y</code>. When you see <code>forall s. MkSomeDoor (Sing s) (Door s)</code>, you should read (the pseudo-haskell) <code>forall s. MkSomeDoor s (Door s)</code>. The role of <code>Sing s</code> there is, like in Part 1, simply to be a run-time stand-in for the type <code>s</code> itself.</p>
<p>So, for our original <code>Door s</code> functions, we need to know <code>s</code> at runtime – storing the <code>Sing s</code> gives GHC exactly that. Once you get the <code>Sing s</code> back, you can now use it in all of our type-safe functions from Part 1, and you’re back in type-safe land.<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a></p>
<h3 id="some-lingo">Some Lingo</h3>
<p>In the language of dependently typed programming, we call <code>SomeDoor</code> a <strong>dependent sum</strong>, because you can imagine it basically as a sum type:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">SomeDoor</span> <span class="ot">=</span> <span class="dt">SDOpened</span> (<span class="dt">Door</span> <span class="dt">&#39;Opened</span>)</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>              <span class="op">|</span> <span class="dt">SDClosed</span> (<span class="dt">Door</span> <span class="dt">&#39;Closed</span>)</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>              <span class="op">|</span> <span class="dt">SDLocked</span> (<span class="dt">Door</span> <span class="dt">&#39;Locked</span>)</span></code></pre></div>
<p>A three-way sum between a <code>Door 'Opened</code>, a <code>Door 'Closed</code>, and a <code>Door 'Locked</code>, essentially. If you have a <code>SomeDoor</code>, it’s <em>either</em> an opened door, a closed door, or a locked door. Try looking at this new <code>SomeDoor</code> until you realize that this type is the same type as the previous <code>SomeDoor</code>!</p>
<p>You might also see <code>SomeDoor</code> called a <strong>dependent pair</strong> – it’s a “tuple” where the <em>type</em> of the second item (our <code>Door s</code>) is determined by the <em>value</em> of the first item (our <code>Sing s</code>).</p>
<p>In Idris, we could write <code>SomeDoor</code> as a type alias, using its native <a href="http://docs.idris-lang.org/en/latest/tutorial/typesfuns.html#dependent-pairs">dependent pair syntactic sugar</a>, as <code>(s ** Door s)</code>. The <em>value</em> of the first item reveals to us (through a pattern match, in Haskell) the <em>type</em> of the second.</p>
<h3 id="types-at-runtime">Types at Runtime</h3>
<p>With this new tool, we finally have enough to build a function to “make” a door with the status unknown until runtime:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="ot">mkSomeDoor ::</span> <span class="dt">DoorState</span> <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">SomeDoor</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>mkSomeDoor <span class="ot">=</span> \<span class="kw">case</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Opened</span> <span class="ot">-&gt;</span> fromDoor_ <span class="op">.</span> mkDoor <span class="dt">SOpened</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Closed</span> <span class="ot">-&gt;</span> fromDoor_ <span class="op">.</span> mkDoor <span class="dt">SClosed</span></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Locked</span> <span class="ot">-&gt;</span> fromDoor_ <span class="op">.</span> mkDoor <span class="dt">SLocked</span></span></code></pre></div>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> <span class="kw">let</span> mySomeDoor <span class="ot">=</span> mkSomeDoor <span class="dt">Opened</span> <span class="st">&quot;Birch&quot;</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> <span class="op">:</span>t mySomeDoor</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a><span class="dt">SomeDoor</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> <span class="fu">putStrLn</span> <span class="op">$</span> <span class="kw">case</span> mySomeDoor <span class="kw">of</span></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>        <span class="dt">MkSomeDoor</span> <span class="dt">SOpened</span> _ <span class="ot">-&gt;</span> <span class="st">&quot;mySomeDoor was opened!&quot;</span></span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a>        <span class="dt">MkSomeDoor</span> <span class="dt">SClosed</span> _ <span class="ot">-&gt;</span> <span class="st">&quot;mySomeDoor was closed!&quot;</span></span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a>        <span class="dt">MkSomeDoor</span> <span class="dt">SLocked</span> _ <span class="ot">-&gt;</span> <span class="st">&quot;mySomeDoor was locked!&quot;</span></span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a>mySomeDoor was opened<span class="op">!</span></span></code></pre></div>
<p>Using <code>mkSomeDoor</code>, we can truly pass in a <code>DoorState</code> that we generate at runtime (from IO, or a user prompt, or a configuration file, maybe), and create a <code>Door</code> based on it.</p>
<p>Take <em>that</em>, type erasure! :D</p>
<h3 id="the-existential-type">The Existential Type</h3>
<p>An <em>existentially quantified</em> type is one that is hidden to the user/consumer, but directly chosen by the producer. The producer chooses the type, and the user has to handle any possible type that the producer gave.</p>
<p>This is in direct contrast to the <em>universally quantified</em> type (which most Haskellers are used to seeing), where the type is directly chosen by the <em>user</em>. The user chooses the type, and the producer has to handle any possible type that the user asks for.</p>
<p>For example, a function like:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="fu">read</span><span class="ot"> ::</span> <span class="dt">Read</span> a <span class="ot">=&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> a</span></code></pre></div>
<p>Is universally quantified over <code>a</code>: The <em>caller</em> of <code>read</code> gets to pick which type is given. The burden is on the implementor of <code>read</code> to be able to handle whatever <code>a</code> the user picks.</p>
<p>But, for a value like:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="ot">myDoor ::</span> <span class="dt">SomeDoor</span></span></code></pre></div>
<p>The type variable <code>s</code> is existentially quantified. The person who <em>made</em> <code>myDoor</code> picked what <code>s</code> was. And, if you <em>use</em> <code>myDoor</code>, you have to be ready to handle <em>any</em> <code>s</code> they could have chosen.</p>
<p>In Haskell, there’s another way to express an existentially quantified type: the CPS-style encoding. This way is useful because it doesn’t require creating an intermediate helper data type. To help us understand it, let’s compare a basic function in both styles. We saw earlier <code>mkSomeDoor</code>, which takes a <code>DoorState</code> and a <code>String</code> and returns an existentially quantified <code>Door</code> in the form of <code>SomeDoor</code>:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>mkSomeDoor</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a><span class="ot">    ::</span> <span class="dt">DoorState</span></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>    <span class="ot">-&gt;</span> <span class="dt">String</span></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>    <span class="ot">-&gt;</span> <span class="dt">SomeDoor</span></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>mkSomeDoor s m <span class="ot">=</span> <span class="kw">case</span> s <span class="kw">of</span></span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Opened</span> <span class="ot">-&gt;</span> fromDoor_ (mkDoor <span class="dt">SOpened</span> m)</span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Closed</span> <span class="ot">-&gt;</span> fromDoor_ (mkDoor <span class="dt">SClosed</span> m)</span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Locked</span> <span class="ot">-&gt;</span> fromDoor_ (mkDoor <span class="dt">SLocked</span> m)</span></code></pre></div>
<p>The caller of the function can then break open the <code>SomeDoor</code> and must handle whatever <code>s</code> they find inside.</p>
<p>We can write the same function using a <em>CPS-style</em> existential instead:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a>withDoor</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a><span class="ot">    ::</span> <span class="dt">DoorState</span></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>    <span class="ot">-&gt;</span> <span class="dt">String</span></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>    <span class="ot">-&gt;</span> (<span class="kw">forall</span> s<span class="op">.</span> <span class="dt">Sing</span> s <span class="ot">-&gt;</span> <span class="dt">Door</span> s <span class="ot">-&gt;</span> r)</span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>    <span class="ot">-&gt;</span> r</span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a>withDoor s m f <span class="ot">=</span> <span class="kw">case</span> s <span class="kw">of</span></span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Opened</span> <span class="ot">-&gt;</span> f <span class="dt">SOpened</span> (mkDoor <span class="dt">SOpened</span> m)</span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Closed</span> <span class="ot">-&gt;</span> f <span class="dt">SClosed</span> (mkDoor <span class="dt">SClosed</span> m)</span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Locked</span> <span class="ot">-&gt;</span> f <span class="dt">SLocked</span> (mkDoor <span class="dt">SLocked</span> m)</span></code></pre></div>
<p>With a Rank-N Type, <code>withDoor</code> takes a <code>DoorState</code> and a <code>String</code> and a <em>function to handle a <code>Door s</code> polymorphically</em>. The caller of <code>withDoor</code> must provide a handler that can handle <em>any</em> <code>s</code>, in a uniform and parametrically polymorphic way. The function then gives the result of the handler function called on the resulting <code>Sing s</code> and <code>Door s</code>.</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> withDoor <span class="dt">Opened</span> <span class="st">&quot;Birch&quot;</span> <span class="op">$</span> \s _ <span class="ot">-&gt;</span> <span class="kw">case</span> s <span class="kw">of</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>         <span class="dt">SOpened</span> <span class="ot">-&gt;</span> <span class="st">&quot;Opened door!&quot;</span></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>         <span class="dt">SClosed</span> <span class="ot">-&gt;</span> <span class="st">&quot;Closed door!&quot;</span></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a>         <span class="dt">SLocked</span> <span class="ot">-&gt;</span> <span class="st">&quot;Locked door!&quot;</span></span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a><span class="dt">Opened</span> door<span class="op">!</span></span></code></pre></div>
<p>The key to making this work is that your handler function <em>has to be polymorphic</em> over all possible <code>s</code>s. This way, it can handle any potential <code>s</code> that the producer gives. Essentially, the producer is “returning” an <code>s</code> – existentially quantified.</p>
<h3 id="reification">Reification</h3>
<p>The general pattern we are exploring here is called <strong>reification</strong> – we’re taking a dynamic run-time value, and lifting it to the type level as a type (here, the type variable <code>s</code>). Reification is often considered as the opposite of reflection, and we can imagine the two as being the “gateway” between the type-safe and unsafe world. In the dynamic world of a <code>DoorState</code> term-level value, you have no type safety. You live in the world of <code>SomeDoor</code>, <code>closeSomeOpenedDoor</code>, <code>lockAnySomeDoor</code>, etc. But, you can <em>reify</em> your <code>DoorState</code> value to a <em>type</em>, and enter the type-safe world of <code>Door s</code>, <code>closeDoor</code>, <code>lockDoor</code>, and <code>lockAnyDoor</code>.</p>
<p>The <em>singletons</em> library automatically generates functions to directly reify <code>DoorState</code> values:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="ot">toSing       ::</span> <span class="dt">DoorState</span> <span class="ot">-&gt;</span> <span class="dt">SomeSing</span> <span class="dt">DoorState</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a><span class="ot">withSomeSing ::</span> <span class="dt">DoorState</span> <span class="ot">-&gt;</span> (<span class="kw">forall</span> s<span class="op">.</span> <span class="dt">Sing</span> s        <span class="ot">-&gt;</span> r) <span class="ot">-&gt;</span> r</span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a><span class="ot">withSomeSing ::</span> <span class="dt">DoorState</span> <span class="ot">-&gt;</span> (<span class="kw">forall</span> s<span class="op">.</span> <span class="dt">SDoorState</span> s  <span class="ot">-&gt;</span> r) <span class="ot">-&gt;</span> r</span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a>                                     <span class="co">-- ^ using the convenience type synonym</span></span></code></pre></div>
<p>The first one reifies a <code>DoorState</code> as an existentially quantified data type, and the second one reifies one in CPS-style, without the intermediate data type.</p>
<p>We can actually use these to write <code>mkSomeDoor</code> and <code>withDoor</code> in a nicer way, without directly pattern matching on our constructors:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/singletons/Door2.hs#L78-L83</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a><span class="ot">mkSomeDoor ::</span> <span class="dt">DoorState</span> <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">SomeDoor</span></span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a>mkSomeDoor ds <span class="ot">=</span> <span class="kw">case</span> toSing ds <span class="kw">of</span></span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">SomeSing</span> s <span class="ot">-&gt;</span> fromDoor s <span class="op">.</span> mkDoor s</span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true" tabindex="-1"></a><span class="ot">withDoor ::</span> <span class="dt">DoorState</span> <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> (<span class="kw">forall</span> s<span class="op">.</span> <span class="dt">Sing</span> s <span class="ot">-&gt;</span> <span class="dt">Door</span> s <span class="ot">-&gt;</span> r) <span class="ot">-&gt;</span> r</span>
<span id="cb22-8"><a href="#cb22-8" aria-hidden="true" tabindex="-1"></a>withDoor ds m f <span class="ot">=</span> withSomeSing ds <span class="op">$</span> \s <span class="ot">-&gt;</span> f s (mkDoor s m)</span></code></pre></div>
<h2 id="zooming-out">Zooming Out</h2>
<p>Alright! We’ve spent two blog posts going over a lot of different things in the context of our humble <code>Door s</code> type. Let’s zoom out and take a large-scale look at how <em>singletons</em> (the design pattern, and the library) helps us in general.</p>
<h3 id="sing">Sing</h3>
<p>The crux of everything is the <code>Sing :: k -&gt; Type</code> kind-indexed injective type family. If you see a value of type <code>Sing s</code>, you should really just think “a runtime witness for <code>s</code>”. If you see:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="ot">lockAnyDoor ::</span> <span class="dt">Sing</span> s <span class="ot">-&gt;</span> <span class="dt">Door</span> s <span class="ot">-&gt;</span> <span class="dt">Door</span> <span class="dt">&#39;Locked</span></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a><span class="dt">MkSomeDoor</span><span class="ot">  ::</span> <span class="dt">Sing</span> s <span class="ot">-&gt;</span> <span class="dt">Door</span> s <span class="ot">-&gt;</span> <span class="dt">SomeDoor</span></span></code></pre></div>
<p>You should read it as (in pseudo-Haskell)</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="ot">lockAnyDoor ::</span> { s } <span class="ot">-&gt;</span> <span class="dt">Door</span> s <span class="ot">-&gt;</span> <span class="dt">Door</span> <span class="dt">&#39;Locked</span></span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a><span class="dt">MkSomeDoor</span><span class="ot">  ::</span> { s } <span class="ot">-&gt;</span> <span class="dt">Door</span> s <span class="ot">-&gt;</span> <span class="dt">SomeDoor</span></span></code></pre></div>
<p>This is seen clearly if we look at the partially applied type signatures:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a>lockAnyDoor <span class="dt">SOpened</span><span class="ot"> ::</span> <span class="dt">Door</span> <span class="dt">&#39;Opened</span> <span class="ot">-&gt;</span> <span class="dt">Door</span> <span class="dt">&#39;Locked</span></span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a><span class="dt">MkSomeDoor</span>  <span class="dt">SLocked</span><span class="ot"> ::</span> <span class="dt">Door</span> <span class="dt">&#39;Locked</span> <span class="ot">-&gt;</span> <span class="dt">SomeDoor</span></span></code></pre></div>
<p>If you squint, this kinda looks like:</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a>lockAnyDoor <span class="dt">&#39;Opened</span><span class="ot"> ::</span> <span class="dt">Door</span> <span class="dt">&#39;Opened</span> <span class="ot">-&gt;</span> <span class="dt">Door</span> <span class="dt">&#39;Locked</span></span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a><span class="dt">MkSomeDoor</span>  <span class="dt">&#39;Locked</span><span class="ot"> ::</span> <span class="dt">Door</span> <span class="dt">&#39;Locked</span> <span class="ot">-&gt;</span> <span class="dt">SomeDoor</span></span></code></pre></div>
<p>And indeed, when we get real dependent types in Haskell, we will really be directly passing types (that act as their own runtime values) instead of singletons.</p>
<p>It is important to remember that <code>Sing</code> is poly-kinded, so we can have <code>Sing 'Opened</code>, but also <code>Sing 'True</code>, <code>Sing 5</code>, and <code>Sing '['Just 3, 'Nothing, 'Just 0]</code> as well. <code>Sing x</code> is an “synonym” for <code>SDoorState x</code> when <code>x</code> is a <code>DoorState</code>, but <code>Sing x</code> is a “synonym” for <code>SBool x</code> is a <code>Bool</code>. This is the real benefit of using the <em>singletons</em> library instead of writing our own singletons – we get to work uniformly with singletons of all kinds.</p>
<h4 id="singi">SingI</h4>
<p><code>SingI</code> is a bit of typeclass trickery that lets us implicitly pass <code>Sing</code>s to functions:</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">SingI</span> s <span class="kw">where</span></span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a><span class="ot">    sing ::</span> <span class="dt">Sing</span> s</span></code></pre></div>
<p>If you see:</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="ot">lockAnyDoor ::</span> <span class="dt">Sing</span>  s <span class="ot">-&gt;</span> <span class="dt">Door</span> s <span class="ot">-&gt;</span> <span class="dt">Door</span> <span class="dt">&#39;Locked</span></span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a><span class="ot">fromDoor    ::</span> <span class="dt">Sing</span>  s <span class="ot">-&gt;</span> <span class="dt">Door</span> s <span class="ot">-&gt;</span> <span class="dt">SomeDoor</span></span></code></pre></div>
<p>These are <em>identical in power</em> to</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="ot">lockAnyDoor ::</span> <span class="dt">SingI</span> s <span class="ot">=&gt;</span> <span class="dt">Door</span> s <span class="ot">-&gt;</span> <span class="dt">Door</span> <span class="dt">&#39;Locked</span></span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a><span class="ot">fromDoor    ::</span> <span class="dt">SingI</span> s <span class="ot">=&gt;</span> <span class="dt">Door</span> s <span class="ot">-&gt;</span> <span class="dt">SomeDoor</span></span></code></pre></div>
<p>Either way, you’re passing in the ability to get a runtime witness on <code>s</code> – just in one way, it is asked for as an explicit argument, and the second way, it is passed in using a typeclass.</p>
<p>We can <em>convert</em> from <code>SingI s -&gt;</code> style to <code>SingI s =&gt;</code> style using <code>sing</code>:</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/singletons/Door2.hs#L54-L67</span></span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a><span class="ot">lockAnyDoor_ ::</span> <span class="dt">SingI</span> s <span class="ot">=&gt;</span> <span class="dt">Door</span> s <span class="ot">-&gt;</span> <span class="dt">Door</span> <span class="dt">&#39;Locked</span></span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true" tabindex="-1"></a>lockAnyDoor_ <span class="ot">=</span> lockAnyDoor sing</span>
<span id="cb30-5"><a href="#cb30-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-6"><a href="#cb30-6" aria-hidden="true" tabindex="-1"></a><span class="ot">fromDoor_ ::</span> <span class="dt">SingI</span> s <span class="ot">=&gt;</span> <span class="dt">Door</span> s <span class="ot">-&gt;</span> <span class="dt">SomeDoor</span></span>
<span id="cb30-7"><a href="#cb30-7" aria-hidden="true" tabindex="-1"></a>fromDoor_ <span class="ot">=</span> fromDoor sing</span></code></pre></div>
<p>And we can convert from <code>SingI s =&gt;</code> style to <code>SingI s -&gt;</code> style using <code>withSingI</code>:</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a><span class="ot">lockAnyDoor ::</span> <span class="dt">Sing</span> s <span class="ot">-&gt;</span> <span class="dt">Door</span> s <span class="ot">-&gt;</span> <span class="dt">Door</span> <span class="dt">&#39;Locked</span></span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a>lockAnyDoor s d <span class="ot">=</span> withSingI s (lockAnyDoor_ d)</span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true" tabindex="-1"></a><span class="ot">fromDoor ::</span> <span class="dt">Sing</span> s <span class="ot">-&gt;</span> <span class="dt">Door</span> s <span class="ot">-&gt;</span> <span class="dt">SomeDoor</span></span>
<span id="cb31-5"><a href="#cb31-5" aria-hidden="true" tabindex="-1"></a>fromDoor s d <span class="ot">=</span> withSingI s (fromDoor_ d)</span></code></pre></div>
<p>Again, the same function – just two different styles of calling them.</p>
<p>Here’s a nice trick to make this a little more clean: <em>singletons-2.4</em> offers a nice pattern synonym <code>Sing</code> to reflect this symmetry. The pattern <code>Sing :: SingI a =&gt; Sing a</code> acts both as a constructor and a witness for <code>SingI</code> and <code>Sing</code>:</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="ot">doorStatus_ ::</span> <span class="dt">SingI</span> s <span class="ot">=&gt;</span> <span class="dt">Door</span> s <span class="ot">-&gt;</span> <span class="dt">DoorState</span></span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a>doorStatus_ <span class="ot">=</span> doorStatus <span class="dt">Sing</span>           <span class="co">-- using Sing constructs the Sing s</span></span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true" tabindex="-1"></a><span class="ot">lockAnyDoor_ ::</span> <span class="dt">SingI</span> s <span class="ot">=&gt;</span> <span class="dt">Door</span> s <span class="ot">-&gt;</span> <span class="dt">Door</span> <span class="dt">&#39;Locked</span></span>
<span id="cb32-5"><a href="#cb32-5" aria-hidden="true" tabindex="-1"></a>lockAnyDoor_ <span class="ot">=</span> lockAnyDoor <span class="dt">Sing</span>         <span class="co">-- using Sing constructs the Sing s</span></span>
<span id="cb32-6"><a href="#cb32-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-7"><a href="#cb32-7" aria-hidden="true" tabindex="-1"></a><span class="ot">lockAnyDoor ::</span> <span class="dt">Sing</span> s <span class="ot">-&gt;</span> <span class="dt">Door</span> s <span class="ot">-&gt;</span> <span class="dt">Door</span> <span class="dt">&#39;Locked</span></span>
<span id="cb32-8"><a href="#cb32-8" aria-hidden="true" tabindex="-1"></a>lockAnyDoor <span class="dt">Sing</span> d <span class="ot">=</span> lockAnyDoor_ d     <span class="co">-- matching on Sing introduces SingI s</span></span>
<span id="cb32-9"><a href="#cb32-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-10"><a href="#cb32-10" aria-hidden="true" tabindex="-1"></a><span class="ot">fromDoor ::</span> <span class="dt">Sing</span> s <span class="ot">-&gt;</span> <span class="dt">Door</span> s <span class="ot">-&gt;</span> <span class="dt">SomeDoor</span></span>
<span id="cb32-11"><a href="#cb32-11" aria-hidden="true" tabindex="-1"></a>fromDoor <span class="dt">Sing</span> d <span class="ot">=</span> fromDoor_ d           <span class="co">-- matching on Sing introduces SingI s</span></span></code></pre></div>
<h3 id="reflection-and-reification">Reflection and Reification</h3>
<p>Reflection is the process of bringing a type-level thing to a value at the term level (“losing” the type information in the process) and reification is the process of bringing a value at the <em>term level</em> to the <em>type level</em>.</p>
<p>Reflection and reification can be thought of as the gateways between the untyped/unsafe world and the typed/safe world. Reflection takes you from the typed world to the untyped world (from <code>Sing s</code> to <code>DoorState</code>) and reification takes you from the untyped world to the typed world (from <code>DoorState</code> to <code>Sing s</code>).</p>
<p>One limitation in Haskell is that there is no actual link between the type <code>DoorState</code> and its <em>values</em> with the <em>kind</em> <code>DoorState</code> with its <em>types</em>. Sure, the constructors have the same names, but the language doesn’t actually link them together for us.</p>
<h4 id="singkind">SingKind</h4>
<p>The <em>singletons</em> library handles this by using a typeclass with associated types to implement a generalized reflection and reification process. It gives us the <code>SingKind</code> “kindclass”:</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">SingKind</span> k <span class="kw">where</span>      <span class="co">-- `k` is a kind!</span></span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- | Associate a kind k with its reflected type</span></span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">type</span> <span class="dt">Demote</span> k <span class="ot">=</span> (<span class="ot">r ::</span> <span class="dt">Type</span>)</span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-5"><a href="#cb33-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- | Reflect a singleton to its term-level value</span></span>
<span id="cb33-6"><a href="#cb33-6" aria-hidden="true" tabindex="-1"></a><span class="ot">    fromSing ::</span> <span class="dt">Sing</span> (<span class="ot">a ::</span> k) <span class="ot">-&gt;</span> <span class="dt">Demote</span> k</span>
<span id="cb33-7"><a href="#cb33-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-8"><a href="#cb33-8" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- | Reify a term-level value to the type level, as an existentially</span></span>
<span id="cb33-9"><a href="#cb33-9" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- quantified singleton</span></span>
<span id="cb33-10"><a href="#cb33-10" aria-hidden="true" tabindex="-1"></a><span class="ot">    toSing ::</span> <span class="dt">Demote</span> k <span class="ot">-&gt;</span> <span class="dt">SomeSing</span> k</span></code></pre></div>
<p>Instances of <code>SingKind</code> are (promoted) <em>kinds</em> like <code>Bool</code>-the-kind, <code>DoorState</code>-the-kind, etc., and <code>Demote</code> is an associated type/type family that associates each instance with the <em>type</em> it is promoted from. (Note – writing these type signatures requires the <code>-XTypeInType</code> extension, which lets us treat kinds as types)</p>
<p>For example, remember how <code>data DoorState = Opened | Closed | Locked</code> created the <em>type</em> <code>DoorState</code> (with value constructors <code>Opened</code>, <code>Closed</code>, and <code>Locked</code>), and also the <em>kind</em> <code>DoorState</code> (with <em>type</em> constructors <code>'Opened</code>, <code>'Closed</code>, and <code>'Locked</code>). Our <em>kind</em> <code>DoorState</code> would be the instance of <code>SingKind</code>, and <code>Demote DoorState</code> would be the <em>type</em> <code>DoorState</code>.</p>
<p>The reason we need an explicit <code>Demote</code> associated type is, again, that GHC doesn’t actually link the type and its promoted kind. <code>Demote</code> lets us explicitly specify what type a <code>Kind</code> should expect its term-level reflected values to be. (And, like most things in this post, <code>Demote</code> will hopefully one day become obsolete, along with the rest of <code>SingKind</code>)</p>
<h4 id="examples">Examples</h4>
<p>To illustrate explicitly, here is the automatically generated instance of <code>SingKind</code> for the <code>DoorState</code> <em>kind</em>:</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">SingKind</span> <span class="dt">DoorState</span> <span class="kw">where</span>       <span class="co">-- the *kind* DoorState</span></span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">type</span> <span class="dt">Demote</span> <span class="dt">DoorState</span> <span class="ot">=</span> <span class="dt">DoorState</span>   <span class="co">-- the *type* DoorState</span></span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-4"><a href="#cb34-4" aria-hidden="true" tabindex="-1"></a>    fromSing</span>
<span id="cb34-5"><a href="#cb34-5" aria-hidden="true" tabindex="-1"></a><span class="ot">        ::</span> <span class="dt">Sing</span> (<span class="ot">s ::</span> <span class="dt">DoorState</span>)        <span class="co">-- the *kind* DoorState</span></span>
<span id="cb34-6"><a href="#cb34-6" aria-hidden="true" tabindex="-1"></a>        <span class="ot">-&gt;</span> <span class="dt">DoorState</span>                    <span class="co">-- the *type* DoorState</span></span>
<span id="cb34-7"><a href="#cb34-7" aria-hidden="true" tabindex="-1"></a>    fromSing <span class="ot">=</span> \<span class="kw">case</span></span>
<span id="cb34-8"><a href="#cb34-8" aria-hidden="true" tabindex="-1"></a>        <span class="dt">SOpened</span> <span class="ot">-&gt;</span> <span class="dt">Opened</span></span>
<span id="cb34-9"><a href="#cb34-9" aria-hidden="true" tabindex="-1"></a>        <span class="dt">SClosed</span> <span class="ot">-&gt;</span> <span class="dt">Closed</span></span>
<span id="cb34-10"><a href="#cb34-10" aria-hidden="true" tabindex="-1"></a>        <span class="dt">SLocked</span> <span class="ot">-&gt;</span> <span class="dt">Locked</span></span>
<span id="cb34-11"><a href="#cb34-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-12"><a href="#cb34-12" aria-hidden="true" tabindex="-1"></a>    toSing</span>
<span id="cb34-13"><a href="#cb34-13" aria-hidden="true" tabindex="-1"></a><span class="ot">        ::</span> <span class="dt">DoorState</span>                    <span class="co">-- the *type* DoorState</span></span>
<span id="cb34-14"><a href="#cb34-14" aria-hidden="true" tabindex="-1"></a>        <span class="ot">-&gt;</span> <span class="dt">SomeSing</span> <span class="dt">DoorState</span>           <span class="co">-- the *kind* DoorState</span></span>
<span id="cb34-15"><a href="#cb34-15" aria-hidden="true" tabindex="-1"></a>    toSing <span class="ot">=</span> \<span class="kw">case</span></span>
<span id="cb34-16"><a href="#cb34-16" aria-hidden="true" tabindex="-1"></a>        <span class="dt">Opened</span> <span class="ot">-&gt;</span> <span class="dt">SomeSing</span> <span class="dt">SOpened</span></span>
<span id="cb34-17"><a href="#cb34-17" aria-hidden="true" tabindex="-1"></a>        <span class="dt">Closed</span> <span class="ot">-&gt;</span> <span class="dt">SomeSing</span> <span class="dt">SClosed</span></span>
<span id="cb34-18"><a href="#cb34-18" aria-hidden="true" tabindex="-1"></a>        <span class="dt">Locked</span> <span class="ot">-&gt;</span> <span class="dt">SomeSing</span> <span class="dt">SLocked</span></span></code></pre></div>
<p>If you are unfamiliar with how associated types work, <code>type Demote DoorState = DoorState</code> means that wherever we see <code>Demote DoorState</code> (with <code>DoorState</code> the <em>kind</em>), we replace it with <code>DoorState</code> (the <em>type</em>). That’s why the type of our reflection function <code>fromSing :: Sing s -&gt; Demote DoorState</code> can be simplified to <code>fromSing :: Sing s -&gt; DoorState</code>.</p>
<p>Let’s take a look at the instance for <code>Bool</code>, to compare:</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- Bool singletons have two constructors:</span></span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a><span class="dt">SFalse</span><span class="ot"> ::</span> <span class="dt">Sing</span> <span class="dt">&#39;False</span></span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true" tabindex="-1"></a><span class="dt">STrue</span><span class="ot">  ::</span> <span class="dt">Sing</span> <span class="dt">&#39;True</span></span>
<span id="cb35-4"><a href="#cb35-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-5"><a href="#cb35-5" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">SingKind</span> <span class="dt">Bool</span> <span class="kw">where</span>    <span class="co">-- the *kind* Bool</span></span>
<span id="cb35-6"><a href="#cb35-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">type</span> <span class="dt">Demote</span> <span class="dt">Bool</span> <span class="ot">=</span> <span class="dt">Bool</span>     <span class="co">-- the *type* Bool</span></span>
<span id="cb35-7"><a href="#cb35-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-8"><a href="#cb35-8" aria-hidden="true" tabindex="-1"></a>    fromSing</span>
<span id="cb35-9"><a href="#cb35-9" aria-hidden="true" tabindex="-1"></a><span class="ot">        ::</span> <span class="dt">Sing</span> (<span class="ot">b ::</span> <span class="dt">Bool</span>)        <span class="co">-- the *kind* Bool</span></span>
<span id="cb35-10"><a href="#cb35-10" aria-hidden="true" tabindex="-1"></a>        <span class="ot">-&gt;</span> <span class="dt">Bool</span>                    <span class="co">-- the *type* Bool</span></span>
<span id="cb35-11"><a href="#cb35-11" aria-hidden="true" tabindex="-1"></a>    fromSing <span class="ot">=</span> \<span class="kw">case</span></span>
<span id="cb35-12"><a href="#cb35-12" aria-hidden="true" tabindex="-1"></a>        <span class="dt">SFalse</span> <span class="ot">-&gt;</span> <span class="dt">False</span></span>
<span id="cb35-13"><a href="#cb35-13" aria-hidden="true" tabindex="-1"></a>        <span class="dt">STrue</span>  <span class="ot">-&gt;</span> <span class="dt">True</span></span>
<span id="cb35-14"><a href="#cb35-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-15"><a href="#cb35-15" aria-hidden="true" tabindex="-1"></a>    toSing</span>
<span id="cb35-16"><a href="#cb35-16" aria-hidden="true" tabindex="-1"></a><span class="ot">        ::</span> <span class="dt">Bool</span>                    <span class="co">-- the *type* Bool</span></span>
<span id="cb35-17"><a href="#cb35-17" aria-hidden="true" tabindex="-1"></a>        <span class="ot">-&gt;</span> <span class="dt">SomeSing</span> <span class="dt">Bool</span>           <span class="co">-- the *kind* Bool</span></span>
<span id="cb35-18"><a href="#cb35-18" aria-hidden="true" tabindex="-1"></a>    toSing <span class="ot">=</span> \<span class="kw">case</span></span>
<span id="cb35-19"><a href="#cb35-19" aria-hidden="true" tabindex="-1"></a>        <span class="dt">False</span> <span class="ot">-&gt;</span> <span class="dt">SomeSing</span> <span class="dt">SFalse</span></span>
<span id="cb35-20"><a href="#cb35-20" aria-hidden="true" tabindex="-1"></a>        <span class="dt">True</span>  <span class="ot">-&gt;</span> <span class="dt">SomeSing</span> <span class="dt">STrue</span></span></code></pre></div>
<p>And a more sophisticated example, let’s look at the instance for <code>Maybe</code>:</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- Maybe singletons have two constructors:</span></span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">SMaybe</span><span class="ot"> ::</span> <span class="dt">Maybe</span> k <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="kw">where</span></span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">SNothing</span><span class="ot"> ::</span> <span class="dt">SMaybe</span> <span class="dt">&#39;Nothing</span></span>
<span id="cb36-4"><a href="#cb36-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">SJust</span><span class="ot">    ::</span> <span class="dt">Sing</span> x <span class="ot">-&gt;</span> <span class="dt">SMaybe</span> (<span class="dt">&#39;Just</span> x)</span>
<span id="cb36-5"><a href="#cb36-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-6"><a href="#cb36-6" aria-hidden="true" tabindex="-1"></a><span class="co">-- The syntax for declaring an instance for the kind-indexed type family</span></span>
<span id="cb36-7"><a href="#cb36-7" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="kw">instance</span> <span class="dt">Sing</span> <span class="ot">=</span> <span class="dt">SMaybe</span></span>
<span id="cb36-8"><a href="#cb36-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-9"><a href="#cb36-9" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">SingKind</span> k <span class="ot">=&gt;</span> <span class="dt">SingKind</span> (<span class="dt">Maybe</span> k) <span class="kw">where</span>     <span class="co">-- the *kind* Maybe</span></span>
<span id="cb36-10"><a href="#cb36-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">type</span> <span class="dt">Demote</span> (<span class="dt">Maybe</span> k) <span class="ot">=</span> <span class="dt">Maybe</span> (<span class="dt">Demote</span> k)        <span class="co">-- the *type* Maybe</span></span>
<span id="cb36-11"><a href="#cb36-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-12"><a href="#cb36-12" aria-hidden="true" tabindex="-1"></a>    fromSing</span>
<span id="cb36-13"><a href="#cb36-13" aria-hidden="true" tabindex="-1"></a><span class="ot">        ::</span> <span class="dt">Sing</span> (<span class="ot">m ::</span> <span class="dt">Maybe</span> k)        <span class="co">-- the *kind* Maybe</span></span>
<span id="cb36-14"><a href="#cb36-14" aria-hidden="true" tabindex="-1"></a>        <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">Demote</span> k)           <span class="co">-- the *type* Maybe</span></span>
<span id="cb36-15"><a href="#cb36-15" aria-hidden="true" tabindex="-1"></a>    fromSing <span class="ot">=</span> \<span class="kw">case</span></span>
<span id="cb36-16"><a href="#cb36-16" aria-hidden="true" tabindex="-1"></a>        <span class="dt">SNothing</span> <span class="ot">-&gt;</span> <span class="dt">Nothing</span></span>
<span id="cb36-17"><a href="#cb36-17" aria-hidden="true" tabindex="-1"></a>        <span class="dt">SJust</span> sx <span class="ot">-&gt;</span> <span class="dt">Just</span> (fromSing sx)</span>
<span id="cb36-18"><a href="#cb36-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-19"><a href="#cb36-19" aria-hidden="true" tabindex="-1"></a>    toSing</span>
<span id="cb36-20"><a href="#cb36-20" aria-hidden="true" tabindex="-1"></a><span class="ot">        ::</span> <span class="dt">Maybe</span> (<span class="dt">Demote</span> k)             <span class="co">-- the *type* Maybe</span></span>
<span id="cb36-21"><a href="#cb36-21" aria-hidden="true" tabindex="-1"></a>        <span class="ot">-&gt;</span> <span class="dt">SomeSing</span> (<span class="dt">Maybe</span> k)           <span class="co">-- the *kind* Maybe</span></span>
<span id="cb36-22"><a href="#cb36-22" aria-hidden="true" tabindex="-1"></a>    toSing <span class="ot">=</span> \<span class="kw">case</span></span>
<span id="cb36-23"><a href="#cb36-23" aria-hidden="true" tabindex="-1"></a>        <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="dt">SomeSing</span> <span class="dt">SNothing</span></span>
<span id="cb36-24"><a href="#cb36-24" aria-hidden="true" tabindex="-1"></a>        <span class="dt">Just</span> x  <span class="ot">-&gt;</span> <span class="kw">case</span> toSing x <span class="kw">of</span></span>
<span id="cb36-25"><a href="#cb36-25" aria-hidden="true" tabindex="-1"></a>          <span class="dt">SomeSing</span> sx <span class="ot">-&gt;</span> <span class="dt">SomeSing</span> (<span class="dt">SJust</span> sx)</span></code></pre></div>
<p>This definition, I think, is a real testament to the usefulness of having all of our singletons be unified under the same system. Because of how <code>SingKind</code> works, <code>Demote (Maybe DoorState)</code> is evaluated to <code>Maybe (Demote DoorState)</code>, which is simplified to <code>Maybe DoorState</code>. This means that if we have a way to reify <code>DoorState</code> values, we also have a way to reify <code>Maybe DoorState</code> values! And, if we have a way to reflect <code>DoorState</code> singletons, we also have a way to reflect <code>Maybe DoorState</code> singletons!</p>
<h4 id="somesing">SomeSing</h4>
<p>Throughout all of this, we utilize <code>SomeSing</code> as a generic poly-kinded existential wrapper:</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">SomeSing</span><span class="ot"> ::</span> <span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="kw">where</span></span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">SomeSing</span><span class="ot"> ::</span> <span class="dt">Sing</span> (<span class="ot">x ::</span> k) <span class="ot">-&gt;</span> <span class="dt">SomeSing</span> k</span></code></pre></div>
<p>Basically, this says that <code>SomeSing k</code> contains a <code>Sing x</code>, where <code>x</code> is of kind <code>k</code>. This is why we had, earlier:</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a><span class="dt">SomeSing</span><span class="ot"> ::</span> <span class="dt">Sing</span> (<span class="ot">s ::</span> <span class="dt">DoorState</span>) <span class="ot">-&gt;</span> <span class="dt">SomeSing</span> <span class="dt">DoorState</span></span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true" tabindex="-1"></a><span class="dt">SomeSing</span><span class="ot"> ::</span> <span class="dt">Sing</span> (<span class="ot">s ::</span> <span class="dt">Bool</span>)      <span class="ot">-&gt;</span> <span class="dt">SomeSing</span> <span class="dt">Bool</span></span>
<span id="cb38-3"><a href="#cb38-3" aria-hidden="true" tabindex="-1"></a><span class="dt">SomeSing</span><span class="ot"> ::</span> <span class="dt">Sing</span> (<span class="ot">s ::</span> <span class="dt">Maybe</span> k)   <span class="ot">-&gt;</span> <span class="dt">SomeSing</span> (<span class="dt">Maybe</span> k)</span></code></pre></div>
<p>If we use <code>SomeSing</code> with, say, <code>SClosed</code>, we get <code>SomeSing :: Sing 'Closed -&gt; SomeSing DoorState</code>. <code>SomeSing</code> is an indexed type that tells us the <em>kind</em> of the type variable we existentially quantifying over. The value <code>SomeSing STrue</code> would have the type <code>SomeSing Bool</code>. The value <code>SomeSing (SJust SClosed)</code> would have the type <code>SomeSing (Maybe DoorState)</code>.</p>
<p>And, like for <code>SomeDoor</code>, it is important to remember that <code>SomeSing a</code>, for kind <code>a</code>, is <em>isomorphic</em> to the type <code>a</code>. This isomorphism is witnessed by <code>fromSing</code> and <code>toSing</code>, but here’s, visually, how things match up for <code>DoorState</code>:</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a><span class="dt">Opened</span>   <span class="op">&lt;~&gt;</span>    <span class="dt">SomeSing</span> <span class="dt">SOpened</span></span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true" tabindex="-1"></a><span class="dt">Closed</span>   <span class="op">&lt;~&gt;</span>    <span class="dt">SomeSing</span> <span class="dt">SClosed</span></span>
<span id="cb39-3"><a href="#cb39-3" aria-hidden="true" tabindex="-1"></a><span class="dt">Locked</span>   <span class="op">&lt;~&gt;</span>    <span class="dt">SomeSing</span> <span class="dt">SLocked</span></span></code></pre></div>
<p>And how they match up for <code>Maybe Bool</code>:</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a><span class="dt">Nothing</span>      <span class="op">&lt;~&gt;</span>  <span class="dt">SomeSing</span> <span class="dt">SNothing</span></span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a><span class="dt">Just</span> <span class="dt">False</span>   <span class="op">&lt;~&gt;</span>  <span class="dt">SomeSing</span> (<span class="dt">SJust</span> <span class="dt">SFalse</span>)</span>
<span id="cb40-3"><a href="#cb40-3" aria-hidden="true" tabindex="-1"></a><span class="dt">Just</span> <span class="dt">True</span>    <span class="op">&lt;~&gt;</span>  <span class="dt">SomeSing</span> (<span class="dt">SJust</span> <span class="dt">STrue</span>)</span></code></pre></div>
<h2 id="looking-forward">Looking Forward</h2>
<p>Between these first two parts, we explored a specific use case that would benefit from dependent types (simple phantom types for state transitions) and explored how the <em>singletons</em> and design pattern help us implement the functionality necessary to make things useful, and snuck in some concepts from dependently typed programming as well. We then took a step back to explore the <em>singletons</em> library in a more “universal” way, and saw how it is generalized to many different types.</p>
<p>The code is available <a href="https://github.com/mstksg/inCode/tree/master/code-samples/singletons/Door2.hs">here</a> for you to play around with yourself!</p>
<p>Now that the basics are out of the way, in Part 3 we’ll jump deep into type-level programming and being able to lift our term-level functions on values up to become type-level functions, and how to use this to express complex relationships and enhance our code!</p>
<p>Let me know in the comments if you have any questions! I’m also usually idling on the freenode <code>#haskell</code> channel, as well, as <em>jle`</em>.</p>
<p>And, again, I definitely recommend checking out the <a href="https://cs.brynmawr.edu/~rae/papers/2012/singletons/paper.pdf">original singletons paper</a> for a really nice technical overview of all of these techniques from the source itself.</p>
<h3 id="exercises">Exercises</h3>
<p>Check out the <a href="https://github.com/mstksg/inCode/tree/master/code-samples/singletons/Door2.hs">sample code</a> for solutions!</p>
<ol type="1">
<li><p>Let’s revisit our original redundant <code>SomeDoor</code>, compared to our final <code>SomeDoor</code>:</p>
<div class="sourceCode" id="cb41"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/singletons/Door2.hs#L60-L91</span></span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-3"><a href="#cb41-3" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">OldSomeDoor</span><span class="ot"> ::</span> <span class="dt">Type</span> <span class="kw">where</span></span>
<span id="cb41-4"><a href="#cb41-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">OldMkSomeDoor</span><span class="ot"> ::</span> <span class="dt">DoorState</span> <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">OldSomeDoor</span></span>
<span id="cb41-5"><a href="#cb41-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-6"><a href="#cb41-6" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">SomeDoor</span><span class="ot"> ::</span> <span class="dt">Type</span> <span class="kw">where</span></span>
<span id="cb41-7"><a href="#cb41-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">MkSomeDoor</span><span class="ot"> ::</span> <span class="dt">Sing</span> s <span class="ot">-&gt;</span> <span class="dt">Door</span> s <span class="ot">-&gt;</span> <span class="dt">SomeDoor</span></span></code></pre></div>
<p>To help convince yourself that the two are equal, write functions converting between the two:</p>
<div class="sourceCode" id="cb42"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/singletons/Door2.hs#L93-L96</span></span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-3"><a href="#cb42-3" aria-hidden="true" tabindex="-1"></a><span class="ot">toOld ::</span> <span class="dt">SomeDoor</span> <span class="ot">-&gt;</span> <span class="dt">OldSomeDoor</span></span>
<span id="cb42-4"><a href="#cb42-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-5"><a href="#cb42-5" aria-hidden="true" tabindex="-1"></a><span class="ot">fromOld ::</span> <span class="dt">OldSomeDoor</span> <span class="ot">-&gt;</span> <span class="dt">SomeDoor</span></span></code></pre></div>
<p><strong>Avoid directly pattern matching on the singletons or constructors</strong>. Instead, use <em>singletons</em> library tools like <code>toSing</code>, <code>withSomeSing</code>, <code>fromSing</code>, etc.</p></li>
<li><p>Previously, we had an <code>unlockDoor</code> function that took an <code>Int</code> (the “password”) with a <code>Door 'Locked</code> and returned a <code>Maybe (Door 'Closed)</code>. It returns a <code>Door 'Closed</code> (unlocked door) in <code>Just</code> if an odd number was given, and <code>Nothing</code> otherwise (a failed unlock)</p>
<p>Use this to implement a that would return a <code>SomeDoor</code>. Re-use the “password” logic from the original <code>unlockDoor</code>. If the door is successfully unlocked (with a <code>Just</code>), return the unlocked door in a <code>SomeDoor</code>. Otherwise, <em>return the original locked door</em> (in a <code>SomeDoor</code>).</p>
<div class="sourceCode" id="cb43"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/singletons/Door2.hs#L99-L104</span></span>
<span id="cb43-2"><a href="#cb43-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-3"><a href="#cb43-3" aria-hidden="true" tabindex="-1"></a><span class="ot">unlockDoor ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Door</span> <span class="dt">&#39;Locked</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">Door</span> <span class="dt">&#39;Closed</span>)</span>
<span id="cb43-4"><a href="#cb43-4" aria-hidden="true" tabindex="-1"></a>unlockDoor n (<span class="dt">UnsafeMkDoor</span> m)</span>
<span id="cb43-5"><a href="#cb43-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> n <span class="ot">`mod`</span> <span class="dv">2</span> <span class="op">==</span> <span class="dv">1</span> <span class="ot">=</span> <span class="dt">Just</span> (<span class="dt">UnsafeMkDoor</span> m)</span>
<span id="cb43-6"><a href="#cb43-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> <span class="fu">otherwise</span>      <span class="ot">=</span> <span class="dt">Nothing</span></span>
<span id="cb43-7"><a href="#cb43-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-8"><a href="#cb43-8" aria-hidden="true" tabindex="-1"></a><span class="ot">unlockSomeDoor ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Door</span> <span class="dt">&#39;Locked</span> <span class="ot">-&gt;</span> <span class="dt">SomeDoor</span></span>
<span id="cb43-9"><a href="#cb43-9" aria-hidden="true" tabindex="-1"></a>unlockSomeDoor <span class="ot">=</span> <span class="op">???</span></span></code></pre></div></li>
<li><p>Implement <code>openAnyDoor'</code> in the same style, with respect to <code>openAnyDoor</code>:</p>
<div class="sourceCode" id="cb44"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/singletons/Door2.hs#L109-L118</span></span>
<span id="cb44-2"><a href="#cb44-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb44-3"><a href="#cb44-3" aria-hidden="true" tabindex="-1"></a><span class="ot">openAnyDoor ::</span> <span class="dt">SingI</span> s <span class="ot">=&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Door</span> s <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">Door</span> <span class="dt">&#39;Opened</span>)</span>
<span id="cb44-4"><a href="#cb44-4" aria-hidden="true" tabindex="-1"></a>openAnyDoor n <span class="ot">=</span> openAnyDoor_ sing</span>
<span id="cb44-5"><a href="#cb44-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb44-6"><a href="#cb44-6" aria-hidden="true" tabindex="-1"></a><span class="ot">    openAnyDoor_ ::</span> <span class="dt">Sing</span> s <span class="ot">-&gt;</span> <span class="dt">Door</span> s <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">Door</span> <span class="dt">&#39;Opened</span>)</span>
<span id="cb44-7"><a href="#cb44-7" aria-hidden="true" tabindex="-1"></a>    openAnyDoor_ <span class="ot">=</span> \<span class="kw">case</span></span>
<span id="cb44-8"><a href="#cb44-8" aria-hidden="true" tabindex="-1"></a>      <span class="dt">SOpened</span> <span class="ot">-&gt;</span> <span class="dt">Just</span></span>
<span id="cb44-9"><a href="#cb44-9" aria-hidden="true" tabindex="-1"></a>      <span class="dt">SClosed</span> <span class="ot">-&gt;</span> <span class="dt">Just</span> <span class="op">.</span> openDoor</span>
<span id="cb44-10"><a href="#cb44-10" aria-hidden="true" tabindex="-1"></a>      <span class="dt">SLocked</span> <span class="ot">-&gt;</span> <span class="fu">fmap</span> openDoor <span class="op">.</span> unlockDoor n</span>
<span id="cb44-11"><a href="#cb44-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb44-12"><a href="#cb44-12" aria-hidden="true" tabindex="-1"></a><span class="ot">openAnySomeDoor ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">SomeDoor</span> <span class="ot">-&gt;</span> <span class="dt">SomeDoor</span></span>
<span id="cb44-13"><a href="#cb44-13" aria-hidden="true" tabindex="-1"></a>openAnySomeDoor <span class="ot">=</span> <span class="op">???</span></span></code></pre></div>
<p>Remember to re-use <code>openAnyDoor</code>.</p></li>
<li><p>Write the <code>SingKind</code> instance for the promoted kind of a custom list type:</p>
<div class="sourceCode" id="cb45"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/singletons/Door2.hs#L124-L132</span></span>
<span id="cb45-2"><a href="#cb45-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-3"><a href="#cb45-3" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">List</span> a <span class="ot">=</span> <span class="dt">Nil</span> <span class="op">|</span> <span class="dt">Cons</span> a (<span class="dt">List</span> a)</span>
<span id="cb45-4"><a href="#cb45-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-5"><a href="#cb45-5" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">SList</span><span class="ot"> ::</span> <span class="dt">List</span> a <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="kw">where</span></span>
<span id="cb45-6"><a href="#cb45-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">SNil</span><span class="ot">  ::</span> <span class="dt">SList</span> <span class="dt">&#39;Nil</span></span>
<span id="cb45-7"><a href="#cb45-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">SCons</span><span class="ot"> ::</span> <span class="dt">Sing</span> x <span class="ot">-&gt;</span> <span class="dt">SList</span> xs <span class="ot">-&gt;</span> <span class="dt">SList</span> (<span class="dt">&#39;Cons</span> x xs)</span>
<span id="cb45-8"><a href="#cb45-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-9"><a href="#cb45-9" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="kw">instance</span> <span class="dt">Sing</span> <span class="ot">=</span> <span class="dt">SList</span></span>
<span id="cb45-10"><a href="#cb45-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-11"><a href="#cb45-11" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">SingKind</span> k <span class="ot">=&gt;</span> <span class="dt">SingKind</span> (<span class="dt">List</span> k) <span class="kw">where</span></span>
<span id="cb45-12"><a href="#cb45-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">type</span> <span class="dt">Demote</span> (<span class="dt">List</span> k) <span class="ot">=</span> <span class="op">???</span></span>
<span id="cb45-13"><a href="#cb45-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-14"><a href="#cb45-14" aria-hidden="true" tabindex="-1"></a><span class="ot">    fromSing ::</span> <span class="dt">Sing</span> (<span class="ot">xs ::</span> <span class="dt">List</span> k) <span class="ot">-&gt;</span> <span class="dt">List</span> (<span class="dt">Demote</span> k)</span>
<span id="cb45-15"><a href="#cb45-15" aria-hidden="true" tabindex="-1"></a>    fromSing <span class="ot">=</span> <span class="op">???</span></span>
<span id="cb45-16"><a href="#cb45-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-17"><a href="#cb45-17" aria-hidden="true" tabindex="-1"></a><span class="ot">    toSing ::</span> <span class="dt">List</span> (<span class="dt">Demote</span> k) <span class="ot">-&gt;</span> <span class="dt">SomeSing</span> (<span class="dt">List</span> k)</span>
<span id="cb45-18"><a href="#cb45-18" aria-hidden="true" tabindex="-1"></a>    toSing <span class="ot">=</span> <span class="op">???</span></span></code></pre></div>
<p>Note that the built-in singletons for the list type also uses these same constructor names, for <code>[]</code> and <code>:</code>.</p></li>
</ol>
<section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes">
<hr />
<ol>
<li id="fn1"><p>And also a not-so-obvious fourth type, <code>forall s. Door s</code>, which is a subtype of all of those three!<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p>You might have noticed I was a bit sneaky by jumping straight <code>SomeDoor</code> when we already had a perfectly good “I don’t care” option. We used it last post!</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="ot">lockAnyDoor ::</span> <span class="dt">Sing</span> s <span class="ot">-&gt;</span> <span class="dt">Door</span> s <span class="ot">-&gt;</span> <span class="dt">Door</span> <span class="dt">&#39;Locked</span></span></code></pre></div>
<p>This does work! <code>lockAnyDoor</code> takes a <code>Door s</code> and doesn’t “care” about what <code>s</code> it gets (it’s parametrically polymorphic).</p>
<p>So, this normal “parametrically polymorphic” way is how we have, in the past, treated functions that <em>can take</em> a <code>Door</code> with an <code>s</code> we don’t want the type system to care about. However, the reason we need <code>SomeDoor</code> and existentially quantified types is for the situation where we want to <em>return</em> something that we want to the type system to not care about.<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section></div><footer><hr><div class="copy-content"><p>Hi, thanks for reading! You can reach me via email at <a href="mailto:justin@jle.im" class="email">justin@jle.im</a>, or at twitter at <a href="https://twitter.com/mstk">@mstk</a>! This post and all others are published under the <a href="https://creativecommons.org/licenses/by-nc-nd/3.0/">CC-BY-NC-ND 3.0</a> license. Corrections and edits via pull request are welcome and encouraged at <a href="https://github.com/mstksg/inCode">the source repository</a>.</p>
<p>If you feel inclined, or this post was particularly helpful for you, why not consider <a href="https://www.patreon.com/justinle/overview">supporting me on Patreon</a>, or a <a href="bitcoin:3D7rmAYgbDnp4gp4rf22THsGt74fNucPDU">BTC donation</a>? :)</p></div><div class="clear"></div><ul class="entry-series"><li><div>This entry is a part of a series called <b>&quot;Introduction to Singletons&quot;</b>.  Find the rest of the entries in this series at its <a href="https://blog.jle.im/entries/series/+introduction-to-singletons.html" class="tag-a-series" title="+Introduction to Singletons"> series history</a>.</div></li></ul><ul class="tag-list"><li><a href="https://blog.jle.im/entries/tagged/dependent-types.html" class="tag-a-tag">#dependent types</a></li><li><a href="https://blog.jle.im/entries/tagged/functional-programming.html" class="tag-a-tag">#functional programming</a></li><li><a href="https://blog.jle.im/entries/tagged/haskell.html" class="tag-a-tag">#haskell</a></li><li><a href="https://blog.jle.im/entries/tagged/singletons.html" class="tag-a-tag">#singletons</a></li><li><a href="https://blog.jle.im/entries/tagged/types.html" class="tag-a-tag">#types</a></li><li><a href="https://blog.jle.im/entries/category/@haskell.html" class="tag-a-category">@HASKELL</a></li><li><a href="https://blog.jle.im/entries/category/@tutorials.html" class="tag-a-category">@TUTORIALS</a></li><li><a href="https://blog.jle.im/entries/series/+introduction-to-singletons.html" class="tag-a-series">+Introduction to Singletons</a></li></ul><aside class="social-buttons"><div class="addthis_toolbox addthis_default_style addthis-buttons"><a class="addthis_button_facebook_like" fb:like:layout="button_count"></a><a class="addthis_button_tweet"></a><a class="addthis_button_google_plusone" g:plusone:size="medium"></a><a class="addthis_counter addthis_pill_style"></a></div><div class="custom-social-buttons"><div class="custom-social-button"><a href="https://www.reddit.com/submit" onclick="window.location = &#39;https://www.reddit.com/submit?url=&#39;+ encodeURIComponent(window.location); return false"><img src="https://www.reddit.com/static/spreddit7.gif" alt="submit to reddit"></a></div></div></aside><nav class="next-prev-links"><ul><li class="prev-entry-link">&larr; <a href="https://blog.jle.im/entry/introduction-to-singletons-1.html">Introduction to Singletons (Part 1)</a> (Previous)</li><li class="next-entry-link">(Next) <a href="https://blog.jle.im/entry/interpreters-a-la-carte-duet.html">&quot;Interpreters a la Carte&quot; in Advent of Code 2017 Duet</a> &rarr;</li></ul></nav></footer></article><div class="post-entry"><div class="tile"><div id="disqus_thread"></div><script type="text/javascript">var disqus_config = function () {
    this.page.url = 'https://blog.jle.im/entry/introduction-to-singletons-2.html';
    this.page.identifier = 'singletons-2';
};
(function() {
    var d = document, s = d.createElement('script');
    s.src = '//incode.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
})();
</script><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a><br></noscript><a href="http://disqus.com" class="dsq-brlink">Comments powered by <span class="logo-disqus">Disqus</span></a></div></div></div></div></div><div id="footer-container"><div id="footer-content"><div class="tile"><div class="footer-copyright">&copy; 2020 Justin Le <span class="license-link">(<a href="https://creativecommons.org/licenses/by-nc-nd/3.0/" class="license">CC-BY-NC-ND 3.0</a>)</span></div><div class="footer-follow social-follows"><ul class="social-follows-list"><li><ul class="social-follows-list-social"><li><a class="social-follow-twitter" title="Follow me on Twitter!" href="https://twitter.com/intent/user?user_id=mstk" onclick="window.open(
  &#39;http://twitter.com/intent/user?user_id=907281&#39;,
  &#39;facebook-share-dialog&#39;,
  &#39;width=550,height=520&#39;);
return false;
">Twitter</a></li><li><a class="social-follow-github" title="Fork me on Github!" href="https://github.com/mstksg">Github</a></li><li><a class="social-follow-twitch" title="Watch me on Twitch!" href="https://www.twitch.tv/justin_l">Twitch</a></li><li><a class="social-follow-patreon" title="Support me on Patreon!" href="https://www.patreon.com/justinle/overview">Patreon</a></li><li><a class="social-follow-gplus" title="Add me on Google+!" href="https://plus.google.com/+JustinLe">Google+</a></li><li><a class="social-follow-keybase" title="Track me on Keybase!" href="https://keybase.io/mstksg">Keybase</a></li><li><a class="social-follow-linkedin" title="Connect with me on LinkedIn!" href="https://linkedin.com/in/lejustin">LinkedIn</a></li><li><a class="social-follow-bitcoin" title="Donate via bitcoin!" href="bitcoin:3D7rmAYgbDnp4gp4rf22THsGt74fNucPDU">Bitcoin</a></li></ul></li><li><ul class="social-follows-list-site"><li><a class="social-follow-rss" title="Subscribe to my RSS Feed!" href="http://feeds.feedburner.com/incodeblog">RSS</a></li><li><a class="social-follow-email" title="Subscribe to the mailing list!" href="https://feedburner.google.com/fb/a/mailverify?loc=en_US&amp;uri=incodeblog">Mailing list</a></li></ul></li></ul></div></div></div></div></body></html>