<!DOCTYPE HTML>
<html><head><title>A Non-Unique Monad Instance · in Code</title><meta name="description" content="Weblog of Justin Le, covering various adventures in programming and explorations in the worlds of computation physics, and knowledge.
"><meta http-equiv="Content-Type" content="text/html;charset=utf-8"><meta name="viewport" content="width=device-width,initial-scale=1.0"><meta name="flattr:id" content="3p9jqr"><meta property="og:site_name" content="in Code"><meta property="og:description" content="Just stopping in for a short post before continuing with a long-overdue series or two :) This post is a bit of a short fun one that describes a quest I had, and hopefully some useful extra ideas I found along the way. Soon after I discovered Haskell, one question has plagued my mind. Day and night, I wondered… Are there any Haskell types with more than one unique Monad instance? This was a question that was pretty simple…so simple that I was sure many people had already asked and answered this. But I couldn’t really find any answers and nobody I asked at the time could really give me one either, so this soon embedded itself as a pretty deep mystery to my psyche. The background?"><meta property="og:type" content="article"><meta property="og:title" content="A Non-Unique Monad Instance"><meta property="og:image" content="https://blog.jle.im/img/site_logo.jpg"><meta property="og:locale" content="en_US"><meta property="og:url" content="https://blog.jle.im/entry/a-non-unique-monad-instance.html"><meta name="twitter:card" content="summary"><meta name="twitter:creator:id" content="mstk"><link rel="author" href="https://plus.google.com/107705320197444500140"><link rel="alternate" type="application/rss+xml" title="in Code (RSS Feed)" href="http://feeds.feedburner.com/incodeblog"><link rel="canonical" href="https://blog.jle.im/entry/a-non-unique-monad-instance.html"><link href="https://blog.jle.im/favicon.ico" rel="shortcut icon"><link href="https://blog.jle.im/css/toast.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/font.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/main.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/page/entry.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/pygments.css" rel="stylesheet" type="text/css"><script type="text/javascript">var page_data = {};
var disqus_shortname='incode';
</script><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-443711-8', 'jle.im');
ga('send', 'pageview');
</script><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script id="MathJax-script" async="" src="https://cdn.jsdelivr.net/npm/mathjax@3.0.1/es5/tex-mml-chtml.js"></script><script type="text/javascript" src="//ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script><script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5234d67a6b68dcd4"></script><script type="text/javascript" src="https://blog.jle.im/js/page/entry_toc.js"></script><script type="text/javascript" src="https://blog.jle.im/js/disqus_count.js"></script><script type="text/javascript" src="https://blog.jle.im/js/social.js"></script><script type="text/javascript" src="https://blog.jle.im/js/jquery/jquery.toc.js"></script><script type="text/javascript" src="https://blog.jle.im/purescript/entry.js"></script></head><body><div id="fb-root"><script>(function(d, s, id) {
 var js, fjs = d.getElementsByTagName(s)[0];
 if (d.getElementById(id)) return;
 js = d.createElement(s); js.id = id;
 js.src = "//connect.facebook.net/en_US/all.js#xfbml=1&appId=641852699171929";
 fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));
</script></div><div id="header-container"><div id="navbar-container" class="tile"><nav id="navbar-content"><div class="nav-info"><h1 class="site-title"><a href="https://blog.jle.im/" class="nav-title">in Code</a></h1><span class="nav-author">Justin Le</span></div><ul class="nav-links"><li><a href="https://blog.jle.im/">home</a></li><li><a href="https://blog.jle.im/entries.html">archives</a></li><li><a href="https://cv.jle.im">cv</a></li><div class="clear"></div></ul></nav></div><div id="header-content"></div></div><div id="body-container" class="container"><div id="main-container" class="grid"><div class="entry-section unit span-grid" role="main"><article class="tile article"><header><h1 id="title">A Non-Unique Monad Instance</h1><p class="entry-info">by <a class="author" href="https://blog.jle.im/">Justin Le</a><span class="info-separator"> &diams; </span><time datetime="2015-01-28T10:36:34Z" pubdate="" class="pubdate">Wednesday January 28, 2015</time></p><p><span class="source-info"><a class="source-link" href="https://github.com/mstksg/inCode/tree/master/copy/entries/multimonad.md">Source</a><span class="info-separator"> &diams; </span><a class="source-link" href="https://github.com/mstksg/inCode/tree/gh-pages/entry/a-non-unique-monad-instance.md">Markdown</a><span class="info-separator"> &diams; </span><a class="source-link" href="https://blog.jle.im/entry/a-non-unique-monad-instance.tex">LaTeX</a><span class="info-separator"> &diams; </span></span>Posted in <a href="https://blog.jle.im/entries/category/@haskell.html" class="tag-a-category" title="Functional, pure, non-strict, statically and strongly typed, natively
compiled...really just the king of great languages.
">Haskell</a>, <a href="https://blog.jle.im/entries/category/@projects.html" class="tag-a-category" title="Progress or presentations of completed or ongoing open source projects I have
worked/am working on. Hopefully either the development process or the end
product can be useful to someone!
">Projects</a><span class="info-separator"> &diams; </span><a class="comment-link" href="#disqus_thread">Comments</a></p></header><hr><aside class="contents-container"><h5 id="contents-header">Contents</h5><div id="toc"></div></aside><div class="main-content copy-content"><p>Just stopping in for a short post before continuing with a long-overdue series or two :) This post is a bit of a short fun one that describes a quest I had, and hopefully some useful extra ideas I found along the way.</p>
<p>Soon after I discovered Haskell, one question has plagued my mind. Day and night, I wondered…</p>
<blockquote>
<p>Are there any Haskell types with more than one unique <code>Monad</code> instance?</p>
</blockquote>
<p>This was a question that was pretty simple…so simple that I was sure many people had already asked and answered this. But I couldn’t really find any answers and nobody I asked at the time could really give me one either, so this soon embedded itself as a pretty deep mystery to my psyche.</p>
<p>The background?</p>
<h2 id="functor-and-applicative">Functor and Applicative</h2>
<p>All <code>Functor</code> instances, if they exist, are <em>unique</em> for the type. The type uniquely determines the instance. There is only one possible <code>Functor</code> instance for <code>[]</code>, one possible <code>Functor</code> instance for <code>Maybe</code>, <code>Either</code>, etc.</p>
<p>This fact is taken advantage of by GHC to allow you to derive, for some types, a <code>Functor</code> instance automatically.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> <span class="op">:</span>set <span class="op">-</span><span class="dt">XDeriveFunctor</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> <span class="kw">data</span> <span class="dt">Foo</span> a <span class="ot">=</span> <span class="dt">Bar</span> [a] (<span class="dt">Maybe</span> (<span class="dt">Foo</span> a)) <span class="op">|</span> <span class="dt">Baz</span> (<span class="dt">Either</span> <span class="dt">String</span> a) (<span class="dt">Foo</span> a)</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> <span class="kw">let</span> x <span class="ot">=</span> <span class="dt">Bar</span> [<span class="dv">1</span>, <span class="dv">3</span>] (<span class="dt">Just</span> (<span class="dt">Baz</span> (<span class="dt">Right</span> <span class="dv">4</span>) (<span class="dt">Bar</span> [<span class="dv">10</span>] <span class="dt">Nothing</span>)))</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> <span class="fu">fmap</span> (<span class="op">*</span><span class="dv">2</span>) x</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="dt">Bar</span> [<span class="dv">2</span>, <span class="dv">6</span>] (<span class="dt">Just</span> (<span class="dt">Baz</span> (<span class="dt">Right</span> <span class="dv">8</span>) (<span class="dt">Bar</span> [<span class="dv">20</span>] <span class="dt">Nothing</span>)))</span></code></pre></div>
<p>There is no other possible <code>Functor</code> instance for that data type. Go ahead, try :D</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Foo</span> a <span class="ot">=</span> <span class="dt">Bar</span> [a] (<span class="dt">Maybe</span> (<span class="dt">Foo</span> a)) <span class="op">|</span> <span class="dt">Baz</span> (<span class="dt">Either</span> <span class="dt">String</span> a) (<span class="dt">Foo</span> a)</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Functor</span> <span class="dt">Foo</span> <span class="kw">where</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>    <span class="fu">fmap</span> f (<span class="dt">Bar</span> xs y) <span class="ot">=</span> <span class="dt">Bar</span> (<span class="fu">fmap</span> f xs) (<span class="fu">fmap</span> f y)</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>    <span class="fu">fmap</span> f (<span class="dt">Baz</span> x fy) <span class="ot">=</span> <span class="dt">Baz</span> (<span class="fu">fmap</span> f x) (<span class="fu">fmap</span> f fy)</span></code></pre></div>
<p>However, this is not the case for <code>Applicative</code>. Everyone knows of course about the normal (cartesian product) Applicative instance and the zippy Applicative instance for list:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Applicative</span> [] <span class="kw">where</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>    <span class="fu">pure</span> x    <span class="ot">=</span> [x]</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>    fs <span class="op">&lt;*&gt;</span> xs <span class="ot">=</span> [ f x <span class="op">|</span> f <span class="ot">&lt;-</span> fs, x <span class="ot">&lt;-</span> xs ]</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Applicative</span> [] <span class="kw">where</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>    <span class="fu">pure</span>      <span class="ot">=</span> <span class="fu">repeat</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>    fs <span class="op">&lt;*&gt;</span> xs <span class="ot">=</span> <span class="fu">zipWith</span> (<span class="op">$</span>) fs xs</span></code></pre></div>
<p>What is also fairly established is that every <em>noncommutative</em> <code>Applicative</code> instance also has a “flipped” version:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- a flipped IO Applicative</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">FlipIO</span> a <span class="ot">=</span> <span class="dt">FlipIO</span> {<span class="ot"> runFlipIO ::</span> <span class="dt">IO</span> a }</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Applicative</span> <span class="dt">FlipIO</span> <span class="kw">where</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>    <span class="fu">pure</span> x    <span class="ot">=</span> <span class="dt">FlipIO</span> (<span class="fu">pure</span> x)</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>    fi <span class="op">&lt;*&gt;</span> xi <span class="ot">=</span> <span class="dt">FlipIO</span> <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>                  x <span class="ot">&lt;-</span> runFlipIO xi</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>                  f <span class="ot">&lt;-</span> runFlipIO fi     <span class="co">-- note the backwards effects</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>                  <span class="fu">return</span> (f x)</span></code></pre></div>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">State</span> s a <span class="ot">=</span> <span class="dt">State</span> {<span class="ot"> runState ::</span> s <span class="ot">-&gt;</span> (a, s) }</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span class="co">-- the normal instance</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Applicative</span> (<span class="dt">State</span> s) <span class="kw">where</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>    <span class="fu">pure</span> x    <span class="ot">=</span> <span class="dt">State</span> <span class="op">$</span> \s0 <span class="ot">-&gt;</span> (x, s0)</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>    fs <span class="op">&lt;*&gt;</span> xs <span class="ot">=</span> <span class="dt">State</span> <span class="op">$</span> \s0 <span class="ot">-&gt;</span> <span class="kw">let</span> (f, s1) <span class="ot">=</span> runState fs s0</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>                                   (x, s2) <span class="ot">=</span> runState xs s1</span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>                               <span class="kw">in</span>  (f x, s2)</span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a><span class="co">-- the flipped instance</span></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Applicative</span> (<span class="dt">State</span> s) <span class="kw">where</span></span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a>    <span class="fu">pure</span> x    <span class="ot">=</span> <span class="dt">State</span> <span class="op">$</span> \s0 <span class="ot">-&gt;</span> (x, s0)</span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a>    fs <span class="op">&lt;*&gt;</span> xs <span class="ot">=</span> <span class="dt">State</span> <span class="op">$</span> \s0 <span class="ot">-&gt;</span> <span class="kw">let</span> (x, s1) <span class="ot">=</span> runState xs s0</span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a>                                   (f, s2) <span class="ot">=</span> runState fs s1</span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a>                               <span class="kw">in</span>  (f x, s2)</span></code></pre></div>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> liftA2 (,) <span class="fu">getLine</span> <span class="fu">getLine</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;</span> hello         <span class="co">-- asking for the first field</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;</span> world         <span class="co">-- asking for the second field</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>(<span class="st">&quot;hello&quot;</span>, <span class="st">&quot;world&quot;</span>)</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> runFlipIO <span class="op">$</span> liftA2 (,) (<span class="dt">FlipIO</span> <span class="fu">getLine</span>) (<span class="dt">FlipIO</span> <span class="fu">getLine</span>)</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;</span> hello         <span class="co">-- asking for the second field</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;</span> world         <span class="co">-- asking for the first field</span></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>(<span class="st">&quot;world&quot;</span>, <span class="st">&quot;hello&quot;</span>)</span></code></pre></div>
<p>Every non-commutative <code>Applicative</code> admits an alternative instance where “flipping” the order of the “effects” is also a valid <code>Applicative</code> instance. So, not <code>Maybe</code> or <code>Either</code>, but <code>State</code>, <code>[]</code>, and <code>IO</code>.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- free &quot;flipped&quot; Applicative instance</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Flipped</span> f a <span class="ot">=</span> <span class="dt">Flipped</span> {<span class="ot"> runFlipped ::</span> f a }</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a><span class="co">-- instance where (&lt;*&gt;) is the same, but the order of effects is switched</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Applicative</span> f <span class="ot">=&gt;</span> <span class="dt">Applicative</span> (<span class="dt">Flipped</span> f) <span class="kw">where</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>    <span class="fu">pure</span> <span class="ot">=</span> <span class="dt">Flipped</span> <span class="op">.</span> <span class="fu">pure</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Flipped</span> f <span class="op">&lt;*&gt;</span> <span class="dt">Flipped</span> x <span class="ot">=</span> <span class="dt">Flipped</span> <span class="op">$</span> liftA2 (<span class="fu">flip</span> (<span class="op">$</span>)) x f</span></code></pre></div>
<p>Cool. Types that have <code>Functor</code> instances only have one. Types that have <code>Applicative</code> instances very often have more than one.</p>
<p>So, the obvious next question is…what about <code>Monad</code>s? Is a <code>Monad</code> instance uniquely determined by its type?</p>
<h2 id="monad">Monad</h2>
<p>The answer wasn’t that simple, for me. Yes, <em>most</em> <code>Applicative</code>s in the wild are non-unique, and there was a generating rule. But not so for <code>Monad</code>s. You can’t have a <code>Monad</code> where the effects are switched, because for <code>(&gt;&gt;=)</code>, you need the effects of the first action in order to even decide what the effects of the next action are.</p>
<p>I vaguely remember from my past two data types that are very similar yet have very different <code>Monad</code> and <code>Applicative</code> instances: (finite) lists, (infinite) <a href="http://blog.jle.im/entry/intro-to-machines-arrows-part-1-stream-and">streams</a>. From the outset, the two have almost identical structure. A <code>Stream</code> is just a list with no <code>[]</code>/nil:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Stream</span> a <span class="ot">=</span> a <span class="op">:~</span> <span class="dt">Stream</span> a</span></code></pre></div>
<p>The <code>Functor</code> instance is identical:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Functor</span> <span class="dt">Stream</span> <span class="kw">where</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>    <span class="fu">fmap</span> f (x <span class="op">:~</span> xs) <span class="ot">=</span> f x <span class="op">:~</span> <span class="fu">fmap</span> f xs</span></code></pre></div>
<p>And the (only??) <code>Applicative</code> instance is the <code>ZipList</code> instance for lists:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Applicative</span> <span class="dt">Stream</span> <span class="kw">where</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>    <span class="fu">pure</span> x <span class="ot">=</span> x <span class="op">:~</span> <span class="fu">pure</span> x</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>    (f <span class="op">:~</span> fs) <span class="op">&lt;*&gt;</span> (x <span class="op">:~</span> xs) <span class="ot">=</span> f x <span class="op">:~</span> (fs <span class="op">&lt;*&gt;</span> xs)</span></code></pre></div>
<p>The <code>Monad</code> instance is however very different from that of lists:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Monad</span> <span class="dt">Stream</span> <span class="kw">where</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>    <span class="fu">return</span> x <span class="ot">=</span> x <span class="op">:~</span> <span class="fu">return</span> x</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>    xs <span class="op">&gt;&gt;=</span> f <span class="ot">=</span> join&#39; (<span class="fu">fmap</span> f xs)</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>      <span class="kw">where</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a><span class="ot">        join&#39; ::</span> <span class="dt">Stream</span> (<span class="dt">Stream</span> a) <span class="ot">-&gt;</span> <span class="dt">Stream</span> a</span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>        join&#39; ((x <span class="op">:~</span> _) <span class="op">:~</span> yss) <span class="ot">=</span> x <span class="op">:~</span> join&#39; (<span class="fu">fmap</span> tail&#39; yss)</span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>        tail&#39; (_ <span class="op">:~</span> xs) <span class="ot">=</span> xs</span></code></pre></div>
<p>The <code>Monad</code> instance itself is actually interesting enough to write about. It all revolves around <code>join</code>, where <code>join</code> takes a stream of streams and creates a stream <em>of the diagonals</em>. So it takes the first element of the first stream, the second element of the second stream, the third element of the third stream, etc.</p>
<p>This is actually a special case of the <code>Monad</code> instance for all fixed-sized ordered containers. A length 5 vector, for example, will have the same <code>Applicative</code> and <code>Monad</code> instance as described here: <code>(&lt;*&gt;)</code> with “zipping”, and <code>join</code> with grabbing the diagonal of the 5-vector of 5-vectors.</p>
<p>This was a promising lead, but, it doesn’t take <em>too</em> much thought to see that neither lists nor <code>Stream</code> are appropriate for <em>both</em> instances.</p>
<div class="note">
<p><strong>Aside</strong></p>
<p>In case you were wondering, here is an elaboration :D</p>
<ul>
<li><p>Fixed length vectors can’t have the normal list Applicative instance at all, unless they are of size 0 or 1. That’s because the result after <code>(&lt;*&gt;)</code>, the resulting list’s length is the product of the original lists. So you can forget the <code>Monad</code> instance, too.</p></li>
<li><p>Streams give you no luck, either. The easiest way to see is by considering the analogous <code>Monad</code> instance, where <code>join</code> is the straight-up concatenation. <code>m &gt;&gt;= return == m</code> is clearly violated. If <code>m</code> is an infinite list, <code>fmap return</code> gives you an infinite list of infinite lists, “joining”/concatenating them back will just give you an infinite list of the first item in <code>m</code>.</p>
<p>To put succinctly, for <code>Stream</code>, <code>concat == head</code>.</p></li>
<li><p>Lists can have the <code>Applicative</code> instance fine, but not the <code>Monad</code> instance. Here we assume that zipping and “getting the diagonal” go only as “far as possible”, and stop when one of the lists is too short.</p>
<p>This one is a little trickier, but the weakness is when you have lists of lists of lists of different lengths.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> <span class="kw">let</span> counterexample <span class="ot">=</span> [[[<span class="dv">1</span>]], [[], [<span class="dv">2</span>,<span class="dv">3</span>]]]</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> join counterexample</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>[[<span class="dv">1</span>], [<span class="dv">2</span>,<span class="dv">3</span>]]</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> join<span class="op">.</span> join <span class="op">$</span> counterexample</span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>[<span class="dv">1</span>,<span class="dv">3</span>]</span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> <span class="fu">fmap</span> join counterexample</span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>[[<span class="dv">1</span>], []]</span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> join <span class="op">.</span> <span class="fu">fmap</span> join <span class="op">$</span> counterexample</span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a>[<span class="dv">1</span>]</span></code></pre></div>
<p>For a monad, joining the inner layer and then joining it all should be the same as joining it all and joining it all. The order of the joining shouldn’t count. We can see this in the more haskelly monad laws by noting:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> <span class="fu">id</span> <span class="op">&lt;=&lt;</span> (<span class="fu">id</span> <span class="op">&lt;=&lt;</span> <span class="fu">id</span>) <span class="op">$</span> counterexample</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>[<span class="dv">1</span>,<span class="dv">2</span>]</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> (<span class="fu">id</span> <span class="op">&lt;=&lt;</span> <span class="fu">id</span>) <span class="op">&lt;=&lt;</span> <span class="fu">id</span> <span class="op">$</span> counterexample</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>[<span class="dv">1</span>]</span></code></pre></div>
<p>So, dead end here.</p></li>
</ul>
</div>
<p>So I didn’t really have any leads at that point; I tried a couple of other paths but nothing really panned out. So I shelved it for a while.</p>
<h2 id="revelation">Revelation</h2>
<p>Several centuries later<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>, the final revelation came as many revelations do in Haskell — from a hint by Edward Kmett. He pointed out something interesting regarding a <code>Monad</code> instance that I had yet to notice:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Monoid</span> w <span class="ot">=&gt;</span> <span class="dt">Monad</span> ((,) w) <span class="kw">where</span></span></code></pre></div>
<p>This is the classic “Writer” monad instance, which is literally about as old as monads in functional programming is.</p>
<p>The key is that the <code>Monad</code> instance of <code>(w,)</code> depends on the <code>Monoid</code> instance of <code>w</code>. This is the “log”, so to speak. You need a <code>Monoid</code> instance in order to make the <code>Monad</code> instance…and the behavior of the <code>Monad</code> instance is directly determined by the behavior of the <code>Monoid</code> instance of <code>w</code>.</p>
<p>And…<code>Monoid</code> instances in Haskell are rarely ever unique! A different <code>Monoid</code> instance would create a very different <code>Monad</code> instance for the same type!</p>
<p>So, by factoring out the dependency on an external <code>Monoid</code> instance, you get…</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Two</span> a <span class="ot">=</span> <span class="dt">One</span> a <span class="op">|</span> <span class="dt">Two</span> a</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Functor</span> <span class="dt">Two</span> <span class="kw">where</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>    <span class="fu">fmap</span> f (<span class="dt">One</span> a) <span class="ot">=</span> <span class="dt">One</span> (f a)</span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>    <span class="fu">fmap</span> f (<span class="dt">Two</span> a) <span class="ot">=</span> <span class="dt">Two</span> (f a)</span></code></pre></div>
<p>and…voila! There it is!</p>
<p>This type is basically equivalent to <code>(Bool, a)</code>. And <code>Bool</code> has multiple <code>Monoid</code>s on it. Instead of requiring an outside <code>Monoid</code> instance, we can encode the instance directly into the behavior of <code>(&gt;&gt;=)</code>. And here we go!</p>
<p>Our instances are basically the <code>Writer</code> instance for <code>(Bool, a)</code>, with different <code>Monoid</code> instances for <code>Bool</code>.</p>
<p>The first instance:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Applicative</span> <span class="dt">Two</span> <span class="kw">where</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>    <span class="fu">pure</span> <span class="ot">=</span> <span class="dt">One</span></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">One</span> f <span class="op">&lt;*&gt;</span> <span class="dt">One</span> x <span class="ot">=</span> <span class="dt">One</span> (f x)</span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">One</span> f <span class="op">&lt;*&gt;</span> <span class="dt">Two</span> x <span class="ot">=</span> <span class="dt">Two</span> (f x)</span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Two</span> f <span class="op">&lt;*&gt;</span> <span class="dt">One</span> x <span class="ot">=</span> <span class="dt">Two</span> (f x)</span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Two</span> f <span class="op">&lt;*&gt;</span> <span class="dt">Two</span> x <span class="ot">=</span> <span class="dt">Two</span> (f x)</span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Monad</span> <span class="dt">Two</span> <span class="kw">where</span></span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a>    <span class="fu">return</span> <span class="ot">=</span> <span class="dt">One</span></span>
<span id="cb16-10"><a href="#cb16-10" aria-hidden="true" tabindex="-1"></a>    <span class="dt">One</span> x <span class="op">&gt;&gt;=</span> f <span class="ot">=</span> f x</span>
<span id="cb16-11"><a href="#cb16-11" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Two</span> x <span class="op">&gt;&gt;=</span> f <span class="ot">=</span> <span class="kw">case</span> f x <span class="kw">of</span></span>
<span id="cb16-12"><a href="#cb16-12" aria-hidden="true" tabindex="-1"></a>                    <span class="dt">One</span> y <span class="ot">-&gt;</span> <span class="dt">Two</span> y</span>
<span id="cb16-13"><a href="#cb16-13" aria-hidden="true" tabindex="-1"></a>                    <span class="dt">Two</span> y <span class="ot">-&gt;</span> <span class="dt">Two</span> y</span></code></pre></div>
<p>Which represents the monoids formed by <code>(&amp;&amp;)</code> with <code>True</code> or by <code>(||)</code> with <code>False</code> (depending on which one you pick as <code>True</code> and which one you pick as <code>False</code>; the two instances are isomorphic)</p>
<p>The second:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Applicative</span> <span class="dt">Two</span> <span class="kw">where</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>    <span class="fu">pure</span> <span class="ot">=</span> <span class="dt">One</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">One</span> f <span class="op">&lt;*&gt;</span> <span class="dt">One</span> x <span class="ot">=</span> <span class="dt">One</span> (f x)</span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">One</span> f <span class="op">&lt;*&gt;</span> <span class="dt">Two</span> x <span class="ot">=</span> <span class="dt">Two</span> (f x)</span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Two</span> f <span class="op">&lt;*&gt;</span> <span class="dt">One</span> x <span class="ot">=</span> <span class="dt">Two</span> (f x)</span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Two</span> f <span class="op">&lt;*&gt;</span> <span class="dt">Two</span> x <span class="ot">=</span> <span class="dt">One</span> (f x)</span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Monad</span> <span class="dt">Two</span> <span class="kw">where</span></span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true" tabindex="-1"></a>    <span class="fu">return</span> <span class="ot">=</span> <span class="dt">One</span></span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true" tabindex="-1"></a>    <span class="dt">One</span> x <span class="op">&gt;&gt;=</span> f <span class="ot">=</span> f x</span>
<span id="cb17-11"><a href="#cb17-11" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Two</span> x <span class="op">&gt;&gt;=</span> f <span class="ot">=</span> <span class="kw">case</span> f x <span class="kw">of</span></span>
<span id="cb17-12"><a href="#cb17-12" aria-hidden="true" tabindex="-1"></a>                    <span class="dt">One</span> y <span class="ot">-&gt;</span> <span class="dt">Two</span> y</span>
<span id="cb17-13"><a href="#cb17-13" aria-hidden="true" tabindex="-1"></a>                    <span class="dt">Two</span> y <span class="ot">-&gt;</span> <span class="dt">One</span> y</span></code></pre></div>
<p>Which represents the monoid formed by <code>(/=)</code> (or “XOR”) with <code>False</code>.</p>
<p>And there you go. One type, two possible unique, non-isomorphic <code>Monad</code> instances.</p>
<div class="note">
<p><strong>Aside</strong></p>
<p>One interesting thing to note is that the Monad instance for <code>(-&gt;) a</code> requires no monoid constraint, and the Monad instance for <code>(,) a</code> <em>does</em>.</p>
<p>Interestingly enough, if we look at <em>comonads</em>, the Comonad instance for <code>(-&gt;) a</code> <em>does</em> require a monoid constraint on <code>a</code> (so for example there are many unique Comonad instances for things isomorphic to <code>(-&gt;) a</code> where <code>a</code> has more than one Monoid instance) and and the Comonad instance for <code>(,) a</code> <em>does not</em> require a monoid constraint on <code>a</code>.</p>
<p>Is there some duality at play here?</p>
<p>The answer is, apparently, yes! But according to Edward Kmett, it is one that is pretty hard to arrive at and a big headache and overall not worth the time to dig into. So you’re going to have to take my second-hand word for it.</p>
</div>
<section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes">
<hr />
<ol>
<li id="fn1"><p>More accurately, “about a year”<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section></div><footer><hr><div class="copy-content"><p>Hi, thanks for reading! You can reach me via email at <a href="mailto:justin@jle.im" class="email">justin@jle.im</a>, or at twitter at <a href="https://twitter.com/mstk">@mstk</a>! This post and all others are published under the <a href="https://creativecommons.org/licenses/by-nc-nd/3.0/">CC-BY-NC-ND 3.0</a> license. Corrections and edits via pull request are welcome and encouraged at <a href="https://github.com/mstksg/inCode">the source repository</a>.</p>
<p>If you feel inclined, or this post was particularly helpful for you, why not consider <a href="https://www.patreon.com/justinle/overview">supporting me on Patreon</a>, or a <a href="bitcoin:3D7rmAYgbDnp4gp4rf22THsGt74fNucPDU">BTC donation</a>? :)</p></div><div class="clear"></div><ul class="entry-series"></ul><ul class="tag-list"><li><a href="https://blog.jle.im/entries/tagged/algebra.html" class="tag-a-tag">#algebra</a></li><li><a href="https://blog.jle.im/entries/tagged/functional-programming.html" class="tag-a-tag">#functional programming</a></li><li><a href="https://blog.jle.im/entries/tagged/haskell.html" class="tag-a-tag">#haskell</a></li><li><a href="https://blog.jle.im/entries/tagged/monads.html" class="tag-a-tag">#monads</a></li><li><a href="https://blog.jle.im/entries/category/@haskell.html" class="tag-a-category">@HASKELL</a></li><li><a href="https://blog.jle.im/entries/category/@projects.html" class="tag-a-category">@PROJECTS</a></li></ul><aside class="social-buttons"><div class="addthis_toolbox addthis_default_style addthis-buttons"><a class="addthis_button_facebook_like" fb:like:layout="button_count"></a><a class="addthis_button_tweet"></a><a class="addthis_button_google_plusone" g:plusone:size="medium"></a><a class="addthis_counter addthis_pill_style"></a></div><div class="custom-social-buttons"><div class="custom-social-button"><a href="https://www.reddit.com/submit" onclick="window.location = &#39;https://www.reddit.com/submit?url=&#39;+ encodeURIComponent(window.location); return false"><img src="https://www.reddit.com/static/spreddit7.gif" alt="submit to reddit"></a></div></div></aside><nav class="next-prev-links"><ul><li class="prev-entry-link">&larr; <a href="https://blog.jle.im/entry/io-monad-considered-harmful.html">IO Monad Considered Harmful</a> (Previous)</li><li class="next-entry-link">(Next) <a href="https://blog.jle.im/entry/effectful-recursive-real-world-autos-intro-to-machine.html">Effectful, Recursive, Real-World Autos: Intro to Machine/Auto Part 3</a> &rarr;</li></ul></nav></footer></article><div class="post-entry"><div class="tile"><div id="disqus_thread"></div><script type="text/javascript">var disqus_config = function () {
    this.page.url = 'https://blog.jle.im/entry/a-non-unique-monad-instance.html';
    this.page.identifier = 'multimonad';
};
(function() {
    var d = document, s = d.createElement('script');
    s.src = '//incode.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
})();
</script><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a><br></noscript><a href="http://disqus.com" class="dsq-brlink">Comments powered by <span class="logo-disqus">Disqus</span></a></div></div></div></div></div><div id="footer-container"><div id="footer-content"><div class="tile"><div class="footer-copyright">&copy; 2020 Justin Le <span class="license-link">(<a href="https://creativecommons.org/licenses/by-nc-nd/3.0/" class="license">CC-BY-NC-ND 3.0</a>)</span></div><div class="footer-follow social-follows"><ul class="social-follows-list"><li><ul class="social-follows-list-social"><li><a class="social-follow-twitter" title="Follow me on Twitter!" href="https://twitter.com/intent/user?user_id=mstk" onclick="window.open(
  &#39;http://twitter.com/intent/user?user_id=907281&#39;,
  &#39;facebook-share-dialog&#39;,
  &#39;width=550,height=520&#39;);
return false;
">Twitter</a></li><li><a class="social-follow-github" title="Fork me on Github!" href="https://github.com/mstksg">Github</a></li><li><a class="social-follow-twitch" title="Watch me on Twitch!" href="https://www.twitch.tv/justin_l">Twitch</a></li><li><a class="social-follow-patreon" title="Support me on Patreon!" href="https://www.patreon.com/justinle/overview">Patreon</a></li><li><a class="social-follow-gplus" title="Add me on Google+!" href="https://plus.google.com/+JustinLe">Google+</a></li><li><a class="social-follow-keybase" title="Track me on Keybase!" href="https://keybase.io/mstksg">Keybase</a></li><li><a class="social-follow-linkedin" title="Connect with me on LinkedIn!" href="https://linkedin.com/in/lejustin">LinkedIn</a></li><li><a class="social-follow-bitcoin" title="Donate via bitcoin!" href="bitcoin:3D7rmAYgbDnp4gp4rf22THsGt74fNucPDU">Bitcoin</a></li></ul></li><li><ul class="social-follows-list-site"><li><a class="social-follow-rss" title="Subscribe to my RSS Feed!" href="http://feeds.feedburner.com/incodeblog">RSS</a></li><li><a class="social-follow-email" title="Subscribe to the mailing list!" href="https://feedburner.google.com/fb/a/mailverify?loc=en_US&amp;uri=incodeblog">Mailing list</a></li></ul></li></ul></div></div></div></div></body></html>