<!DOCTYPE HTML>
<html><head><title>Sum Types and Subtypes and Unions · in Code</title><meta name="description" content="Weblog of Justin Le, covering various adventures in programming and explorations in the worlds of computation physics, and knowledge.
"><meta http-equiv="Content-Type" content="text/html;charset=utf-8"><meta name="viewport" content="width=device-width,initial-scale=1.0"><meta name="flattr:id" content="3p9jqr"><meta property="og:site_name" content="in Code"><meta property="og:description" content="There’s yet again been a bit of functional programming-adjacent twitter drama recently, but it’s actually sort of touched into some subtleties about sum types that I am asked about (and think about) a lot nowadays. So, I’d like to take this opportunity to talk a bit about the “why” and nature of sum types and how to use them effectively, and how they contrast with other related concepts in programming and software development and when even cases where sum types aren’t the best option."><meta property="og:type" content="article"><meta property="og:title" content="Sum Types and Subtypes and Unions"><meta property="og:image" content="https://blog.jle.im/img/site_logo.jpg"><meta property="og:locale" content="en_US"><meta property="og:url" content="https://blog.jle.im/entry/sum-types-and-subtypes-and-unions.html"><meta name="twitter:card" content="summary"><meta name="twitter:creator:id" content="mstk"><link rel="author" href="https://plus.google.com/107705320197444500140"><link rel="alternate" type="application/rss+xml" title="in Code (RSS Feed)" href="http://feeds.feedburner.com/incodeblog"><link rel="canonical" href="https://blog.jle.im/entry/sum-types-and-subtypes-and-unions.html"><link href="https://blog.jle.im/favicon.ico" rel="shortcut icon"><link href="https://blog.jle.im/css/toast.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/font.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/main.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/page/entry.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/pygments.css" rel="stylesheet" type="text/css"><script type="text/javascript">var page_data = {};
var disqus_shortname='incode';
</script><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-443711-8', 'jle.im');
ga('send', 'pageview');
</script><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script id="MathJax-script" async="" src="https://cdn.jsdelivr.net/npm/mathjax@3.0.1/es5/tex-mml-chtml.js"></script><script type="text/javascript" src="//ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script><script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5234d67a6b68dcd4"></script><script type="text/javascript" src="https://blog.jle.im/js/page/entry_toc.js"></script><script type="text/javascript" src="https://blog.jle.im/js/disqus_count.js"></script><script type="text/javascript" src="https://blog.jle.im/js/social.js"></script><script type="text/javascript" src="https://blog.jle.im/js/jquery/jquery.toc.js"></script><script type="text/javascript" src="https://blog.jle.im/purescript/entry.js"></script></head><body><div id="fb-root"><script>(function(d, s, id) {
 var js, fjs = d.getElementsByTagName(s)[0];
 if (d.getElementById(id)) return;
 js = d.createElement(s); js.id = id;
 js.src = "//connect.facebook.net/en_US/all.js#xfbml=1&appId=641852699171929";
 fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));
</script></div><div id="header-container"><div id="navbar-container" class="tile"><nav id="navbar-content"><div class="nav-info"><h1 class="site-title"><a href="https://blog.jle.im/" class="nav-title">in Code</a></h1><span class="nav-author">Justin Le</span></div><ul class="nav-links"><li><a href="https://blog.jle.im/">home</a></li><li><a href="https://blog.jle.im/entries.html">archives</a></li><li><a href="https://cv.jle.im">cv</a></li><div class="clear"></div></ul></nav></div><div id="header-content"></div></div><div id="body-container" class="container"><div id="main-container" class="grid"><div class="entry-section unit span-grid" role="main"><article class="tile article"><header><h1 id="title">Sum Types and Subtypes and Unions</h1><p class="entry-info">by <a class="author" href="https://blog.jle.im/">Justin Le</a><span class="info-separator"> &diams; </span><time datetime="2025-03-06T09:25:28Z" pubdate="" class="pubdate">Thursday March 6, 2025</time></p><p><span class="source-info"><a class="source-link" href="https://github.com/mstksg/inCode/tree/master/copy/entries/sum-types-and-subtypes-and-unions.md">Source</a><span class="info-separator"> &diams; </span><a class="source-link" href="https://github.com/mstksg/inCode/tree/gh-pages/entry/sum-types-and-subtypes-and-unions.md">Markdown</a><span class="info-separator"> &diams; </span><a class="source-link" href="https://blog.jle.im/entry/sum-types-and-subtypes-and-unions.tex">LaTeX</a><span class="info-separator"> &diams; </span></span>Posted in <a href="https://blog.jle.im/entries/category/@haskell.html" class="tag-a-category" title="Functional, pure, non-strict, statically and strongly typed, natively
compiled...really just the king of great languages.
">Haskell</a><span class="info-separator"> &diams; </span><a class="comment-link" href="#disqus_thread">Comments</a></p></header><hr><aside class="contents-container"><h5 id="contents-header">Contents</h5><div id="toc"></div></aside><div class="main-content copy-content"><p>There’s yet again been a bit of functional programming-adjacent twitter drama recently, but it’s actually sort of touched into some subtleties about sum types that I am asked about (and think about) a lot nowadays. So, I’d like to take this opportunity to talk a bit about the “why” and nature of sum types and how to use them effectively, and how they contrast with other related concepts in programming and software development and when even cases where sum types aren’t the best option.</p>
<h2 id="sum-types-at-their-best">Sum Types at their Best</h2>
<p>The quintessential sum type that you just can’t live without is <code>Maybe</code>, now adopted in a lot of languages as <code>Optional</code>:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Maybe</span> a <span class="ot">=</span> <span class="dt">Nothing</span> <span class="op">|</span> <span class="dt">Just</span> a</span></code></pre></div>
<p>If you have a value of type <code>Maybe Int</code>, it means that its valid values are <code>Nothing</code>, <code>Just 0</code>, <code>Just 1</code>, etc.</p>
<p>This is also a good illustration to why we call it a “sum” type: if <code>a</code> has <code>n</code> possible values, then <code>Maybe a</code> has <code>1 + n</code>: we add the single new value <code>Nothing</code> to it.</p>
<p>The “benefit” of the sum type is illustrated pretty clearly here too: every time you <em>use</em> a value of type <code>Maybe Int</code>, you are forced to consider the fact that it could be <code>Nothing</code>:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="ot">showMaybeInt ::</span> <span class="dt">Maybe</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">String</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>showMaybeInt <span class="ot">=</span> \<span class="kw">case</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="st">&quot;There&#39;s nothing here&quot;</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Just</span> i <span class="ot">-&gt;</span> <span class="st">&quot;Something is here: &quot;</span> <span class="op">&lt;&gt;</span> <span class="fu">show</span> i</span></code></pre></div>
<p>That’s because usually in sum type implementations, they are implemented in a way that forces you to handle each case exhaustively. Otherwise, sum types are <em>much</em> less useful.</p>
<p>At the most fundamental level, this behaves like a compiler-enforced null check, but built within the language in user-space instead being compiler magic, ad-hoc syntax<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>, or static analysis — and the fact that it can live in user-space is why it’s been adopted so widely. At a higher level, functional abstractions like Functor, Applicative, Monad, Foldable, Traversable allow you to use a <code>Maybe a</code> like just a normal <code>a</code> with the appropriate semantics, but that’s <a href="https://blog.jle.im/entry/inside-my-world-ode-to-functor-and-monad.html">a topic for another time (like 2014)</a>.</p>
<p>This power is very special to me on a personal level. I remember many years ago on my first major haskell project changing a type from <code>String</code> to <code>Maybe String</code>, and then GHC telling me every place in the codebase where something needed to change in order for things to work still. Coming from dynamically typed languages in the past, this sublime experience truly altered my brain chemistry and Haskell-pilled me for the rest of my life. I still remember the exact moment, what coffee shop I was at, what my order was, the weather that day … it was truly the first day of the rest of my life.</p>
<p>It should be noted that I don’t consider sum types a “language feature” or a compiler feature as much as I’d consider it a design pattern. Languages that don’t have sum types built-in can usually implement them using typed unions and an abstract visitor pattern interface (more on that later). Of course, having a way to “check” your code before running it (like with a type system or statically verified type annotations) does make a lot of the features much more useful.</p>
<p>Anyway, this basic pattern can be extended to include more error information in your <code>Nothing</code> branch, which is how you get the <code>Either e a</code> type in the Haskell standard library, or the <code>Result&lt;T,E&gt;</code> type in rust.</p>
<p>Along different lines, we have the common use case of defining syntax trees:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Expr</span> <span class="ot">=</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Lit</span> <span class="dt">Int</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">Negate</span> <span class="dt">Expr</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">Add</span> <span class="dt">Expr</span> <span class="dt">Expr</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">Sub</span> <span class="dt">Expr</span> <span class="dt">Expr</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">Mul</span> <span class="dt">Expr</span> <span class="dt">Expr</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a><span class="ot">eval ::</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>eval <span class="ot">=</span> \<span class="kw">case</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Lit</span> i <span class="ot">-&gt;</span> i</span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Negate</span> x <span class="ot">-&gt;</span> <span class="op">-</span>(eval x)</span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Add</span> x y <span class="ot">-&gt;</span> eval x <span class="op">+</span> eval y</span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Sub</span> x y <span class="ot">-&gt;</span> eval x <span class="op">-</span> eval y</span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Mul</span> x y <span class="ot">-&gt;</span> eval x <span class="op">*</span> eval y</span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a><span class="ot">pretty ::</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">String</span></span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a>pretty <span class="ot">=</span> go <span class="dv">0</span></span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a><span class="ot">    wrap ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span></span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a>    wrap prio opPrec s</span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true" tabindex="-1"></a>      <span class="op">|</span> prio <span class="op">&gt;</span> opPrec <span class="ot">=</span> <span class="st">&quot;(&quot;</span> <span class="op">&lt;&gt;</span> s <span class="op">&lt;&gt;</span> <span class="st">&quot;)&quot;</span></span>
<span id="cb3-22"><a href="#cb3-22" aria-hidden="true" tabindex="-1"></a>      <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> s</span>
<span id="cb3-23"><a href="#cb3-23" aria-hidden="true" tabindex="-1"></a>    go prio <span class="ot">=</span> \<span class="kw">case</span></span>
<span id="cb3-24"><a href="#cb3-24" aria-hidden="true" tabindex="-1"></a>        <span class="dt">Lit</span> i <span class="ot">-&gt;</span> <span class="fu">show</span> i</span>
<span id="cb3-25"><a href="#cb3-25" aria-hidden="true" tabindex="-1"></a>        <span class="dt">Negate</span> x <span class="ot">-&gt;</span> wrap prio <span class="dv">2</span> <span class="op">$</span> <span class="st">&quot;-&quot;</span> <span class="op">&lt;&gt;</span> go <span class="dv">2</span> x</span>
<span id="cb3-26"><a href="#cb3-26" aria-hidden="true" tabindex="-1"></a>        <span class="dt">Add</span> x y <span class="ot">-&gt;</span> wrap prio <span class="dv">0</span> <span class="op">$</span> go <span class="dv">0</span> x <span class="op">&lt;&gt;</span> <span class="st">&quot; + &quot;</span> <span class="op">&lt;&gt;</span> go <span class="dv">1</span> y</span>
<span id="cb3-27"><a href="#cb3-27" aria-hidden="true" tabindex="-1"></a>        <span class="dt">Sub</span> x y <span class="ot">-&gt;</span> wrap prio <span class="dv">0</span> <span class="op">$</span> go <span class="dv">0</span> x <span class="op">&lt;&gt;</span> <span class="st">&quot; - &quot;</span> <span class="op">&lt;&gt;</span> go <span class="dv">1</span> y</span>
<span id="cb3-28"><a href="#cb3-28" aria-hidden="true" tabindex="-1"></a>        <span class="dt">Mul</span> x y <span class="ot">-&gt;</span> wrap prio <span class="dv">1</span> <span class="op">$</span> go <span class="dv">1</span> x <span class="op">&lt;&gt;</span> <span class="st">&quot; * &quot;</span> <span class="op">&lt;&gt;</span> go <span class="dv">2</span> y</span>
<span id="cb3-29"><a href="#cb3-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-30"><a href="#cb3-30" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb3-31"><a href="#cb3-31" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb3-32"><a href="#cb3-32" aria-hidden="true" tabindex="-1"></a>    <span class="fu">putStrLn</span> <span class="op">$</span> pretty myExpr</span>
<span id="cb3-33"><a href="#cb3-33" aria-hidden="true" tabindex="-1"></a>    <span class="fu">print</span> <span class="op">$</span> eval myExpr</span>
<span id="cb3-34"><a href="#cb3-34" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb3-35"><a href="#cb3-35" aria-hidden="true" tabindex="-1"></a>    myExpr <span class="ot">=</span> <span class="dt">Mul</span> (<span class="dt">Negate</span> (<span class="dt">Add</span> (<span class="dt">Lit</span> <span class="dv">4</span>) (<span class="dt">Lit</span> <span class="dv">5</span>))) (<span class="dt">Lit</span> <span class="dv">8</span>)</span></code></pre></div>
<pre><code>-(4 + 5) * 8
-72</code></pre>
<p>Now, if we add a new command to the sum type, the compiler enforces us to handle it.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Expr</span> <span class="ot">=</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Lit</span> <span class="dt">Int</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">Negate</span> <span class="dt">Expr</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">Add</span> <span class="dt">Expr</span> <span class="dt">Expr</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">Sub</span> <span class="dt">Expr</span> <span class="dt">Expr</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">Mul</span> <span class="dt">Expr</span> <span class="dt">Expr</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">Abs</span> <span class="dt">Expr</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a><span class="ot">eval ::</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>eval <span class="ot">=</span> \<span class="kw">case</span></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Lit</span> i <span class="ot">-&gt;</span> i</span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Negate</span> x <span class="ot">-&gt;</span> <span class="op">-</span>(eval x)</span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Add</span> x y <span class="ot">-&gt;</span> eval x <span class="op">+</span> eval y</span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Sub</span> x y <span class="ot">-&gt;</span> eval x <span class="op">-</span> eval y</span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Mul</span> x y <span class="ot">-&gt;</span> eval x <span class="op">*</span> eval y</span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Abs</span> x <span class="ot">-&gt;</span> <span class="fu">abs</span> (eval x)</span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true" tabindex="-1"></a><span class="ot">pretty ::</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">String</span></span>
<span id="cb5-19"><a href="#cb5-19" aria-hidden="true" tabindex="-1"></a>pretty <span class="ot">=</span> go <span class="dv">0</span></span>
<span id="cb5-20"><a href="#cb5-20" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb5-21"><a href="#cb5-21" aria-hidden="true" tabindex="-1"></a><span class="ot">    wrap ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span></span>
<span id="cb5-22"><a href="#cb5-22" aria-hidden="true" tabindex="-1"></a>    wrap prio opPrec s</span>
<span id="cb5-23"><a href="#cb5-23" aria-hidden="true" tabindex="-1"></a>      <span class="op">|</span> prio <span class="op">&gt;</span> opPrec <span class="ot">=</span> <span class="st">&quot;(&quot;</span> <span class="op">&lt;&gt;</span> s <span class="op">&lt;&gt;</span> <span class="st">&quot;)&quot;</span></span>
<span id="cb5-24"><a href="#cb5-24" aria-hidden="true" tabindex="-1"></a>      <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> s</span>
<span id="cb5-25"><a href="#cb5-25" aria-hidden="true" tabindex="-1"></a>    go prio <span class="ot">=</span> \<span class="kw">case</span></span>
<span id="cb5-26"><a href="#cb5-26" aria-hidden="true" tabindex="-1"></a>        <span class="dt">Lit</span> i <span class="ot">-&gt;</span> <span class="fu">show</span> i</span>
<span id="cb5-27"><a href="#cb5-27" aria-hidden="true" tabindex="-1"></a>        <span class="dt">Negate</span> x <span class="ot">-&gt;</span> wrap prio <span class="dv">2</span> <span class="op">$</span> <span class="st">&quot;-&quot;</span> <span class="op">&lt;&gt;</span> go <span class="dv">2</span> x</span>
<span id="cb5-28"><a href="#cb5-28" aria-hidden="true" tabindex="-1"></a>        <span class="dt">Add</span> x y <span class="ot">-&gt;</span> wrap prio <span class="dv">0</span> <span class="op">$</span> go <span class="dv">0</span> x <span class="op">&lt;&gt;</span> <span class="st">&quot; + &quot;</span> <span class="op">&lt;&gt;</span> go <span class="dv">1</span> y</span>
<span id="cb5-29"><a href="#cb5-29" aria-hidden="true" tabindex="-1"></a>        <span class="dt">Sub</span> x y <span class="ot">-&gt;</span> wrap prio <span class="dv">0</span> <span class="op">$</span> go <span class="dv">0</span> x <span class="op">&lt;&gt;</span> <span class="st">&quot; - &quot;</span> <span class="op">&lt;&gt;</span> go <span class="dv">1</span> y</span>
<span id="cb5-30"><a href="#cb5-30" aria-hidden="true" tabindex="-1"></a>        <span class="dt">Mul</span> x y <span class="ot">-&gt;</span> wrap prio <span class="dv">1</span> <span class="op">$</span> go <span class="dv">1</span> x <span class="op">&lt;&gt;</span> <span class="st">&quot; * &quot;</span> <span class="op">&lt;&gt;</span> go <span class="dv">2</span> y</span>
<span id="cb5-31"><a href="#cb5-31" aria-hidden="true" tabindex="-1"></a>        <span class="dt">Abs</span> x <span class="ot">-&gt;</span> wrap prio <span class="dv">2</span> <span class="op">$</span> <span class="st">&quot;|&quot;</span> <span class="op">&lt;&gt;</span> go <span class="dv">0</span> x <span class="op">&lt;&gt;</span> <span class="st">&quot;|&quot;</span></span></code></pre></div>
<p>Another example where things shine are as clearly-fined APIs between processes. For example, we can imagine a “command” type that sends different types of commands with different payloads. This can be interpreted as perhaps the result of parsing command line arguments or the message in some communication protocol.</p>
<p>For example, you could have a protocol that launches and controls processes:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Command</span> a <span class="ot">=</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Launch</span> <span class="dt">String</span> (<span class="dt">Int</span> <span class="ot">-&gt;</span> a)    <span class="co">-- ^ takes a name, returns a process ID</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">Stop</span> <span class="dt">Int</span> (<span class="dt">Bool</span> <span class="ot">-&gt;</span> a)        <span class="co">-- ^ takes a process ID, returns success/failure</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a><span class="ot">launch ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Command</span> <span class="dt">Int</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>launch nm <span class="ot">=</span> <span class="dt">Launch</span> nm <span class="fu">id</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a><span class="ot">stop ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Command</span> <span class="dt">Bool</span></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>stop pid <span class="ot">=</span> <span class="dt">Stop</span> pid <span class="fu">id</span></span></code></pre></div>
<p>This ADT is written in the “interpreter” pattern (used often with things like free monad), where any arguments not involving <code>a</code> are the command payload, any <code>X -&gt; a</code> represent that the command could respond with <code>X</code>.</p>
<p>Let’s write a sample interpreter backing the state in an IntMap in an IORef:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.IntMap</span> <span class="kw">as</span> <span class="dt">IM</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.IntMap</span> (<span class="dt">IntMap</span>)</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a><span class="ot">runCommand ::</span> <span class="dt">IORef</span> (<span class="dt">IntMap</span> <span class="dt">String</span>) <span class="ot">-&gt;</span> <span class="dt">Command</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> a</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>runCommand ref <span class="ot">=</span> \<span class="kw">case</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Launch</span> newName next <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>        currMap <span class="ot">&lt;-</span> readIORef ref</span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> newId <span class="ot">=</span> <span class="kw">case</span> IM.lookupMax currMap <span class="kw">of</span></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>              <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="dv">0</span></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>              <span class="dt">Just</span> (i, _) <span class="ot">-&gt;</span> i <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a>        modifyIORef ref <span class="op">$</span> IM.insert newId newName</span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a>        <span class="fu">pure</span> (next newId)</span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Stop</span> procId next <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a>        existed <span class="ot">&lt;-</span> IM.member procId <span class="op">&lt;$&gt;</span> readIORef ref</span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a>        modifyIORef ref <span class="op">$</span> IM.delete procId</span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true" tabindex="-1"></a>        <span class="fu">pure</span> (next existed)</span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-18"><a href="#cb7-18" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb7-19"><a href="#cb7-19" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb7-20"><a href="#cb7-20" aria-hidden="true" tabindex="-1"></a>    ref <span class="ot">&lt;-</span> newIORef IM.empty</span>
<span id="cb7-21"><a href="#cb7-21" aria-hidden="true" tabindex="-1"></a>    aliceId <span class="ot">&lt;-</span> runCommand ref <span class="op">$</span> launch <span class="st">&quot;alice&quot;</span></span>
<span id="cb7-22"><a href="#cb7-22" aria-hidden="true" tabindex="-1"></a>    <span class="fu">putStrLn</span> <span class="op">$</span> <span class="st">&quot;Launched alice with ID &quot;</span> <span class="op">&lt;&gt;</span> <span class="fu">show</span> aliceId</span>
<span id="cb7-23"><a href="#cb7-23" aria-hidden="true" tabindex="-1"></a>    bobId <span class="ot">&lt;-</span> runCommand ref <span class="op">$</span> launch <span class="st">&quot;bob&quot;</span></span>
<span id="cb7-24"><a href="#cb7-24" aria-hidden="true" tabindex="-1"></a>    <span class="fu">putStrLn</span> <span class="op">$</span> <span class="st">&quot;Launched bob with ID &quot;</span> <span class="op">&lt;&gt;</span> <span class="fu">show</span> bobId</span>
<span id="cb7-25"><a href="#cb7-25" aria-hidden="true" tabindex="-1"></a>    success <span class="ot">&lt;-</span> runCommand ref <span class="op">$</span> stop aliceId</span>
<span id="cb7-26"><a href="#cb7-26" aria-hidden="true" tabindex="-1"></a>    <span class="fu">putStrLn</span> <span class="op">$</span></span>
<span id="cb7-27"><a href="#cb7-27" aria-hidden="true" tabindex="-1"></a>      <span class="kw">if</span> success</span>
<span id="cb7-28"><a href="#cb7-28" aria-hidden="true" tabindex="-1"></a>        <span class="kw">then</span> <span class="st">&quot;alice succesfully stopped&quot;</span></span>
<span id="cb7-29"><a href="#cb7-29" aria-hidden="true" tabindex="-1"></a>        <span class="kw">else</span> <span class="st">&quot;alice unsuccesfully stopped&quot;</span></span>
<span id="cb7-30"><a href="#cb7-30" aria-hidden="true" tabindex="-1"></a>    <span class="fu">print</span> <span class="op">=&lt;&lt;</span> readIORef ref</span></code></pre></div>
<pre><code>Launched alice with ID 0
Launched bob with ID 1
alice succesfully stopped
fromList [(1, &quot;bob&quot;)]</code></pre>
<p>Let’s add a command to “query” a process id for its current status:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Command</span> a <span class="ot">=</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Launch</span> <span class="dt">String</span> (<span class="dt">Int</span> <span class="ot">-&gt;</span> a)    <span class="co">-- ^ takes a name, returns a process ID</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">Stop</span> <span class="dt">Int</span> (<span class="dt">Bool</span> <span class="ot">-&gt;</span> a)        <span class="co">-- ^ takes a process ID, returns success/failure</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">Query</span> <span class="dt">Int</span> (<span class="dt">String</span> <span class="ot">-&gt;</span> a)     <span class="co">-- ^ takes a process ID, returns a status message</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a><span class="ot">query ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Command</span> <span class="dt">String</span></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>query pid <span class="ot">=</span> <span class="dt">Query</span> pid <span class="fu">id</span></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a><span class="ot">runCommand ::</span> <span class="dt">IORef</span> (<span class="dt">IntMap</span> <span class="dt">String</span>) <span class="ot">-&gt;</span> <span class="dt">Command</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> a</span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a>runCommand ref <span class="ot">=</span> \<span class="kw">case</span></span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- ...</span></span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Query</span> procId next <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a>        procName <span class="ot">&lt;-</span> IM.lookup procId <span class="op">&lt;$&gt;</span> readIORef ref</span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a>        <span class="fu">pure</span> <span class="kw">case</span> procName <span class="kw">of</span></span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true" tabindex="-1"></a>          <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="st">&quot;This process doesn&#39;t exist, silly.&quot;</span></span>
<span id="cb9-16"><a href="#cb9-16" aria-hidden="true" tabindex="-1"></a>          <span class="dt">Just</span> n <span class="ot">-&gt;</span> <span class="st">&quot;Process &quot;</span> <span class="op">&lt;&gt;</span> n <span class="op">&lt;&gt;</span> <span class="st">&quot; chugging along...&quot;</span></span></code></pre></div>
<h3 id="relationship-with-unions">Relationship with Unions</h3>
<p>To clarify a common confusion: sum types can be described as “tagged unions”: you have a tag to indicate which branch you are on (which can be case-matched on), and then the rest of your data is conditionally present.</p>
<p>In many languages this can be implemented under the hood as a struct with a tag and a union of data, along with some <a href="https://en.wikipedia.org/wiki/Visitor_pattern">abstract visitor pattern interface</a> to ensure exhaustiveness.</p>
<p>Remember, it’s not <em>exactly</em> a union, because, ie, consider a type like:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Entity</span> <span class="ot">=</span> <span class="dt">User</span> <span class="dt">Int</span> <span class="op">|</span> <span class="dt">Post</span> <span class="dt">Int</span></span></code></pre></div>
<p>An <code>Entity</code> here could represent a user at a user id, or a post at a post id. If we considered it purely as a union of <code>Int</code> and <code>Int</code>:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="kw">union</span> Entity <span class="op">{</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> user_id<span class="op">;</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> post_id<span class="op">;</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>we’d lose the ability to branch on whether or not we have a user or an int. If we have the tagged union, we recover the original tagged union semantics:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Entity <span class="op">{</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">bool</span> is_user<span class="op">;</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">union</span> <span class="op">{</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> user_id<span class="op">;</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> post_id<span class="op">;</span></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span> payload<span class="op">;</span></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>Of course, you still need an abstract interface like the visitor pattern to actually be able to use this as a sum type with guarantees that you handle every branch, but that’s a story for another day. Alternatively, if your language supports dynamic dispatch nicely, that’s another underlying implementation that would work to back a higher-level visitor pattern interface.</p>
<h2 id="subtypes-solve-a-different-problem">Subtypes Solve a Different Problem</h2>
<p>Now, sum types aren’t exactly a part of common programming education curriculum, but <em>subtypes</em> and <em>supertypes</em> definitely were drilled into every CS student’s brain and waking nightmares from their first year.</p>
<p>Informally (a la Liskov), <code>B</code> is a subtype of <code>A</code> (and <code>A</code> is a supertype of <code>B</code>) if anywhere that expects an <code>A</code>, you could also provide a <code>B</code>.</p>
<p>In normal object-oriented programming, this often shows up in early lessons as <code>Cat</code> and <code>Dog</code> being subclasses of an <code>Animal</code> class, or <code>Square</code> and <code>Circle</code> being subclasses of a <code>Shape</code> class.</p>
<p>When people first learn about sum types, there is a tendency to understand them as similar to subtyping. This is unfortunately understandable, since a lot of introductions to sum types often start with something like</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- | Bad Sum Type Example!</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Shape</span> <span class="ot">=</span> <span class="dt">Circle</span> <span class="dt">Double</span> <span class="op">|</span> <span class="dt">Rectangle</span> <span class="dt">Double</span> <span class="dt">Double</span></span></code></pre></div>
<p>While there are situations where this might be a good sum type (ie, for an API specification or a state machine), on face-value this is a bad example on the sum types vs. subtyping distinction.</p>
<p>You might notice the essential “tension” of the sum type: you declare all of your options up-front, the functions that consume your value are open and declared ad-hoc. And, if you add new options, all of the consuming functions must be adjusted.</p>
<p>So, <em>subtypes</em> (and supertypes) are more effective when they lean into the opposite end: the universe of possible options are open and declared ad-hoc, but the <em>consuming functions</em> are closed. And, if you add new functions, all of the members must be adjusted.</p>
<p>In typed languages with a concept of “objects” and “classes”, subtyping is often implemented using inheritance and interfaces.</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode java"><code class="sourceCode java"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="kw">interface</span> Widget <span class="op">{</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> <span class="fu">draw</span><span class="op">();</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> <span class="fu">handleEvent</span><span class="op">(</span><span class="bu">String</span> event<span class="op">);</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>    <span class="bu">String</span> <span class="fu">getName</span><span class="op">();</span></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="bu">Button</span> <span class="kw">implements</span> Widget <span class="op">{</span></span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ..</span></span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> InputField <span class="kw">implements</span> Widget <span class="op">{</span></span>
<span id="cb14-12"><a href="#cb14-12" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ..</span></span>
<span id="cb14-13"><a href="#cb14-13" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb14-14"><a href="#cb14-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-15"><a href="#cb14-15" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="bu">Box</span> <span class="kw">implements</span> Widget <span class="op">{</span></span>
<span id="cb14-16"><a href="#cb14-16" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ..</span></span>
<span id="cb14-17"><a href="#cb14-17" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>So, a function like <code>processWidget(Widget widget)</code> that expects a <code>Widget</code> would be able to be passed a <code>Button</code> or <code>InputField</code> or <code>Box</code>. And, if you had a container like <code>List&lt;Widget&gt;</code>, you could assemble a structure using <code>Button</code>, <code>InputField</code>, and <code>Box</code>. A perfect Liskov storm.</p>
<p>In typical library design, you’re able to add new implementations of <code>Widget</code> as an open universe easily: anyone that imports <code>Widget</code> can, and they can now use it with functions taking <code>Widget</code>s. <em>But</em>, if you ever wanted to add new functionality to the <code>Widget</code> interface, that would be a breaking change to all downstream implementations.</p>
<p>However, this implementation of subtyping, while prevalent, is the most mind-numbly boring realization of the concept, and it pained my soul to even spend time talking about it. So let’s jump into the more interesting way that subtype and supertype relationships manifest in the only language where anything is interesting: Haskell.</p>
<h3 id="subtyping-via-parametric-polymorphism">Subtyping via Parametric Polymorphism</h3>
<p>In Haskell, subtyping is implemented in terms of parametric polymorphism and sometimes typeclasses. This allows for us to work nicely with the concept of functions and APIs as subtypes and supertypes of each other.</p>
<p>For example, let’s look at a function that takes indexers and applies them:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="ot">sumAtLocs ::</span> ([<span class="dt">Double</span>] <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Double</span>) <span class="ot">-&gt;</span> [<span class="dt">Double</span>] <span class="ot">-&gt;</span> <span class="dt">Double</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>sumAtLocs ixer xs <span class="ot">=</span> ixer xs <span class="dv">1</span> <span class="op">+</span> ixer xs <span class="dv">2</span> <span class="op">*</span> ixer xs <span class="dv">3</span></span></code></pre></div>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> sumAtLocs (<span class="op">!!</span>) [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>]</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a><span class="dv">14</span></span></code></pre></div>
<p>So, what functions could you pass to <code>sumAtLocs</code>? Can you <em>only</em> pass <code>[Double] -&gt; Int -&gt; Double</code>?</p>
<p>Well, not quite. Look at the above where we passed <code>(!!)</code>, which has type <code>forall a. [a] -&gt; Int -&gt; a</code>!</p>
<p>In fact, what other types could we pass? Here are some examples:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="ot">fun1 ::</span> [a] <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> a</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>fun1 <span class="ot">=</span> (<span class="op">!!</span>)</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a><span class="ot">fun2 ::</span> [a] <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> a</span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>fun2 xs i <span class="ot">=</span> <span class="fu">reverse</span> xs <span class="op">!!</span> i</span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a><span class="ot">fun3 ::</span> (<span class="dt">Foldable</span> t, <span class="dt">Floating</span> a) <span class="ot">=&gt;</span> t a <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> a</span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a>fun3 xs i <span class="ot">=</span> <span class="kw">if</span> <span class="fu">length</span> xs <span class="op">&gt;</span> i <span class="kw">then</span> xs <span class="op">!!</span> i <span class="kw">else</span> <span class="fu">pi</span></span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true" tabindex="-1"></a><span class="ot">fun4 ::</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> a</span>
<span id="cb17-11"><a href="#cb17-11" aria-hidden="true" tabindex="-1"></a>fun4 xs i <span class="ot">=</span> <span class="fu">sum</span> (<span class="fu">take</span> i xs)</span>
<span id="cb17-12"><a href="#cb17-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-13"><a href="#cb17-13" aria-hidden="true" tabindex="-1"></a><span class="ot">fun5 ::</span> (<span class="dt">Integral</span> b, <span class="dt">Num</span> c) <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c</span>
<span id="cb17-14"><a href="#cb17-14" aria-hidden="true" tabindex="-1"></a>fun5 xs i <span class="ot">=</span> <span class="fu">fromIntegral</span> i</span>
<span id="cb17-15"><a href="#cb17-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-16"><a href="#cb17-16" aria-hidden="true" tabindex="-1"></a><span class="ot">fun5 ::</span> (<span class="dt">Foldable</span> t, <span class="dt">Fractional</span> a, <span class="dt">Integral</span> b) <span class="ot">=&gt;</span> t a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> a</span>
<span id="cb17-17"><a href="#cb17-17" aria-hidden="true" tabindex="-1"></a>fun5 xs i <span class="ot">=</span> <span class="fu">sum</span> xs <span class="op">/</span> <span class="fu">fromIntegral</span> i</span>
<span id="cb17-18"><a href="#cb17-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-19"><a href="#cb17-19" aria-hidden="true" tabindex="-1"></a><span class="ot">fun5 ::</span> (<span class="dt">Foldable</span> t, <span class="dt">Integral</span> b, <span class="dt">Floating</span> a) <span class="ot">=&gt;</span> t a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> a</span>
<span id="cb17-20"><a href="#cb17-20" aria-hidden="true" tabindex="-1"></a>fun5 xs i <span class="ot">=</span> <span class="fu">logBase</span> (<span class="fu">fromIntegral</span> i) (<span class="fu">sum</span> xs)</span></code></pre></div>
<p>What’s going on here? Well, the function <em>expects</em> a <code>[Double] -&gt; Int -&gt; Double</code>, but there are a lot of other types that could be passed instead.</p>
<p>At first this might seem like meaningless semantics or trickery, but it’s deeper than that: remember that each of the above types actually has a very different meaning and different possible behaviors!</p>
<ol type="1">
<li><code>forall a. [a] -&gt; Int -&gt; a</code> means that the <code>a</code> <em>must</em> come from the given list. In fact, any function with that type is guaranteed to be partial: if you pass it an empty list, there is no <code>a</code> available to use.</li>
<li><code>forall a. Num a =&gt; [a] -&gt; Int -&gt; a</code> means that the result might actually come from outside of the list: the implementation could always return <code>0</code> or <code>1</code>, even if the list is empty. It also guarantees that it will only add, subtract, multiply, or abs: it will never divide.</li>
<li><code>forall a. Fractional a =&gt; [a] -&gt; Int -&gt; a</code> means that we could possibly do division on the result, but we can’t do anything “floating” like square rooting or logarithms.</li>
<li><code>forall a. Floating a =&gt; [a] -&gt; Int -&gt; a</code> means that we can possibly start square rooting or taking the logarithms of our input numbers</li>
<li><code>[Double] -&gt; Int -&gt; Double</code> gives us the least guarantees about the behavior: the result could come from thin air (and not be a part of the list), and we can even inspect the machine representation of our inputs.</li>
</ol>
<p>So, we have all of these types with completely different semantics and meanings. And yet, they can all be passed to something expecting a <code>[Double] -&gt; Int -&gt; Double</code>. That means that they are all <em>subtypes</em> of <code>[Double] -&gt; Int -&gt; Double</code>! <code>[Double] -&gt; Int -&gt; Double</code> is a supertype that houses multitudes of possible values, uniting all of the possible values and semantics into one big supertype.</p>
<p>Through the power of parametric polymorphism and typeclasses, you can actually create an extensible hierarchy of <em>supertypes</em>, not just of subtypes.</p>
<p>Consider a common API for json serialization. You could have multiple functions that serialize into JSON:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="ot">fooToJson ::</span> <span class="dt">Foo</span> <span class="ot">-&gt;</span> <span class="dt">Value</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a><span class="ot">barToJson ::</span> <span class="dt">Bar</span> <span class="ot">-&gt;</span> <span class="dt">Value</span></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a><span class="ot">bazToJson ::</span> <span class="dt">Baz</span> <span class="ot">-&gt;</span> <span class="dt">Value</span></span></code></pre></div>
<p>Through typeclasses, you can create:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="ot">toJSON ::</span> <span class="dt">ToJSON</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Value</span></span></code></pre></div>
<p>The type of <code>toJSON :: forall a. JSON a =&gt; a -&gt; Value</code> is a subtype of <code>Foo -&gt; Value</code>, <code>Bar -&gt; Value</code>, and <code>Baz -&gt; Value</code>, because everywhere you would <em>want</em> a <code>Foo -&gt; Value</code>, you could give <code>toJSON</code> instead. Every time you <em>want</em> to serialize a <code>Foo</code>, you could use <code>toJSON</code>.</p>
<p>This usage works well, as it gives you an extensible abstraction to design code around. When you write code polymorphic over <code>Monoid a</code>, it forces you to reason about your values with respect to only the aspects relating to monoidness. If you write code polymorphic over <code>Num a</code>, it forces you to reason about your values only with respect to how they can be added, subtracted, negated, or multiplied, instead of having to worry about things like their machine representation.</p>
<p>The extensibility comes from the fact that you can create <em>even more supertypes</em> of <code>forall a. ToJSON a =&gt; a -&gt; Value</code> easily, just by defining a new typeclass instance. So, if you need a <code>MyType -&gt; Value</code>, you could <em>make</em> it a supertype of <code>toJSON :: ToJSON a =&gt; a -&gt; Value</code> by defining an instance of the <code>ToJSON</code> typeclass, and now you have something you can use in its place.</p>
<p><em>Practically</em> this is used by many libraries. For example, <a href="https://hackage.haskell.org/package/ad">ad</a> uses it for automatic differentiation: its <code>diff</code> function looks scary:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="ot">diff ::</span> (<span class="kw">forall</span> s<span class="op">.</span> <span class="dt">AD</span> s <span class="dt">ForwardDouble</span> <span class="ot">-&gt;</span> <span class="dt">AD</span> s <span class="dt">ForwardDouble</span>) <span class="ot">-&gt;</span> <span class="dt">Double</span> <span class="ot">-&gt;</span> <span class="dt">Double</span></span></code></pre></div>
<p>But it relies on the fact that that <code>(forall s. AD s ForwardDouble -&gt; AD s ForwardDuble)</code> is a <em>superclass</em> of <code>(forall a. Floating a =&gt; a -&gt; a)</code>, <code>(forall a. Num a =&gt; a -&gt; a)</code>, etc., so you can give it functions like <code>\x -&gt; x * x</code> (which is a <code>forall a. Num a =&gt; a -&gt; a</code>) and it will work as that <code>AD s</code> type:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> diff (\x <span class="ot">-&gt;</span> x <span class="op">*</span> x) <span class="dv">10</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a><span class="dv">20</span>      <span class="co">-- 2*x</span></span></code></pre></div>
<p>This “numeric overloading” method is used by libraries for GPU programming, as well, to accept numeric functions to be optimized and compiled to GPU code.</p>
<p>Another huge application is in the <em><a href="https://hackage.haskell.org/package/lens">lens</a></em> library, which uses subtyping to unite its hierarchy of optics.</p>
<p>For example, an <code>Iso</code> is a subtype of <code>Traversal</code> which is a subtype of <code>Lens</code>, and <code>Lens</code> is a supertype of <code>Fold</code> and <code>Traversal</code>, etc. In the end the system even allows you to use <code>id</code> from the <em>Prelude</em> as a lens or a traversal, because the type signature of <code>id :: a -&gt; a</code> is actually a subtype of all of those types!</p>
<h3 id="subtyping-using-existential-types">Subtyping using Existential Types</h3>
<p>What more closely matches the <em>spirit</em> of subtypes in OOP and other languages is the <em>existential type</em>: a value that can be a value of any type matching some interface.</p>
<p>For example, let’s imagine a value that could be any instance of <code>Num</code>:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">SomeNum</span> <span class="ot">=</span> <span class="kw">forall</span> a<span class="op">.</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> <span class="dt">SomeNum</span> a</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a><span class="ot">someNums ::</span> [<span class="dt">SomeNum</span>]</span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a>someNums <span class="ot">=</span> [<span class="dt">SomeNum</span> (<span class="dv">1</span><span class="ot"> ::</span> <span class="dt">Int</span>), <span class="dt">SomeNum</span> (<span class="fu">pi</span><span class="ot"> ::</span> <span class="dt">Double</span>), <span class="dt">SomeNum</span> (<span class="bn">0xfe</span><span class="ot"> ::</span> <span class="dt">Word</span>)]</span></code></pre></div>
<p>This is <em>somewhat</em> equivalent to Java’s <code>List&lt;MyInterface&gt;</code> or <code>List&lt;MyClass&gt;</code>, or python’s <code>List[MyClass]</code>.</p>
<p>Note that to use this effectively in Haskell with superclasses and subclasses, you need to manually wrap and unwrap:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">SomeFrational</span> <span class="ot">=</span> <span class="kw">forall</span> a<span class="op">.</span> <span class="dt">Fractional</span> a <span class="ot">=&gt;</span> <span class="dt">SumFractional</span> a</span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a><span class="ot">castUp ::</span> <span class="dt">SomeFractional</span> <span class="ot">-&gt;</span> <span class="dt">SumNum</span></span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a>castUp (<span class="dt">SomeFractional</span> x) <span class="ot">=</span> <span class="dt">SomeNum</span> x</span></code></pre></div>
<p>So, <code>SomeNum</code> is “technically” a supertype of <code>SomeFractional</code>: everywhere a <code>SomeNum</code> is expected, a <code>SomeFractional</code> can be given…but in Haskell it’s a lot less convenient because you have to explicitly cast.</p>
<p>In OOP languages, you can often cast “down” using runtime reflection (<code>SomeNum -&gt; Maybe SomeFractional</code>). However, this is impossible in Haskell the way we have written it!</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="ot">castDown ::</span> <span class="dt">SomeNum</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">SomeFractional</span></span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a>castDown <span class="ot">=</span> <span class="fu">error</span> <span class="st">&quot;impossible!&quot;</span></span></code></pre></div>
<p>That’s because of type erasure: Haskell does not (by default) couple a value at runtime with all of its associated interface implementations. When you create a value of type <code>SomeNum</code>, you are packing an untyped pointer to that value as well as a “dictionary” of all the functions you could use it with:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">NumDict</span> a <span class="ot">=</span> <span class="dt">NumDict</span></span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a>    {<span class="ot"> (+) ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a</span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a>    ,<span class="ot"> (*) ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a</span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a>    ,<span class="ot"> negate ::</span> a <span class="ot">-&gt;</span> a</span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a>    ,<span class="ot"> abs ::</span> a <span class="ot">-&gt;</span> a</span>
<span id="cb25-6"><a href="#cb25-6" aria-hidden="true" tabindex="-1"></a>    ,<span class="ot"> fromInteger ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> a</span>
<span id="cb25-7"><a href="#cb25-7" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb25-8"><a href="#cb25-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-9"><a href="#cb25-9" aria-hidden="true" tabindex="-1"></a><span class="ot">mkNumDict ::</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> <span class="dt">NumDict</span> a</span>
<span id="cb25-10"><a href="#cb25-10" aria-hidden="true" tabindex="-1"></a>mkNumDict <span class="ot">=</span> <span class="dt">NumDict</span> (<span class="op">+</span>) (<span class="op">*</span>) <span class="fu">negate</span> <span class="fu">abs</span> <span class="fu">fromInteger</span></span>
<span id="cb25-11"><a href="#cb25-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-12"><a href="#cb25-12" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">FractionalDict</span> a <span class="ot">=</span> <span class="dt">FractionalDict</span></span>
<span id="cb25-13"><a href="#cb25-13" aria-hidden="true" tabindex="-1"></a>    {<span class="ot"> numDict ::</span> <span class="dt">NumDict</span> a</span>
<span id="cb25-14"><a href="#cb25-14" aria-hidden="true" tabindex="-1"></a>    ,<span class="ot"> (/) ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a</span>
<span id="cb25-15"><a href="#cb25-15" aria-hidden="true" tabindex="-1"></a>    ,<span class="ot"> fromRational ::</span> <span class="dt">Rational</span> <span class="ot">-&gt;</span> a</span>
<span id="cb25-16"><a href="#cb25-16" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb25-17"><a href="#cb25-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-18"><a href="#cb25-18" aria-hidden="true" tabindex="-1"></a><span class="co">-- | Essentially equivalent to the previous &#39;SomeNum&#39;</span></span>
<span id="cb25-19"><a href="#cb25-19" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">SomeNum</span> <span class="ot">=</span> <span class="kw">forall</span> a<span class="op">.</span> <span class="dt">SomeNum</span></span>
<span id="cb25-20"><a href="#cb25-20" aria-hidden="true" tabindex="-1"></a>    {<span class="ot"> numDict ::</span> <span class="dt">NumDict</span> a</span>
<span id="cb25-21"><a href="#cb25-21" aria-hidden="true" tabindex="-1"></a>    ,<span class="ot"> value ::</span> a</span>
<span id="cb25-22"><a href="#cb25-22" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb25-23"><a href="#cb25-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-24"><a href="#cb25-24" aria-hidden="true" tabindex="-1"></a><span class="co">-- | Essentially equivalent to the previous &#39;SomeFractional&#39;</span></span>
<span id="cb25-25"><a href="#cb25-25" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">SomeFractional</span> <span class="ot">=</span> <span class="kw">forall</span> a<span class="op">.</span> <span class="dt">SomeFractional</span></span>
<span id="cb25-26"><a href="#cb25-26" aria-hidden="true" tabindex="-1"></a>    {<span class="ot"> fractionalDict ::</span> <span class="dt">FractionalDict</span> a</span>
<span id="cb25-27"><a href="#cb25-27" aria-hidden="true" tabindex="-1"></a>    ,<span class="ot"> value ::</span> a</span>
<span id="cb25-28"><a href="#cb25-28" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb25-29"><a href="#cb25-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-30"><a href="#cb25-30" aria-hidden="true" tabindex="-1"></a><span class="ot">castUp ::</span> <span class="dt">SomeFractional</span> <span class="ot">-&gt;</span> <span class="dt">SomeNum</span></span>
<span id="cb25-31"><a href="#cb25-31" aria-hidden="true" tabindex="-1"></a>castUp (<span class="dt">SomeFractional</span> (<span class="dt">FractionalDict</span> {numDict}) x) <span class="ot">=</span> <span class="dt">SomeNum</span> d x</span>
<span id="cb25-32"><a href="#cb25-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-33"><a href="#cb25-33" aria-hidden="true" tabindex="-1"></a><span class="ot">castDown ::</span> <span class="dt">SomeNum</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">SomeFractional</span></span>
<span id="cb25-34"><a href="#cb25-34" aria-hidden="true" tabindex="-1"></a>castDown (<span class="dt">SomeNum</span> nd x) <span class="ot">=</span> <span class="fu">error</span> <span class="st">&quot;not possible!&quot;</span></span></code></pre></div>
<p>All of these function pointers essentially exist at runtime <em>inside</em> the <code>SomeNum</code>. So, <code>SomeFractional</code> can be “cast up” to <code>SomeNum</code> by simply dropping the <code>FractionalDict</code>. However, you cannot “cast down” from <code>SomeNum</code> because there is no way to materialize the <code>FractionalDict</code>: the association from type to instance is lost at runtime. OOP languages usually get around this by having the <em>value itself</em> hold pointers to all of its interface implementations at runtime. However, in Haskell, we have type erasure by default: there are no tables carried around at runtime.<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a></p>
<p>In the end, existential subtyping requires explicit wrapping/unwrapping instead of implicit or lightweight casting possible in OOP languages optimized around this sort of behavior.<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a> Existential-based subtyping is just less common in Haskell because parametric polymorphism offers a solution to most similar problems. For more on this topic, Simon Peyton Jones has <a href="https://www.youtube.com/watch?v=6COvD8oynmI">a nice lecture</a> on the topic.</p>
<p>The pattern of <em>using</em> existentially qualified data in a container (like <code>[SomeNum]</code>) is often called the “widget pattern” because it’s used in libraries like <em><a href="https://hackage.haskell.org/package/xmonad">xmonad</a></em> to allow extensible “widgets” stored alongside the methods used to manipualte them. It’s more common to explicitly store the handler functions (a “dictionary”) inside the type instead of of existential typeclasses, but sometimes it can be nice to let the compiler handle generating and passing your method tables implicitly for you. Using existential typeclasses instead of explicit dictionaries also allows you to bless certain methods and functions as “canonical” to your type, and the compiler will make sure they are always coherent.</p>
<p>I do mention in <a href="https://blog.jle.im/entry/levels-of-type-safety-haskell-lists.html">a blog post about different types of existential lists</a>, however, that this “container of instances” type is much less useful in Haskell than in other languages for many reasons, including the up/downcasting issues mentioned above. In addition, Haskell gives you a whole wealth of functionality to operate over homogeneous parameters (like <code>[a]</code>, where all items have the same type) that jumping to heterogeneous lists gives up so much.</p>
<div class="note">
<p><strong>Aside</strong></p>
<p>Let’s briefly take a moment to talk about how typeclass hierarchies give us subtle subtype/supertype relationships.</p>
<p>Let’s look at the classic <code>Num</code> and <code>Fractional</code>:</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Num</span> a</span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> <span class="dt">Fractional</span> a</span></code></pre></div>
<p><code>Num</code> is a <em>superclass</em> of <code>Fractional</code>, and <code>Fractional</code> is a <em>subclass</em> of <code>Num</code>. Everywhere a <code>Num</code> constraint is required, you can provide a <code>Fractional</code> constraint to do the same thing.</p>
<p>However, in these two types:</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="dt">Num</span> a <span class="ot">=&gt;</span> a</span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a><span class="dt">Fractional</span> a <span class="ot">=&gt;</span> a</span></code></pre></div>
<p><code>forall a. Num a =&gt; a</code> is actually a <em>subclass</em> of <code>forall a. Fractional a =&gt; a</code>! That’s because if you need a <code>forall a. Fractional a =&gt; a</code>, you can provide a <code>forall a. Num a =&gt; a</code> instead. In fact, let’s look at three levels: <code>Double</code>, <code>forall a. Fractional a =&gt; a</code>, and <code>forall a. Num a =&gt; a</code>.</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- can be used as `Double`</span></span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a><span class="fl">1.0</span><span class="ot"> ::</span> <span class="dt">Double</span></span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a><span class="fl">1.0</span><span class="ot"> ::</span> <span class="dt">Fractional</span> a <span class="ot">=&gt;</span> a</span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a><span class="dv">1</span><span class="ot"> ::</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> a</span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-6"><a href="#cb28-6" aria-hidden="true" tabindex="-1"></a><span class="co">-- can be used as `forall a. Fractional a =&gt; a`</span></span>
<span id="cb28-7"><a href="#cb28-7" aria-hidden="true" tabindex="-1"></a><span class="fl">1.0</span><span class="ot"> ::</span> <span class="dt">Fractional</span> a <span class="ot">=&gt;</span> a</span>
<span id="cb28-8"><a href="#cb28-8" aria-hidden="true" tabindex="-1"></a><span class="dv">1</span><span class="ot"> ::</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> a</span>
<span id="cb28-9"><a href="#cb28-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-10"><a href="#cb28-10" aria-hidden="true" tabindex="-1"></a><span class="co">-- can be used as `forall a. Num a =&gt; a`</span></span>
<span id="cb28-11"><a href="#cb28-11" aria-hidden="true" tabindex="-1"></a><span class="dv">1</span><span class="ot"> ::</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> a</span></code></pre></div>
<p>So, <code>Double</code> is a supertype of <code>Fractional a =&gt; a</code> is a supertype of <code>Num a =&gt; a</code>.</p>
<p>The general idea here is that the more super- you go, the more you “know” about the actual term you are creating. So, with <code>Num a =&gt; a</code>, you know the <em>least</em> (and, you have the most possible actual terms because there are more instances of <code>Num</code> than of <code>Fractional</code>). And, with <code>Double</code>, you know the <em>most</em>: you even know its machine representation!</p>
<p>So, <code>Num</code> is a superclass of <code>Fractional</code> but <code>forall a. Num a =&gt; a</code> is a subclass of <code>forall a. Fractional a =&gt; a</code>. This actually follows the typical rules of subtyping: if something appears on the “left” of an arrow (<code>=&gt;</code> in this case), it gets flipped from sub- to super-. We often call the left side a “negative” (contravariant) position and the right side a “positive” position, because a negative of a negative (the left side of a left size, like <code>a</code> in <code>(a -&gt; b) -&gt; c</code>) is a positive.</p>
<p>Also note that our “existential wrappers”:</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">SomeNum</span> <span class="ot">=</span> <span class="kw">forall</span> a<span class="op">.</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> <span class="dt">SomeFractional</span> a</span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">SomeFractional</span> <span class="ot">=</span> <span class="kw">forall</span> a<span class="op">.</span> <span class="dt">Fractional</span> a <span class="ot">=&gt;</span> <span class="dt">SomeFractional</span> a</span></code></pre></div>
<p>can be CPS-transformed to their equivalent types:</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">SomeNum&#39;</span> <span class="ot">=</span> <span class="kw">forall</span> r<span class="op">.</span> (<span class="kw">forall</span> a<span class="op">.</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> r) <span class="ot">-&gt;</span> r</span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">SomeFractional&#39;</span> <span class="ot">=</span> <span class="kw">forall</span> r<span class="op">.</span> (<span class="kw">forall</span> a<span class="op">.</span> <span class="dt">Fractional</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> r) <span class="ot">-&gt;</span> r</span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true" tabindex="-1"></a><span class="ot">toSomeNum&#39; ::</span> <span class="dt">SomeNum</span> <span class="ot">-&gt;</span> <span class="dt">SomeNum&#39;</span></span>
<span id="cb30-5"><a href="#cb30-5" aria-hidden="true" tabindex="-1"></a>toSomeNum&#39; (<span class="dt">SomeNum</span> x) f <span class="ot">=</span> f x</span>
<span id="cb30-6"><a href="#cb30-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-7"><a href="#cb30-7" aria-hidden="true" tabindex="-1"></a><span class="ot">toSomeNum ::</span> <span class="dt">SomeNum&#39;</span> <span class="ot">-&gt;</span> <span class="dt">SomeNum</span></span>
<span id="cb30-8"><a href="#cb30-8" aria-hidden="true" tabindex="-1"></a>toSomeNum sn <span class="ot">=</span> sn <span class="dt">SomeNum</span></span></code></pre></div>
<p>And in those cases, <code>Num</code> and <code>Fractional</code> again appear in the covariant (positive) position, since they’re the negative of negative. So, this aligns with our intuition that <code>SomeFractional</code> is a subtype of <code>SomeNum</code>.</p>
</div>
<h2 id="the-expression-problem">The Expression Problem</h2>
<p>This tension that I described earlier is closely related to <a href="https://en.wikipedia.org/wiki/Expression_problem">the expression problem</a>, and is a tension that is inherent to a lot of different aspects of language and abstraction design. However, in the context laid out in this post, it serves as a good general guide to decide what pattern to go down:</p>
<ul>
<li>If you expect a canonical set of “inhabitants” and an open set of “operations”, sum types can suit that end of the spectrum well.</li>
<li>If you expect a canonical set of “operations” and an open set of “inhabitants”, consider subtyping and supertyping.</li>
</ul>
<p>I don’t really think of the expression problem as a “problem” in the sense of “some hindrance to deal with”. Instead, I see it in the “math problem” sort of way: by adjusting how you approach things, you can play with the equation make the most out of what requirements you need in your design.</p>
<h2 id="looking-forward">Looking Forward</h2>
<p>A lot of frustration in Haskell (and programming in general) lies in trying to force abstraction and tools to work in a way they weren’t meant to. Hopefully this short run-down can help you avoid going <em>against</em> the point of these design patterns and start making the most of what they can offer. Happy Haskelling!</p>
<h2 id="special-thanks">Special Thanks</h2>
<p>I am very humbled to be supported by an amazing community, who make it possible for me to devote time to researching and writing these posts. Very special thanks to my supporter at the “Amazing” level on <a href="https://www.patreon.com/justinle/overview">patreon</a>, Josh Vera! :)</p>
<section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes">
<hr />
<ol>
<li id="fn1"><p><code>?</code><a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p>Must OOP languages also have mechanisms for type erasure, but the <em>default</em> is unerased, which is opposite of Haskell.<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3"><p>Note that there are current <a href="https://github.com/ghc-proposals/ghc-proposals/pull/473">GHC proposals</a> that attempt to allow “naked” existentials without newtype wrappers, so we could actually get the same seamless and implicit up-casting as we would get in OOP languages. However, the jury is out on whether or not this is a good idea.<a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section></div><footer><hr><div class="copy-content"><p>Hi, thanks for reading! You can reach me via email at <a href="mailto:justin@jle.im" class="email">justin@jle.im</a>, or at twitter at <a href="https://twitter.com/mstk">@mstk</a>! This post and all others are published under the <a href="https://creativecommons.org/licenses/by-nc-nd/3.0/">CC-BY-NC-ND 3.0</a> license. Corrections and edits via pull request are welcome and encouraged at <a href="https://github.com/mstksg/inCode">the source repository</a>.</p>
<p>If you feel inclined, or this post was particularly helpful for you, why not consider <a href="https://www.patreon.com/justinle/overview">supporting me on Patreon</a>, or a <a href="bitcoin:3D7rmAYgbDnp4gp4rf22THsGt74fNucPDU">BTC donation</a>? :)</p></div><div class="clear"></div><ul class="entry-series"></ul><ul class="tag-list"><li><a href="https://blog.jle.im/entries/tagged/functional-programming.html" class="tag-a-tag">#functional programming</a></li><li><a href="https://blog.jle.im/entries/category/@haskell.html" class="tag-a-category">@HASKELL</a></li></ul><aside class="social-buttons"><div class="addthis_toolbox addthis_default_style addthis-buttons"><a class="addthis_button_facebook_like" fb:like:layout="button_count"></a><a class="addthis_button_tweet"></a><a class="addthis_button_google_plusone" g:plusone:size="medium"></a><a class="addthis_counter addthis_pill_style"></a></div><div class="custom-social-buttons"><div class="custom-social-button"><a href="https://www.reddit.com/submit" onclick="window.location = &#39;https://www.reddit.com/submit?url=&#39;+ encodeURIComponent(window.location); return false"><img src="https://www.reddit.com/static/spreddit7.gif" alt="submit to reddit"></a></div></div></aside><nav class="next-prev-links"><ul><li class="prev-entry-link">&larr; <a href="https://blog.jle.im/entry/advent-of-code-2024.html">Advent of Code 2024: Haskell Solution Reflections for all 25 Days</a> (Previous)</li><li class="next-entry-link">(Next) <a href="https://blog.jle.im/entry/faking-adts-and-gadts.html">Faking ADTs and GADTs in Languages That Shouldn&#39;t Have Them</a> &rarr;</li></ul></nav></footer></article><div class="post-entry"><div class="tile"><div id="disqus_thread"></div><script type="text/javascript">var disqus_config = function () {
    this.page.url = 'https://blog.jle.im/entry/sum-types-and-subtypes-and-unions.html';
    this.page.identifier = 'sum-types-and-subtypes-and-unions';
};
(function() {
    var d = document, s = d.createElement('script');
    s.src = '//incode.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
})();
</script><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a><br></noscript><a href="http://disqus.com" class="dsq-brlink">Comments powered by <span class="logo-disqus">Disqus</span></a></div></div></div></div></div><div id="footer-container"><div id="footer-content"><div class="tile"><div class="footer-copyright">&copy; 2020 Justin Le <span class="license-link">(<a href="https://creativecommons.org/licenses/by-nc-nd/3.0/" class="license">CC-BY-NC-ND 3.0</a>)</span></div><div class="footer-follow social-follows"><ul class="social-follows-list"><li><ul class="social-follows-list-social"><li><a class="social-follow-twitter" title="Follow me on Twitter!" href="https://twitter.com/intent/user?user_id=mstk" onclick="window.open(
  &#39;http://twitter.com/intent/user?user_id=907281&#39;,
  &#39;facebook-share-dialog&#39;,
  &#39;width=550,height=520&#39;);
return false;
">Twitter</a></li><li><a class="social-follow-github" title="Fork me on Github!" href="https://github.com/mstksg">Github</a></li><li><a class="social-follow-twitch" title="Watch me on Twitch!" href="https://www.twitch.tv/justin_l">Twitch</a></li><li><a class="social-follow-patreon" title="Support me on Patreon!" href="https://www.patreon.com/justinle/overview">Patreon</a></li><li><a class="social-follow-gplus" title="Add me on Google+!" href="https://plus.google.com/+JustinLe">Google+</a></li><li><a class="social-follow-keybase" title="Track me on Keybase!" href="https://keybase.io/mstksg">Keybase</a></li><li><a class="social-follow-linkedin" title="Connect with me on LinkedIn!" href="https://linkedin.com/in/lejustin">LinkedIn</a></li><li><a class="social-follow-bitcoin" title="Donate via bitcoin!" href="bitcoin:3D7rmAYgbDnp4gp4rf22THsGt74fNucPDU">Bitcoin</a></li></ul></li><li><ul class="social-follows-list-site"><li><a class="social-follow-rss" title="Subscribe to my RSS Feed!" href="http://feeds.feedburner.com/incodeblog">RSS</a></li><li><a class="social-follow-email" title="Subscribe to the mailing list!" href="https://feedburner.google.com/fb/a/mailverify?loc=en_US&amp;uri=incodeblog">Mailing list</a></li></ul></li></ul></div></div></div></div></body></html>