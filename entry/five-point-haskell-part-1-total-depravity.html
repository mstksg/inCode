<!DOCTYPE HTML>
<html><head><title>&quot;Five-Point Haskell&quot;: Total Depravity (and Defensive Typing) · in Code</title><meta name="description" content="Weblog of Justin Le, covering various adventures in programming and explorations in the worlds of computation physics, and knowledge.
"><meta http-equiv="Content-Type" content="text/html;charset=utf-8"><meta name="viewport" content="width=device-width,initial-scale=1.0"><meta name="flattr:id" content="3p9jqr"><meta property="og:site_name" content="in Code"><meta property="og:description" content="I have thought about distilling the principles by which I program Haskell, and how I’ve been able to steer long-lived projects over years of growth, refactorings, and changes in demands. I find myself coming back to a few distinct and helpful “points” (“doctrines”, if you may allow me to say) that have yet to lead me astray. With a new age of software development coming, what does it even mean to write good, robust, correct code? It is long overdue to clarify the mindset we use to define “good” coding principles. In this series, Five-Point Haskell, I’ll set out to establish a five-point framework for typed functional programming (and Haskell-derived) design that aims to produce code that is maintainable, correct, long-lasting, extensible, and beautiful to write and work with. We’ll reference real-world case studies with actual examples when we can, and also attempt to dispel thought-leader sound bites that have become all too popular on Twitter (“heresies”, so to speak). Let’s jump right into point 1: the doctrine of Total Depravity, and why Haskell is perfectly primed to make living with it as frictionless as possible. Total Depravity: If your code’s correctness depends on keeping complicated interconnected structure in your head, a devastating incident is not a matter of if but when.Therefore, delegate these concerns to tooling and a sufficiently powerful compiler, use types to guard against errors, and free yourself to only mentally track the actual important things."><meta property="og:type" content="article"><meta property="og:title" content="&quot;Five-Point Haskell&quot;: Total Depravity (and Defensive Typing)"><meta property="og:image" content="https://blog.jle.im/img/site_logo.jpg"><meta property="og:locale" content="en_US"><meta property="og:url" content="https://blog.jle.im/entry/five-point-haskell-part-1-total-depravity.html"><meta name="twitter:card" content="summary"><meta name="twitter:creator:id" content="mstk"><link rel="author" href="https://plus.google.com/107705320197444500140"><link rel="alternate" type="application/rss+xml" title="in Code (RSS Feed)" href="http://feeds.feedburner.com/incodeblog"><link rel="canonical" href="https://blog.jle.im/entry/five-point-haskell-part-1-total-depravity.html"><link href="https://blog.jle.im/favicon.ico" rel="shortcut icon"><link href="https://blog.jle.im/css/toast.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/font.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/main.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/page/entry.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/pygments.css" rel="stylesheet" type="text/css"><script type="text/javascript">var page_data = {};
var disqus_shortname='incode';
</script><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-443711-8', 'jle.im');
ga('send', 'pageview');
</script><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script id="MathJax-script" async="" src="https://cdn.jsdelivr.net/npm/mathjax@3.0.1/es5/tex-mml-chtml.js"></script><script type="text/javascript" src="//ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script><script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5234d67a6b68dcd4"></script><script type="text/javascript" src="https://blog.jle.im/js/page/entry_toc.js"></script><script type="text/javascript" src="https://blog.jle.im/js/disqus_count.js"></script><script type="text/javascript" src="https://blog.jle.im/js/social.js"></script><script type="text/javascript" src="https://blog.jle.im/js/jquery/jquery.toc.js"></script><script type="text/javascript" src="https://blog.jle.im/purescript/entry.js"></script></head><body><div id="fb-root"><script>(function(d, s, id) {
 var js, fjs = d.getElementsByTagName(s)[0];
 if (d.getElementById(id)) return;
 js = d.createElement(s); js.id = id;
 js.src = "//connect.facebook.net/en_US/all.js#xfbml=1&appId=641852699171929";
 fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));
</script></div><div id="header-container"><div id="navbar-container" class="tile"><nav id="navbar-content"><div class="nav-info"><h1 class="site-title"><a href="https://blog.jle.im/" class="nav-title">in Code</a></h1><span class="nav-author">Justin Le</span></div><ul class="nav-links"><li><a href="https://blog.jle.im/">home</a></li><li><a href="https://blog.jle.im/entries.html">archives</a></li><li><a href="https://cv.jle.im">cv</a></li><div class="clear"></div></ul></nav></div><div id="header-content"></div></div><div id="body-container" class="container"><div id="main-container" class="grid"><div class="entry-section unit span-grid" role="main"><article class="tile article"><header><h1 id="title">&quot;Five-Point Haskell&quot;: Total Depravity (and Defensive Typing)</h1><p class="entry-info">by <a class="author" href="https://blog.jle.im/">Justin Le</a><span class="info-separator"> &diams; </span><time datetime="2026-02-02T07:06:46Z" pubdate="" class="pubdate">Monday February 2, 2026</time></p><p><span class="source-info"><a class="source-link" href="https://github.com/mstksg/inCode/tree/master/copy/entries/five-point-haskell-1.md">Source</a><span class="info-separator"> &diams; </span><a class="source-link" href="https://github.com/mstksg/inCode/tree/gh-pages/entry/five-point-haskell-part-1-total-depravity.md">Markdown</a><span class="info-separator"> &diams; </span><a class="source-link" href="https://blog.jle.im/entry/five-point-haskell-part-1-total-depravity.tex">LaTeX</a><span class="info-separator"> &diams; </span></span>Posted in <a href="https://blog.jle.im/entries/category/@haskell.html" class="tag-a-category" title="Functional, pure, non-strict, statically and strongly typed, natively
compiled...really just the king of great languages.
">Haskell</a><span class="info-separator"> &diams; </span><a class="comment-link" href="#disqus_thread">Comments</a></p></header><hr><aside class="contents-container"><h5 id="contents-header">Contents</h5><div id="toc"></div></aside><div class="main-content copy-content"><p>I have thought about distilling the principles by which I program Haskell, and how I’ve been able to steer long-lived projects over years of growth, refactorings, and changes in demands. I find myself coming back to a few distinct and helpful “points” (“doctrines”, if you may allow me to say) that have yet to lead me astray.</p>
<p>With a new age of software development coming, what does it even mean to write good, robust, correct code? It is long overdue to clarify the mindset we use to define “good” coding principles.</p>
<p>In this series, <em><a href="https://blog.jle.im/entries/series/+five-point-haskell.html">Five-Point Haskell</a></em>, I’ll set out to establish a five-point framework for typed functional programming (and Haskell-derived) design that aims to produce code that is maintainable, correct, long-lasting, extensible, and beautiful to write and work with. We’ll reference real-world case studies with actual examples when we can, and also attempt to dispel thought-leader sound bites that have become all too popular on Twitter (“heresies”, so to speak).</p>
<p>Let’s jump right into point 1: the doctrine of <strong>Total Depravity</strong>, and why Haskell is perfectly primed to make living with it as frictionless as possible.</p>
<blockquote>
<p>Total Depravity: If your code’s correctness depends on keeping complicated interconnected structure in your head, a devastating incident is not a matter of <em>if</em> but <em>when</em>.</p>
<p>Therefore, delegate these concerns to tooling and a sufficiently powerful compiler, use types to guard against errors, and free yourself to only mentally track the actual important things.</p>
</blockquote>
<h2 id="mix-ups-are-inevitable">Mix-ups Are Inevitable</h2>
<p>Think about the stereotype of a “brilliant programmer” that an inexperienced programmer has in their mind — someone who can hold every detail of a complex system in their head, every intricate connection and relationship between each component. There’s the classic <a href="https://www.monkeyuser.com/2018/focus/">Monkey User Comic</a> that valorizes this ideal.</p>
<figure>
<img src="/img/entries/five-point-haskell/79-focus.png" title="Monkey User --- Focus" style="width:50%;height:auto;" alt="Monkey User — Focus" />
<figcaption aria-hidden="true">Monkey User — Focus</figcaption>
</figure>
<p>The 10x developer is one who can carry the state and interconnectedness of an entire system in their brain, and the bigger the state they can carry, the more 10x they are.</p>
<p>This is the myth of the hero programmer. Did you have a bug? Well, you just need to upgrade your mental awareness and your context window. You just need to be better and better at keeping more in your mind.</p>
<p>Actually <em>addressing</em> these issues in most languages requires a lot of overhead and clunkiness. But luckily we’re in Haskell.</p>
<h3 id="explicit-tags">Explicit Tags</h3>
<p>The <a href="https://www.atlassian.com/blog/atlassian-engineering/post-incident-review-april-2022-outage">2022 Atlassian Outage</a>, in part, was the result of passing the wrong type of ID. The operators were intended to pass <em>App</em> IDs, but instead passed <em>Site</em> IDs, and the errors cascaded from there. It goes without saying that if you have a bunch of “naked” IDs, then mixing them up is eventually going to backfire on you.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">Id</span> <span class="ot">=</span> <span class="dt">Id</span> <span class="dt">String</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">SiteId</span> <span class="ot">=</span> <span class="dt">Id</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">AppId</span> <span class="ot">=</span> <span class="dt">Id</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="ot">getApps ::</span> <span class="dt">SiteId</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> [<span class="dt">AppId</span>]</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="ot">deleteSite ::</span> <span class="dt">SiteId</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="ot">deleteApp ::</span> <span class="dt">AppId</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span></code></pre></div>
<p>This is convenient because you get functions for all IDs without any extra work. Let’s say you want to serialize/print or deserialize/read these IDs — it can be helpful to give them all the same type so that you can write this logic in one place.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">ToJSON</span> <span class="dt">Id</span> <span class="kw">where</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>  toJSON (<span class="dt">Id</span> x) <span class="ot">=</span> object [ <span class="st">&quot;id&quot;</span> <span class="op">.=</span> x ]</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">FromJSON</span> <span class="dt">Id</span> <span class="kw">where</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>  parseJSON <span class="ot">=</span> withObject <span class="st">&quot;Id&quot;</span> <span class="op">$</span> \v <span class="ot">-&gt;</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Id</span> <span class="op">&lt;$&gt;</span> (v <span class="op">.:</span> <span class="st">&quot;id&quot;</span>)</span></code></pre></div>
<p>Convenient and effective, as long as you never accidentally use a <code>SiteId</code> as an <code>AppId</code> or vice versa. And this is a very easy delusion to fall into, if you don’t believe in total depravity. However, sooner or later (maybe in a week, maybe in a year, maybe after you onboard that new team member)…someone is going to accidentally pass a site ID where an app ID is expected.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> targetSites <span class="ot">=</span> [<span class="dt">Id</span> <span class="st">&quot;abc&quot;</span>, <span class="dt">Id</span> <span class="st">&quot;def&quot;</span>]</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>    <span class="fu">mapM_</span> deleteApp targetSites</span></code></pre></div>
<p>And at that point it’s all over.</p>
<p>Knowing this can happen, we can add a simple newtype wrapper so that accidentally using the wrong ID is a compile error:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">SiteId</span> <span class="ot">=</span> <span class="dt">SiteId</span> <span class="dt">String</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">AppId</span> <span class="ot">=</span> <span class="dt">AppId</span> <span class="dt">String</span></span></code></pre></div>
<p>And now such a mis-call will never compile! Congratulations!</p>
<p>We do have a downside now: we can no longer write code polymorphic over IDs when we want to. In the untagged situation, we could <em>only</em> write polymorphic code, and in the new situation we can <em>only</em> write code for one ID type.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">FromJSON</span> <span class="dt">SiteId</span> <span class="kw">where</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>  parseJSON <span class="ot">=</span> withObject <span class="st">&quot;Id&quot;</span> <span class="op">$</span> \v <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>    tag <span class="ot">&lt;-</span> v <span class="op">.:</span> <span class="st">&quot;type&quot;</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>    unless (tag <span class="op">==</span> <span class="st">&quot;Site&quot;</span>) <span class="op">$</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>      <span class="fu">fail</span> <span class="st">&quot;Parsed wrong type of ID!&quot;</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">SiteId</span> <span class="op">&lt;$&gt;</span> (v <span class="op">.:</span> <span class="st">&quot;id&quot;</span>)</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">ToJSON</span> <span class="dt">SiteId</span> <span class="kw">where</span></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>  toJSON (<span class="dt">SiteId</span> x) <span class="ot">=</span> object [ <span class="st">&quot;type&quot;</span> <span class="op">.=</span> <span class="st">&quot;Site&quot;</span>, <span class="st">&quot;id&quot;</span> <span class="op">.=</span> x ]</span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">FromJSON</span> <span class="dt">AppId</span> <span class="kw">where</span></span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a>  parseJSON <span class="ot">=</span> withObject <span class="st">&quot;Id&quot;</span> <span class="op">$</span> \v <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a>    tag <span class="ot">&lt;-</span> v <span class="op">.:</span> <span class="st">&quot;type&quot;</span></span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a>    unless (tag <span class="op">==</span> <span class="st">&quot;App&quot;</span>) <span class="op">$</span></span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a>      <span class="fu">fail</span> <span class="st">&quot;Parsed wrong type of ID!&quot;</span></span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a>    <span class="dt">AppId</span> <span class="op">&lt;$&gt;</span> (v <span class="op">.:</span> <span class="st">&quot;id&quot;</span>)</span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">ToJSON</span> <span class="dt">AppId</span> <span class="kw">where</span></span>
<span id="cb5-19"><a href="#cb5-19" aria-hidden="true" tabindex="-1"></a>  toJSON (<span class="dt">AppId</span> x) <span class="ot">=</span> object [ <span class="st">&quot;type&quot;</span> <span class="op">.=</span> <span class="st">&quot;App&quot;</span>, <span class="st">&quot;id&quot;</span> <span class="op">.=</span> x ]</span></code></pre></div>
<p>However, luckily, because we’re in Haskell, it’s easy to get the best of both worlds with <em>phantom types</em> (that don’t refer to anything inside the actual data representation):</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Id</span> a <span class="ot">=</span> <span class="dt">Id</span> {<span class="ot"> getId ::</span> <span class="dt">String</span> }</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Site</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">App</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">SiteId</span> <span class="ot">=</span> <span class="dt">Id</span> <span class="dt">Site</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">AppId</span> <span class="ot">=</span> <span class="dt">Id</span> <span class="dt">App</span></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a><span class="co">-- using Typeable for demonstration purposes</span></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Typeable</span> a <span class="ot">=&gt;</span> <span class="dt">ToJSON</span> (<span class="dt">Id</span> a) <span class="kw">where</span></span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a>  toJSON (<span class="dt">Id</span> x) <span class="ot">=</span> object</span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a>    [ <span class="st">&quot;type&quot;</span> <span class="op">.=</span> <span class="fu">show</span> (typeRep <span class="op">@</span>a)</span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a>    , <span class="st">&quot;id&quot;</span> <span class="op">.=</span> x</span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a>    ]</span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Typeable</span> a <span class="ot">=&gt;</span> <span class="dt">FromJSON</span> (<span class="dt">Id</span> a) <span class="kw">where</span></span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true" tabindex="-1"></a>  parseJSON <span class="ot">=</span> withObject <span class="st">&quot;Id&quot;</span> <span class="op">$</span> \v <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true" tabindex="-1"></a>    tag <span class="ot">&lt;-</span> v <span class="op">.:</span> <span class="st">&quot;type&quot;</span></span>
<span id="cb6-19"><a href="#cb6-19" aria-hidden="true" tabindex="-1"></a>    unless (tag <span class="op">==</span> <span class="fu">show</span> (typeRep <span class="op">@</span>a)) <span class="op">$</span></span>
<span id="cb6-20"><a href="#cb6-20" aria-hidden="true" tabindex="-1"></a>      <span class="fu">fail</span> <span class="st">&quot;Parsed wrong type of ID!&quot;</span></span>
<span id="cb6-21"><a href="#cb6-21" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Id</span> <span class="op">&lt;$&gt;</span> (v <span class="op">.:</span> <span class="st">&quot;id&quot;</span>)</span></code></pre></div>
<p>Type safety doesn’t necessarily mean inflexibility!</p>
<h3 id="phantom-powers">Phantom Powers</h3>
<p>Phantom types give us a <em>lot</em> of low-hanging fruit for preventing inadvertent misuse.</p>
<p>The <a href="https://www.theregister.com/2017/04/11/database_deletion_downed_digital_ocean_last_week/">2017 DigitalOcean outage</a>, for example, was partially about the wrong environment credentials being used.</p>
<p>We could imagine a test harness that clears a test database using <em><a href="https://hackage.haskell.org/package/postgresql-simple">postgresql-simple</a></em>:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- | Warning: do NOT call this outside of test environment!</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="ot">clearTestEnv ::</span> <span class="dt">Connection</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>clearTestEnv conn <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">putStrLn</span> <span class="st">&quot;Are you sure you read the warning on this function? Well, too late now!&quot;</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>  _ <span class="ot">&lt;-</span> execute_ conn <span class="st">&quot;DROP TABLE IF EXISTS users CASCADE&quot;</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>  <span class="fu">putStrLn</span> <span class="st">&quot;Test data wiped.&quot;</span></span></code></pre></div>
<p>However, somewhere down the line, someone is going to call <code>clearTestEnv</code> <em>deep</em> inside a function inside a function inside a function, which itself is called against the prod database. I guarantee it.</p>
<p>To ensure this never happens, we can use closed phantom types using <code>DataKinds</code> (made nicer with <code>TypeData</code> post-GHC 9.6):</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- type data = declare a closed kind and two type constructors at the type level using -XTypeData</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="kw">data</span> <span class="dt">Env</span> <span class="ot">=</span> <span class="dt">Prod</span> <span class="op">|</span> <span class="dt">Test</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">DbConnection</span> (<span class="ot">a ::</span> <span class="dt">Env</span>) <span class="ot">=</span> <span class="dt">DbConnection</span> <span class="dt">Connection</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a><span class="ot">runQuery ::</span> <span class="dt">DbConnection</span> a <span class="ot">-&gt;</span> <span class="dt">Query</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">Int64</span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>runQuery (<span class="dt">DbConnection</span> c) q <span class="ot">=</span> execute_ c q</span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a><span class="co">-- | Warning: Did you remember to charge your chromebook? Oh and this function</span></span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a><span class="co">-- is safe by the way.</span></span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a><span class="ot">clearTestEnv ::</span> <span class="dt">DbConnection</span> <span class="dt">Test</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a>clearTestEnv conn <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a>  _ <span class="ot">&lt;-</span> runQuery conn <span class="st">&quot;DROP TABLE IF EXISTS users CASCADE&quot;</span></span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a>  <span class="fu">putStrLn</span> <span class="st">&quot;Test data wiped.&quot;</span></span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true" tabindex="-1"></a><span class="ot">connectProd ::</span> <span class="dt">IO</span> (<span class="dt">DbConnection</span> <span class="dt">Prod</span>)</span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true" tabindex="-1"></a>connectProd <span class="ot">=</span> <span class="dt">DbConnection</span> <span class="op">&lt;$&gt;</span> connectPostgreSQL <span class="st">&quot;host=prod...&quot;</span></span></code></pre></div>
<p>Now, if you create a connection using <code>connectProd</code>, you can use <code>runQuery</code> on it (because it can run any <code>DbConnection a</code>)…but if any sub-function of a sub-function calls <code>clearTestEnv</code>, it will have to unify with <code>DbConnection Test</code>, which is impossible for a prod connection.</p>
<p>This is somewhat similar to using “mocking-only” subclasses for dependency injection, but with a closed universe. I discuss patterns like this in my <a href="https://blog.jle.im/entries/series/+introduction-to-singletons.html">Introduction to Singletons</a> series.</p>
<h2 id="correct-representations">Correct Representations</h2>
<h3 id="semantic-phantoms">Semantic Phantoms</h3>
<p>And sometimes, phantom types can do the work for you, not only preventing mix-ups but also encoding business logic in their manipulation.</p>
<p>Take, for instance, the <a href="https://en.wikipedia.org/wiki/Mars_Climate_Orbiter">Mars Climate Orbiter failure</a>, where the software module provided by Lockheed Martin expected US Customary Units, and another one developed by NASA expected SI units.</p>
<p>If I had a function like:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- | In Newton-seconds</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="ot">myMomentum ::</span> <span class="dt">Double</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>myMomentum <span class="ot">=</span> <span class="dv">20</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a><span class="co">-- | In Pounds-second</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a><span class="ot">myImpulse ::</span> <span class="dt">Double</span></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>myImpulse <span class="ot">=</span> <span class="dv">4</span></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a><span class="co">-- | Make sure these are both the same units!</span></span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a><span class="ot">applyImpulse ::</span> <span class="dt">Double</span> <span class="ot">-&gt;</span> <span class="dt">Double</span> <span class="ot">-&gt;</span> <span class="dt">Double</span></span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a>applyImpulse currentMomentum impulse <span class="ot">=</span> currentMomentum <span class="op">+</span> impulse</span></code></pre></div>
<p>This is just <em>asking</em> for someone to come along and provide newtons alongside pounds. It isn’t even clear from the types what is expected!</p>
<p>We can instead use the <em><a href="https://hackage.haskell.org/package/dimensional">dimensional</a></em> library:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Numeric.Units.Dimensional.Prelude</span> <span class="kw">as</span> <span class="dt">U</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Numeric.Units.Dimensional</span> ((*~))</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Numeric.Units.Dimensional.SIUnits</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Numeric.Units.Dimensional.NonSI</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a><span class="ot">myMomentum ::</span> <span class="dt">Momentum</span></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>myMomentum <span class="ot">=</span> <span class="dv">20</span> <span class="op">*~</span> (newton <span class="op">U.*</span> seconds)</span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a><span class="ot">myImpulse ::</span> <span class="dt">Impulse</span></span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>myImpulse <span class="ot">=</span> <span class="dv">4</span> <span class="op">*~</span> (poundForce <span class="op">U.*</span> seconds)</span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a><span class="co">-- Verify at compile-time that we can use &#39;+&#39; with Momentum and Impulse</span></span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a><span class="ot">applyImpulse ::</span> <span class="dt">Momentum</span> <span class="ot">-&gt;</span> <span class="dt">Impulse</span> <span class="ot">-&gt;</span> <span class="dt">Momentum</span></span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a>applyImpulse currentMomentum impulse <span class="ot">=</span> currentMomentum <span class="op">+</span> impulse</span></code></pre></div>
<p>Now as long as momentum and impulse are provided in the correct types at API boundaries, no mix-up will happen. No need to send 300 million dollars down the drain! Libraries will just need to provide a unified <code>Momentum</code> or <code>Impulse</code> type, and everything will work out.</p>
<h3 id="the-billion-dollar-mistake">The Billion-Dollar Mistake</h3>
<p>Speaking of costly errors, there is one extremely egregious pattern that is so pervasive, so alluring, and yet so inevitably devastating, it has been dubbed the “Billion Dollar Mistake”. It’s the idea of a <em>sentinel value</em>, or in-band signaling.</p>
<p>There are examples:</p>
<ul>
<li><code>String.indexOf()</code>, <code>str.find()</code>, etc. in many languages return -1 if the substring is not found</li>
<li>C’s <code>fgetc()</code>, <code>getchar()</code>, return -1 for <code>EOF</code>. And if you cast to <code>char</code>, you basically can’t distinguish EOF from <code>0xff</code> (<code>ÿ</code>).</li>
<li><code>malloc()</code> returning the pointer 0 means not enough memory</li>
<li>Some languages have a special <code>NULL</code> pointer value as well — or even a value <code>null</code> that can be passed in for any expected type or object or value.</li>
<li>JavaScript’s <code>parseInt</code> returns not <code>null</code>, but rather <code>NaN</code> for a bad parse — giving two distinct sentinel values</li>
<li>A lot of Unix scripting uses the empty string <code>""</code> for non-presence</li>
<li>Sensor firmware often reports values like <code>-999</code> for a bad reading…but sometimes <code>-999</code> might actually be a valid value!</li>
</ul>
<p>It should be evident that these are just accidents and ticking time bombs waiting to happen. Some caller just needs to forget to handle the sentinel value, or to falsely assume that the sentinel value is impossible to occur in any situation.</p>
<p>It’s called the billion dollar mistake, but it’s definitely arguable that the cumulative damage has been much higher. High-profile incidents include <a href="https://www.rapid7.com/db/modules/exploit/linux/local/sock_sendpage/">sock_sendpage</a> and the <a href="https://www.thousandeyes.com/blog/google-cloud-outage-analysis-june-12-2025">2025 GCP outage</a>, but if you’re reading this and you are honest with yourself, it’s probably happened to you multiple times and has been the source of many frustrating bug hunts.</p>
<p>There’s also <a href="https://www.invicti.com/web-application-vulnerabilities/openssl-improper-input-validation-vulnerability-cve-2008-5077">CVE-2008-5077</a>, because <a href="https://docs.openssl.org/1.1.1/man3/EVP_VerifyInit/">EVP_VerifyInit</a> returns <code>0</code> for false, <code>1</code> for true, and <code>-1</code> for error! So some OpenSSL code did a simple if-then-else check (<code>result != 0</code>) and treated error and true the same way. Whoops.</p>
<p>Why do we do this to ourselves? Because it is convenient. In the case of <code>EVP_VerifyInit</code>, we can define an enum instead…</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">VerifyResult</span> <span class="ot">=</span> <span class="dt">Success</span> <span class="op">|</span> <span class="dt">Failure</span> <span class="op">|</span> <span class="dt">Error</span></span></code></pre></div>
<p>However, it’s not easy to make an “integer or not found” type in C or JavaScript without some sort of side-channel. Imagine if JavaScript’s <code>String.indexOf()</code> instead expected continuations on success and failure and became much less usable as a result:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="ot">unsafeIndexOf ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a><span class="co">-- vs.</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a><span class="co">-- takes a success continuation and a failure continuation</span></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a><span class="ot">indexOf ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> (<span class="dt">Int</span> <span class="ot">-&gt;</span> r) <span class="ot">-&gt;</span> (() <span class="ot">-&gt;</span> r) <span class="ot">-&gt;</span> r</span></code></pre></div>
<p>All of this just to <a href="https://blog.jle.im/entry/faking-adts-and-gadts.html">fake having actual sum types</a>.</p>
<p>We don’t really have an excuse in Haskell, since we can just return <code>Maybe</code>:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- from Data.Vector</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a><span class="ot">elemIndex ::</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Vector</span> a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Int</span></span></code></pre></div>
<p>Returning <code>Maybe</code> or <code>Option</code> forces the caller to handle:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="kw">case</span> elemIndex <span class="dv">3</span> myVec <span class="kw">of</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Just</span> i <span class="ot">-&gt;</span> <span class="co">-- ..</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="co">-- ..</span></span></code></pre></div>
<p>and this handling is compiler-enforced. Provided, of course, you don’t <a href="https://blog.cloudflare.com/18-november-2025-outage/">intentionally throw away your type-safety and compiler checks for no reason</a>. You can even return <code>Either</code> with an enum for richer responses, and very easily <a href="https://blog.jle.im/entry/inside-my-world-ode-to-functor-and-monad.html">chain erroring operations using Functor and Monad</a>. In fact, with cheap ADTs, you can define your own rich result type, like in <em><a href="https://hackage-content.haskell.org/package/unix">unix</a></em>’s <code>ProcessStatus</code>:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">ProcessStatus</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>   <span class="ot">=</span> <span class="dt">Exited</span> <span class="dt">ExitCode</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>   <span class="op">|</span> <span class="dt">Terminated</span> <span class="dt">Signal</span> <span class="dt">Bool</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>   <span class="op">|</span> <span class="dt">Stopped</span> <span class="dt">Signal</span></span></code></pre></div>
<p>Imagine trying to cram all of that information into an <code>int</code>!</p>
<h2 id="unmarked-assumptions">Unmarked Assumptions</h2>
<p>Assumptions kill, and a lot of times we arrive at implicit assumptions in our code. Unfortunately, even if we add these assumptions in our documentation, it only takes a minor refactor or lapse in memory for these to cause catastrophic incidents.</p>
<p>There are the simple cases — consider a <code>mean</code> function:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- | Warning: do not give an empty list!</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a><span class="ot">mean ::</span> [<span class="dt">Double</span>] <span class="ot">-&gt;</span> <span class="dt">Double</span></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>mean xs <span class="ot">=</span> <span class="fu">sum</span> xs <span class="op">/</span> <span class="fu">fromIntegral</span> (<span class="fu">length</span> xs)</span></code></pre></div>
<p>But are you <em>really</em> going to remember to check if your list is empty <em>every</em> time you give it to <code>mean</code>? No, of course not. Instead, make it a compiler-enforced constraint.</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="ot">mean ::</span> <span class="dt">NonEmpty</span> <span class="dt">Double</span> <span class="ot">-&gt;</span> <span class="dt">Double</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>mean xs <span class="ot">=</span> <span class="fu">sum</span> xs <span class="op">/</span> <span class="fu">fromIntegral</span> (<span class="fu">length</span> xs)</span></code></pre></div>
<p>Now <code>mean</code> takes a <code>NonEmpty</code> list, which can only be created safely using <code>nonEmpty :: [a] -&gt; Maybe (NonEmpty a)</code> (where the caller has to explicitly handle the empty list case, so they’ll never forget) or from functions that already return <code>NonEmpty</code> by default (like <code>some :: f a -&gt; f (NonEmpty a)</code> or <code>group :: Eq a =&gt; [a] -&gt; [NonEmpty a]</code>), allowing you to beautifully chain post-conditions directly into pre-conditions.</p>
<p>Accessing containers is, in general, very fraught…even things like indexing lists can send us into a graveyard spiral. Sometimes the issue is more subtle. This is our reminder to never let these implicit assumptions go unnoticed.</p>
<h3 id="separate-processed-data">Separate Processed Data</h3>
<p>“Shotgun parsing” involves mixing validated and unvalidated data at different levels in your program. Oftentimes it is considered “fine” because you just need to remember which inputs are validated and which aren’t…right? In truth, all it takes is a simple temporary lapse of mental model, a time delay between working on code, or uncoordinated contributions before things fall apart.</p>
<p>Consider a situation where we validate usernames only on write to the database.</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="ot">validUsername ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>validUsername s <span class="ot">=</span> <span class="fu">all</span> <span class="fu">isAlphaNum</span> s <span class="op">&amp;&amp;</span> <span class="fu">all</span> <span class="fu">isLower</span> s</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a><span class="co">-- | Returns &#39;Nothing&#39; if username is invalid or insertion failed</span></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a><span class="ot">saveUser ::</span> <span class="dt">Connection</span> <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">Maybe</span> <span class="dt">UUID</span>)</span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a>saveUser conn s</span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> validUsername s <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a>      newId <span class="ot">&lt;-</span> query conn <span class="st">&quot;INSERT INTO users (username) VALUES (?) returning user_id&quot;</span> (<span class="dt">Only</span> s)</span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true" tabindex="-1"></a>      <span class="fu">pure</span> <span class="op">$</span> <span class="kw">case</span> newId <span class="kw">of</span></span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true" tabindex="-1"></a>        [] <span class="ot">-&gt;</span> <span class="dt">Nothing</span></span>
<span id="cb18-11"><a href="#cb18-11" aria-hidden="true" tabindex="-1"></a>        <span class="dt">Only</span> i <span class="op">:</span> _ <span class="ot">-&gt;</span> <span class="dt">Just</span> i</span>
<span id="cb18-12"><a href="#cb18-12" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> <span class="fu">pure</span> <span class="dt">Nothing</span></span>
<span id="cb18-13"><a href="#cb18-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-14"><a href="#cb18-14" aria-hidden="true" tabindex="-1"></a><span class="ot">getUser ::</span> <span class="dt">Connection</span> <span class="ot">-&gt;</span> <span class="dt">UUID</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">Maybe</span> <span class="dt">String</span>)</span>
<span id="cb18-15"><a href="#cb18-15" aria-hidden="true" tabindex="-1"></a>getUser conn uid <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb18-16"><a href="#cb18-16" aria-hidden="true" tabindex="-1"></a>  unames <span class="ot">&lt;-</span> query conn <span class="st">&quot;SELECT username FROM users where user_id = ?&quot;</span> (<span class="dt">Only</span> uid)</span>
<span id="cb18-17"><a href="#cb18-17" aria-hidden="true" tabindex="-1"></a>  <span class="fu">pure</span> <span class="op">$</span> <span class="kw">case</span> unames <span class="kw">of</span></span>
<span id="cb18-18"><a href="#cb18-18" aria-hidden="true" tabindex="-1"></a>    [] <span class="ot">-&gt;</span> <span class="dt">Nothing</span></span>
<span id="cb18-19"><a href="#cb18-19" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Only</span> s <span class="op">:</span> _ <span class="ot">-&gt;</span> <span class="dt">Just</span> s</span></code></pre></div>
<p>It <em>should</em> be fine as long as you only ever use <code>saveUser</code> and <code>getUser</code>…and nobody else has access to the database. But, if someone hooks up a custom connector, or does some manual modifications, then the <code>users</code> table will now have an invalid username, bypassing Haskell. And because of that, <code>getUser</code> can return an invalid string!</p>
<p>Don’t assume that these inconsequential slip-ups won’t happen; assume that it’s only a matter of time.</p>
<p>Instead, we can bake the state of a validated string into the type itself:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">Username</span> <span class="ot">=</span> <span class="dt">UnsafeUsername</span> <span class="dt">String</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Eq</span>)</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a><span class="co">-- | Our &quot;Smart Constructor&quot;</span></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a><span class="ot">mkUsername ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Username</span></span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a>mkUsername s</span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> validUsername s <span class="ot">=</span> <span class="dt">Just</span> (<span class="dt">UnsafeUsername</span> s)</span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="fu">otherwise</span>       <span class="ot">=</span> <span class="dt">Nothing</span></span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-10"><a href="#cb19-10" aria-hidden="true" tabindex="-1"></a><span class="co">-- | Access the raw string if needed</span></span>
<span id="cb19-11"><a href="#cb19-11" aria-hidden="true" tabindex="-1"></a><span class="ot">unUsername ::</span> <span class="dt">Username</span> <span class="ot">-&gt;</span> <span class="dt">String</span></span>
<span id="cb19-12"><a href="#cb19-12" aria-hidden="true" tabindex="-1"></a>unUsername (<span class="dt">UnsafeUsername</span> s) <span class="ot">=</span> s</span></code></pre></div>
<p><code>Username</code> and <code>String</code> themselves are not structurally different — instead, <code>Username</code> is a compiler-enforced tag specifying it went through a specific required validation function <em>within Haskell</em>, not just externally verified.</p>
<p>Now <code>saveUser</code> and <code>getUser</code> are safe at the boundaries:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="ot">saveUser ::</span> <span class="dt">Connection</span> <span class="ot">-&gt;</span> <span class="dt">Username</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">Maybe</span> <span class="dt">UUID</span>)</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>saveUser conn s <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>  newId <span class="ot">&lt;-</span> query conn <span class="st">&quot;INSERT INTO users (username) VALUES (?) returning user_id&quot;</span> (<span class="dt">Only</span> (unUsername s))</span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">pure</span> <span class="op">$</span> <span class="kw">case</span> newId <span class="kw">of</span></span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a>    [] <span class="ot">-&gt;</span> <span class="dt">Nothing</span></span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Only</span> i <span class="op">:</span> _ <span class="ot">-&gt;</span> <span class="dt">Just</span> i</span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true" tabindex="-1"></a><span class="ot">getUser ::</span> <span class="dt">Connection</span> <span class="ot">-&gt;</span> <span class="dt">UUID</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">Maybe</span> <span class="dt">Username</span>)</span>
<span id="cb20-9"><a href="#cb20-9" aria-hidden="true" tabindex="-1"></a>getUser conn uid <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb20-10"><a href="#cb20-10" aria-hidden="true" tabindex="-1"></a>  unames <span class="ot">&lt;-</span> query conn <span class="st">&quot;SELECT username FROM users where user_id = ?&quot;</span> (<span class="dt">Only</span> uid)</span>
<span id="cb20-11"><a href="#cb20-11" aria-hidden="true" tabindex="-1"></a>  <span class="fu">pure</span> <span class="op">$</span> <span class="kw">case</span> unames <span class="kw">of</span></span>
<span id="cb20-12"><a href="#cb20-12" aria-hidden="true" tabindex="-1"></a>    [] <span class="ot">-&gt;</span> <span class="dt">Nothing</span></span>
<span id="cb20-13"><a href="#cb20-13" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Only</span> s <span class="op">:</span> _ <span class="ot">-&gt;</span> mkUsername s</span></code></pre></div>
<p>(In real code, of course, we would use a more usable indication of failure than <code>Maybe</code>)</p>
<p>We can even hook this into Haskell’s typeclass system to make this even more rigorous: <code>Username</code> could have its own <code>FromField</code> and <code>ToField</code> instances that push the validation to the driver level.</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">FromField</span> <span class="dt">Username</span> <span class="kw">where</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>  fromField f mdata <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a><span class="ot">    s ::</span> <span class="dt">String</span> <span class="ot">&lt;-</span> fromField f mdata</span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">case</span> mkUsername s <span class="kw">of</span></span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a>      <span class="dt">Just</span> u  <span class="ot">-&gt;</span> <span class="fu">pure</span> u</span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a>      <span class="dt">Nothing</span> <span class="ot">-&gt;</span> returnError <span class="dt">ConversionFailed</span> f (<span class="st">&quot;Invalid username format: &quot;</span> <span class="op">++</span> s)</span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-8"><a href="#cb21-8" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">ToField</span> <span class="dt">Username</span> <span class="kw">where</span></span>
<span id="cb21-9"><a href="#cb21-9" aria-hidden="true" tabindex="-1"></a>  toField <span class="ot">=</span> toField <span class="op">.</span> unUsername</span>
<span id="cb21-10"><a href="#cb21-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-11"><a href="#cb21-11" aria-hidden="true" tabindex="-1"></a><span class="ot">saveUser ::</span> <span class="dt">Connection</span> <span class="ot">-&gt;</span> <span class="dt">Username</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">Maybe</span> <span class="dt">UUID</span>)</span>
<span id="cb21-12"><a href="#cb21-12" aria-hidden="true" tabindex="-1"></a>saveUser conn s <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb21-13"><a href="#cb21-13" aria-hidden="true" tabindex="-1"></a>  newId <span class="ot">&lt;-</span> query conn <span class="st">&quot;INSERT INTO users (username) VALUES (?) returning user_id&quot;</span> (<span class="dt">Only</span> s)</span>
<span id="cb21-14"><a href="#cb21-14" aria-hidden="true" tabindex="-1"></a>  <span class="fu">pure</span> <span class="op">$</span> <span class="kw">case</span> newId <span class="kw">of</span></span>
<span id="cb21-15"><a href="#cb21-15" aria-hidden="true" tabindex="-1"></a>    [] <span class="ot">-&gt;</span> <span class="dt">Nothing</span></span>
<span id="cb21-16"><a href="#cb21-16" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Only</span> i <span class="op">:</span> _ <span class="ot">-&gt;</span> <span class="dt">Just</span> i</span>
<span id="cb21-17"><a href="#cb21-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-18"><a href="#cb21-18" aria-hidden="true" tabindex="-1"></a><span class="ot">getUser ::</span> <span class="dt">Connection</span> <span class="ot">-&gt;</span> <span class="dt">UUID</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">Maybe</span> <span class="dt">Username</span>)</span>
<span id="cb21-19"><a href="#cb21-19" aria-hidden="true" tabindex="-1"></a>getUser conn uid <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb21-20"><a href="#cb21-20" aria-hidden="true" tabindex="-1"></a>  unames <span class="ot">&lt;-</span> query conn <span class="st">&quot;SELECT username FROM users where user_id = ?&quot;</span> (<span class="dt">Only</span> uid)</span>
<span id="cb21-21"><a href="#cb21-21" aria-hidden="true" tabindex="-1"></a>  <span class="fu">pure</span> <span class="op">$</span> <span class="kw">case</span> unames <span class="kw">of</span></span>
<span id="cb21-22"><a href="#cb21-22" aria-hidden="true" tabindex="-1"></a>    [] <span class="ot">-&gt;</span> <span class="dt">Nothing</span></span>
<span id="cb21-23"><a href="#cb21-23" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Only</span> s <span class="op">:</span> _ <span class="ot">-&gt;</span> <span class="dt">Just</span> s</span></code></pre></div>
<p>Pushing it to the driver level will also unify everything with the driver’s error-handling system.</p>
<p>These ideas are elaborated further in one of the best Haskell posts of all time, <a href="https://lexi-lambda.github.io/blog/2019/11/05/parse-don-t-validate/">Parse, Don’t Validate</a>.</p>
<h3 id="boolean-blindness">Boolean Blindness</h3>
<p>At the heart of it, the previous examples’ cardinal sin was “boolean blindness”. If we have a predicate like <code>validUsername :: String -&gt; Bool</code>, we will branch on that <code>Bool</code> once and throw it away. Instead, by having a function like <code>mkUsername :: String -&gt; Maybe Username</code>, we <em>keep</em> the proof alongside the value for the entire lifetime of the value. We basically pair the string with its proof forever, making them inseparable.</p>
<p>There was another example of such a thing earlier: instead of using <code>null :: [a] -&gt; Bool</code> and gating a call to <code>mean</code> with <code>null</code>, we instead use <code>nonEmpty :: [a] -&gt; Maybe (NonEmpty a)</code>, and pass along the proof of non-emptiness alongside the value itself. And, for the rest of that list’s life, it will always be paired with its non-emptiness proof.</p>
<p>Embracing total depravity means always keeping these proofs together, with the witnesses bundled with the value itself, because if you don’t, someone is going to assume it exists when it doesn’t, or drop it unnecessarily.</p>
<p>Boolean blindness also has another facet, which is where <code>Bool</code> itself is not a semantically meaningful type. This is “semantic boolean blindness”.</p>
<p>The classic example is <code>filter :: (a -&gt; Bool) -&gt; [a] -&gt; [a]</code>. It might sound silly until it happens to you, but it is pretty easy to mix up if <code>True</code> means “keep” or “discard”. After all, a “water filter” only lets water through, but a “profanity filter” only rejects profanity. Instead, how about <code>mapMaybe :: (a -&gt; Maybe b) -&gt; [a] -&gt; [b]</code>? In that case, it is clear that <code>Just</code> results are kept, and the <code>Nothing</code> results are discarded.</p>
<p>Sometimes, the boolean is ambiguous as to what it means. You can sort of interpret the <a href="https://en.wikipedia.org/wiki/Mars_Polar_Lander">1999 Mars Polar Lander</a> crash this way. Its functions took a boolean based on the state of the legs:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="ot">deployThrusters ::</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span></code></pre></div>
<p>and <code>True</code> and <code>False</code> were misinterpreted. Instead, they could have considered semantically meaningful types: (simplified)</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">LegState</span> <span class="ot">=</span> <span class="dt">Extended</span> <span class="op">|</span> <span class="dt">Retracted</span></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a><span class="ot">deployThrusters ::</span> <span class="dt">LegState</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span></code></pre></div>
<p>Note that <code>Maybe</code> itself is not immune from “semantic blindness” — if you find yourself using a lot of anonymous combinators like <code>Maybe</code> and <code>Either</code> to get around boolean blindness, be aware of falling into <a href="https://github.com/quchen/articles/blob/master/algebraic-blindness.md">algebraic blindness</a>!</p>
<h3 id="resource-cleanup">Resource Cleanup</h3>
<p>Clean-up of finite system resources is another area that is very easy to assume you have a handle on before it gets out of hand and sneaks up on you.</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="ot">process ::</span> <span class="dt">Handle</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a><span class="ot">doTheThing ::</span> <span class="dt">FilePath</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a>doTheThing path <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a>  h <span class="ot">&lt;-</span> openFile path <span class="dt">ReadMode</span></span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true" tabindex="-1"></a>  process h</span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true" tabindex="-1"></a>  hClose h</span></code></pre></div>
<p>A bunch of things could go wrong —</p>
<ul>
<li>You might forget to always <code>hClose</code> a file handle, and if your files come at you dynamically, you’re going to run out of file descriptors, or hold on to locks longer than you should</li>
<li>If <code>process</code> throws an exception, we never get to <code>hClose</code>, and the same issues happen</li>
<li>If another thread throws an asynchronous exception (like a thread cancellation), you have to make sure the close still happens!</li>
</ul>
<p>The typical solution that other languages (like Python, modern Java) take is to put everything inside a “block” where quitting the block guarantees the closure. In Haskell we have the <code>bracket</code> pattern:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- strongly discourage using `openFile` and `hClose` directly</span></span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a><span class="ot">withFile ::</span> <span class="dt">FilePath</span> <span class="ot">-&gt;</span> (<span class="dt">Handle</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> r) <span class="ot">-&gt;</span> <span class="dt">IO</span> r</span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a>withFile path <span class="ot">=</span> bracket (openFile path <span class="dt">ReadMode</span>) hClose</span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a><span class="ot">doTheThing ::</span> <span class="dt">FilePath</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span>
<span id="cb25-6"><a href="#cb25-6" aria-hidden="true" tabindex="-1"></a>doTheThing path <span class="ot">=</span> withFile path <span class="op">$</span> \h <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb25-7"><a href="#cb25-7" aria-hidden="true" tabindex="-1"></a>  process h</span></code></pre></div>
<p>If you never use <code>openFile</code> directly, and always use <code>withFile</code>, all file usage is safe!</p>
<p>But, admittedly, continuations can be annoying to work with. For example, what if you wanted to safely open a list of files?</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="ot">processAll ::</span> [<span class="dt">Handle</span>] <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a><span class="ot">doTheThings ::</span> [<span class="dt">FilePath</span>] <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a>doTheThings paths <span class="ot">=</span> <span class="co">-- uh...</span></span></code></pre></div>
<p>All of a sudden, not so fun. And what if you had, for example, a Map of files, like <code>Map Username FilePath</code>?</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="ot">processAll ::</span> <span class="dt">Map</span> <span class="dt">Username</span> <span class="dt">Handle</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a><span class="ot">doTheThings ::</span> <span class="dt">Map</span> <span class="dt">Username</span> <span class="dt">FilePath</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a>doTheThings paths <span class="ot">=</span> <span class="co">-- uh...</span></span></code></pre></div>
<p>In another language, at this point, we might just give up and resort to manual opening and closing of files.</p>
<p>But this is Haskell. We have a better solution: cleanup-tracking monads!</p>
<p>This is a classic usage of <code>ContT</code> to let you chain bracket-like continuations:</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="ot">processTwo ::</span> <span class="dt">Handle</span> <span class="ot">-&gt;</span> <span class="dt">Handle</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a><span class="ot">doTwoThings ::</span> <span class="dt">FilePath</span> <span class="ot">-&gt;</span> <span class="dt">FilePath</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a>doTwoThings path1 path2 <span class="ot">=</span> evalContT <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true" tabindex="-1"></a>    h1 <span class="ot">&lt;-</span> <span class="dt">ContT</span> <span class="op">$</span> withFile path1</span>
<span id="cb28-6"><a href="#cb28-6" aria-hidden="true" tabindex="-1"></a>    h2 <span class="ot">&lt;-</span> <span class="dt">ContT</span> <span class="op">$</span> withFile path2</span>
<span id="cb28-7"><a href="#cb28-7" aria-hidden="true" tabindex="-1"></a>    liftIO <span class="op">$</span> processTwo h1 h2</span>
<span id="cb28-8"><a href="#cb28-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-9"><a href="#cb28-9" aria-hidden="true" tabindex="-1"></a><span class="ot">processAll ::</span> <span class="dt">Map</span> <span class="dt">Username</span> <span class="dt">Handle</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span>
<span id="cb28-10"><a href="#cb28-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-11"><a href="#cb28-11" aria-hidden="true" tabindex="-1"></a><span class="ot">doTheThings ::</span> <span class="dt">Map</span> <span class="dt">Username</span> <span class="dt">FilePath</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span>
<span id="cb28-12"><a href="#cb28-12" aria-hidden="true" tabindex="-1"></a>doTheThings paths <span class="ot">=</span> evalContT <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb28-13"><a href="#cb28-13" aria-hidden="true" tabindex="-1"></a>    handles <span class="ot">&lt;-</span> <span class="fu">traverse</span> (<span class="dt">ContT</span> <span class="op">.</span> withFile) paths</span>
<span id="cb28-14"><a href="#cb28-14" aria-hidden="true" tabindex="-1"></a>    liftIO <span class="op">$</span> processAll handles</span></code></pre></div>
<p>However, using <code>ContT</code> doesn’t allow you to do things like early cleanups or canceling cleanup events. It forces us into a last-in, first-out sort of cleanup pattern. If you want to deviate, this might cause you to, for convenience, go for manual resource management. However, we have tools for more fine-grained control, we have things like <em><a href="https://hackage.haskell.org/package/resourcet">resourcet</a></em> <code>ResourceT</code>, which lets you manually control the order of clean-up events, with the guarantee that all of them <em>eventually</em> happen.</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Map</span> <span class="kw">as</span> <span class="dt">M</span></span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a><span class="co">-- | Returns set of usernames to close</span></span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a><span class="ot">processAll ::</span> <span class="dt">Map</span> <span class="dt">Username</span> <span class="dt">Handle</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">Set</span> <span class="dt">Username</span>)</span>
<span id="cb29-5"><a href="#cb29-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-6"><a href="#cb29-6" aria-hidden="true" tabindex="-1"></a><span class="ot">allocateFile ::</span> <span class="dt">FilePath</span> <span class="ot">-&gt;</span> <span class="dt">ResourceT</span> <span class="dt">IO</span> (<span class="dt">ReleaseKey</span>, <span class="dt">Handle</span>)</span>
<span id="cb29-7"><a href="#cb29-7" aria-hidden="true" tabindex="-1"></a>allocateFile fp <span class="ot">=</span> allocate (openFile fp <span class="dt">ReadMode</span>) hClose</span>
<span id="cb29-8"><a href="#cb29-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-9"><a href="#cb29-9" aria-hidden="true" tabindex="-1"></a><span class="co">-- Guarantees that all handles will eventually close, even if `go` crashes</span></span>
<span id="cb29-10"><a href="#cb29-10" aria-hidden="true" tabindex="-1"></a><span class="ot">doTheThings ::</span> <span class="dt">Map</span> <span class="dt">Username</span> <span class="dt">FilePath</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span>
<span id="cb29-11"><a href="#cb29-11" aria-hidden="true" tabindex="-1"></a>doTheThings paths <span class="ot">=</span> runResourceT <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb29-12"><a href="#cb29-12" aria-hidden="true" tabindex="-1"></a>    releasersAndHandlers <span class="ot">&lt;-</span> <span class="fu">traverse</span> allocateFile paths</span>
<span id="cb29-13"><a href="#cb29-13" aria-hidden="true" tabindex="-1"></a>    go releasersAndHandlers</span>
<span id="cb29-14"><a href="#cb29-14" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb29-15"><a href="#cb29-15" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- normal operation: slowly releases handlers as we drop them</span></span>
<span id="cb29-16"><a href="#cb29-16" aria-hidden="true" tabindex="-1"></a><span class="ot">    go ::</span> <span class="dt">Map</span> <span class="dt">Username</span> (<span class="dt">ReleaseKey</span>, <span class="dt">Handle</span>) <span class="ot">-&gt;</span> <span class="dt">ResourceT</span> <span class="dt">IO</span> ()</span>
<span id="cb29-17"><a href="#cb29-17" aria-hidden="true" tabindex="-1"></a>    go currOpen <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb29-18"><a href="#cb29-18" aria-hidden="true" tabindex="-1"></a>      toClose <span class="ot">&lt;-</span> liftIO <span class="op">$</span> processAll (<span class="fu">snd</span> <span class="op">&lt;$&gt;</span> currOpen)</span>
<span id="cb29-19"><a href="#cb29-19" aria-hidden="true" tabindex="-1"></a>      traverse_ (release <span class="op">.</span> <span class="fu">fst</span>) (currOpen <span class="ot">`M.restrictKeys`</span> toClose)</span>
<span id="cb29-20"><a href="#cb29-20" aria-hidden="true" tabindex="-1"></a>      <span class="kw">let</span> newOpen <span class="ot">=</span> currOpen <span class="ot">`M.withoutKeys`</span> toClose</span>
<span id="cb29-21"><a href="#cb29-21" aria-hidden="true" tabindex="-1"></a>      unless (M.null newOpen) <span class="op">$</span></span>
<span id="cb29-22"><a href="#cb29-22" aria-hidden="true" tabindex="-1"></a>        go newOpen</span></code></pre></div>
<p>Here we get the best of both worlds: the ability to manually close handlers when they are no longer needed, but also the guarantee that they will eventually be closed.</p>
<h2 id="embracing-total-depravity">Embracing Total Depravity</h2>
<p>Hopefully these examples, and similar situations, should feel relatable. We’ve all experienced the biting pain of too much self-trust. Or, too much trust in our ability to communicate with team members. Or, too much trust in ourselves 6 months from now. The traumas described here <em>should</em> resonate with you if you have programmed in any capacity for more than a couple of scripts.</p>
<p>The doctrine of total depravity does not mean that we don’t recognize the ability to write sloppy code that works, or that flow states can enable some great feats. After all, we all program with a certain sense of <em>imago machinae</em>. Instead, it means that all such states are <em>fundamentally unstable</em> in their nature and will always fail at some point. The “total” doesn’t mean we are totally cooked, it means this eventual reckoning applies to <em>all</em> such shortcuts.</p>
<p>The problem won’t be solved by “get good”. The problem is solved by utilizing the tooling we are given, especially since Haskell makes them so accessible and easy to pull in.</p>
<p>There’s another layer here that comes as a result of embracing this mindset: you’ll find that you have more mental space to dedicate to things that actually matter! Instead of worrying about inconsequential minutiae and details of your flawed abstractions, you can actually think about your business logic, the flow of your program, and architecting that castle of beauty I know you are capable of.</p>
<h3 id="in-the-age-of-agentic-coding">In the Age of Agentic Coding</h3>
<p>Before we end, let’s address the elephant in the room. We’re writing this in 2026, in the middle of one of the biggest revolutions in software engineering in the history of the field. A lot of people have claimed that types and safety are now no longer important in the age of LLMs and agentic coding.</p>
<p>However, these claims seem to miss the fact that the fundamental issue being addressed here exists both in LLMs and humans: the limited “context window” and attention. Humans might be barely able to keep a dozen things in our heads, LLMs might be able to keep a dozen dozen things, but it will still be ultimately finite. So, the more we can move concerns out of our context window (be it biological or mechanical), the less crowded our context windows will be, and the more productive we will be.</p>
<p>Agentic coding is progressing quickly, and over the past few months I have been exploring this a lot, using models hands-on. One conclusion I have found (and, this agrees with everyone else I’ve asked who has been trying the same thing) is that Haskell’s types, in many ways, are the killer productivity secret of agentic coding.</p>
<p>Many of my Haskell coding tasks for an LLM agent often involve:</p>
<ol type="1">
<li>How will the types change, or what should the types be?</li>
<li>Ralph Wiggum loop to death until the program typechecks, using <code>ghci</code> and <code>cabal</code>.</li>
</ol>
<p>And, this isn’t 100% effective, but from personal experience it is much more effective than the similar situation without typed guardrails for fast feedback, and without instant compiler feedback. The feedback loop is tighter, the objectives clearer, the constraints more resilient, the tooling more utilized.</p>
<p>I have noticed, also, that my LLM agents often check the types of the APIs using <code>ghci :type</code>, and rarely the documentation of the functions using <code>ghci :docs</code>. So, any “documentation-based contracts” are definitely much more likely to explode in your face in this new world than type-based contracts.</p>
<p>I’m not sure how quickly LLM-based agentic coding will progress, but I am sure that the accidental “dropping” of concerns will continue to be a bottleneck. All of the traits described in this post for humans will continue to be traits of limited context windows for LLMs.</p>
<p>If anything, limited “brain space” might be <em>the</em> bottleneck, for both humans and LLMs. If provide LLMs with properly “depravity-aware” typed code (and encourage them to write it by giving them the right iterative tooling), I truly believe that we have the key to unlocking the full potential of agentic coding.</p>
<p>And…not whatever <a href="https://x.com/rywalker/status/2003525268821188746">this tweet is</a>.</p>
<h3 id="the-next-step">The Next Step</h3>
<p>Total depravity is all about using types to <em>prevent errors</em>. However, you can only go so far with defensive programming and carefully picking the structure of your types. Sometimes, it feels like you are expending a lot of energy and human effort just picking the perfectly designed data type, only for things out of your hand to ruin your typed castle.</p>
<p>In the next chapter, we’ll see how a little-discussed aspect of Haskell’s type system gives you a powerful tool for opening your mind to new avenues of design that were impossible before. At the same time, we’ll see how we can leverage universal properties of mathematics itself to help us analyze our code in unexpected ways.</p>
<p>Let’s explore this further in the next principle of <a href="https://blog.jle.im/entries/series/+five-point-haskell.html">Five-Point Haskell</a>, <strong>Unconditional Election</strong>!</p>
<h2 id="special-thanks">Special Thanks</h2>
<p>I am very humbled to be supported by an amazing community, who make it possible for me to devote time to researching and writing these posts. Very special thanks to my supporter at the “Amazing” level on <a href="https://www.patreon.com/justinle/overview">patreon</a>, Josh Vera! :)</p>
<p>Also thanks to <a href="https://www.reddit.com/r/haskell/comments/1qtxnsm/comment/o3889uy"><em>jackdk</em>’s comment</a> for highlighting extra resources and context that I believe are very useful and relevant!</p></div><footer><hr><div class="copy-content"><p>Hi, thanks for reading! You can reach me via email at <a href="mailto:justin@jle.im" class="email">justin@jle.im</a>, or at twitter at <a href="https://twitter.com/mstk">@mstk</a>! This post and all others are published under the <a href="https://creativecommons.org/licenses/by-nc-nd/3.0/">CC-BY-NC-ND 3.0</a> license. Corrections and edits via pull request are welcome and encouraged at <a href="https://github.com/mstksg/inCode">the source repository</a>.</p>
<p>If you feel inclined, or this post was particularly helpful for you, why not consider <a href="https://www.patreon.com/justinle/overview">supporting me on Patreon</a>, or a <a href="bitcoin:3D7rmAYgbDnp4gp4rf22THsGt74fNucPDU">BTC donation</a>? :)</p></div><div class="clear"></div><ul class="entry-series"><li><div>This entry is a part of a series called <b>&quot;Five-Point Haskell&quot;</b>.  Find the rest of the entries in this series at its <a href="https://blog.jle.im/entries/series/+five-point-haskell.html" class="tag-a-series" title="+Five-Point Haskell"> series history</a>.</div></li></ul><ul class="tag-list"><li><a href="https://blog.jle.im/entries/tagged/functional-programming.html" class="tag-a-tag">#functional programming</a></li><li><a href="https://blog.jle.im/entries/tagged/type-safety.html" class="tag-a-tag">#type safety</a></li><li><a href="https://blog.jle.im/entries/category/@haskell.html" class="tag-a-category">@HASKELL</a></li><li><a href="https://blog.jle.im/entries/series/+five-point-haskell.html" class="tag-a-series">+Five-Point Haskell</a></li></ul><aside class="social-buttons"><div class="addthis_toolbox addthis_default_style addthis-buttons"><a class="addthis_button_facebook_like" fb:like:layout="button_count"></a><a class="addthis_button_tweet"></a><a class="addthis_button_google_plusone" g:plusone:size="medium"></a><a class="addthis_counter addthis_pill_style"></a></div><div class="custom-social-buttons"><div class="custom-social-button"><a href="https://www.reddit.com/submit" onclick="window.location = &#39;https://www.reddit.com/submit?url=&#39;+ encodeURIComponent(window.location); return false"><img src="https://www.reddit.com/static/spreddit7.gif" alt="submit to reddit"></a></div></div></aside><nav class="next-prev-links"><ul><li class="prev-entry-link">&larr; <a href="https://blog.jle.im/entry/advent-of-code-2025.html">Advent of Code 2025: Haskell Solution Reflections for all 12 Days</a> (Previous)</li></ul></nav></footer></article><div class="post-entry"><div class="tile"><div id="disqus_thread"></div><script type="text/javascript">var disqus_config = function () {
    this.page.url = 'https://blog.jle.im/entry/five-point-haskell-part-1-total-depravity.html';
    this.page.identifier = 'five-point-haskell-1';
};
(function() {
    var d = document, s = d.createElement('script');
    s.src = '//incode.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
})();
</script><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a><br></noscript><a href="http://disqus.com" class="dsq-brlink">Comments powered by <span class="logo-disqus">Disqus</span></a></div></div></div></div></div><div id="footer-container"><div id="footer-content"><div class="tile"><div class="footer-copyright">&copy; 2020 Justin Le <span class="license-link">(<a href="https://creativecommons.org/licenses/by-nc-nd/3.0/" class="license">CC-BY-NC-ND 3.0</a>)</span></div><div class="footer-follow social-follows"><ul class="social-follows-list"><li><ul class="social-follows-list-social"><li><a class="social-follow-twitter" title="Follow me on Twitter!" href="https://twitter.com/intent/user?user_id=mstk" onclick="window.open(
  &#39;http://twitter.com/intent/user?user_id=907281&#39;,
  &#39;facebook-share-dialog&#39;,
  &#39;width=550,height=520&#39;);
return false;
">Twitter</a></li><li><a class="social-follow-github" title="Fork me on Github!" href="https://github.com/mstksg">Github</a></li><li><a class="social-follow-twitch" title="Watch me on Twitch!" href="https://www.twitch.tv/justin_l">Twitch</a></li><li><a class="social-follow-patreon" title="Support me on Patreon!" href="https://www.patreon.com/justinle/overview">Patreon</a></li><li><a class="social-follow-gplus" title="Add me on Google+!" href="https://plus.google.com/+JustinLe">Google+</a></li><li><a class="social-follow-keybase" title="Track me on Keybase!" href="https://keybase.io/mstksg">Keybase</a></li><li><a class="social-follow-linkedin" title="Connect with me on LinkedIn!" href="https://linkedin.com/in/lejustin">LinkedIn</a></li><li><a class="social-follow-bitcoin" title="Donate via bitcoin!" href="bitcoin:3D7rmAYgbDnp4gp4rf22THsGt74fNucPDU">Bitcoin</a></li></ul></li><li><ul class="social-follows-list-site"><li><a class="social-follow-rss" title="Subscribe to my RSS Feed!" href="http://feeds.feedburner.com/incodeblog">RSS</a></li><li><a class="social-follow-email" title="Subscribe to the mailing list!" href="https://feedburner.google.com/fb/a/mailverify?loc=en_US&amp;uri=incodeblog">Mailing list</a></li></ul></li></ul></div></div></div></div></body></html>