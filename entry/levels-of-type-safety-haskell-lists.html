<!DOCTYPE HTML>
<html><head><title>Seven Levels of Type Safety in Haskell: Lists · in Code</title><meta name="description" content="Weblog of Justin Le, covering various adventures in programming and explorations in the worlds of computation physics, and knowledge.
"><meta http-equiv="Content-Type" content="text/html;charset=utf-8"><meta name="viewport" content="width=device-width,initial-scale=1.0"><meta name="flattr:id" content="3p9jqr"><meta property="og:site_name" content="in Code"><meta property="og:description" content="One thing I always appreciate about Haskell is that you can often choose the level of type-safety you want to work at. Haskell offers tools to be able to work at both extremes, whereas most languages only offer some limited part of the spectrum. Picking the right level often comes down to being consciously aware of the benefits/drawbacks/unique advantages to each. So, here is a rundown of seven “levels” of type safety that you can operate at when working with the ubiquitous linked list data type, and how to use them! I genuinely believe all of these are useful (or useless) in their own different circumstances, even though the “extremes” at both ends are definitely pushing the limits of the language. This post is written for an intermediate Haskeller, who is already familiar with ADTs and defining their own custom list type like data List a = Nil | Cons a (List a). But, be advised that most of the techniques discussed in this post (especially at both extremes) are considered esoteric at best and harmful at worst for most actual real-world applications. The point of this post is more to inspire the imagination and demonstrate principles that could be useful to apply in actual code, and not to present actual useful data structures. All of the code here is available online here, and if you check out the repo and run nix develop you should be able to load them all in ghci as well: $ cd code-samples/type-levels $ nix develop $ ghci ghci&gt; :load Level1.hs"><meta property="og:type" content="article"><meta property="og:title" content="Seven Levels of Type Safety in Haskell: Lists"><meta property="og:image" content="https://blog.jle.im/img/site_logo.jpg"><meta property="og:locale" content="en_US"><meta property="og:url" content="https://blog.jle.im/entry/levels-of-type-safety-haskell-lists.html"><meta name="twitter:card" content="summary"><meta name="twitter:creator:id" content="mstk"><link rel="author" href="https://plus.google.com/107705320197444500140"><link rel="alternate" type="application/rss+xml" title="in Code (RSS Feed)" href="http://feeds.feedburner.com/incodeblog"><link rel="canonical" href="https://blog.jle.im/entry/levels-of-type-safety-haskell-lists.html"><link href="https://blog.jle.im/favicon.ico" rel="shortcut icon"><link href="https://blog.jle.im/css/toast.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/font.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/main.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/page/entry.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/pygments.css" rel="stylesheet" type="text/css"><script type="text/javascript">var page_data = {};
var disqus_shortname='incode';
</script><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-443711-8', 'jle.im');
ga('send', 'pageview');
</script><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script id="MathJax-script" async="" src="https://cdn.jsdelivr.net/npm/mathjax@3.0.1/es5/tex-mml-chtml.js"></script><script type="text/javascript" src="//ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script><script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5234d67a6b68dcd4"></script><script type="text/javascript" src="https://blog.jle.im/js/page/entry_toc.js"></script><script type="text/javascript" src="https://blog.jle.im/js/disqus_count.js"></script><script type="text/javascript" src="https://blog.jle.im/js/social.js"></script><script type="text/javascript" src="https://blog.jle.im/js/jquery/jquery.toc.js"></script><script type="text/javascript" src="https://blog.jle.im/purescript/entry.js"></script></head><body><div id="fb-root"><script>(function(d, s, id) {
 var js, fjs = d.getElementsByTagName(s)[0];
 if (d.getElementById(id)) return;
 js = d.createElement(s); js.id = id;
 js.src = "//connect.facebook.net/en_US/all.js#xfbml=1&appId=641852699171929";
 fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));
</script></div><div id="header-container"><div id="navbar-container" class="tile"><nav id="navbar-content"><div class="nav-info"><h1 class="site-title"><a href="https://blog.jle.im/" class="nav-title">in Code</a></h1><span class="nav-author">Justin Le</span></div><ul class="nav-links"><li><a href="https://blog.jle.im/">home</a></li><li><a href="https://blog.jle.im/entries.html">archives</a></li><li><a href="https://cv.jle.im">cv</a></li><div class="clear"></div></ul></nav></div><div id="header-content"></div></div><div id="body-container" class="container"><div id="main-container" class="grid"><div class="entry-section unit span-grid" role="main"><article class="tile article"><header><h1 id="title">Seven Levels of Type Safety in Haskell: Lists</h1><p class="entry-info">by <a class="author" href="https://blog.jle.im/">Justin Le</a><span class="info-separator"> &diams; </span><time datetime="2024-09-04T10:35:47Z" pubdate="" class="pubdate">Wednesday September 4, 2024</time></p><p><span class="source-info"><a class="source-link" href="https://github.com/mstksg/inCode/tree/master/copy/entries/type-levels.md">Source</a><span class="info-separator"> &diams; </span><a class="source-link" href="https://github.com/mstksg/inCode/tree/gh-pages/entry/levels-of-type-safety-haskell-lists.md">Markdown</a><span class="info-separator"> &diams; </span><a class="source-link" href="https://blog.jle.im/entry/levels-of-type-safety-haskell-lists.tex">LaTeX</a><span class="info-separator"> &diams; </span></span>Posted in <a href="https://blog.jle.im/entries/category/@haskell.html" class="tag-a-category" title="Functional, pure, non-strict, statically and strongly typed, natively
compiled...really just the king of great languages.
">Haskell</a><span class="info-separator"> &diams; </span><a class="comment-link" href="#disqus_thread">Comments</a></p></header><hr><aside class="contents-container"><h5 id="contents-header">Contents</h5><div id="toc"></div></aside><div class="main-content copy-content"><p>One thing I always appreciate about Haskell is that you can often choose the level of type-safety you want to work at. Haskell offers tools to be able to work at <em>both</em> extremes, whereas most languages only offer some limited part of the spectrum. Picking the right level often comes down to being consciously aware of the benefits/drawbacks/unique advantages to each.</p>
<p>So, here is a rundown of seven “levels” of type safety that you can operate at when working with the ubiquitous linked list data type, and how to use them! I genuinely believe all of these are useful (or useless) in their own different circumstances, even though the “extremes” at both ends are definitely pushing the limits of the language.</p>
<p>This post is written for an intermediate Haskeller, who is already familiar with ADTs and defining their own custom list type like <code>data List a = Nil | Cons a (List a)</code>. But, be advised that <em>most</em> of the techniques discussed in this post (especially at both extremes) are considered esoteric at best and harmful at worst for most actual real-world applications. The point of this post is more to inspire the imagination and demonstrate principles that could be useful to apply in actual code, and <em>not</em> to present actual useful data structures.</p>
<p>All of the code here is <a href="https://github.com/mstksg/inCode/tree/master/code-samples/type-levels/flake.nix">available online</a> here, and if you check out the repo and run <code>nix develop</code> you should be able to load them all in ghci as well:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> cd code-samples/type-levels</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> nix develop</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> ghci</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="ex">ghci</span><span class="op">&gt;</span> :load Level1.hs</span></code></pre></div>
<h2 id="level-1-could-be-anything">Level 1: Could be anything</h2>
<p><em><a href="https://github.com/mstksg/inCode/tree/master/code-samples/type-levels/Level1.hs">Code available here</a></em></p>
<p>What’s the moooost type-unsafe you can be in Haskell? Well, we can make a “black hole” data type that could be anything:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/type-levels/Level1.hs#L12-L13</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Any</span><span class="ot"> ::</span> <span class="dt">Type</span> <span class="kw">where</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">MkAny</span><span class="ot"> ::</span> a <span class="ot">-&gt;</span> <span class="dt">Any</span></span></code></pre></div>
<p>(This data type declaration written using <a href="https://typeclasses.com/ghc/gadt-syntax">GADT Syntax</a>, and the name was chosen because it resembles <a href="https://hackage.haskell.org/package/bas/docs/GHC-Exts.html#t:Any">the Any type in base</a>)</p>
<p>So you can have values:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/type-levels/Level1.hs#L15-L22</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="ot">anyInt ::</span> <span class="dt">Any</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>anyInt <span class="ot">=</span> <span class="dt">MkAny</span> (<span class="dv">8</span><span class="ot"> ::</span> <span class="dt">Int</span>)</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a><span class="ot">anyBool ::</span> <span class="dt">Any</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>anyBool <span class="ot">=</span> <span class="dt">MkAny</span> <span class="dt">True</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a><span class="ot">anyList ::</span> <span class="dt">Any</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>anyList <span class="ot">=</span> <span class="dt">MkAny</span> ([<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>]<span class="ot"> ::</span> [<span class="dt">Int</span>])</span></code></pre></div>
<p>A value of any type can be given to <code>MkAny</code>, and the resulting type will have type <code>Any</code>.</p>
<p>However, this type is <em>truly</em> a black hole; you can’t really do anything with the values inside it because of parametric polymorphism: you must treat any value inside it in a way that is compatible with a value of <em>any</em> type. But there aren’t <em>too</em> many useful things you can do with something in a way that is compatible with a value of any type (things like, <code>id :: a -&gt; a</code>, <code>const 3 :: a -&gt; Int</code>). In the end, it’s essentially isomorphic to unit <code>()</code>.</p>
<p>However, this isn’t really how dynamic types work. In other languages, we are at least able to query and interrogate a type for things we can do with it using runtime reflection. To get there, we can instead allow some sort of witness on the type of the value. Here’s <code>Sigma</code>, where <code>Sigma p</code> is a value <code>a</code> paired with some witness <code>p a</code>:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/type-levels/Level1.hs#L24-L25</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Sigma</span><span class="ot"> ::</span> (<span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span>) <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="kw">where</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">MkSigma</span><span class="ot"> ::</span> p a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Sigma</span> p</span></code></pre></div>
<p>And the most classic witness is <a href="https://hackage.haskell.org/package/base/docs/Type-Reflection.html#t:TypeRep"><code>TypeRep</code></a> from <em>base</em>, which is a witness that lets you “match” on the type.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/type-levels/Level1.hs#L27-L32</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span class="ot">showIfBool ::</span> <span class="dt">Sigma</span> <span class="dt">TypeRep</span> <span class="ot">-&gt;</span> <span class="dt">String</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>showIfBool (<span class="dt">MkSigma</span> tr x) <span class="ot">=</span> <span class="kw">case</span> testEquality tr (typeRep <span class="op">@</span><span class="dt">Bool</span>) <span class="kw">of</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Just</span> <span class="dt">Refl</span> <span class="ot">-&gt;</span> <span class="kw">case</span> x <span class="kw">of</span> <span class="co">-- in this branch, we know x is a Bool</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">False</span> <span class="ot">-&gt;</span> <span class="st">&quot;False&quot;</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">True</span> <span class="ot">-&gt;</span> <span class="st">&quot;True&quot;</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="st">&quot;Not a Bool&quot;</span></span></code></pre></div>
<p>This uses <em>type application syntax</em>, <code>@Bool</code>, that lets us pass in the <em>type</em> <code>Bool</code> to the function <code>typeRep :: Typeable a =&gt; TypeRep a</code>.</p>
<p>Now we can use <code>TypeRep</code>’s interface to “match” (using <code>testEquality</code>) on if the value inside is a <code>Bool</code>. If the match works (and we get <code>Just Refl</code>) then we can treat <code>x</code> as a <code>Bool</code> in that case. If it doesn’t (and we get <code>Nothing</code>), then we do what we would want to do otherwise.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> <span class="kw">let</span> x <span class="ot">=</span> <span class="dt">MkSigma</span> typeRep <span class="dt">True</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> <span class="kw">let</span> y <span class="ot">=</span> <span class="dt">MkSigma</span> typeRep (<span class="dv">4</span><span class="ot"> ::</span> <span class="dt">Int</span>)</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> showIfBool x</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a><span class="st">&quot;True&quot;</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> showIfBool y</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a><span class="st">&quot;Not a Bool&quot;</span></span></code></pre></div>
<p>This pattern is common enough that there’s the <em><a href="https://hackage.haskell.org/package/base/docs/Data-Dynamic.html">Data.Dynamic</a></em> module in base that is <code>Sigma TypeRep</code>, and <code>testEquality</code> is replaced with that module’s <code>fromDynamic</code>:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/type-levels/Level1.hs#L40-L45</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a><span class="ot">showIfBoolDynamic ::</span> <span class="dt">Dynamic</span> <span class="ot">-&gt;</span> <span class="dt">String</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>showIfBoolDynamic dyn <span class="ot">=</span> <span class="kw">case</span> fromDynamic dyn <span class="kw">of</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Just</span> x <span class="ot">-&gt;</span> <span class="kw">case</span> x <span class="kw">of</span> <span class="co">-- in this branch, we know x is a Bool</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">False</span> <span class="ot">-&gt;</span> <span class="st">&quot;False&quot;</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">True</span> <span class="ot">-&gt;</span> <span class="st">&quot;True&quot;</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="st">&quot;Not a Bool&quot;</span></span></code></pre></div>
<p>For make our life easier in the future, let’s write a version of <code>fromDynamic</code> for our <code>Sigma TypeRep</code>:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/type-levels/Level1.hs#L47-L53</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a><span class="ot">castSigma ::</span> <span class="dt">TypeRep</span> a <span class="ot">-&gt;</span> <span class="dt">Sigma</span> <span class="dt">TypeRep</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>castSigma tr (<span class="dt">MkSigma</span> tr&#39; x) <span class="ot">=</span> <span class="kw">case</span> testEquality tr tr&#39; <span class="kw">of</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Just</span> <span class="dt">Refl</span> <span class="ot">-&gt;</span> <span class="dt">Just</span> x</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="dt">Nothing</span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a><span class="ot">castSigma&#39; ::</span> <span class="dt">Typeable</span> a <span class="ot">=&gt;</span> <span class="dt">Sigma</span> <span class="dt">TypeRep</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a</span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>castSigma&#39; <span class="ot">=</span> castSigma typeRep</span></code></pre></div>
<p>But the reason why I’m presenting the more generic <code>Sigma</code> instead of the specific <code>type Dynamic = Sigma TypeRep</code> is that you can swap out <code>TypeRep</code> to get other interesting types. For example, if you had a witness of showability:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/type-levels/Level1.hs#L55-L62</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Showable</span><span class="ot"> ::</span> <span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="kw">where</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">WitShowable</span><span class="ot"> ::</span> <span class="dt">Show</span> a <span class="ot">=&gt;</span> <span class="dt">Showable</span> a</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a><span class="ot">showableInt ::</span> <span class="dt">Sigma</span> <span class="dt">Showable</span></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>showableInt <span class="ot">=</span> <span class="dt">MkSigma</span> <span class="dt">WitShowable</span> (<span class="dv">3</span><span class="ot"> ::</span> <span class="dt">Int</span>)</span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a><span class="ot">showableBool ::</span> <span class="dt">Sigma</span> <span class="dt">Showable</span></span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a>showableBool <span class="ot">=</span> <span class="dt">MkSigma</span> <span class="dt">WitShowable</span> <span class="dt">True</span></span></code></pre></div>
<p>(This type is related to <code>Dict Show</code> from the <a href="https://hackage.haskell.org/package/constraints-0.13/docs/Data-Constraint.html#t:Dict">constraints</a> library; it’s technically <code>Compose Dict Show</code>)</p>
<p>And now we have a type <code>Sigma Showable</code> that’s kind of of “not-so-black”: we can at least use <code>show</code> on it:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/type-levels/Level1.hs#L64-L65</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a><span class="ot">showSigma ::</span> <span class="dt">Sigma</span> <span class="dt">Showable</span> <span class="ot">-&gt;</span> <span class="dt">String</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>showSigma (<span class="dt">MkSigma</span> <span class="dt">WitShowable</span> x) <span class="ot">=</span> <span class="fu">show</span> x <span class="co">-- here, we know x is Show</span></span></code></pre></div>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> <span class="kw">let</span> x <span class="ot">=</span> <span class="dt">MkSigma</span> <span class="dt">WitShowable</span> <span class="dt">True</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> <span class="kw">let</span> y <span class="ot">=</span> <span class="dt">MkSigma</span> <span class="dt">WitShowable</span> <span class="dv">4</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> showSigma x</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a><span class="st">&quot;True&quot;</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> showSigma y</span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a><span class="st">&quot;4&quot;</span></span></code></pre></div>
<p>This is the “<a href="https://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/">existential typeclass antipattern</a>”<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>, but since we are talking about different ways we can push the type system, it’s probably worth mentioning. In particular, <code>Show</code> is a silly typeclass to use in this context because a <code>Sigma Showable</code> is equivalent to just a <code>String</code>: once you match on the constructor to get the value, the only thing you can do with the value is <code>show</code> it anyway.</p>
<p>One fun thing we can do is provide a “useless witness”, like <code>Proxy</code>:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/type-levels/Level1.hs#L67-L70</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Proxy</span> a <span class="ot">=</span> <span class="dt">Proxy</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a><span class="ot">uselessBool ::</span> <span class="dt">Sigma</span> <span class="dt">Proxy</span></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>uselessBool <span class="ot">=</span> <span class="dt">MkSigma</span> <span class="dt">Proxy</span> <span class="dt">True</span></span></code></pre></div>
<p>So a value like <code>MkSigma Proxy True :: Sigma Proxy</code> is truly a useless data type (basically our <code>Any</code> from before), since we know that <code>MkSigma</code> constrains <em>some</em> value of <em>some</em> type, but there’s no witness to give us any clue on how we can use it. A <code>Sigma Proxy</code> is isomorphic to <code>()</code>.</p>
<p>On the other extreme, we can use a witness to constrain the value to only be a specific type, like <code>IsBool</code>:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/type-levels/Level1.hs#L72-L76</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">IsBool</span><span class="ot"> ::</span> <span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="kw">where</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">ItsABool</span><span class="ot"> ::</span> <span class="dt">IsBool</span> <span class="dt">Bool</span></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a><span class="ot">justABool ::</span> <span class="dt">Sigma</span> <span class="dt">IsBool</span></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a>justABool <span class="ot">=</span> <span class="dt">MkSigma</span> <span class="dt">ItsABool</span> <span class="dt">False</span></span></code></pre></div>
<p>So you can have a value of type <code>MkSigma ItsABool True :: Sigma IsBool</code>, or <code>MkSigma ItsABool False</code>, but <code>MkSigma ItsABool 2</code> will not typecheck — remember, to make a <code>Sigma</code>, you need a <code>p a</code> and an <code>a</code>. <code>ItsABool :: IsBool Bool</code>, so the <code>a</code> you put in must be <code>Bool</code> to match. <code>Sigma IsBool</code> is essentially isomorphic to <code>Bool</code>.</p>
<p>There’s a general version of this too, <code>(:~:) a</code> (from <em><a href="https://hackage.haskell.org/package/base/docs/Data-Type-Equality.html#t::-126-:">Data.Type.Equality</a></em> in base). <code>(:~:) Bool</code> is our <code>IsBool</code> earlier. <code>Sigma ((:~:) a)</code> is essentially exactly <code>a</code>…basically bringing us incidentally back to complete type safety? Weird. Anyway.</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/type-levels/Level1.hs#L78-L79</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a><span class="ot">justAnInt ::</span> <span class="dt">Sigma</span> ((<span class="op">:~:</span>) <span class="dt">Int</span>)</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>justAnInt <span class="ot">=</span> <span class="dt">MkSigma</span> <span class="dt">Refl</span> <span class="dv">10</span> <span class="co">-- Refl :: Int :~: Int</span></span></code></pre></div>
<p>I think one interesting thing to see here is that being “type-unsafe” in Haskell can be much less convenient than doing something similar in a dynamically typed language like python. The python ecosystem is designed around runtime reflection and inspection for properties and interfaces, whereas the dominant implementation of interfaces in Haskell (typeclasses) doesn’t gel with this. There’s no runtime typeclass instantiation: we can’t pattern match on a <code>TypeRep</code> and check if it’s an instance of <code>Ord</code> or not.</p>
<p>That’s why I don’t fancy those memes/jokes about how dynamically typed languages are just “static types with a single type”. The actual way you use those types (and the ecosystem built around them) lend themselves to different ergonomics, and the reductionist take doesn’t quite capture that nuance.</p>
<h2 id="level-2-heterogeneous-list">Level 2: Heterogeneous List</h2>
<p><em><a href="https://github.com/mstksg/inCode/tree/master/code-samples/type-levels/Level2.hs">Code available here</a></em></p>
<p>The lowest level of safety in which a list might be useful is the dynamically heterogeneous list. This is the level where lists (or “arrays”) live in most dynamic languages.</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/type-levels/Level2.hs#L12-L12</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">HList</span> p <span class="ot">=</span> [<span class="dt">Sigma</span> p]</span></code></pre></div>
<p>We tag values with a witness <code>p</code> for the same reason as before: if we don’t provide <em>some</em> type of witness, our type is useless.</p>
<p>The “dynamically heterogeneous list of values of any type” is <code>HList TypeRep</code>. This is somewhat similar to how functions with positional arguments work in a dynamic language like javascript. For example, here’s a function that connects to a host (<code>String</code>), optionally taking a port (<code>Int</code>) and a method (<code>Method</code>).</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/type-levels/Level2.hs#L14-L33</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Method</span> <span class="ot">=</span> <span class="dt">HTTP</span> <span class="op">|</span> <span class="dt">HTTPS</span></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a><span class="ot">indexHList ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">HList</span> p <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">Sigma</span> p)</span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a>indexHList <span class="dv">0</span> [] <span class="ot">=</span> <span class="dt">Nothing</span></span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a>indexHList <span class="dv">0</span> (x <span class="op">:</span> _) <span class="ot">=</span> <span class="dt">Just</span> x</span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a>indexHList n (_ <span class="op">:</span> xs) <span class="ot">=</span> indexHList (n <span class="op">-</span> <span class="dv">1</span>) xs</span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-10"><a href="#cb16-10" aria-hidden="true" tabindex="-1"></a><span class="ot">mkConnection ::</span> <span class="dt">HList</span> <span class="dt">TypeRep</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span>
<span id="cb16-11"><a href="#cb16-11" aria-hidden="true" tabindex="-1"></a>mkConnection args <span class="ot">=</span> doTheThing host port method</span>
<span id="cb16-12"><a href="#cb16-12" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb16-13"><a href="#cb16-13" aria-hidden="true" tabindex="-1"></a><span class="ot">    host ::</span> <span class="dt">Maybe</span> <span class="dt">String</span></span>
<span id="cb16-14"><a href="#cb16-14" aria-hidden="true" tabindex="-1"></a>    host <span class="ot">=</span> castSigma&#39; <span class="op">=&lt;&lt;</span> indexHList <span class="dv">0</span> args</span>
<span id="cb16-15"><a href="#cb16-15" aria-hidden="true" tabindex="-1"></a><span class="ot">    port ::</span> <span class="dt">Maybe</span> <span class="dt">Int</span></span>
<span id="cb16-16"><a href="#cb16-16" aria-hidden="true" tabindex="-1"></a>    port <span class="ot">=</span> castSigma&#39; <span class="op">=&lt;&lt;</span> indexHList <span class="dv">1</span> args</span>
<span id="cb16-17"><a href="#cb16-17" aria-hidden="true" tabindex="-1"></a><span class="ot">    method ::</span> <span class="dt">Maybe</span> <span class="dt">Method</span></span>
<span id="cb16-18"><a href="#cb16-18" aria-hidden="true" tabindex="-1"></a>    method <span class="ot">=</span> castSigma&#39; <span class="op">=&lt;&lt;</span> indexHList <span class="dv">2</span> args</span></code></pre></div>
<p>Of course, this would <em>probably</em> be better expressed in Haskell as a function of type <code>Maybe String -&gt; Maybe Int -&gt; Maybe Method -&gt; IO ()</code>. But maybe this could be useful in a situation where you would want to offer the ability to take arguments in any order? We could “find” the first value of a given type:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/type-levels/Level2.hs#L35-L36</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a><span class="ot">findValueOfType ::</span> <span class="dt">Typeable</span> a <span class="ot">=&gt;</span> <span class="dt">HList</span> <span class="dt">TypeRep</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a</span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>findValueOfType <span class="ot">=</span> listToMaybe <span class="op">.</span> mapMaybe castSigma&#39;</span></code></pre></div>
<p>Then we could write:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/type-levels/Level2.hs#L39-L47</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a><span class="ot">mkConnectionAnyOrder ::</span> <span class="dt">HList</span> <span class="dt">TypeRep</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>mkConnectionAnyOrder args <span class="ot">=</span> doTheThing host port method</span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a><span class="ot">    host ::</span> <span class="dt">Maybe</span> <span class="dt">String</span></span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a>    host <span class="ot">=</span> findValueOfType args</span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a><span class="ot">    port ::</span> <span class="dt">Maybe</span> <span class="dt">Int</span></span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true" tabindex="-1"></a>    port <span class="ot">=</span> findValueOfType args</span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true" tabindex="-1"></a><span class="ot">    method ::</span> <span class="dt">Maybe</span> <span class="dt">Method</span></span>
<span id="cb18-11"><a href="#cb18-11" aria-hidden="true" tabindex="-1"></a>    method <span class="ot">=</span> findValueOfType args</span></code></pre></div>
<p>But is this a good idea? Probably not.</p>
<p>Anyway, one very common usage of this type is for “extensible” systems that let you store components of different types in a container, as long as they all support some common interface (ie, the widgets system from the <a href="https://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/">Luke Palmer</a> post).</p>
<p>For example, we could have a list of any item as long as the item is an instance of <code>Show</code>: that’s <code>HList Showable</code>!</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/type-levels/Level2.hs#L52-L55</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a><span class="ot">showAll ::</span> <span class="dt">HList</span> <span class="dt">Showable</span> <span class="ot">-&gt;</span> [<span class="dt">String</span>]</span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>showAll <span class="ot">=</span> <span class="fu">map</span> showSigma</span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a>    showSigma (<span class="dt">MkSigma</span> <span class="dt">WitShowable</span> x) <span class="ot">=</span> <span class="fu">show</span> x</span></code></pre></div>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> <span class="kw">let</span> xs <span class="ot">=</span> [<span class="dt">MkSigma</span> <span class="dt">WitShowable</span> <span class="dv">1</span>, <span class="dt">MkSigma</span> <span class="dt">WitShowable</span> <span class="dt">True</span>]</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> showAll xs</span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>[<span class="st">&quot;1&quot;</span>, <span class="st">&quot;True&quot;</span>]</span></code></pre></div>
<p>Again, <code>Show</code> is a bad typeclass to use for this because we might as well be storing <code>[String]</code>. But for fun, let’s imagine some other things we could fill in for <code>p</code>. If we use <code>HList Proxy</code>, then we basically don’t have any witness at all. We can’t use the values in the list in any meaningful way; <code>HList Proxy</code> is essentially the same as <code>Natural</code>, since the only information is the length.</p>
<p>If we use <code>HList IsBool</code>, we basically have <code>[Bool]</code>, since every item must be a <code>Bool</code>! In general, <code>HList ((:~:) a)</code> is the same as <code>[a]</code>.</p>
<h2 id="level-3-homogeneous-dynamic-list">Level 3: Homogeneous Dynamic List</h2>
<p><em><a href="https://github.com/mstksg/inCode/tree/master/code-samples/type-levels/Level3.hs">Code available here</a></em></p>
<p>A next level of type safety we can add is to ensure that all elements in the list are of the same type. This adds a layer of usefulness because there are a lot of things we might want to do with the elements of a list that are only possible if they are all of the same type.</p>
<p>First of all, let’s clarify a subtle point here. It’s very easy in Haskell to <em>consume</em> lists where all elements are of the same (but not necessarily known) type. Functions like <code>sum :: Num a =&gt; [a] -&gt; a</code> and <code>sort :: Ord a =&gt; [a] -&gt; [a]</code> do that. This is “polymorphism”, where the function is written to not worry about the type, and the ultimate <em>caller</em> of the function must pick the type they want to use with it. For the sake of this discussion, we aren’t talking about <em>consuming</em> values — we’re talking about <em>producing</em> and <em>storing</em> values where the <em>producer</em> (and not the consumer) controls the type variable.</p>
<p>To do this, we can flip the witness to <em>outside</em> the list:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/type-levels/Level3.hs#L17-L18</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">SomeList</span><span class="ot"> ::</span> (<span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span>) <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="kw">where</span></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">MkSomeList</span><span class="ot"> ::</span> p a <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">SomeList</span> p</span></code></pre></div>
<p>We can write some meaningful predicates on this list — for example, we can check if it is monotonic (the items increase in order)</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/type-levels/Level3.hs#L21-L32</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Comparable</span><span class="ot"> ::</span> <span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="kw">where</span></span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">WitOrd</span><span class="ot"> ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">Comparable</span> a</span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a><span class="ot">monotonic ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true" tabindex="-1"></a>monotonic [] <span class="ot">=</span> <span class="dt">True</span></span>
<span id="cb22-8"><a href="#cb22-8" aria-hidden="true" tabindex="-1"></a>monotonic (x <span class="op">:</span> xs) <span class="ot">=</span> go x xs</span>
<span id="cb22-9"><a href="#cb22-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb22-10"><a href="#cb22-10" aria-hidden="true" tabindex="-1"></a>    go y [] <span class="ot">=</span> <span class="dt">True</span></span>
<span id="cb22-11"><a href="#cb22-11" aria-hidden="true" tabindex="-1"></a>    go y (z <span class="op">:</span> zs) <span class="ot">=</span> (y <span class="op">&lt;=</span> z) <span class="op">&amp;&amp;</span> go z zs</span>
<span id="cb22-12"><a href="#cb22-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-13"><a href="#cb22-13" aria-hidden="true" tabindex="-1"></a><span class="ot">monotonicSomeList ::</span> <span class="dt">SomeList</span> <span class="dt">Comparable</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb22-14"><a href="#cb22-14" aria-hidden="true" tabindex="-1"></a>monotonicSomeList (<span class="dt">MkSomeList</span> <span class="dt">WitOrd</span> xs) <span class="ot">=</span> monotonic xs</span></code></pre></div>
<p>This is fun, but, as mentioned before, <code>monotonicSomeList</code> doesn’t have any advantage over <code>monotonic</code>, because the caller determines the type. What would be more motivating here is a function that produces “any sortable type”, and the caller has to use it in a way generic over all sortable types. For example, a database API might let you query a database for a column of values, but you don’t know ahead of time what the exact <em>type</em> of that column is. You only know that it is “some sortable type”. In <em>that case</em>, a <code>SomeList</code> could be useful.</p>
<p>For a contrived one, let’s think about pulling such a list from IO:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/type-levels/Level3.hs#L34-L54</span></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a><span class="ot">getItems ::</span> <span class="dt">IO</span> (<span class="dt">SomeList</span> <span class="dt">Comparable</span>)</span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a>getItems <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a>  <span class="fu">putStrLn</span> <span class="st">&quot;would you like to provide int or bool or string?&quot;</span></span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true" tabindex="-1"></a>  ans <span class="ot">&lt;-</span> <span class="fu">getLine</span></span>
<span id="cb23-7"><a href="#cb23-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">case</span> <span class="fu">map</span> <span class="fu">toLower</span> ans <span class="kw">of</span></span>
<span id="cb23-8"><a href="#cb23-8" aria-hidden="true" tabindex="-1"></a>    <span class="st">&quot;int&quot;</span> <span class="ot">-&gt;</span> <span class="dt">MkSomeList</span> <span class="dt">WitOrd</span> <span class="op">&lt;$&gt;</span> replicateM <span class="dv">3</span> (<span class="fu">readLn</span> <span class="op">@</span><span class="dt">Int</span>)</span>
<span id="cb23-9"><a href="#cb23-9" aria-hidden="true" tabindex="-1"></a>    <span class="st">&quot;bool&quot;</span> <span class="ot">-&gt;</span> <span class="dt">MkSomeList</span> <span class="dt">WitOrd</span> <span class="op">&lt;$&gt;</span> replicateM <span class="dv">3</span> (<span class="fu">readLn</span> <span class="op">@</span><span class="dt">Bool</span>)</span>
<span id="cb23-10"><a href="#cb23-10" aria-hidden="true" tabindex="-1"></a>    <span class="st">&quot;string&quot;</span> <span class="ot">-&gt;</span> <span class="dt">MkSomeList</span> <span class="dt">WitOrd</span> <span class="op">&lt;$&gt;</span> replicateM <span class="dv">3</span> <span class="fu">getLine</span></span>
<span id="cb23-11"><a href="#cb23-11" aria-hidden="true" tabindex="-1"></a>    _ <span class="ot">-&gt;</span> throwIO <span class="op">$</span> <span class="fu">userError</span> <span class="st">&quot;no&quot;</span></span>
<span id="cb23-12"><a href="#cb23-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-13"><a href="#cb23-13" aria-hidden="true" tabindex="-1"></a><span class="ot">getAndAnalyze ::</span> <span class="dt">IO</span> ()</span>
<span id="cb23-14"><a href="#cb23-14" aria-hidden="true" tabindex="-1"></a>getAndAnalyze <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb23-15"><a href="#cb23-15" aria-hidden="true" tabindex="-1"></a>  <span class="dt">MkSomeList</span> <span class="dt">WitOrd</span> xs <span class="ot">&lt;-</span> getItems</span>
<span id="cb23-16"><a href="#cb23-16" aria-hidden="true" tabindex="-1"></a>  <span class="fu">putStrLn</span> <span class="op">$</span> <span class="st">&quot;Got &quot;</span> <span class="op">++</span> <span class="fu">show</span> (<span class="fu">length</span> xs) <span class="op">++</span> <span class="st">&quot; items.&quot;</span></span>
<span id="cb23-17"><a href="#cb23-17" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> isMono <span class="ot">=</span> monotonic xs</span>
<span id="cb23-18"><a href="#cb23-18" aria-hidden="true" tabindex="-1"></a>      isRevMono <span class="ot">=</span> monotonic (<span class="fu">reverse</span> xs)</span>
<span id="cb23-19"><a href="#cb23-19" aria-hidden="true" tabindex="-1"></a>  when isMono <span class="op">$</span></span>
<span id="cb23-20"><a href="#cb23-20" aria-hidden="true" tabindex="-1"></a>    <span class="fu">putStrLn</span> <span class="st">&quot;The items are monotonic.&quot;</span></span>
<span id="cb23-21"><a href="#cb23-21" aria-hidden="true" tabindex="-1"></a>  when (isMono <span class="op">&amp;&amp;</span> isRevMono) <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb23-22"><a href="#cb23-22" aria-hidden="true" tabindex="-1"></a>    <span class="fu">putStrLn</span> <span class="st">&quot;The items are monotonic both directions.&quot;</span></span>
<span id="cb23-23"><a href="#cb23-23" aria-hidden="true" tabindex="-1"></a>    <span class="fu">putStrLn</span> <span class="st">&quot;This means the items are all identical.&quot;</span></span></code></pre></div>
<p>Consider also an example where process items different based on what type they have:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/type-levels/Level3.hs#L62-L68</span></span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a><span class="ot">processList ::</span> <span class="dt">SomeList</span> <span class="dt">TypeRep</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a>processList (<span class="dt">MkSomeList</span> tr xs)</span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">Just</span> <span class="dt">Refl</span> <span class="ot">&lt;-</span> testEquality tr (typeRep <span class="op">@</span><span class="dt">Bool</span>) <span class="ot">=</span> <span class="fu">and</span> xs</span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">Just</span> <span class="dt">Refl</span> <span class="ot">&lt;-</span> testEquality tr (<span class="dt">TypeRep</span> <span class="op">@</span><span class="dt">Int</span>) <span class="ot">=</span> <span class="fu">sum</span> xs <span class="op">&gt;</span> <span class="dv">50</span></span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">Just</span> <span class="dt">Refl</span> <span class="ot">&lt;-</span> testEquality tr (<span class="dt">TypeRep</span> <span class="op">@</span><span class="dt">Double</span>) <span class="ot">=</span> <span class="fu">sum</span> xs <span class="op">&gt;</span> <span class="fl">5.0</span></span>
<span id="cb24-8"><a href="#cb24-8" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">Just</span> <span class="dt">Refl</span> <span class="ot">&lt;-</span> testEquality tr (<span class="dt">TypeRep</span> <span class="op">@</span><span class="dt">String</span>) <span class="ot">=</span> <span class="st">&quot;hello&quot;</span> <span class="ot">`elem`</span> xs</span>
<span id="cb24-9"><a href="#cb24-9" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> <span class="dt">False</span></span></code></pre></div>
<p>(That’s <a href="https://wiki.haskell.org/Pattern_guard">pattern guard</a> syntax, if you were wondering)</p>
<p>In this specific situation, using a closed ADT of all the types you’d actually want is probably preferred (like <code>data Value = VBool Bool | VInt Int | VDouble Double | VString String</code>), since we only ever get one of four different types. Using <code>Comparable</code> like this gives you a <em>completely open</em> type that can take <em>any</em> instance of <code>Ord</code>, and using <code>TypeRep</code> gives you a <em>completely open type</em> that can take literally <em>anything</em>.</p>
<p>This pattern is overall similar to how lists are often used in practice for dynamic languages: often when we use lists in dynamically typed situations, we expect them all to have items of the same type or interface. However, using lists this way (in a language without type safety) makes it really tempting to hop down into Level 2, where you start throwing “alternatively typed” things into your list, as well, for convenience. And then the temptation comes to also hop down to Level 1 and throw a <code>null</code> in every once in a while. All of a sudden, any consumers must now check the type of <em>every</em> item, and a lot of things are going to start needing unit tests.</p>
<p>Now, let’s talk a bit about ascending and descending between each levels. In the general case we don’t have much to work with, but let’s assume our constraint is <code>TypeRep</code> here, so we can match for type equality.</p>
<p>We can move from Level 3 to Level 2 by moving the <code>TypeRep</code> into the values of the list, and we can move from Level 3 to Level 1 by converting our <code>TypeRep a</code> into a <code>TypeRep [a]</code>:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/type-levels/Level3.hs#L75-L86</span></span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a><span class="ot">someListToHList ::</span> <span class="dt">SomeList</span> <span class="dt">TypeRep</span> <span class="ot">-&gt;</span> <span class="dt">HList</span> <span class="dt">TypeRep</span></span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a>someListToHList (<span class="dt">MkSomeList</span> tr xs) <span class="ot">=</span> <span class="dt">MkSigma</span> tr <span class="op">&lt;$&gt;</span> xs</span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-6"><a href="#cb25-6" aria-hidden="true" tabindex="-1"></a><span class="ot">someListToSigma ::</span> <span class="dt">SomeList</span> <span class="dt">TypeRep</span> <span class="ot">-&gt;</span> <span class="dt">Sigma</span> <span class="dt">TypeRep</span></span>
<span id="cb25-7"><a href="#cb25-7" aria-hidden="true" tabindex="-1"></a>someListToSigma (<span class="dt">MkSomeList</span> tr xs) <span class="ot">=</span> <span class="dt">MkSigma</span> (typeRep <span class="op">@</span>[] <span class="ot">`App`</span> tr) xs</span></code></pre></div>
<p><code>App</code> here as a constructor lets us come <code>TypeRep</code>s: <code>App :: TypeRep f -&gt; TypeRep a -&gt; TypeRep (f a)</code>.</p>
<p>Going the other way around is trickier. For <code>HList</code>, we don’t even know if every item has the same type, so we can only successfully move up if every item has the same type. So, first we get the <code>typeRep</code> for the first value, and then cast the other values to be the same type if possible:</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/type-levels/Level3.hs#L70-L73</span></span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a><span class="ot">hlistToSomeList ::</span> <span class="dt">HList</span> <span class="dt">TypeRep</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">SomeList</span> <span class="dt">TypeRep</span>)</span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a>hlistToSomeList <span class="ot">=</span> \<span class="kw">case</span></span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a>  [] <span class="ot">-&gt;</span> <span class="dt">Nothing</span></span>
<span id="cb26-6"><a href="#cb26-6" aria-hidden="true" tabindex="-1"></a>  <span class="dt">MkSigma</span> tr x <span class="op">:</span> xs <span class="ot">-&gt;</span> <span class="dt">MkSomeList</span> tr <span class="op">.</span> (x <span class="op">:</span>) <span class="op">&lt;$&gt;</span> <span class="fu">traverse</span> (castSigma tr) xs</span></code></pre></div>
<p>To go from <code>Sigma TypeRep</code>, we first need to match the <code>TypeRep</code> as some <code>f a</code> application using the <code>App</code> pattern…then we can check if <code>f</code> is <code>[]</code> (list), then we can create a <code>SomeList</code> with the <code>TypeRep a</code>. <em>But</em>, <code>testEquality</code> can only be called on things of the same kind, so we have to verify that <code>f</code> has kind <code>Type -&gt; Type</code> first, so that we can even call <code>testEquality</code> on <code>f</code> and <code>[]</code>! Phew! Dynamic types are hard!</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/type-levels/Level3.hs#L78-L83</span></span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a><span class="ot">sigmaToHList ::</span> <span class="dt">Sigma</span> <span class="dt">TypeRep</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">SomeList</span> <span class="dt">TypeRep</span>)</span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a>sigmaToHList (<span class="dt">MkSigma</span> tr xs) <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true" tabindex="-1"></a>  <span class="dt">App</span> tcon telem <span class="ot">&lt;-</span> <span class="dt">Just</span> tr</span>
<span id="cb27-6"><a href="#cb27-6" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Refl</span> <span class="ot">&lt;-</span> testEquality (typeRepKind telem) (typeRep <span class="op">@</span><span class="dt">Type</span>)</span>
<span id="cb27-7"><a href="#cb27-7" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Refl</span> <span class="ot">&lt;-</span> testEquality tcon (typeRep <span class="op">@</span>[])</span>
<span id="cb27-8"><a href="#cb27-8" aria-hidden="true" tabindex="-1"></a>  <span class="fu">pure</span> <span class="op">$</span> <span class="dt">MkSomeList</span> telem xs</span></code></pre></div>
<h2 id="level-4-homogeneous-typed-list">Level 4: Homogeneous Typed List</h2>
<p>Ahh, now right in the middle, we’ve reached Haskell’s ubiquitous list type! It is essentially:</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">List</span><span class="ot"> ::</span> <span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="kw">where</span></span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Nil</span><span class="ot">  ::</span> <span class="dt">List</span> a</span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Cons</span><span class="ot"> ::</span> a <span class="ot">-&gt;</span> <span class="dt">List</span> a <span class="ot">-&gt;</span> <span class="dt">List</span> a</span></code></pre></div>
<p>I don’t have too much to say here, other than to acknowledge that this is truly a “sweet spot” in terms of safety vs. unsafety and usability. This simple <code>List a</code> / <code>[a]</code> type has so many benefits from type-safety:</p>
<ul>
<li>It lets us write functions that can meaningfully say that the input and result types are the same, like <code>take :: Int -&gt; [a] -&gt; [a]</code></li>
<li>It lets us write functions that can meaningfully link lists and the items in the list, like <code>head :: [a] -&gt; a</code> and <code>replicate :: Int -&gt; a -&gt; [a]</code>.</li>
<li>It lets us write functions that can meaningfully state relationships between input and results, like <code>map :: (a -&gt; b) -&gt; [a] -&gt; [b]</code></li>
<li>We can require two input lists to have the same type of items, like <code>(++)     :: [a] -&gt; [a] -&gt; [a]</code></li>
<li>We can express complex relationships between inputs and outputs, like <code>zipWith :: (a -&gt; b -&gt; c) -&gt; [a] -&gt; [b] -&gt; [c]</code>.</li>
</ul>
<p>The property of being able to state and express relationships between the values of input lists and output lists and the items in those lists is extremely powerful, and also extremely ergonomic to use in Haskell. It can be argued that Haskell, as a language, was tuned explicitly to be used with the least friction at <em>this</em> exact level of type safety. Haskell is a “Level 4 language”.</p>
<h2 id="level-5-fixed-size-list">Level 5: Fixed-size List</h2>
<p><em><a href="https://github.com/mstksg/inCode/tree/master/code-samples/type-levels/Level5.hs">Code available here</a></em></p>
<p>From here on, we aren’t going to be “building up” linearly on safety, but rather showing three structural type safety mechanism of increasing strength and complexity.</p>
<p>For Level 5, we’re not going to try to enforce anything on the contents of the list, but we can try to enforce something on the <em>spline</em> of the list: the number of items!</p>
<p>To me, this level still feels very natural in Haskell to write in, although in terms of usability we are starting to bump into some of the things Haskell is lacking for higher type safety ergonomics. I’ve talked about <a href="https://blog.jle.im/entry/fixed-length-vector-types-in-haskell.html">fixed-length vector types in depth before</a>, so this is going to be a high-level view contrasting this level with the others.<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a></p>
<p>The essential concept is to introduce a <em>phantom type</em>, a type parameter that doesn’t do anything other than indicate something that we can use in user-space. Here we will create a type that structurally encodes the natural numbers 0, 1, 2…:</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/type-levels/Level5.hs#L15-L15</span></span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Nat</span> <span class="ot">=</span> <span class="dt">Z</span> <span class="op">|</span> <span class="dt">S</span> <span class="dt">Nat</span></span></code></pre></div>
<p>So, <code>Z</code> will represent zero, <code>S Z</code> will represent one, <code>S (S Z)</code> will represent two, etc. We want to create a type <code>Vec n a</code>, where <code>n</code> will be a type of kind <code>Nat</code> (promoted using DataKinds, which lets us use <code>Z</code> and <code>S</code> as type constructors), representing a linked list with <code>n</code> elements of type <code>a</code>.</p>
<p>We can define <code>Vec</code> in a way that structurally matches how <code>Nat</code> is constructed, which is the key to making things work nicely:</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/type-levels/Level5.hs#L17-L21</span></span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Vec</span><span class="ot"> ::</span> <span class="dt">Nat</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="kw">where</span></span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">VNil</span><span class="ot"> ::</span> <span class="dt">Vec</span> <span class="dt">Z</span> a</span>
<span id="cb30-5"><a href="#cb30-5" aria-hidden="true" tabindex="-1"></a><span class="ot">  (:+) ::</span> a <span class="ot">-&gt;</span> <span class="dt">Vec</span> n a <span class="ot">-&gt;</span> <span class="dt">Vec</span> (<span class="dt">S</span> n) a</span>
<span id="cb30-6"><a href="#cb30-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-7"><a href="#cb30-7" aria-hidden="true" tabindex="-1"></a><span class="kw">infixr</span> <span class="dv">5</span> <span class="op">:+</span></span></code></pre></div>
<p>This is offered in the <em><a href="https://hackage.haskell.org/package/vec">vec</a></em> library. Here are some example values:</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/type-levels/Level5.hs#L23-L33</span></span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a><span class="ot">zeroItems ::</span> <span class="dt">Vec</span> <span class="dt">Z</span> <span class="dt">Int</span></span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true" tabindex="-1"></a>zeroItems <span class="ot">=</span> <span class="dt">VNil</span></span>
<span id="cb31-5"><a href="#cb31-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-6"><a href="#cb31-6" aria-hidden="true" tabindex="-1"></a><span class="ot">oneItem ::</span> <span class="dt">Vec</span> (<span class="dt">S</span> <span class="dt">Z</span>) <span class="dt">Int</span></span>
<span id="cb31-7"><a href="#cb31-7" aria-hidden="true" tabindex="-1"></a>oneItem <span class="ot">=</span> <span class="dv">1</span> <span class="op">:+</span> <span class="dt">VNil</span></span>
<span id="cb31-8"><a href="#cb31-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-9"><a href="#cb31-9" aria-hidden="true" tabindex="-1"></a><span class="ot">twoItems ::</span> <span class="dt">Vec</span> (<span class="dt">S</span> (<span class="dt">S</span> <span class="dt">Z</span>)) <span class="dt">Int</span></span>
<span id="cb31-10"><a href="#cb31-10" aria-hidden="true" tabindex="-1"></a>twoItems <span class="ot">=</span> <span class="dv">1</span> <span class="op">:+</span> <span class="dv">2</span> <span class="op">:+</span> <span class="dt">VNil</span></span>
<span id="cb31-11"><a href="#cb31-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-12"><a href="#cb31-12" aria-hidden="true" tabindex="-1"></a><span class="ot">threeItems ::</span> <span class="dt">Vec</span> (<span class="dt">S</span> (<span class="dt">S</span> (<span class="dt">S</span> <span class="dt">Z</span>))) <span class="dt">Int</span></span>
<span id="cb31-13"><a href="#cb31-13" aria-hidden="true" tabindex="-1"></a>threeItems <span class="ot">=</span> <span class="dv">1</span> <span class="op">:+</span> <span class="dv">2</span> <span class="op">:+</span> <span class="dv">3</span> <span class="op">:+</span> <span class="dt">VNil</span></span></code></pre></div>
<p>Note two things:</p>
<ol type="1">
<li><code>1 :+ 2 :+ VNil</code> gets automatically type-inferred to be a <code>Vec (S (S Z))     a</code>, because every application of <code>:+</code> adds an <code>S</code> to the phantom type.</li>
<li>There is <em>only one way</em> to construct a <code>Vec (S (S Z)) a</code>: by using <code>:+</code> twice. That means that such a value is a list of exactly two items.</li>
</ol>
<p>However, the main benefit of this system is <em>not</em> so you can create a two-item list…just use tuples or <code>data V2 a = V2 a a</code> from <em><a href="https://hackage.haskell.org/package/linear">linear</a></em> for that. No, the main benefit is that you can now encode how arguments in your functions relate to each other with respect to length.</p>
<p>For example, the <em>type</em> alone of <code>map :: (a -&gt; b) -&gt; [a] -&gt; [b]</code> does <em>not</em> tell you that the length of the result list is the same as the length of the input list. However, consider <code>vmap :: (a -&gt; b) -&gt; Vec n a -&gt; Vec n b</code>. Here we see that the output list must have the same number of items as the input list, and it’s enforced right there in the type signature!</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/type-levels/Level5.hs#L35-L38</span></span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a><span class="ot">vmap ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Vec</span> n a <span class="ot">-&gt;</span> <span class="dt">Vec</span> n b</span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true" tabindex="-1"></a>vmap f <span class="ot">=</span> \<span class="kw">case</span></span>
<span id="cb32-5"><a href="#cb32-5" aria-hidden="true" tabindex="-1"></a>  <span class="dt">VNil</span> <span class="ot">-&gt;</span> <span class="dt">VNil</span></span>
<span id="cb32-6"><a href="#cb32-6" aria-hidden="true" tabindex="-1"></a>  x <span class="op">:+</span> xs <span class="ot">-&gt;</span> f x <span class="op">:+</span> vmap f xs</span></code></pre></div>
<p>And how about <code>zipWith :: (a -&gt; b -&gt; c) -&gt; [a] -&gt; [b] -&gt; [c]</code>? It’s not clear or obvious at all how the final list’s length depends on the input lists’ lengths. However, a <code>vzipWith</code> would ensure the input lengths are the same size and that the output list is also the same length:</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/type-levels/Level5.hs#L40-L45</span></span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a><span class="ot">vzipWith ::</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> <span class="dt">Vec</span> n a <span class="ot">-&gt;</span> <span class="dt">Vec</span> n b <span class="ot">-&gt;</span> <span class="dt">Vec</span> n c</span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true" tabindex="-1"></a>vzipWith f <span class="ot">=</span> \<span class="kw">case</span></span>
<span id="cb33-5"><a href="#cb33-5" aria-hidden="true" tabindex="-1"></a>  <span class="dt">VNil</span> <span class="ot">-&gt;</span> \<span class="kw">case</span></span>
<span id="cb33-6"><a href="#cb33-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">VNil</span> <span class="ot">-&gt;</span> <span class="dt">VNil</span></span>
<span id="cb33-7"><a href="#cb33-7" aria-hidden="true" tabindex="-1"></a>  x <span class="op">:+</span> xs <span class="ot">-&gt;</span> \<span class="kw">case</span></span>
<span id="cb33-8"><a href="#cb33-8" aria-hidden="true" tabindex="-1"></a>    y <span class="op">:+</span> ys <span class="ot">-&gt;</span> f x y <span class="op">:+</span> vzipWith f xs ys</span></code></pre></div>
<p>Note that both of the inner pattern matches are known by GHC to be exhaustive: if it knows that the first list is <code>VNil</code>, then it knows that <code>n ~ Z</code>, so the second list <em>has to also</em> be <code>VNil</code>. Thanks GHC!</p>
<p>From here on out, we’re now always going to assume that GHC’s exhaustiveness checker is on, so we always handle every branch that GHC tells us is necessary, and skip handling branches that GHC tells us is unnecessary (through compiler warnings).</p>
<p>We can even express more complicated relationships with type families (type-level “functions”):</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/type-levels/Level5.hs#L47-L63</span></span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="kw">family</span> <span class="dt">Plus</span> (<span class="ot">x ::</span> <span class="dt">Nat</span>) (<span class="ot">y ::</span> <span class="dt">Nat</span>) <span class="kw">where</span></span>
<span id="cb34-4"><a href="#cb34-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Plus</span> <span class="dt">Z</span> y <span class="ot">=</span> y</span>
<span id="cb34-5"><a href="#cb34-5" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Plus</span> (<span class="dt">S</span> z) y <span class="ot">=</span> <span class="dt">S</span> (<span class="dt">Plus</span> z y)</span>
<span id="cb34-6"><a href="#cb34-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-7"><a href="#cb34-7" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="kw">family</span> <span class="dt">Times</span> (<span class="ot">x ::</span> <span class="dt">Nat</span>) (<span class="ot">y ::</span> <span class="dt">Nat</span>) <span class="kw">where</span></span>
<span id="cb34-8"><a href="#cb34-8" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Times</span> <span class="dt">Z</span> y <span class="ot">=</span> <span class="dt">Z</span></span>
<span id="cb34-9"><a href="#cb34-9" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Times</span> (<span class="dt">S</span> z) y <span class="ot">=</span> <span class="dt">Plus</span> y (<span class="dt">Times</span> z y)</span>
<span id="cb34-10"><a href="#cb34-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-11"><a href="#cb34-11" aria-hidden="true" tabindex="-1"></a><span class="ot">vconcat ::</span> <span class="dt">Vec</span> n a <span class="ot">-&gt;</span> <span class="dt">Vec</span> m a <span class="ot">-&gt;</span> <span class="dt">Vec</span> (<span class="dt">Plus</span> n m) a</span>
<span id="cb34-12"><a href="#cb34-12" aria-hidden="true" tabindex="-1"></a>vconcat <span class="ot">=</span> \<span class="kw">case</span></span>
<span id="cb34-13"><a href="#cb34-13" aria-hidden="true" tabindex="-1"></a>  <span class="dt">VNil</span> <span class="ot">-&gt;</span> <span class="fu">id</span></span>
<span id="cb34-14"><a href="#cb34-14" aria-hidden="true" tabindex="-1"></a>  x <span class="op">:+</span> xs <span class="ot">-&gt;</span> \ys <span class="ot">-&gt;</span> x <span class="op">:+</span> vconcat xs ys</span>
<span id="cb34-15"><a href="#cb34-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-16"><a href="#cb34-16" aria-hidden="true" tabindex="-1"></a><span class="ot">vconcatMap ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Vec</span> m b) <span class="ot">-&gt;</span> <span class="dt">Vec</span> n a <span class="ot">-&gt;</span> <span class="dt">Vec</span> (<span class="dt">Times</span> n m) b</span>
<span id="cb34-17"><a href="#cb34-17" aria-hidden="true" tabindex="-1"></a>vconcatMap f <span class="ot">=</span> \<span class="kw">case</span></span>
<span id="cb34-18"><a href="#cb34-18" aria-hidden="true" tabindex="-1"></a>  <span class="dt">VNil</span> <span class="ot">-&gt;</span> <span class="dt">VNil</span></span>
<span id="cb34-19"><a href="#cb34-19" aria-hidden="true" tabindex="-1"></a>  x <span class="op">:+</span> xs <span class="ot">-&gt;</span> f x <span class="ot">`vconcat`</span> vconcatMap f xs</span></code></pre></div>
<p>Note that all of these only work in GHC because the structure of the functions themselves match exactly the structure of the type families. If you follow the pattern matches in the functions, note that they match exactly with the different equations of the type family.</p>
<p>Famously, we can totally index into fixed-length lists, in a way that indexing will not fail. To do that, we have to define a type <code>Fin n</code>, which represents an index into a list of length <code>n</code>. So, <code>Fin (S (S (S Z)))</code> will be either 0, 1, or 2, the three possible indices of a three-item list.</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/type-levels/Level5.hs#L65-L76</span></span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Fin</span><span class="ot"> ::</span> <span class="dt">Nat</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="kw">where</span></span>
<span id="cb35-4"><a href="#cb35-4" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- | if z is non-zero, FZ :: Fin z gives you the first item</span></span>
<span id="cb35-5"><a href="#cb35-5" aria-hidden="true" tabindex="-1"></a>  <span class="dt">FZ</span><span class="ot"> ::</span> <span class="dt">Fin</span> (<span class="dt">&#39;S</span> n)</span>
<span id="cb35-6"><a href="#cb35-6" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- | if i indexes into length z, then (i+1) indixes into length (z+1)</span></span>
<span id="cb35-7"><a href="#cb35-7" aria-hidden="true" tabindex="-1"></a>  <span class="dt">FS</span><span class="ot"> ::</span> <span class="dt">Fin</span> n <span class="ot">-&gt;</span> <span class="dt">Fin</span> (<span class="dt">&#39;S</span> n)</span>
<span id="cb35-8"><a href="#cb35-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-9"><a href="#cb35-9" aria-hidden="true" tabindex="-1"></a><span class="ot">vindex ::</span> <span class="dt">Fin</span> n <span class="ot">-&gt;</span> <span class="dt">Vec</span> n a <span class="ot">-&gt;</span> a</span>
<span id="cb35-10"><a href="#cb35-10" aria-hidden="true" tabindex="-1"></a>vindex <span class="ot">=</span> \<span class="kw">case</span></span>
<span id="cb35-11"><a href="#cb35-11" aria-hidden="true" tabindex="-1"></a>  <span class="dt">FZ</span> <span class="ot">-&gt;</span> \<span class="kw">case</span></span>
<span id="cb35-12"><a href="#cb35-12" aria-hidden="true" tabindex="-1"></a>    x <span class="op">:+</span> _ <span class="ot">-&gt;</span> x</span>
<span id="cb35-13"><a href="#cb35-13" aria-hidden="true" tabindex="-1"></a>  <span class="dt">FS</span> i <span class="ot">-&gt;</span> \<span class="kw">case</span></span>
<span id="cb35-14"><a href="#cb35-14" aria-hidden="true" tabindex="-1"></a>    _ <span class="op">:+</span> xs <span class="ot">-&gt;</span> vindex i xs</span></code></pre></div>
<p><code>Fin</code> takes the place of <code>Int</code> in <code>index :: Int -&gt; [a] -&gt; a</code>. You can use <code>FZ</code> in any non-empty list, because <code>FZ :: Fin (S n)</code> will match any <code>Vec (S n)</code> (which is necessarily of length greater than 0). You can use <code>FS FZ</code> only on something that matches <code>Vec (S (S n))</code>. This is the type-safety.</p>
<p>We can also specify non-trivial relationships between lengths of lists, like making a more type-safe <code>take :: Int -&gt; [a] -&gt; [a]</code>. We want to make sure that the result list has a length less than or equal to the input list. We need another “int” that can only be constructed in the case that the result length is less than or equal to the first length. This called “proofs” or “witnesses”, and act in the same role as <code>TypeRep</code>, <code>(:~:)</code>, etc. did above for our <code>Sigma</code> examples.</p>
<p>We want a type <code>LTE n m</code> that is a “witness” that <code>n</code> is less than or equal to <code>m</code>. It can only be constructed for if <code>n</code> is less than or equal to <code>m</code>. For example, you can create a value of type <code>LTE (S Z) (S (S Z))</code>, but not of <code>LTE (S (S Z)) Z</code></p>
<div class="sourceCode" id="cb36"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/type-levels/Level5.hs#L78-L87</span></span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">LTE</span><span class="ot"> ::</span> <span class="dt">Nat</span> <span class="ot">-&gt;</span> <span class="dt">Nat</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="kw">where</span></span>
<span id="cb36-4"><a href="#cb36-4" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- | Z is less than or equal to any number</span></span>
<span id="cb36-5"><a href="#cb36-5" aria-hidden="true" tabindex="-1"></a>  <span class="dt">LTEZ</span><span class="ot"> ::</span> <span class="dt">LTE</span> <span class="dt">Z</span> m</span>
<span id="cb36-6"><a href="#cb36-6" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- | if n &lt;= m, then (n + 1) &lt;= (m + 1)</span></span>
<span id="cb36-7"><a href="#cb36-7" aria-hidden="true" tabindex="-1"></a>  <span class="dt">LTES</span><span class="ot"> ::</span> <span class="dt">LTE</span> n m <span class="ot">-&gt;</span> <span class="dt">LTE</span> (<span class="dt">&#39;S</span> n) (<span class="dt">&#39;S</span> m)</span>
<span id="cb36-8"><a href="#cb36-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-9"><a href="#cb36-9" aria-hidden="true" tabindex="-1"></a><span class="ot">vtake ::</span> <span class="dt">LTE</span> n m <span class="ot">-&gt;</span> <span class="dt">Vec</span> m a <span class="ot">-&gt;</span> <span class="dt">Vec</span> n a</span>
<span id="cb36-10"><a href="#cb36-10" aria-hidden="true" tabindex="-1"></a>vtake <span class="ot">=</span> \<span class="kw">case</span></span>
<span id="cb36-11"><a href="#cb36-11" aria-hidden="true" tabindex="-1"></a>  <span class="dt">LTEZ</span> <span class="ot">-&gt;</span> \_ <span class="ot">-&gt;</span> <span class="dt">VNil</span></span>
<span id="cb36-12"><a href="#cb36-12" aria-hidden="true" tabindex="-1"></a>  <span class="dt">LTES</span> l <span class="ot">-&gt;</span> \<span class="kw">case</span> x <span class="op">:+</span> xs <span class="ot">-&gt;</span> x <span class="op">:+</span> vtake l xs</span></code></pre></div>
<p>Notice the similarity to how we would define <code>take :: Int -&gt; [a] -&gt; [a]</code>. We just spiced up the <code>Int</code> argument with type safety.</p>
<p>Another thing we would like to do is use be able to <em>create</em> lists of arbitrary length. We can look at <code>replicate :: Int -&gt; a -&gt; [a]</code>, and create a new “spicy int” <code>SNat n</code>, so <code>vreplicate :: SNat n -&gt; a -&gt; Vec n a</code></p>
<div class="sourceCode" id="cb37"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/type-levels/Level5.hs#L89-L96</span></span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">SNat</span><span class="ot"> ::</span> <span class="dt">Nat</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="kw">where</span></span>
<span id="cb37-4"><a href="#cb37-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">SZ</span><span class="ot"> ::</span> <span class="dt">SNat</span> <span class="dt">Z</span></span>
<span id="cb37-5"><a href="#cb37-5" aria-hidden="true" tabindex="-1"></a>  <span class="dt">SS</span><span class="ot"> ::</span> <span class="dt">SNat</span> n <span class="ot">-&gt;</span> <span class="dt">SNat</span> (<span class="dt">S</span> n)</span>
<span id="cb37-6"><a href="#cb37-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-7"><a href="#cb37-7" aria-hidden="true" tabindex="-1"></a><span class="ot">vreplicate ::</span> <span class="dt">SNat</span> n <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Vec</span> n a</span>
<span id="cb37-8"><a href="#cb37-8" aria-hidden="true" tabindex="-1"></a>vreplicate <span class="ot">=</span> \<span class="kw">case</span></span>
<span id="cb37-9"><a href="#cb37-9" aria-hidden="true" tabindex="-1"></a>  <span class="dt">SZ</span> <span class="ot">-&gt;</span> \_ <span class="ot">-&gt;</span> <span class="dt">VNil</span></span>
<span id="cb37-10"><a href="#cb37-10" aria-hidden="true" tabindex="-1"></a>  <span class="dt">SS</span> n <span class="ot">-&gt;</span> \x <span class="ot">-&gt;</span> x <span class="op">:+</span> vreplicate n x</span></code></pre></div>
<p>Notice that this type has a lot more guarantees than <code>replicate</code>. For <code>replicate :: Int -&gt; a -&gt; [a]</code>, we can’t guarantee (as the caller) that the return type does have the length we give it. But for <code>vreplicate :: SNat n -&gt; a -&gt; Vec n a</code>, it does!</p>
<p><code>SNat n</code> is actually kind of special. We call it a <em>singleton</em>, and it’s useful because it perfectly reflects the structure of <code>n</code> the type, as a value…nothing more and nothing less. By pattern matching on <code>SNat n</code>, we can exactly determine what <code>n</code> is. <code>SZ</code> means <code>n</code> is <code>Z</code>, <code>SS SZ</code> means <code>n</code> is <code>S Z</code>, etc. This is useful because we can’t directly pattern match on types at runtime in Haskell (because of type erasure), but we <em>can</em> pattern match on singletons at runtime.</p>
<p>We actually encountered singletons before in this post! <code>TypeRep a</code> is a singleton for the type <code>a</code>: by pattern matching on it (like with <code>App</code> earlier), we can essentially “pattern match” on the type <code>a</code> itself.</p>
<p>In practice, we often write typeclasses to automatically generate singletons, similar to <code>Typeable</code> from before:</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/type-levels/Level5.hs#L98-L108</span></span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-3"><a href="#cb38-3" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">KnownNat</span> n <span class="kw">where</span></span>
<span id="cb38-4"><a href="#cb38-4" aria-hidden="true" tabindex="-1"></a><span class="ot">  nat ::</span> <span class="dt">SNat</span> n</span>
<span id="cb38-5"><a href="#cb38-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-6"><a href="#cb38-6" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">KnownNat</span> <span class="dt">Z</span> <span class="kw">where</span></span>
<span id="cb38-7"><a href="#cb38-7" aria-hidden="true" tabindex="-1"></a>  nat <span class="ot">=</span> <span class="dt">SZ</span></span>
<span id="cb38-8"><a href="#cb38-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-9"><a href="#cb38-9" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">KnownNat</span> n <span class="ot">=&gt;</span> <span class="dt">KnownNat</span> (<span class="dt">S</span> n) <span class="kw">where</span></span>
<span id="cb38-10"><a href="#cb38-10" aria-hidden="true" tabindex="-1"></a>  nat <span class="ot">=</span> <span class="dt">SS</span> nat</span>
<span id="cb38-11"><a href="#cb38-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-12"><a href="#cb38-12" aria-hidden="true" tabindex="-1"></a><span class="ot">vreplicate&#39; ::</span> <span class="dt">KnownNat</span> n <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Vec</span> n a</span>
<span id="cb38-13"><a href="#cb38-13" aria-hidden="true" tabindex="-1"></a>vreplicate&#39; <span class="ot">=</span> vreplicate nat</span></code></pre></div>
<p>One last thing: moving back and forth between the different levels. We can’t really write a <code>[a] -&gt; Vec n a</code>, because in Haskell, the type variables are determined by the <em>caller</em>. We want <code>n</code> to be determined by the list, and the function itself. And now suddenly we run into the same issue that we ran into before, when moving between levels 2 and 3.</p>
<p>We can do the same trick before and write an existential wrapper:</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/type-levels/Level5.hs#L110-L116</span></span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-3"><a href="#cb39-3" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">SomeVec</span> a <span class="ot">=</span> <span class="kw">forall</span> n<span class="op">.</span> <span class="dt">MkSomeVec</span> (<span class="dt">SNat</span> n) (<span class="dt">Vec</span> n a)</span>
<span id="cb39-4"><a href="#cb39-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-5"><a href="#cb39-5" aria-hidden="true" tabindex="-1"></a><span class="ot">toSomeVec ::</span> [a] <span class="ot">-&gt;</span> <span class="dt">SomeVec</span> a</span>
<span id="cb39-6"><a href="#cb39-6" aria-hidden="true" tabindex="-1"></a>toSomeVec <span class="ot">=</span> \<span class="kw">case</span></span>
<span id="cb39-7"><a href="#cb39-7" aria-hidden="true" tabindex="-1"></a>  [] <span class="ot">-&gt;</span> <span class="dt">MkSomeVec</span> <span class="dt">SZ</span> <span class="dt">VNil</span></span>
<span id="cb39-8"><a href="#cb39-8" aria-hidden="true" tabindex="-1"></a>  x <span class="op">:</span> xs <span class="ot">-&gt;</span> <span class="kw">case</span> toSomeVec xs <span class="kw">of</span></span>
<span id="cb39-9"><a href="#cb39-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">MkSomeVec</span> n ys <span class="ot">-&gt;</span> <span class="dt">MkSomeVec</span> (<span class="dt">SS</span> n) (x <span class="op">:+</span> ys)</span></code></pre></div>
<p>It is common practice (and a good habit) to always include a singleton (or a singleton-like typeclass constraint) to the type you are “hiding” when you create an existential type wrapper, even when it is not always necessary. That’s why we included <code>TypeRep</code> in <code>HList</code> and <code>SomeList</code> earlier.</p>
<p><code>SomeVec a</code> is essentially isomorphic to <code>[a]</code>, except you can pattern match on it and get the length <code>n</code> as a type you can use.</p>
<p>There’s a slightly more light-weight method of returning an existential type: by returning it in a continuation.</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/type-levels/Level5.hs#L118-L121</span></span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-3"><a href="#cb40-3" aria-hidden="true" tabindex="-1"></a><span class="ot">withVec ::</span> [a] <span class="ot">-&gt;</span> (<span class="kw">forall</span> n<span class="op">.</span> <span class="dt">SNat</span> n <span class="ot">-&gt;</span> <span class="dt">Vec</span> n a <span class="ot">-&gt;</span> r) <span class="ot">-&gt;</span> r</span>
<span id="cb40-4"><a href="#cb40-4" aria-hidden="true" tabindex="-1"></a>withVec <span class="ot">=</span> \<span class="kw">case</span></span>
<span id="cb40-5"><a href="#cb40-5" aria-hidden="true" tabindex="-1"></a>  [] <span class="ot">-&gt;</span> \f <span class="ot">-&gt;</span> f <span class="dt">SZ</span> <span class="dt">VNil</span></span>
<span id="cb40-6"><a href="#cb40-6" aria-hidden="true" tabindex="-1"></a>  x <span class="op">:</span> xs <span class="ot">-&gt;</span> \f <span class="ot">-&gt;</span> withVec xs \n ys <span class="ot">-&gt;</span> f (<span class="dt">SS</span> n) (x <span class="op">:+</span> ys)</span></code></pre></div>
<p>That way, you can use the type variable within the continuation. Doing <code>withSomeVec xs \n v -&gt; ....</code> is identical to <code>case toSomeVec xs of SomeVec n v -&gt; ...</code>.</p>
<p>However, since you don’t get the <code>n</code> itself until runtime, you might find yourself struggling to use concepts like <code>Fin</code> and <code>LTE</code>. To do use them comfortably, you have to write functions to “check” if your <code>LTE</code> is even possible, known as “decision functions”:</p>
<div class="sourceCode" id="cb41"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/type-levels/Level5.hs#L123-L128</span></span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-3"><a href="#cb41-3" aria-hidden="true" tabindex="-1"></a><span class="ot">isLTE ::</span> <span class="dt">SNat</span> n <span class="ot">-&gt;</span> <span class="dt">SNat</span> m <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">LTE</span> n m)</span>
<span id="cb41-4"><a href="#cb41-4" aria-hidden="true" tabindex="-1"></a>isLTE <span class="ot">=</span> \<span class="kw">case</span></span>
<span id="cb41-5"><a href="#cb41-5" aria-hidden="true" tabindex="-1"></a>  <span class="dt">SZ</span> <span class="ot">-&gt;</span> \_ <span class="ot">-&gt;</span> <span class="dt">Just</span> <span class="dt">LTEZ</span></span>
<span id="cb41-6"><a href="#cb41-6" aria-hidden="true" tabindex="-1"></a>  <span class="dt">SS</span> n <span class="ot">-&gt;</span> \<span class="kw">case</span></span>
<span id="cb41-7"><a href="#cb41-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">SZ</span> <span class="ot">-&gt;</span> <span class="dt">Nothing</span></span>
<span id="cb41-8"><a href="#cb41-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">SS</span> m <span class="ot">-&gt;</span> <span class="dt">LTES</span> <span class="op">&lt;$&gt;</span> isLTE n m</span></code></pre></div>
<p>This was a very whirlwind introduction, and I definitely recommend reading <a href="https://blog.jle.im/entry/fixed-length-vector-types-in-haskell.html">this post on fixed-length lists</a> for a more in-depth guide and tour of the features. In practice, fixed-length lists are not that useful because the situations where you want lazily linked lists and the situations where you want them to be statically sized has very little overlap. But you will often see <a href="https://hackage.haskell.org/package/vector-sized">fixed-length vectors</a> in real life code — mostly numerical code.</p>
<p>Overall as you can see, at this level we gain some powerful guarantees and tools, but we also run into some small inconveniences (like manipulating witnesses and singletons). This level is fairly comfortable to work with in modern Haskell tooling. However, if you live here long enough, you’re going to eventually be tempted to wander into…</p>
<h2 id="level-6-local-structure-enforced-list">Level 6: Local Structure Enforced List</h2>
<p><em><a href="https://github.com/mstksg/inCode/tree/master/code-samples/type-levels/Level6.hs">Code available here</a></em></p>
<p>For our next level let’s jump back back into constraints on the <em>contents</em> of the list. Let’s imagine a <em>priority queue</em> on top of a list. Each value in the list will be a <code>(priority, value)</code> pair. To make the <code>pop</code> operation (pop out the value of lowest priority) efficient, we can enforce that the list is <em>always sorted by priority</em>: the lowest priority is always first, the second lowest is second, etc.</p>
<p>If we didn’t care about type safety, we could do this by always inserting a new item so that it is sorted:</p>
<div class="sourceCode" id="cb42"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/type-levels/Level6.hs#L21-L26</span></span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-3"><a href="#cb42-3" aria-hidden="true" tabindex="-1"></a><span class="ot">insertSortedList ::</span> (<span class="dt">Int</span>, a) <span class="ot">-&gt;</span> [(<span class="dt">Int</span>, a)] <span class="ot">-&gt;</span> [(<span class="dt">Int</span>, a)]</span>
<span id="cb42-4"><a href="#cb42-4" aria-hidden="true" tabindex="-1"></a>insertSortedList (p, x) <span class="ot">=</span> \<span class="kw">case</span></span>
<span id="cb42-5"><a href="#cb42-5" aria-hidden="true" tabindex="-1"></a>  [] <span class="ot">-&gt;</span> [(p, x)]</span>
<span id="cb42-6"><a href="#cb42-6" aria-hidden="true" tabindex="-1"></a>  (q, y) <span class="op">:</span> ys</span>
<span id="cb42-7"><a href="#cb42-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> p <span class="op">&lt;=</span> q <span class="ot">-&gt;</span> (p, x) <span class="op">:</span> (q, y) <span class="op">:</span> ys</span>
<span id="cb42-8"><a href="#cb42-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">-&gt;</span> (q, y) <span class="op">:</span> insertSortedList (p, x) ys</span></code></pre></div>
<p>This method enforces a <em>local</em> structure: between every item <code>x</code> and the next item <code>y</code> in <code>x:y:zs</code>, the priority of <code>x</code> has to be less than the priority <code>y</code>. Keeping our structure local means we only need to enforce local invariants.</p>
<p>Writing it all willy nilly type unsafe like this could be good for a single function, but we’re also going to need some more complicated functions. What if we wanted to “combine” (merge) two sorted lists together. Using a normal list, we don’t have any assurances that we have written it correctly, and it’s very easy to mess up. How about we leverage type safety to ask GHC to ensure that our functions are always correct, and always preserve this local structure? Now you’re thinking in types!</p>
<p>Introducing level 6: enforcing local structure!</p>
<p>But, first, a quick note before we dive in: for the rest of this post, for the sake of simplicity, let’s switch from inductively defined types (like <code>Nat</code> above) to GHC’s built in <a href="https://hackage.haskell.org/package/base/docs/GHC-TypeNats.html">opaque <code>Nat</code> type</a>. You can think of it as essentially the same as the <code>Nat</code> we wrote above, but <em>opaque</em> and provided by the compiler. Under the hood, it’s implemented using machine integers for efficiency. And, instead of using concrete <code>S (S (S Z))</code> syntax, you’d use abstract numeric literals, like <code>3</code>. There’s a trade-off: because it’s opaque, we can’t pattern match on it and create or manipulate our own witnesses — we are at the mercy of the API that GHC gives us. We get <code>+</code>, <code>&lt;=</code>, <code>Min</code>, etc., but in total it’s not that extensive. That’s why I never use these without also bringing typechecker plugins (<em><a href="https://hackage.haskell.org/package/ghc-typelits-natnormalise">ghc-typelits-natnormalise</a></em> and <em><a href="https://hackage.haskell.org/package/ghc-typelits-knownnat">ghc-typelits-knonwnnat</a></em>) to help automatically bring witnesses and equalities and relationships into scope for us. Everything here could be done using hand-defined witnesses and types, but we’re using TypeNats here just for the sake of example.</p>
<div class="sourceCode" id="cb43"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# OPTIONS_GHC -fplugin GHC.TypeLits.KnownNat.Solver #-}</span></span>
<span id="cb43-2"><a href="#cb43-2" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# OPTIONS_GHC -fplugin GHC.TypeLits.Normalise #-}</span></span></code></pre></div>
<p>With that disclaimer out of the way, let’s create our types! Let’s make an <code>Entry n a</code> type that represents a value of type <code>a</code> with priority <code>n</code>.</p>
<div class="sourceCode" id="cb44"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/type-levels/Level6.hs#L28-L28</span></span>
<span id="cb44-2"><a href="#cb44-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb44-3"><a href="#cb44-3" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">Entry</span> (<span class="ot">n ::</span> <span class="dt">Nat</span>) a <span class="ot">=</span> <span class="dt">Entry</span> a</span></code></pre></div>
<p>We’d construct this like <code>Entry @3 "hello"</code>, which produces <code>Entry 3 String</code>. Again this uses <em>type application syntax</em>, <code>@3</code>, that lets us pass in the <em>type</em> <code>3</code> to the constructor <code>Entry :: forall n a. a -&gt; Entry n a</code>.</p>
<p>Now, let’s think about what phantom types we want to include in our list. The fundamental strategy in this, as I learned from <a href="http://strictlypositive.org/">Conor McBride</a>’s great writings on this topic, are:</p>
<ul>
<li>Think about what “type safe operations” you want to have for your structure</li>
<li>Add just enough phantom types to perform those operations.</li>
</ul>
<p>In our case, we want to be able to cons an <code>Entry n a</code> to the start of a sorted list. To ensure this, we need to know that n is less than or equal to the list’s <em>current minimum priority</em>. So, we need our list type to be <code>Sorted n a</code>, where <code>n</code> is the <em>current minimum priority</em>.</p>
<div class="sourceCode" id="cb45"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/type-levels/Level6.hs#L33-L35</span></span>
<span id="cb45-2"><a href="#cb45-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-3"><a href="#cb45-3" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Sorted</span><span class="ot"> ::</span> <span class="dt">Nat</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="kw">where</span></span>
<span id="cb45-4"><a href="#cb45-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">SSingle</span><span class="ot"> ::</span> <span class="dt">Entry</span> n a <span class="ot">-&gt;</span> <span class="dt">Sorted</span> n a</span>
<span id="cb45-5"><a href="#cb45-5" aria-hidden="true" tabindex="-1"></a>  <span class="dt">SCons</span><span class="ot"> ::</span> (<span class="dt">KnownNat</span> m, n <span class="op">&lt;=</span> m) <span class="ot">=&gt;</span> <span class="dt">Entry</span> n a <span class="ot">-&gt;</span> <span class="dt">Sorted</span> m a <span class="ot">-&gt;</span> <span class="dt">Sorted</span> n a</span></code></pre></div>
<p>To keep things simple, we are only going to talk about non-empty lists, so the minimum priority is always defined.</p>
<p>So, a <code>Sorted n a</code> is either <code>SSingle (x :: Entry n a)</code>, where the single item is a value of priority <code>n</code>, or <code>SCons x xs</code>, where <code>x</code> has priority <code>n</code> and <code>xs :: Sorted m a</code>, where <code>n &lt;= m</code>. In our previous inductive <code>Nat</code>, you could imagine this as <code>SCons :: SNat m -&gt; LTE n m -&gt; Entry n a -&gt; Sorted m a -&gt; Sorted n a</code>, but here we will use GHC’s built-in <code>&lt;=</code> typeclass-based witness of less-than-or-equal-to-ness.</p>
<p>This works! You should be able to write:</p>
<div class="sourceCode" id="cb46"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a><span class="dt">Entry</span> <span class="op">@</span><span class="dv">1</span> <span class="ch">&#39;a&#39;</span> <span class="ot">`SCons`</span> <span class="dt">Entry</span> <span class="op">@</span><span class="dv">2</span> <span class="ch">&#39;b&#39;</span> <span class="ot">`SCons`</span> <span class="dt">SSingle</span> (<span class="dt">Entry</span> <span class="op">@</span><span class="dv">4</span> <span class="ch">&#39;c&#39;</span>)</span></code></pre></div>
<p>This creates a valid list where the priorities are all sorted from lowest to highest. You can now pop using pattern matching, which gives you the lowest element <em>by construction</em>. If you match on <code>SCons x xs</code>, you <em>know</em> that no entry in <code>xs</code> has a priority lower than <code>x</code>.</p>
<p>Critically, note that creating something out-of-order like the following would be a compiler error:</p>
<div class="sourceCode" id="cb47"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a><span class="dt">Entry</span> <span class="op">@</span><span class="dv">9</span> <span class="ch">&#39;a&#39;</span> <span class="ot">`SCons`</span> <span class="dt">Entry</span> <span class="op">@</span><span class="dv">2</span> <span class="ch">&#39;b&#39;</span> <span class="ot">`SCons`</span> <span class="dt">SSingle</span> (<span class="dt">Entry</span> <span class="op">@</span><span class="dv">4</span> <span class="ch">&#39;c&#39;</span>)</span></code></pre></div>
<p>Now, the <em>users</em> of our priority queue probably won’t often care about having the minimum priority in the type. In this case, we are using the phantom type to ensure that our data structure is correct by construction, for our own sake, and also to help us write internal functions in a correct way. So, for practical end-user usage, we want to existentially wrap out <code>n</code>.</p>
<div class="sourceCode" id="cb48"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/type-levels/Level6.hs#L103-L120</span></span>
<span id="cb48-2"><a href="#cb48-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-3"><a href="#cb48-3" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">SomeSorted</span> a <span class="ot">=</span> <span class="kw">forall</span> n<span class="op">.</span> <span class="dt">KnownNat</span> n <span class="ot">=&gt;</span> <span class="dt">SomeSorted</span> (<span class="dt">Sorted</span> n a)</span>
<span id="cb48-4"><a href="#cb48-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-5"><a href="#cb48-5" aria-hidden="true" tabindex="-1"></a><span class="ot">popSomeSorted ::</span> <span class="dt">Sorted</span> n a <span class="ot">-&gt;</span> (<span class="dt">Entry</span> n a, <span class="dt">Maybe</span> (<span class="dt">SomeSorted</span> a))</span>
<span id="cb48-6"><a href="#cb48-6" aria-hidden="true" tabindex="-1"></a>popSomeSorted <span class="ot">=</span> \<span class="kw">case</span></span>
<span id="cb48-7"><a href="#cb48-7" aria-hidden="true" tabindex="-1"></a>  <span class="dt">SSingle</span> x <span class="ot">-&gt;</span> (x, <span class="dt">Nothing</span>)</span>
<span id="cb48-8"><a href="#cb48-8" aria-hidden="true" tabindex="-1"></a>  <span class="dt">SCons</span> x xs <span class="ot">-&gt;</span> (x, <span class="dt">Just</span> (<span class="dt">SomeSorted</span> xs))</span></code></pre></div>
<p><code>popSomeSorted</code> takes an <code>Sorted n a</code> and returns the <code>Entry n a</code> promised at the start of it, and then the rest of the list if there is anything left, eliding the phantom parameter.</p>
<p>Now let’s get to the interesting parts where we actually leverage <code>n</code>: let’s write <code>insertSortedList</code>, but the type-safe way!</p>
<p>First of all, what should the type be if we insert an <code>Entry n a</code> into a <code>Sorted m a</code>? If <code>n &lt;= m</code>, it would be <code>Sorted n a</code>. If <code>n &gt; m</code>, it should be <code>Sorted m a</code>. GHC gives us a type family <code>Min n m</code>, which returns the minimum between <code>n</code> and <code>m</code>. So our type should be:</p>
<div class="sourceCode" id="cb49"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true" tabindex="-1"></a><span class="ot">insertSorted ::</span> <span class="dt">Entry</span> n a <span class="ot">-&gt;</span> <span class="dt">Sorted</span> m a <span class="ot">-&gt;</span> <span class="dt">Sorted</span> (<span class="dt">Min</span> n m) a</span></code></pre></div>
<p>To write this, we can use some helper functions: first, to decide <em>if</em> we are in the <code>n &lt;= m</code> or the <code>n &gt; m</code> case:</p>
<div class="sourceCode" id="cb50"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb50-1"><a href="#cb50-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/type-levels/Level6.hs#L41-L51</span></span>
<span id="cb50-2"><a href="#cb50-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-3"><a href="#cb50-3" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">DecideInsert</span><span class="ot"> ::</span> <span class="dt">Nat</span> <span class="ot">-&gt;</span> <span class="dt">Nat</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="kw">where</span></span>
<span id="cb50-4"><a href="#cb50-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">DIZ</span><span class="ot"> ::</span> (n <span class="op">&lt;=</span> m, <span class="dt">Min</span> n m <span class="op">~</span> n) <span class="ot">=&gt;</span> <span class="dt">DecideInsert</span> n m</span>
<span id="cb50-5"><a href="#cb50-5" aria-hidden="true" tabindex="-1"></a>  <span class="dt">DIS</span><span class="ot"> ::</span> (m <span class="op">&lt;=</span> n, <span class="dt">Min</span> n m <span class="op">~</span> m) <span class="ot">=&gt;</span> <span class="dt">DecideInsert</span> n m</span>
<span id="cb50-6"><a href="#cb50-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-7"><a href="#cb50-7" aria-hidden="true" tabindex="-1"></a><span class="ot">decideInsert ::</span> <span class="kw">forall</span> a b<span class="op">.</span> (<span class="dt">KnownNat</span> a, <span class="dt">KnownNat</span> b) <span class="ot">=&gt;</span> <span class="dt">DecideInsert</span> a b</span>
<span id="cb50-8"><a href="#cb50-8" aria-hidden="true" tabindex="-1"></a>decideInsert <span class="ot">=</span> <span class="kw">case</span> cmpNat (<span class="dt">Proxy</span> <span class="op">@</span>a) (<span class="dt">Proxy</span> <span class="op">@</span>b) <span class="kw">of</span></span>
<span id="cb50-9"><a href="#cb50-9" aria-hidden="true" tabindex="-1"></a>  <span class="dt">LTI</span> <span class="ot">-&gt;</span> <span class="dt">DIZ</span> <span class="co">-- if a &lt; b, DIZ</span></span>
<span id="cb50-10"><a href="#cb50-10" aria-hidden="true" tabindex="-1"></a>  <span class="dt">EQI</span> <span class="ot">-&gt;</span> <span class="dt">DIZ</span> <span class="co">-- if a == b, DIZ</span></span>
<span id="cb50-11"><a href="#cb50-11" aria-hidden="true" tabindex="-1"></a>  <span class="dt">GTI</span> <span class="ot">-&gt;</span> <span class="kw">case</span> cmpNat (<span class="dt">Proxy</span> <span class="op">@</span>b) (<span class="dt">Proxy</span> <span class="op">@</span>a) <span class="kw">of</span></span>
<span id="cb50-12"><a href="#cb50-12" aria-hidden="true" tabindex="-1"></a>    <span class="dt">LTI</span> <span class="ot">-&gt;</span> <span class="dt">DIS</span> <span class="co">-- if a &gt; b, DIZ, except GHC isn&#39;t smart enough to know this</span></span>
<span id="cb50-13"><a href="#cb50-13" aria-hidden="true" tabindex="-1"></a>    <span class="dt">GTI</span> <span class="ot">-&gt;</span> <span class="fu">error</span> <span class="st">&quot;absurd, we can&#39;t have both a &gt; b and b &gt; a&quot;</span></span></code></pre></div>
<p>We can use <code>decideInsert</code> to branch on if we are in the case where we insert the entry at the head or the case where we have to insert it deeper. <code>DecideInsert</code> here is our witness, and <code>decideInsert</code> constructs it using <code>cmpNat</code>, provided by GHC to compare two <code>Nat</code>s. We use <code>Proxy :: Proxy n</code> to tell it what nats we want to compare. <code>KnownNat</code> is the equivalent of our <code>KnownNat</code> class we wrote from scratch, but with GHC’s TypeNats instead of our custom inductive Nats.</p>
<div class="sourceCode" id="cb51"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb51-1"><a href="#cb51-1" aria-hidden="true" tabindex="-1"></a><span class="ot">cmpNat ::</span> (<span class="dt">KnownNat</span> a, <span class="dt">KnownNat</span> b) <span class="ot">=&gt;</span> p a <span class="ot">-&gt;</span> p b <span class="ot">-&gt;</span> <span class="dt">OrderingI</span> a b</span>
<span id="cb51-2"><a href="#cb51-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-3"><a href="#cb51-3" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">OrderingI</span><span class="ot"> ::</span> k <span class="ot">-&gt;</span> k <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="kw">where</span></span>
<span id="cb51-4"><a href="#cb51-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">LTI</span><span class="ot"> ::</span> <span class="co">-- in this branch, a &lt; b</span></span>
<span id="cb51-5"><a href="#cb51-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">EQI</span><span class="ot"> ::</span> <span class="co">-- in this branch, a ~ b</span></span>
<span id="cb51-6"><a href="#cb51-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">GTI</span><span class="ot"> ::</span> <span class="co">-- in this branch, a &gt; b</span></span></code></pre></div>
<p>Note that GHC and our typechecker plugins aren’t smart enough to know we can rule out <code>b &gt; a</code> if <code>a &gt; b</code> is true, so we have to leave an <code>error</code> that we know will never be called. Oh well. If we were writing our witnesses by hand using inductive types, we could write this ourselves, but since we are using GHC’s Nat, we are limited by what their API can prove.</p>
<p>Let’s start writing our <code>insertSorted</code>:</p>
<div class="sourceCode" id="cb52"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb52-1"><a href="#cb52-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/type-levels/Level6.hs#L64-L76</span></span>
<span id="cb52-2"><a href="#cb52-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb52-3"><a href="#cb52-3" aria-hidden="true" tabindex="-1"></a><span class="ot">insertSorted ::</span></span>
<span id="cb52-4"><a href="#cb52-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">forall</span> n m a<span class="op">.</span></span>
<span id="cb52-5"><a href="#cb52-5" aria-hidden="true" tabindex="-1"></a>  (<span class="dt">KnownNat</span> n, <span class="dt">KnownNat</span> m) <span class="ot">=&gt;</span></span>
<span id="cb52-6"><a href="#cb52-6" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Entry</span> n a <span class="ot">-&gt;</span></span>
<span id="cb52-7"><a href="#cb52-7" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Sorted</span> m a <span class="ot">-&gt;</span></span>
<span id="cb52-8"><a href="#cb52-8" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Sorted</span> (<span class="dt">Min</span> n m) a</span>
<span id="cb52-9"><a href="#cb52-9" aria-hidden="true" tabindex="-1"></a>insertSorted x <span class="ot">=</span> \<span class="kw">case</span></span>
<span id="cb52-10"><a href="#cb52-10" aria-hidden="true" tabindex="-1"></a>  <span class="dt">SSingle</span> y <span class="ot">-&gt;</span> <span class="kw">case</span> decideInsert <span class="op">@</span>n <span class="op">@</span>m <span class="kw">of</span></span>
<span id="cb52-11"><a href="#cb52-11" aria-hidden="true" tabindex="-1"></a>    <span class="dt">DIZ</span> <span class="ot">-&gt;</span> <span class="dt">SCons</span> x (<span class="dt">SSingle</span> y)</span>
<span id="cb52-12"><a href="#cb52-12" aria-hidden="true" tabindex="-1"></a>    <span class="dt">DIS</span> <span class="ot">-&gt;</span> <span class="dt">SCons</span> y (<span class="dt">SSingle</span> x)</span>
<span id="cb52-13"><a href="#cb52-13" aria-hidden="true" tabindex="-1"></a>  <span class="dt">SCons</span> <span class="op">@</span>q y ys <span class="ot">-&gt;</span> <span class="kw">case</span> decideInsert <span class="op">@</span>n <span class="op">@</span>m <span class="kw">of</span></span>
<span id="cb52-14"><a href="#cb52-14" aria-hidden="true" tabindex="-1"></a>    <span class="dt">DIZ</span> <span class="ot">-&gt;</span> <span class="dt">SCons</span> x (<span class="dt">SCons</span> y ys)</span>
<span id="cb52-15"><a href="#cb52-15" aria-hidden="true" tabindex="-1"></a>    <span class="dt">DIS</span> <span class="ot">-&gt;</span> sConsMin <span class="op">@</span>n <span class="op">@</span>q y (insertSorted x ys)</span></code></pre></div>
<p>The structure is more or less the same as <code>insertSortedList</code>, but now type safe! We basically use our handy helper function <code>decideInsert</code> to dictate where we go. I also used a helper function <code>sConsMin</code> to insert into the recursive case</p>
<div class="sourceCode" id="cb53"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb53-1"><a href="#cb53-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/type-levels/Level6.hs#L53-L62</span></span>
<span id="cb53-2"><a href="#cb53-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb53-3"><a href="#cb53-3" aria-hidden="true" tabindex="-1"></a><span class="ot">sConsMin ::</span></span>
<span id="cb53-4"><a href="#cb53-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">forall</span> q r n a<span class="op">.</span></span>
<span id="cb53-5"><a href="#cb53-5" aria-hidden="true" tabindex="-1"></a>  (<span class="dt">KnownNat</span> q, <span class="dt">KnownNat</span> r, n <span class="op">&lt;=</span> q, n <span class="op">&lt;=</span> r) <span class="ot">=&gt;</span></span>
<span id="cb53-6"><a href="#cb53-6" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Entry</span> n a <span class="ot">-&gt;</span></span>
<span id="cb53-7"><a href="#cb53-7" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Sorted</span> (<span class="dt">Min</span> q r) a <span class="ot">-&gt;</span></span>
<span id="cb53-8"><a href="#cb53-8" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Sorted</span> n a</span>
<span id="cb53-9"><a href="#cb53-9" aria-hidden="true" tabindex="-1"></a>sConsMin <span class="ot">=</span> <span class="kw">case</span> cmpNat (<span class="dt">Proxy</span> <span class="op">@</span>q) (<span class="dt">Proxy</span> <span class="op">@</span>r) <span class="kw">of</span></span>
<span id="cb53-10"><a href="#cb53-10" aria-hidden="true" tabindex="-1"></a>  <span class="dt">LTI</span> <span class="ot">-&gt;</span> <span class="dt">SCons</span><span class="ot"> ::</span> <span class="dt">Entry</span> n a <span class="ot">-&gt;</span> <span class="dt">Sorted</span> q a <span class="ot">-&gt;</span> <span class="dt">Sorted</span> n a</span>
<span id="cb53-11"><a href="#cb53-11" aria-hidden="true" tabindex="-1"></a>  <span class="dt">EQI</span> <span class="ot">-&gt;</span> <span class="dt">SCons</span><span class="ot"> ::</span> <span class="dt">Entry</span> n a <span class="ot">-&gt;</span> <span class="dt">Sorted</span> q a <span class="ot">-&gt;</span> <span class="dt">Sorted</span> n a</span>
<span id="cb53-12"><a href="#cb53-12" aria-hidden="true" tabindex="-1"></a>  <span class="dt">GTI</span> <span class="ot">-&gt;</span> <span class="dt">SCons</span><span class="ot"> ::</span> <span class="dt">Entry</span> n a <span class="ot">-&gt;</span> <span class="dt">Sorted</span> r a <span class="ot">-&gt;</span> <span class="dt">Sorted</span> n a</span></code></pre></div>
<p><code>sConsMin</code> isn’t strictly necessary, but it saves a lot of unnecessary pattern matching. The reason why we need it is because we <em>want</em> to write <code>SCons y (insertSorted x ys)</code> in the last line of <code>insertSorted</code>. However, in this case, <code>SCons</code> does not have a well-defined type. It can either be <code>Entry n -&gt; Sorted q a -&gt; Sorted n a</code> or <code>Entry n -&gt; Sorted r a -&gt; Sorted n a</code>. Haskell requires functions to be specialized at the place we actually <em>use</em> them, so this is no good. We would have to pattern match on <code>cmpNat</code> and <code>LTI</code>/<code>EQI</code>/<code>GTI</code> in order to know how to specialize <code>SCons</code>. So, we use <code>sConsMin</code> to wrap this up for clarity.</p>
<p>How did I know this? I basically tried writing it out the full messy way, bringing in as much witnesses and pattern matching as I could, until I got it to compile. Then I spent time factoring out the common parts until I got what we have now!</p>
<p>Note that we use a feature called “Type Abstractions” to “match on” the existential type variable <code>q</code> in the pattern <code>SCons @q y ys</code>. Recall from the definition of <code>SCons</code> that the first type variable is the minimum priority of the tail.</p>
<p>And just like that, we made our <code>insertSortedList</code> <em>type-safe</em>! We can no longer return an unsorted list: it always inserts sortedly, by <em>construction</em>, enforced by GHC. We did cheat a little with <code>error</code>, that was only because we used GHC’s TypeNats…if we used our own inductive types, all unsafety can be avoided.</p>
<p>Let’s write the function to <em>merge</em> two sorted lists together. This is essentially the merge step of a merge sort: take two lists, look at the head of each one, cons the smaller of the two heads, then recurse.</p>
<div class="sourceCode" id="cb54"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb54-1"><a href="#cb54-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/type-levels/Level6.hs#L78-L92</span></span>
<span id="cb54-2"><a href="#cb54-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-3"><a href="#cb54-3" aria-hidden="true" tabindex="-1"></a><span class="ot">mergeSorted ::</span></span>
<span id="cb54-4"><a href="#cb54-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">forall</span> n m a<span class="op">.</span></span>
<span id="cb54-5"><a href="#cb54-5" aria-hidden="true" tabindex="-1"></a>  (<span class="dt">KnownNat</span> n, <span class="dt">KnownNat</span> m) <span class="ot">=&gt;</span></span>
<span id="cb54-6"><a href="#cb54-6" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Sorted</span> n a <span class="ot">-&gt;</span></span>
<span id="cb54-7"><a href="#cb54-7" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Sorted</span> m a <span class="ot">-&gt;</span></span>
<span id="cb54-8"><a href="#cb54-8" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Sorted</span> (<span class="dt">Min</span> n m) a</span>
<span id="cb54-9"><a href="#cb54-9" aria-hidden="true" tabindex="-1"></a>mergeSorted <span class="ot">=</span> \<span class="kw">case</span></span>
<span id="cb54-10"><a href="#cb54-10" aria-hidden="true" tabindex="-1"></a>  <span class="dt">SSingle</span> x <span class="ot">-&gt;</span> insertSorted x</span>
<span id="cb54-11"><a href="#cb54-11" aria-hidden="true" tabindex="-1"></a>  <span class="dt">SCons</span> <span class="op">@</span>q x xs <span class="ot">-&gt;</span> \<span class="kw">case</span></span>
<span id="cb54-12"><a href="#cb54-12" aria-hidden="true" tabindex="-1"></a>    <span class="dt">SSingle</span> y <span class="ot">-&gt;</span> <span class="kw">case</span> decideInsert <span class="op">@</span>n <span class="op">@</span>m <span class="kw">of</span></span>
<span id="cb54-13"><a href="#cb54-13" aria-hidden="true" tabindex="-1"></a>      <span class="dt">DIZ</span> <span class="ot">-&gt;</span> sConsMin <span class="op">@</span>q <span class="op">@</span>m x (mergeSorted xs (<span class="dt">SSingle</span> y))</span>
<span id="cb54-14"><a href="#cb54-14" aria-hidden="true" tabindex="-1"></a>      <span class="dt">DIS</span> <span class="ot">-&gt;</span> <span class="dt">SCons</span> y (<span class="dt">SCons</span> x xs)</span>
<span id="cb54-15"><a href="#cb54-15" aria-hidden="true" tabindex="-1"></a>    <span class="dt">SCons</span> <span class="op">@</span>r y ys <span class="ot">-&gt;</span> <span class="kw">case</span> decideInsert <span class="op">@</span>n <span class="op">@</span>m <span class="kw">of</span></span>
<span id="cb54-16"><a href="#cb54-16" aria-hidden="true" tabindex="-1"></a>      <span class="dt">DIZ</span> <span class="ot">-&gt;</span> sConsMin <span class="op">@</span>q <span class="op">@</span>m x (mergeSorted xs (<span class="dt">SCons</span> y ys))</span>
<span id="cb54-17"><a href="#cb54-17" aria-hidden="true" tabindex="-1"></a>      <span class="dt">DIS</span> <span class="ot">-&gt;</span> sConsMin <span class="op">@</span>n <span class="op">@</span>r y (mergeSorted (<span class="dt">SCons</span> x xs) ys)</span></code></pre></div>
<p>Again, this looks a lot like how you would write the normal function to merge two sorted lists…except this time, it’s type-safe! You <em>can’t</em> return an unsorted list because the result list has to be sorted <em>by construction</em>.</p>
<p>To wrap it all up, let’s write our conversion functions. First, an <code>insertionSort</code> function that takes a normal non-empty list of priority-value pairs and throws them all into a <code>Sorted</code>, which (by construction) is guaranteed to be sorted:</p>
<div class="sourceCode" id="cb55"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb55-1"><a href="#cb55-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/type-levels/Level6.hs#L107-L135</span></span>
<span id="cb55-2"><a href="#cb55-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-3"><a href="#cb55-3" aria-hidden="true" tabindex="-1"></a><span class="ot">insertionSort ::</span></span>
<span id="cb55-4"><a href="#cb55-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">forall</span> a<span class="op">.</span></span>
<span id="cb55-5"><a href="#cb55-5" aria-hidden="true" tabindex="-1"></a>  <span class="dt">NonEmpty</span> (<span class="dt">Natural</span>, a) <span class="ot">-&gt;</span></span>
<span id="cb55-6"><a href="#cb55-6" aria-hidden="true" tabindex="-1"></a>  <span class="dt">SomeSorted</span> a</span>
<span id="cb55-7"><a href="#cb55-7" aria-hidden="true" tabindex="-1"></a>insertionSort ((k0, x0) <span class="op">:|</span> xs0) <span class="ot">=</span> withSomeSNat k0 \(<span class="dt">SNat</span> <span class="op">@</span>k) <span class="ot">-&gt;</span></span>
<span id="cb55-8"><a href="#cb55-8" aria-hidden="true" tabindex="-1"></a>  go xs0 (<span class="dt">SomeSorted</span> (<span class="dt">SSingle</span> (<span class="dt">Entry</span> <span class="op">@</span>k x0)))</span>
<span id="cb55-9"><a href="#cb55-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb55-10"><a href="#cb55-10" aria-hidden="true" tabindex="-1"></a><span class="ot">    go ::</span> [(<span class="dt">Natural</span>, a)] <span class="ot">-&gt;</span> <span class="dt">SomeSorted</span> a <span class="ot">-&gt;</span> <span class="dt">SomeSorted</span> a</span>
<span id="cb55-11"><a href="#cb55-11" aria-hidden="true" tabindex="-1"></a>    go [] <span class="ot">=</span> <span class="fu">id</span></span>
<span id="cb55-12"><a href="#cb55-12" aria-hidden="true" tabindex="-1"></a>    go ((k, x) <span class="op">:</span> xs) <span class="ot">=</span> \<span class="kw">case</span></span>
<span id="cb55-13"><a href="#cb55-13" aria-hidden="true" tabindex="-1"></a>      <span class="dt">SomeSorted</span> <span class="op">@</span>_ <span class="op">@</span>n ys <span class="ot">-&gt;</span> withSomeSNat k \(<span class="dt">SNat</span> <span class="op">@</span>k) <span class="ot">-&gt;</span></span>
<span id="cb55-14"><a href="#cb55-14" aria-hidden="true" tabindex="-1"></a>        go xs <span class="op">$</span></span>
<span id="cb55-15"><a href="#cb55-15" aria-hidden="true" tabindex="-1"></a>          someSortedMin <span class="op">@</span>k <span class="op">@</span>n <span class="op">$</span></span>
<span id="cb55-16"><a href="#cb55-16" aria-hidden="true" tabindex="-1"></a>            insertSorted (<span class="dt">Entry</span> <span class="op">@</span>k x) ys</span>
<span id="cb55-17"><a href="#cb55-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-18"><a href="#cb55-18" aria-hidden="true" tabindex="-1"></a><span class="ot">someSortedMin ::</span></span>
<span id="cb55-19"><a href="#cb55-19" aria-hidden="true" tabindex="-1"></a>  <span class="kw">forall</span> n m a<span class="op">.</span></span>
<span id="cb55-20"><a href="#cb55-20" aria-hidden="true" tabindex="-1"></a>  (<span class="dt">KnownNat</span> n, <span class="dt">KnownNat</span> m) <span class="ot">=&gt;</span></span>
<span id="cb55-21"><a href="#cb55-21" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Sorted</span> (<span class="dt">Min</span> n m) a <span class="ot">-&gt;</span></span>
<span id="cb55-22"><a href="#cb55-22" aria-hidden="true" tabindex="-1"></a>  <span class="dt">SomeSorted</span> a</span>
<span id="cb55-23"><a href="#cb55-23" aria-hidden="true" tabindex="-1"></a>someSortedMin <span class="ot">=</span> <span class="kw">case</span> cmpNat (<span class="dt">Proxy</span> <span class="op">@</span>n) (<span class="dt">Proxy</span> <span class="op">@</span>m) <span class="kw">of</span></span>
<span id="cb55-24"><a href="#cb55-24" aria-hidden="true" tabindex="-1"></a>  <span class="dt">LTI</span> <span class="ot">-&gt;</span> <span class="dt">SomeSorted</span></span>
<span id="cb55-25"><a href="#cb55-25" aria-hidden="true" tabindex="-1"></a>  <span class="dt">EQI</span> <span class="ot">-&gt;</span> <span class="dt">SomeSorted</span></span>
<span id="cb55-26"><a href="#cb55-26" aria-hidden="true" tabindex="-1"></a>  <span class="dt">GTI</span> <span class="ot">-&gt;</span> <span class="dt">SomeSorted</span></span></code></pre></div>
<p>Some things to note:</p>
<ol type="1">
<li>We’re using the <a href="https://hackage.haskell.org/package/base/docs/Data-List-NonEmpty.html">nonempty list type</a> type from <em>base</em>, because <code>Sorted</code> always has at least one element.</li>
<li>We use <code>withSomeSNat</code> to turn a <code>Natural</code> into the type-level <code>n :: Nat</code>, the same way we wrote <code>withVec</code> earlier. This is just just the function that GHC offers to reify a <code>Natural</code> (non-negative <code>Integer</code>) to the type level.</li>
<li><code>someSortedMin</code> is used to clean up the implementation, doing the same job that <code>sConsMin</code> did.</li>
</ol>
<div class="sourceCode" id="cb56"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb56-1"><a href="#cb56-1" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> <span class="kw">case</span> insertionSort ((<span class="dv">4</span>, <span class="ch">&#39;a&#39;</span>) <span class="op">:|</span> [(<span class="dv">3</span>, <span class="ch">&#39;b&#39;</span>), (<span class="dv">5</span>, <span class="ch">&#39;c&#39;</span>), (<span class="dv">4</span>, <span class="ch">&#39;d&#39;</span>)]) <span class="kw">of</span></span>
<span id="cb56-2"><a href="#cb56-2" aria-hidden="true" tabindex="-1"></a>          <span class="dt">SomeSorted</span> xs <span class="ot">-&gt;</span> <span class="fu">print</span> xs</span>
<span id="cb56-3"><a href="#cb56-3" aria-hidden="true" tabindex="-1"></a><span class="dt">SCons</span> <span class="dt">Entry</span> <span class="op">@</span><span class="dv">3</span> <span class="ch">&#39;b&#39;</span> (<span class="dt">SCons</span> <span class="dt">Entry</span> <span class="op">@</span><span class="dv">4</span> <span class="ch">&#39;d&#39;</span> (<span class="dt">SCons</span> <span class="dt">Entry</span> <span class="op">@</span><span class="dv">4</span> <span class="ch">&#39;a&#39;</span> (<span class="dt">SSingle</span> <span class="dt">Entry</span> <span class="op">@</span><span class="dv">5</span> <span class="ch">&#39;c&#39;</span>)))</span></code></pre></div>
<p>Finally, a function to convert back down to a normal non-empty list, using GHC’s <code>natVal</code> to “demote” a type-level <code>n :: Nat</code> to a <code>Natural</code></p>
<div class="sourceCode" id="cb57"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb57-1"><a href="#cb57-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/type-levels/Level6.hs#L137-L140</span></span>
<span id="cb57-2"><a href="#cb57-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-3"><a href="#cb57-3" aria-hidden="true" tabindex="-1"></a><span class="ot">fromSorted ::</span> <span class="kw">forall</span> n a<span class="op">.</span> <span class="dt">KnownNat</span> n <span class="ot">=&gt;</span> <span class="dt">Sorted</span> n a <span class="ot">-&gt;</span> <span class="dt">NonEmpty</span> (<span class="dt">Natural</span>, a)</span>
<span id="cb57-4"><a href="#cb57-4" aria-hidden="true" tabindex="-1"></a>fromSorted <span class="ot">=</span> \<span class="kw">case</span></span>
<span id="cb57-5"><a href="#cb57-5" aria-hidden="true" tabindex="-1"></a>  <span class="dt">SSingle</span> (<span class="dt">Entry</span> x) <span class="ot">-&gt;</span> (natVal (<span class="dt">Proxy</span> <span class="op">@</span>n), x) <span class="op">:|</span> []</span>
<span id="cb57-6"><a href="#cb57-6" aria-hidden="true" tabindex="-1"></a>  <span class="dt">SCons</span> (<span class="dt">Entry</span> x) xs <span class="ot">-&gt;</span> (natVal (<span class="dt">Proxy</span> <span class="op">@</span>n), x) <span class="op">NE.&lt;|</span> fromSorted xs</span></code></pre></div>
<h2 id="level-7-global-structure-enforced-list">Level 7: Global structure Enforced List</h2>
<p><em><a href="https://github.com/mstksg/inCode/tree/master/code-samples/type-levels/Level7.hs">Code available here</a></em></p>
<p>For our final level, let’s imagine a “weighted list” of <code>(Int, a)</code> pairs, where each item <code>a</code> has an associated weight or cost. Then, imagine a “bounded weighted list”, where the <em>total cost</em> must not exceed some limit value. Think of it as a list of files and their sizes and a maximum total file size, or a backpack for a character in a video game with a maximum total carrying weight.</p>
<p>There is a fundamental difference here between this type and our last type: we want to enforce a <em>global</em> invariant (total cannot exceed a limit), and we can’t “fake” this using local invariants like last time.</p>
<p>Introducing level 7: enforcing <em>global</em> structure! This brings some extra complexities, similar to the ones we encountered in Level 5 with our fixed-length lists: whatever phantom type we use to enforce this “global” invariant now becomes entangled to the overall structure of our data type itself.</p>
<p>Let’s re-use our <code>Entry</code> type, but interpret an <code>Entry n a</code> as a value of type <code>a</code> with a weight <code>n</code>. Now, we’ll again “let McBride be our guide” and ask the same question we asked before: what “type-safe” operation do we want, and what minimal phantom types do we need to allow this type-safe operation? In our case, we want to <em>insert</em> into our bounded weighted list in a safe way, to ensure that there is enough room. So, we need <em>two</em> phantom types:</p>
<ol type="1">
<li>One phantom type <code>lim</code> to establish the maximum weight of our container</li>
<li>Another phantom type <code>n</code> to establish the current used capacity of our container.</li>
</ol>
<p>We want <code>Bounded lim n a</code>:</p>
<div class="sourceCode" id="cb58"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb58-1"><a href="#cb58-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/type-levels/Level7.hs#L24-L31</span></span>
<span id="cb58-2"><a href="#cb58-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-3"><a href="#cb58-3" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Bounded</span><span class="ot"> ::</span> <span class="dt">Nat</span> <span class="ot">-&gt;</span> <span class="dt">Nat</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="kw">where</span></span>
<span id="cb58-4"><a href="#cb58-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">BNil</span><span class="ot"> ::</span> <span class="dt">Bounded</span> lim <span class="dv">0</span> a</span>
<span id="cb58-5"><a href="#cb58-5" aria-hidden="true" tabindex="-1"></a>  <span class="dt">BCons</span> <span class="ot">::</span></span>
<span id="cb58-6"><a href="#cb58-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">forall</span> n m lim a<span class="op">.</span></span>
<span id="cb58-7"><a href="#cb58-7" aria-hidden="true" tabindex="-1"></a>    (<span class="dt">KnownNat</span> m, n <span class="op">+</span> m <span class="op">&lt;=</span> lim) <span class="ot">=&gt;</span></span>
<span id="cb58-8"><a href="#cb58-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Entry</span> n a <span class="ot">-&gt;</span></span>
<span id="cb58-9"><a href="#cb58-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Bounded</span> lim m a <span class="ot">-&gt;</span></span>
<span id="cb58-10"><a href="#cb58-10" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Bounded</span> lim (n <span class="op">+</span> m) a</span></code></pre></div>
<ul>
<li>The empty bounded container <code>BNil :: lim 0 a</code> can satisfy <em>any</em> <code>lim</code>, and has weight 0.</li>
<li>If we have a <code>Bounded lim m a</code>, then we can add an <code>Entry n a</code> to get a <code>Bounded lim (m + n) a</code> provided that <code>m + n &lt;= lim</code> using <code>BCons</code>.</li>
</ul>
<p>Let’s try this out by seeing how the end user would “maybe insert” into a bounded list of it had enough capacity:</p>
<div class="sourceCode" id="cb59"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb59-1"><a href="#cb59-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/type-levels/Level7.hs#L133-L145</span></span>
<span id="cb59-2"><a href="#cb59-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb59-3"><a href="#cb59-3" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">SomeBounded</span><span class="ot"> ::</span> <span class="dt">Nat</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="kw">where</span></span>
<span id="cb59-4"><a href="#cb59-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">SomeBounded</span><span class="ot"> ::</span> <span class="dt">KnownNat</span> n <span class="ot">=&gt;</span> <span class="dt">Bounded</span> lim n a <span class="ot">-&gt;</span> <span class="dt">SomeBounded</span> lim a</span>
<span id="cb59-5"><a href="#cb59-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb59-6"><a href="#cb59-6" aria-hidden="true" tabindex="-1"></a><span class="ot">insertSomeBounded ::</span></span>
<span id="cb59-7"><a href="#cb59-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">forall</span> lim n a<span class="op">.</span></span>
<span id="cb59-8"><a href="#cb59-8" aria-hidden="true" tabindex="-1"></a>  (<span class="dt">KnownNat</span> lim, <span class="dt">KnownNat</span> n) <span class="ot">=&gt;</span></span>
<span id="cb59-9"><a href="#cb59-9" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Entry</span> n a <span class="ot">-&gt;</span></span>
<span id="cb59-10"><a href="#cb59-10" aria-hidden="true" tabindex="-1"></a>  <span class="dt">SomeBounded</span> lim a <span class="ot">-&gt;</span></span>
<span id="cb59-11"><a href="#cb59-11" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Maybe</span> (<span class="dt">SomeBounded</span> lim a)</span>
<span id="cb59-12"><a href="#cb59-12" aria-hidden="true" tabindex="-1"></a>insertSomeBounded x (<span class="dt">SomeBounded</span> <span class="op">@</span>m xs) <span class="ot">=</span> <span class="kw">case</span> cmpNat (<span class="dt">Proxy</span> <span class="op">@</span>(n <span class="op">+</span> m)) (<span class="dt">Proxy</span> <span class="op">@</span>lim) <span class="kw">of</span></span>
<span id="cb59-13"><a href="#cb59-13" aria-hidden="true" tabindex="-1"></a>  <span class="dt">LTI</span> <span class="ot">-&gt;</span> <span class="dt">Just</span> <span class="op">$</span> <span class="dt">SomeBounded</span> (<span class="dt">BCons</span> x xs)</span>
<span id="cb59-14"><a href="#cb59-14" aria-hidden="true" tabindex="-1"></a>  <span class="dt">EQI</span> <span class="ot">-&gt;</span> <span class="dt">Just</span> <span class="op">$</span> <span class="dt">SomeBounded</span> (<span class="dt">BCons</span> x xs)</span>
<span id="cb59-15"><a href="#cb59-15" aria-hidden="true" tabindex="-1"></a>  <span class="dt">GTI</span> <span class="ot">-&gt;</span> <span class="dt">Nothing</span></span></code></pre></div>
<p>First we match on the <code>SomeBounded</code> to see what the current capacity <code>m</code> is. Then we check using <code>cmpNat</code> to see if the <code>Bounded</code> can hold <code>m + n</code>. If it does, we can return successfully. Note that we define <code>SomeBounded</code> using GADT syntax so we can precisely control the order of the type variables, so <code>SomeBounded @m xs</code> binds <code>m</code> to the capacity of the inner list.</p>
<p>Remember in this case that the <em>end user</em> here isn’t necessarily using the phantom types to their advantage (except for <code>lim</code>, which could be useful). Instead, it’s <em>us</em> who is going to be using <code>n</code> to ensure that if we ever <em>create</em> any <code>Bounded</code> (or <code>SomeBounded</code>), it will <em>always</em> be within capacity <em>by construction</em>.</p>
<p>Now that the usage makes sense, let’s jump in and write some type-safe functions using our fancy phantom types!</p>
<p>First, let’s notice that we can always “resize” our <code>Bounded lim n a</code> to a <code>Bounded lim' n a</code> as long as the total usage <code>n</code> fits within the new carrying capacity:</p>
<div class="sourceCode" id="cb60"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb60-1"><a href="#cb60-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/type-levels/Level7.hs#L35-L38</span></span>
<span id="cb60-2"><a href="#cb60-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb60-3"><a href="#cb60-3" aria-hidden="true" tabindex="-1"></a><span class="ot">reBounded ::</span> <span class="kw">forall</span> lim lim&#39; n a<span class="op">.</span> n <span class="op">&lt;=</span> lim&#39; <span class="ot">=&gt;</span> <span class="dt">Bounded</span> lim n a <span class="ot">-&gt;</span> <span class="dt">Bounded</span> lim&#39; n a</span>
<span id="cb60-4"><a href="#cb60-4" aria-hidden="true" tabindex="-1"></a>reBounded <span class="ot">=</span> \<span class="kw">case</span></span>
<span id="cb60-5"><a href="#cb60-5" aria-hidden="true" tabindex="-1"></a>  <span class="dt">BNil</span> <span class="ot">-&gt;</span> <span class="dt">BNil</span></span>
<span id="cb60-6"><a href="#cb60-6" aria-hidden="true" tabindex="-1"></a>  <span class="dt">BCons</span> x xs <span class="ot">-&gt;</span> <span class="dt">BCons</span> x (reBounded xs)</span></code></pre></div>
<p>Note that we have full type safety here! GHC will prevent us from using <code>reBounded</code> if we pick a new <code>lim</code> that is <em>less</em> than what the bag currently weighs! You’ll also see the general pattern here that changing any “global” properties for our type here will require recursing over the entire structure to adjust the global property.</p>
<p>How about a function to combine two bags of the same weight? Well, this should be legal as long as the new combined weight is still within the limit:</p>
<div class="sourceCode" id="cb61"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb61-1"><a href="#cb61-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/type-levels/Level7.hs#L48-L56</span></span>
<span id="cb61-2"><a href="#cb61-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-3"><a href="#cb61-3" aria-hidden="true" tabindex="-1"></a><span class="ot">concatBounded ::</span></span>
<span id="cb61-4"><a href="#cb61-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">forall</span> n m lim a<span class="op">.</span></span>
<span id="cb61-5"><a href="#cb61-5" aria-hidden="true" tabindex="-1"></a>  (<span class="dt">KnownNat</span> n, <span class="dt">KnownNat</span> m, <span class="dt">KnownNat</span> lim, n <span class="op">+</span> m <span class="op">&lt;=</span> lim) <span class="ot">=&gt;</span></span>
<span id="cb61-6"><a href="#cb61-6" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Bounded</span> lim n a <span class="ot">-&gt;</span></span>
<span id="cb61-7"><a href="#cb61-7" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Bounded</span> lim m a <span class="ot">-&gt;</span></span>
<span id="cb61-8"><a href="#cb61-8" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Bounded</span> lim (n <span class="op">+</span> m) a</span>
<span id="cb61-9"><a href="#cb61-9" aria-hidden="true" tabindex="-1"></a>concatBounded <span class="ot">=</span> \<span class="kw">case</span></span>
<span id="cb61-10"><a href="#cb61-10" aria-hidden="true" tabindex="-1"></a>  <span class="dt">BNil</span> <span class="ot">-&gt;</span> <span class="fu">id</span></span>
<span id="cb61-11"><a href="#cb61-11" aria-hidden="true" tabindex="-1"></a>  <span class="dt">BCons</span> <span class="op">@</span>x <span class="op">@</span>xs x xs <span class="ot">-&gt;</span> <span class="dt">BCons</span> x <span class="op">.</span> concatBounded xs</span></code></pre></div>
<div class="note">
<p><strong>Aside</strong></p>
<p>This is completely unrelated to the topic at hand, but if you’re a big nerd like me, you might enjoy the fact that this function makes <code>Bounded lim n a</code> the <em>arrows</em> of a <a href="https://ncatlab.org/nlab/show/category">Category</a> whose <em>objects</em> are the natural numbers less than or equal to <code>lim</code>, the identity arrow is <code>BNil</code>, and arrow composition is <code>concatBounded</code>. Between object <code>n</code> and <code>m</code>, if <code>n &lt;= m</code>, its arrows are values of type <code>Bounded lim (m - n) a</code>. Actually wait, it’s the same thing with <code>Vec</code> and <code>vconcat</code> above isn’t it? I guess we were moving so fast that I didn’t have time to realize it.</p>
<p>Anyway this is related to the <a href="https://ncatlab.org/nlab/show/preorder">preorder category</a>, but not thin. A thicc preorder category, if you will. Always nice to spot a category out there in the wild.</p>
</div>
<p>It should be noted that the reason that <code>reBounded</code> and <code>concatBounded</code> look so clean so fresh is that we are heavily leveraging typechecker plugins. But, these are all still possible with normal functions if we construct the witnesses explicitly.</p>
<p>Now for a function within our business logic, let’s write <code>takeBounded</code>, which <em>constricts</em> a <code>Bounded lim n a</code> to a <code>Bounded lim' q a</code> with a smaller limit <code>lim'</code>, where <code>q</code> is the weight of <em>all of the elements that fit in the new limit</em>. For example, if we had a bag of limit 15 containing items weighing 4, 3, and 5 (total 12), but we wanted to <code>takeBounded</code> with a new limit 10, we would take the 4 and 3 items, but leave behind the 5 item, to get a new total weight of 7.</p>
<p>It’d be nice to have a helper data type to existentially wrap the new <code>q</code> weight in our return type:</p>
<div class="sourceCode" id="cb62"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb62-1"><a href="#cb62-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/type-levels/Level7.hs#L113-L118</span></span>
<span id="cb62-2"><a href="#cb62-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb62-3"><a href="#cb62-3" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">TakeBounded</span><span class="ot"> ::</span> <span class="dt">Nat</span> <span class="ot">-&gt;</span> <span class="dt">Nat</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="kw">where</span></span>
<span id="cb62-4"><a href="#cb62-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">TakeBounded</span> <span class="ot">::</span></span>
<span id="cb62-5"><a href="#cb62-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">forall</span> q lim n a<span class="op">.</span></span>
<span id="cb62-6"><a href="#cb62-6" aria-hidden="true" tabindex="-1"></a>    (<span class="dt">KnownNat</span> q, q <span class="op">&lt;=</span> n) <span class="ot">=&gt;</span></span>
<span id="cb62-7"><a href="#cb62-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Bounded</span> lim q a <span class="ot">-&gt;</span></span>
<span id="cb62-8"><a href="#cb62-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">TakeBounded</span> lim n a</span></code></pre></div>
<p>So the type of <code>takeBounded</code> would be:</p>
<div class="sourceCode" id="cb63"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb63-1"><a href="#cb63-1" aria-hidden="true" tabindex="-1"></a><span class="ot">takeBounded ::</span></span>
<span id="cb63-2"><a href="#cb63-2" aria-hidden="true" tabindex="-1"></a>  (<span class="dt">KnownNat</span> lim, <span class="dt">KnownNat</span> lim&#39;, <span class="dt">KnownNat</span> n) <span class="ot">=&gt;</span></span>
<span id="cb63-3"><a href="#cb63-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Bounded</span> lim n a <span class="ot">-&gt;</span></span>
<span id="cb63-4"><a href="#cb63-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">TakeBounded</span> lim&#39; n a</span></code></pre></div>
<p>Again I’m going to introduce some helper functions that will make sense soon:</p>
<div class="sourceCode" id="cb64"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb64-1"><a href="#cb64-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/type-levels/Level7.hs#L40-L46</span></span>
<span id="cb64-2"><a href="#cb64-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb64-3"><a href="#cb64-3" aria-hidden="true" tabindex="-1"></a><span class="ot">bConsExpand ::</span> <span class="dt">KnownNat</span> m <span class="ot">=&gt;</span> <span class="dt">Entry</span> n a <span class="ot">-&gt;</span> <span class="dt">Bounded</span> lim m a <span class="ot">-&gt;</span> <span class="dt">Bounded</span> (n <span class="op">+</span> lim) (n <span class="op">+</span> m) a</span>
<span id="cb64-4"><a href="#cb64-4" aria-hidden="true" tabindex="-1"></a>bConsExpand x xs <span class="ot">=</span> withBoundedWit xs <span class="op">$</span> <span class="dt">BCons</span> x (reBounded xs)</span>
<span id="cb64-5"><a href="#cb64-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb64-6"><a href="#cb64-6" aria-hidden="true" tabindex="-1"></a><span class="ot">withBoundedWit ::</span> <span class="dt">Bounded</span> lim n a <span class="ot">-&gt;</span> (n <span class="op">&lt;=</span> lim <span class="ot">=&gt;</span> r) <span class="ot">-&gt;</span> r</span>
<span id="cb64-7"><a href="#cb64-7" aria-hidden="true" tabindex="-1"></a>withBoundedWit <span class="ot">=</span> \<span class="kw">case</span></span>
<span id="cb64-8"><a href="#cb64-8" aria-hidden="true" tabindex="-1"></a>  <span class="dt">BNil</span> <span class="ot">-&gt;</span> \x <span class="ot">-&gt;</span> x</span>
<span id="cb64-9"><a href="#cb64-9" aria-hidden="true" tabindex="-1"></a>  <span class="dt">BCons</span> _ _ <span class="ot">-&gt;</span> \x <span class="ot">-&gt;</span> x</span></code></pre></div>
<p>From the type, we can see <code>bCons</code> adds a new item while also increasing the limit: <code>bConsExpand :: Entry n a -&gt; Bounded lim m a -&gt; Bounded (n + lim) (n + m) a</code>. This is always safe conceptually because we can always add a new item into any bag if we increase the limit of the bag: <code>Entry 100 a -&gt; Bounded 5 3 a -&gt; Bounded 105 103 a</code>, for instance.</p>
<p>Next, you’ll notice that if we write this as <code>BCons x (reBounded xs)</code> alone, we’ll get a GHC error complaining that this requires <code>m &lt;= lim</code>. This is something that we <em>know</em> has to be true (by construction), since there isn’t any constructor of <code>Bounded</code> that will give us a total weight <code>m</code> bigger than the limit <code>lim</code>. However, this requires a bit of witness manipulation for GHC to <em>know</em> this: we have to essentially enumerate over every constructor, and within each constructor GHC knows that <code>m &lt;= lim</code> holds. This is what <code>withBoundedWit</code> does. We “know” <code>n &lt;= lim</code>, we just need to enumerate over the constructors of <code>Bounded lim n a</code> so GHC is happy in every case.</p>
<p><code>withBoundedWit</code>’s type might be a little confusing if this is the first time you’ve seen an argument of the form <code>(constraint =&gt; r)</code>: it takes a <code>Bounded lim n a</code> and a “value that is only possible if <code>n &lt;= lim</code>”, and then gives you that value.</p>
<p>With that, we’re ready:</p>
<div class="sourceCode" id="cb65"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb65-1"><a href="#cb65-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/type-levels/Level7.hs#L120-L131</span></span>
<span id="cb65-2"><a href="#cb65-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-3"><a href="#cb65-3" aria-hidden="true" tabindex="-1"></a><span class="ot">takeBounded ::</span></span>
<span id="cb65-4"><a href="#cb65-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">forall</span> lim lim&#39; n a<span class="op">.</span></span>
<span id="cb65-5"><a href="#cb65-5" aria-hidden="true" tabindex="-1"></a>  (<span class="dt">KnownNat</span> lim, <span class="dt">KnownNat</span> lim&#39;, <span class="dt">KnownNat</span> n) <span class="ot">=&gt;</span></span>
<span id="cb65-6"><a href="#cb65-6" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Bounded</span> lim n a <span class="ot">-&gt;</span></span>
<span id="cb65-7"><a href="#cb65-7" aria-hidden="true" tabindex="-1"></a>  <span class="dt">TakeBounded</span> lim&#39; n a</span>
<span id="cb65-8"><a href="#cb65-8" aria-hidden="true" tabindex="-1"></a>takeBounded <span class="ot">=</span> \<span class="kw">case</span></span>
<span id="cb65-9"><a href="#cb65-9" aria-hidden="true" tabindex="-1"></a>  <span class="dt">BNil</span> <span class="ot">-&gt;</span> <span class="dt">TakeBounded</span> <span class="dt">BNil</span></span>
<span id="cb65-10"><a href="#cb65-10" aria-hidden="true" tabindex="-1"></a>  <span class="dt">BCons</span> <span class="op">@</span>x <span class="op">@</span>xs x xs <span class="ot">-&gt;</span> <span class="kw">case</span> cmpNat (<span class="dt">Proxy</span> <span class="op">@</span>x) (<span class="dt">Proxy</span> <span class="op">@</span>lim&#39;) <span class="kw">of</span></span>
<span id="cb65-11"><a href="#cb65-11" aria-hidden="true" tabindex="-1"></a>    <span class="dt">LTI</span> <span class="ot">-&gt;</span> <span class="kw">case</span> takeBounded <span class="op">@</span>lim <span class="op">@</span>(lim&#39; <span class="op">-</span> x) xs <span class="kw">of</span></span>
<span id="cb65-12"><a href="#cb65-12" aria-hidden="true" tabindex="-1"></a>      <span class="dt">TakeBounded</span> <span class="op">@</span>q ys <span class="ot">-&gt;</span> <span class="dt">TakeBounded</span> <span class="op">@</span>(x <span class="op">+</span> q) (bConsExpand x ys)</span>
<span id="cb65-13"><a href="#cb65-13" aria-hidden="true" tabindex="-1"></a>    <span class="dt">EQI</span> <span class="ot">-&gt;</span> <span class="dt">TakeBounded</span> (<span class="dt">BCons</span> x <span class="dt">BNil</span>)</span>
<span id="cb65-14"><a href="#cb65-14" aria-hidden="true" tabindex="-1"></a>    <span class="dt">GTI</span> <span class="ot">-&gt;</span> <span class="dt">TakeBounded</span> <span class="dt">BNil</span></span></code></pre></div>
<p>Thanks to the types, we ensure that the returned bag must contain <em>at most</em> <code>lim'</code>!</p>
<p>As an exercise, try writing <code>splitBounded</code>, which is like <code>takeBounded</code> but also returns the items that were leftover. <a href="https://github.com/mstksg/inCode/tree/master/code-samples/type-levels/Level7.hs#L99-L111">Solution here.</a></p>
<div class="sourceCode" id="cb66"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb66-1"><a href="#cb66-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/type-levels/Level7.hs#L91-L103</span></span>
<span id="cb66-2"><a href="#cb66-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb66-3"><a href="#cb66-3" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">SplitBounded</span><span class="ot"> ::</span> <span class="dt">Nat</span> <span class="ot">-&gt;</span> <span class="dt">Nat</span> <span class="ot">-&gt;</span> <span class="dt">Nat</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="kw">where</span></span>
<span id="cb66-4"><a href="#cb66-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">SplitBounded</span> <span class="ot">::</span></span>
<span id="cb66-5"><a href="#cb66-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">forall</span> q lim lim&#39; n a<span class="op">.</span></span>
<span id="cb66-6"><a href="#cb66-6" aria-hidden="true" tabindex="-1"></a>    (<span class="dt">KnownNat</span> q, q <span class="op">&lt;=</span> n) <span class="ot">=&gt;</span></span>
<span id="cb66-7"><a href="#cb66-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Bounded</span> lim&#39; q a <span class="ot">-&gt;</span></span>
<span id="cb66-8"><a href="#cb66-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Bounded</span> lim (n <span class="op">-</span> q) a <span class="ot">-&gt;</span></span>
<span id="cb66-9"><a href="#cb66-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">SplitBounded</span> lim lim&#39; n a</span>
<span id="cb66-10"><a href="#cb66-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb66-11"><a href="#cb66-11" aria-hidden="true" tabindex="-1"></a><span class="ot">splitBounded ::</span></span>
<span id="cb66-12"><a href="#cb66-12" aria-hidden="true" tabindex="-1"></a>  <span class="kw">forall</span> lim lim&#39; n a<span class="op">.</span></span>
<span id="cb66-13"><a href="#cb66-13" aria-hidden="true" tabindex="-1"></a>  (<span class="dt">KnownNat</span> lim, <span class="dt">KnownNat</span> lim&#39;, <span class="dt">KnownNat</span> n) <span class="ot">=&gt;</span></span>
<span id="cb66-14"><a href="#cb66-14" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Bounded</span> lim n a <span class="ot">-&gt;</span></span>
<span id="cb66-15"><a href="#cb66-15" aria-hidden="true" tabindex="-1"></a>  <span class="dt">SplitBounded</span> lim lim&#39; n a</span></code></pre></div>
<p>One final example, how about a function that <em>reverses</em> the <code>Bounded lim n a</code>? We’re going to write a “single-pass reverse”, similar to how it’s often written for lists:</p>
<div class="sourceCode" id="cb67"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb67-1"><a href="#cb67-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/type-levels/Level7.hs#L68-L73</span></span>
<span id="cb67-2"><a href="#cb67-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb67-3"><a href="#cb67-3" aria-hidden="true" tabindex="-1"></a><span class="ot">reverseList ::</span> [a] <span class="ot">-&gt;</span> [a]</span>
<span id="cb67-4"><a href="#cb67-4" aria-hidden="true" tabindex="-1"></a>reverseList <span class="ot">=</span> go []</span>
<span id="cb67-5"><a href="#cb67-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb67-6"><a href="#cb67-6" aria-hidden="true" tabindex="-1"></a>    go res <span class="ot">=</span> \<span class="kw">case</span></span>
<span id="cb67-7"><a href="#cb67-7" aria-hidden="true" tabindex="-1"></a>      [] <span class="ot">-&gt;</span> res</span>
<span id="cb67-8"><a href="#cb67-8" aria-hidden="true" tabindex="-1"></a>      x <span class="op">:</span> xs <span class="ot">-&gt;</span> go (x <span class="op">:</span> res) xs</span></code></pre></div>
<p>Now, reversing a <code>Bounded</code> should be legal, because reversing the order of the items shouldn’t change the total weight. However, we basically “invert” the structure of the <code>Bounded</code> type, which, depending on how we set up our phantom types, could mean a lot of witness reshuffling. Luckily, our typechecker plugin handles most of it for us in this case, but it exposes one gap:</p>
<div class="sourceCode" id="cb68"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb68-1"><a href="#cb68-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/type-levels/Level7.hs#L58-L89</span></span>
<span id="cb68-2"><a href="#cb68-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb68-3"><a href="#cb68-3" aria-hidden="true" tabindex="-1"></a><span class="ot">reverseBounded ::</span></span>
<span id="cb68-4"><a href="#cb68-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">forall</span> lim n a<span class="op">.</span> (n <span class="op">&lt;=</span> lim, <span class="dt">KnownNat</span> lim, <span class="dt">KnownNat</span> n) <span class="ot">=&gt;</span> <span class="dt">Bounded</span> lim n a <span class="ot">-&gt;</span> <span class="dt">Bounded</span> lim n a</span>
<span id="cb68-5"><a href="#cb68-5" aria-hidden="true" tabindex="-1"></a>reverseBounded <span class="ot">=</span> go <span class="dt">BNil</span></span>
<span id="cb68-6"><a href="#cb68-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb68-7"><a href="#cb68-7" aria-hidden="true" tabindex="-1"></a><span class="ot">    go ::</span></span>
<span id="cb68-8"><a href="#cb68-8" aria-hidden="true" tabindex="-1"></a>      <span class="kw">forall</span> m q<span class="op">.</span></span>
<span id="cb68-9"><a href="#cb68-9" aria-hidden="true" tabindex="-1"></a>      (<span class="dt">KnownNat</span> m, <span class="dt">KnownNat</span> q, m <span class="op">&lt;=</span> lim, m <span class="op">+</span> q <span class="op">&lt;=</span> lim) <span class="ot">=&gt;</span></span>
<span id="cb68-10"><a href="#cb68-10" aria-hidden="true" tabindex="-1"></a>      <span class="dt">Bounded</span> lim m a <span class="ot">-&gt;</span></span>
<span id="cb68-11"><a href="#cb68-11" aria-hidden="true" tabindex="-1"></a>      <span class="dt">Bounded</span> lim q a <span class="ot">-&gt;</span></span>
<span id="cb68-12"><a href="#cb68-12" aria-hidden="true" tabindex="-1"></a>      <span class="dt">Bounded</span> lim (m <span class="op">+</span> q) a</span>
<span id="cb68-13"><a href="#cb68-13" aria-hidden="true" tabindex="-1"></a>    go res <span class="ot">=</span> \<span class="kw">case</span></span>
<span id="cb68-14"><a href="#cb68-14" aria-hidden="true" tabindex="-1"></a>      <span class="dt">BNil</span> <span class="ot">-&gt;</span> res</span>
<span id="cb68-15"><a href="#cb68-15" aria-hidden="true" tabindex="-1"></a>      <span class="dt">BCons</span> <span class="op">@</span>x <span class="op">@</span>xs x xs <span class="ot">-&gt;</span></span>
<span id="cb68-16"><a href="#cb68-16" aria-hidden="true" tabindex="-1"></a>        solveLte <span class="op">@</span>m <span class="op">@</span>q <span class="op">@</span>x <span class="op">@</span>lim <span class="op">$</span></span>
<span id="cb68-17"><a href="#cb68-17" aria-hidden="true" tabindex="-1"></a>          go <span class="op">@</span>(x <span class="op">+</span> m) <span class="op">@</span>xs (<span class="dt">BCons</span> <span class="op">@</span>x <span class="op">@</span>m x res) xs</span>
<span id="cb68-18"><a href="#cb68-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb68-19"><a href="#cb68-19" aria-hidden="true" tabindex="-1"></a><span class="ot">solveLte ::</span></span>
<span id="cb68-20"><a href="#cb68-20" aria-hidden="true" tabindex="-1"></a>  <span class="kw">forall</span> a b c n r<span class="op">.</span></span>
<span id="cb68-21"><a href="#cb68-21" aria-hidden="true" tabindex="-1"></a>  (<span class="dt">KnownNat</span> a, <span class="dt">KnownNat</span> c, <span class="dt">KnownNat</span> n, a <span class="op">+</span> b <span class="op">&lt;=</span> n, c <span class="op">&lt;=</span> b) <span class="ot">=&gt;</span></span>
<span id="cb68-22"><a href="#cb68-22" aria-hidden="true" tabindex="-1"></a>  (a <span class="op">+</span> c <span class="op">&lt;=</span> n <span class="ot">=&gt;</span> r) <span class="ot">-&gt;</span></span>
<span id="cb68-23"><a href="#cb68-23" aria-hidden="true" tabindex="-1"></a>  r</span>
<span id="cb68-24"><a href="#cb68-24" aria-hidden="true" tabindex="-1"></a>solveLte x <span class="ot">=</span> <span class="kw">case</span> cmpNat (<span class="dt">Proxy</span> <span class="op">@</span>(a <span class="op">+</span> c)) (<span class="dt">Proxy</span> <span class="op">@</span>n) <span class="kw">of</span></span>
<span id="cb68-25"><a href="#cb68-25" aria-hidden="true" tabindex="-1"></a>  <span class="dt">LTI</span> <span class="ot">-&gt;</span> x</span>
<span id="cb68-26"><a href="#cb68-26" aria-hidden="true" tabindex="-1"></a>  <span class="dt">EQI</span> <span class="ot">-&gt;</span> x</span>
<span id="cb68-27"><a href="#cb68-27" aria-hidden="true" tabindex="-1"></a>  <span class="dt">GTI</span> <span class="ot">-&gt;</span> <span class="fu">error</span> <span class="st">&quot;absurd: if a + b &lt;= n and c &lt; b, the a + c can&#39;t &gt; n&quot;</span></span></code></pre></div>
<p>Due to how everything gets exposed, we need to prove that if <code>a + b &lt;= n</code> and <code>c &lt;= b</code>, then <code>a + c &lt;= n</code>. This is always true, but the typechecker plugin needs a bit of help, and we have to resort to an unsafe operation to get this to work. However, if we were using our manually constructed inductive types instead of GHC’s opaque ones, we could write this in a type-safe and total way. We run into these kinds of issues a lot more often with global invariants than we do with local invariants, because the invariant phantom becomes so entangled with the structure of our data type.</p>
<p>And…that’s about as far as we’re going to go with this final level! If this type of programming with structural invariants is appealing to you, check out Conor McBride’s famous <a href="https://personal.cis.strath.ac.uk/conor.mcbride/Pivotal.pdf">type-safe red-black trees in Haskell</a> paper, or Edwin Brady’s <a href="https://www.manning.com/books/type-driven-development-with-idris">Type-Driven Development in Idris</a> for how to structure entire programs around these principles.</p>
<p>Evident from the fact that Conor’s work is in Agda, and Brady’s in Idris, you can tell that in doing this, we are definitely pushing the boundaries of what is ergonomic to write in Haskell. Well, depending on who you ask, we already zipped that boundary long ago. Still, there’s definitely a certain kind of joy to defining invariants in your data types and then essentially <em>proving</em> to the compiler that you’ve followed them. But, most people will be happier just writing a property test to fuzz the implementation on a non type-safe structure. And some will be happy with…unit tests. Ha ha ha ha. Good joke right?</p>
<p>Anyway, hope you enjoyed the ride! I hope you found some new ideas for ways to write your code in the future, or at least found them interesting or eye-opening. Again, none of the data structures here are presented to be practically useful as-is — the point is more to present these typing principles and mechanics in a fun manner and to inspire a sense of wonder.</p>
<p>Which level is your favorite, and what level do you <em>wish</em> you could work at if things got a little more ergonomic?</p>
<h2 id="special-thanks">Special Thanks</h2>
<p>I am very humbled to be supported by an amazing community, who make it possible for me to devote time to researching and writing these posts. Very special thanks to my supporter at the “Amazing” level on <a href="https://www.patreon.com/justinle/overview">patreon</a>, Josh Vera! :)</p>
<section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes">
<hr />
<ol>
<li id="fn1"><p>Luke’s blog has been known to switch back and forth from private to non-private, so I will link to the official post and respect the decision of the author on whether or not it should be visible. However, the term itself is quite commonly used and if you search for it online you will find much discussion about it.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p>Note that I don’t really like calling these “vectors” any more, because in a computer science context the word vector carries implications of contiguous-memory storage. “Lists” of fixed length is the more appropriate description here, in my opinion. The term “vector” for this concept arises from linear algebra, where a vector is inherently defined by its vector <em>space</em>, which <a href="https://en.wikipedia.org/wiki/Dimension_theorem_for_vector_spaces">does have an inherent dimensionality</a>. But we are talking about computer science concepts here, not mathematical concepts, so we should pick the name that provides the most useful implicit connotations.<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section></div><footer><hr><div class="copy-content"><p>Hi, thanks for reading! You can reach me via email at <a href="mailto:justin@jle.im" class="email">justin@jle.im</a>, or at twitter at <a href="https://twitter.com/mstk">@mstk</a>! This post and all others are published under the <a href="https://creativecommons.org/licenses/by-nc-nd/3.0/">CC-BY-NC-ND 3.0</a> license. Corrections and edits via pull request are welcome and encouraged at <a href="https://github.com/mstksg/inCode">the source repository</a>.</p>
<p>If you feel inclined, or this post was particularly helpful for you, why not consider <a href="https://www.patreon.com/justinle/overview">supporting me on Patreon</a>, or a <a href="bitcoin:3D7rmAYgbDnp4gp4rf22THsGt74fNucPDU">BTC donation</a>? :)</p></div><div class="clear"></div><ul class="entry-series"></ul><ul class="tag-list"><li><a href="https://blog.jle.im/entries/tagged/dependent-types.html" class="tag-a-tag">#dependent types</a></li><li><a href="https://blog.jle.im/entries/tagged/functional-programming.html" class="tag-a-tag">#functional programming</a></li><li><a href="https://blog.jle.im/entries/tagged/haskell.html" class="tag-a-tag">#haskell</a></li><li><a href="https://blog.jle.im/entries/tagged/singletons.html" class="tag-a-tag">#singletons</a></li><li><a href="https://blog.jle.im/entries/tagged/types.html" class="tag-a-tag">#types</a></li><li><a href="https://blog.jle.im/entries/category/@haskell.html" class="tag-a-category">@HASKELL</a></li></ul><aside class="social-buttons"><div class="addthis_toolbox addthis_default_style addthis-buttons"><a class="addthis_button_facebook_like" fb:like:layout="button_count"></a><a class="addthis_button_tweet"></a><a class="addthis_button_google_plusone" g:plusone:size="medium"></a><a class="addthis_counter addthis_pill_style"></a></div><div class="custom-social-buttons"><div class="custom-social-button"><a href="https://www.reddit.com/submit" onclick="window.location = &#39;https://www.reddit.com/submit?url=&#39;+ encodeURIComponent(window.location); return false"><img src="https://www.reddit.com/static/spreddit7.gif" alt="submit to reddit"></a></div></div></aside><nav class="next-prev-links"><ul><li class="prev-entry-link">&larr; <a href="https://blog.jle.im/entry/haskell-nuggets-kmeans.html">Haskell Nuggets: k-means</a> (Previous)</li><li class="next-entry-link">(Next) <a href="https://blog.jle.im/entry/physics-math-heritage.html">My Physics and Math Heritage</a> &rarr;</li></ul></nav></footer></article><div class="post-entry"><div class="tile"><div id="disqus_thread"></div><script type="text/javascript">var disqus_config = function () {
    this.page.url = 'https://blog.jle.im/entry/levels-of-type-safety-haskell-lists.html';
    this.page.identifier = 'type-levels';
};
(function() {
    var d = document, s = d.createElement('script');
    s.src = '//incode.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
})();
</script><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a><br></noscript><a href="http://disqus.com" class="dsq-brlink">Comments powered by <span class="logo-disqus">Disqus</span></a></div></div></div></div></div><div id="footer-container"><div id="footer-content"><div class="tile"><div class="footer-copyright">&copy; 2020 Justin Le <span class="license-link">(<a href="https://creativecommons.org/licenses/by-nc-nd/3.0/" class="license">CC-BY-NC-ND 3.0</a>)</span></div><div class="footer-follow social-follows"><ul class="social-follows-list"><li><ul class="social-follows-list-social"><li><a class="social-follow-twitter" title="Follow me on Twitter!" href="https://twitter.com/intent/user?user_id=mstk" onclick="window.open(
  &#39;http://twitter.com/intent/user?user_id=907281&#39;,
  &#39;facebook-share-dialog&#39;,
  &#39;width=550,height=520&#39;);
return false;
">Twitter</a></li><li><a class="social-follow-github" title="Fork me on Github!" href="https://github.com/mstksg">Github</a></li><li><a class="social-follow-twitch" title="Watch me on Twitch!" href="https://www.twitch.tv/justin_l">Twitch</a></li><li><a class="social-follow-patreon" title="Support me on Patreon!" href="https://www.patreon.com/justinle/overview">Patreon</a></li><li><a class="social-follow-gplus" title="Add me on Google+!" href="https://plus.google.com/+JustinLe">Google+</a></li><li><a class="social-follow-keybase" title="Track me on Keybase!" href="https://keybase.io/mstksg">Keybase</a></li><li><a class="social-follow-linkedin" title="Connect with me on LinkedIn!" href="https://linkedin.com/in/lejustin">LinkedIn</a></li><li><a class="social-follow-bitcoin" title="Donate via bitcoin!" href="bitcoin:3D7rmAYgbDnp4gp4rf22THsGt74fNucPDU">Bitcoin</a></li></ul></li><li><ul class="social-follows-list-site"><li><a class="social-follow-rss" title="Subscribe to my RSS Feed!" href="http://feeds.feedburner.com/incodeblog">RSS</a></li><li><a class="social-follow-email" title="Subscribe to the mailing list!" href="https://feedburner.google.com/fb/a/mailverify?loc=en_US&amp;uri=incodeblog">Mailing list</a></li></ul></li></ul></div></div></div></div></body></html>