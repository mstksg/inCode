<!DOCTYPE HTML>
<html><head><title>Shuffling things up: Applying Group Theory in Advent of Code · in Code</title><meta name="description" content="Weblog of Justin Le, covering various adventures in programming and explorations in the worlds of computation physics, and knowledge.
"><meta http-equiv="Content-Type" content="text/html;charset=utf-8"><meta name="viewport" content="width=device-width,initial-scale=1.0"><meta name="flattr:id" content="3p9jqr"><meta property="og:site_name" content="in Code"><meta property="og:description" content="So it’s November, and Advent of Code season is in the air! It’s time for everyone’s favorite Santa-based light hearted learn-to-program-or-a-new-language holiday season programming challenge series. Every year a bunch of us gather around the fireplace, roast chestnuts, and brainstorm all of the interesting ways we can solve these cute themed puzzles every day. These puzzles are designed to accessible enough for most new programmers, but deep enough to provide entertainment for experienced ones. I’ve written many blog posts on some of the interesting insight some of the puzzles have yielded, and I also post my reflections on as many puzzles I can while solving them in Haskell. And if you’re solving things in Haskell, I also published an open-sourced rate-limited API library so you can fetch and submit answers from the comfort of your command line. To kick off the season, I’ve decided to write about one of my favorite puzzles from Advent of Code 2019 – Day 22: Slam Shuffle. To me, it stands out because it’s a perfect example of how Haskell’s approach to mathematical abstraction nudges you into the direction of an efficient solution — in a way that other languages would obscure or make less obvious. So, let’s dive in! In the end, hopefully this post can get you excited for this wonderful season, and maybe also shed some insight into what it means when we say that Haskell can help you leverage math to find good solutions to your real problems. Of course, this post has spoilers for Advent of Code 2019 Day 22, if you are planning on trying to figure it out from yourself. If you haven’t tried it, I recommend you give it a shot and come back after! :D"><meta property="og:type" content="article"><meta property="og:title" content="Shuffling things up: Applying Group Theory in Advent of Code"><meta property="og:image" content="https://blog.jle.im/img/site_logo.jpg"><meta property="og:locale" content="en_US"><meta property="og:url" content="https://blog.jle.im/entry/shuffling-things-up.html"><meta name="twitter:card" content="summary"><meta name="twitter:creator:id" content="mstk"><link rel="author" href="https://plus.google.com/107705320197444500140"><link rel="alternate" type="application/rss+xml" title="in Code (RSS Feed)" href="http://feeds.feedburner.com/incodeblog"><link rel="canonical" href="https://blog.jle.im/entry/shuffling-things-up.html"><link href="https://blog.jle.im/favicon.ico" rel="shortcut icon"><link href="https://blog.jle.im/css/toast.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/font.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/main.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/page/entry.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/pygments.css" rel="stylesheet" type="text/css"><script type="text/javascript">var page_data = {};
var disqus_shortname='incode';
</script><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-443711-8', 'jle.im');
ga('send', 'pageview');
</script><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script id="MathJax-script" async="" src="https://cdn.jsdelivr.net/npm/mathjax@3.0.1/es5/tex-mml-chtml.js"></script><script type="text/javascript" src="//ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script><script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5234d67a6b68dcd4"></script><script type="text/javascript" src="https://blog.jle.im/js/page/entry_toc.js"></script><script type="text/javascript" src="https://blog.jle.im/js/disqus_count.js"></script><script type="text/javascript" src="https://blog.jle.im/js/social.js"></script><script type="text/javascript" src="https://blog.jle.im/js/jquery/jquery.toc.js"></script><script type="text/javascript" src="https://blog.jle.im/purescript/entry.js"></script></head><body><div id="fb-root"><script>(function(d, s, id) {
 var js, fjs = d.getElementsByTagName(s)[0];
 if (d.getElementById(id)) return;
 js = d.createElement(s); js.id = id;
 js.src = "//connect.facebook.net/en_US/all.js#xfbml=1&appId=641852699171929";
 fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));
</script></div><div id="header-container"><div id="navbar-container" class="tile"><nav id="navbar-content"><div class="nav-info"><h1 class="site-title"><a href="https://blog.jle.im/" class="nav-title">in Code</a></h1><span class="nav-author">Justin Le</span></div><ul class="nav-links"><li><a href="https://blog.jle.im/">home</a></li><li><a href="https://blog.jle.im/entries.html">archives</a></li><li><a href="https://cv.jle.im">cv</a></li><div class="clear"></div></ul></nav></div><div id="header-content"></div></div><div id="body-container" class="container"><div id="main-container" class="grid"><div class="entry-section unit span-grid" role="main"><article class="tile article"><header><h1 id="title">Shuffling things up: Applying Group Theory in Advent of Code</h1><p class="entry-info">by <a class="author" href="https://blog.jle.im/">Justin Le</a><span class="info-separator"> &diams; </span><time datetime="2020-11-18T10:17:52Z" pubdate="" class="pubdate">Wednesday November 18, 2020</time></p><p><span class="source-info"><a class="source-link" href="https://github.com/mstksg/inCode/tree/master/copy/entries/advent-shuffle.md">Source</a><span class="info-separator"> &diams; </span><a class="source-link" href="https://github.com/mstksg/inCode/tree/gh-pages/entry/shuffling-things-up.md">Markdown</a><span class="info-separator"> &diams; </span><a class="source-link" href="https://blog.jle.im/entry/shuffling-things-up.tex">LaTeX</a><span class="info-separator"> &diams; </span></span>Posted in <a href="https://blog.jle.im/entries/category/@haskell.html" class="tag-a-category" title="Functional, pure, non-strict, statically and strongly typed, natively
compiled...really just the king of great languages.
">Haskell</a>, <a href="https://blog.jle.im/entries/category/@math.html" class="tag-a-category" title="@MATH">Math</a><span class="info-separator"> &diams; </span><a class="comment-link" href="#disqus_thread">Comments</a></p></header><hr><aside class="contents-container"><h5 id="contents-header">Contents</h5><div id="toc"></div></aside><div class="main-content copy-content"><p>So it’s November, and <a href="https://adventofcode.com/">Advent of Code</a> season is in the air! It’s time for everyone’s favorite Santa-based light hearted learn-to-program-or-a-new-language holiday season programming challenge series. Every year a bunch of us gather around the fireplace, roast chestnuts, and brainstorm all of the interesting ways we can solve these cute themed puzzles every day. These puzzles are designed to accessible enough for most new programmers, but deep enough to provide entertainment for experienced ones. I’ve <a href="https://blog.jle.im/entries/tagged/advent-of-code.html">written many blog posts</a> on some of the interesting insight some of the puzzles have yielded, and I also <a href="https://github.com/mstksg/advent-of-code-2019/blob/master/reflections.md">post my reflections on as many puzzles I can</a> while solving them in Haskell. And if you’re solving things in Haskell, I also published an <a href="https://hackage.haskell.org/package/advent-of-code-api">open-sourced rate-limited API library</a> so you can fetch and submit answers from the comfort of your command line.</p>
<p>To kick off the season, I’ve decided to write about one of my favorite puzzles from Advent of Code 2019 – <a href="https://adventofcode.com/2019/day/22">Day 22: Slam Shuffle</a>. To me, it stands out because it’s a perfect example of how Haskell’s approach to mathematical abstraction nudges you into the direction of an efficient solution — in a way that other languages would obscure or make less obvious.</p>
<p>So, let’s dive in! In the end, hopefully this post can get you excited for this wonderful season, and maybe also shed some insight into what it means when we say that Haskell can help you leverage math to find good solutions to your real problems.</p>
<p>Of course, this post has spoilers for Advent of Code 2019 Day 22, if you are planning on trying to figure it out from yourself. If you haven’t tried it, I recommend you give it a shot and come back after! :D</p>
<h2 id="slam-shuffle">Slam Shuffle</h2>
<p>If you haven’t already, take some time to <a href="https://adventofcode.com/2019/day/22">read through the problem statement</a>. The basic idea is that we are given a series of operations to “shuffle” a deck of 10007 cards, such as:</p>
<pre><code>deal with increment 7
deal into new stack
deal into new stack
... etc</code></pre>
<p>After performing all of the many operations, the question then asks about the card at a given position (the 2019th card in the deck).</p>
<p>Part 2, which you might not be able to see if you haven’t submitted an answer yet for Part 1, involves the same process with a deck of 119315717514047 cards, and repeating the entire shuffling sequence 101741582076661 times. It then asks you to find the card that ends up at index 2020.</p>
<p>In this problem, it seems we have a list of “shuffles” that we want to run on a deck of cards. However, let’s think about this in a more data-driven approach: instead of thinking about successive shufflings of cards, let’s imagine the specification of a “shuffle” itself as our main data, and how we can combine shuffle operations together into new shuffle operations.</p>
<p>We are looking for “take shuffle A and shuffle B, and return a new shuffle that represents doing B, then A”. This is “shuffle composition”, or “permutation composition” (<a href="https://en.wikipedia.org/wiki/Permutation">permutation</a> being the mathematical word for “shuffling” here, basically)</p>
<p>Since we’ve identified that we want to begin implementing a way of composing/combining permutations together, we can do a bit of reading to learn that one of the most famous properties of permutation composition is that they form a “group”, which means they can be composed (associatively), have an identity, and can be inverted. This means that if you have two permutations, you can “squish” them to create a new permutation, and work with that <em>new</em> permutation.</p>
<p>I’ve talked about <a href="https://blog.jle.im/entry/alchemical-groups.html">using group theory</a> principles before in this blog to help guide us towards solutions and optimizations — the main principle is that if we express our program in terms of group operations, then we can take advantage of the large body of knowledge built up over centuries to understand, analyze, and potentially optimize our program.</p>
<p>The <em>first</em> big advantage in this situation is that we can treat our transformations <em>as data</em>, and not as functions. And that if we have two transformations, we can always create a new one (just a normal data type value) that represents the composition of the two original ones.</p>
<h2 id="now-youre-thinking-with-groups">Now You’re Thinking With Groups</h2>
<p>Knowing permutations are a group, it means that once we settle on our representation of them, <code>Perm</code>, we can write an instance of <code>Perm</code> for <code>Semigroup</code>, <code>Monoid</code>, and <code>Group</code>, abstractions in Haskell that many types are already instances of. Abstractions like <code>Semigroup</code> and <code>Monoid</code> are pretty much an everyday thing in Haskell, so this fits in quite nicely. <code>Group</code> comes from the <em><a href="https://hackage.haskell.org/package/groups">groups</a></em> package, which also provides some nice applications of group theory.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Perm</span> n <span class="ot">=</span> <span class="op">...</span> <span class="co">-- let&#39;s figure out the implementation later, where n is the number of cards</span></span></code></pre></div>
<p>In Haskell, we express things like “<code>Perm</code> is a Semigroup/Monoid/Group” by saying that they are instances of <em>typeclasses</em>, which (for this purpose) are like interfaces in languages like Java.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- | An instance m can be &quot;combined&quot; using `x &lt;&gt; y`</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Semigroup</span> m <span class="kw">where</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="ot">    (&lt;&gt;) ::</span> m <span class="ot">-&gt;</span> m <span class="ot">-&gt;</span> m</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a><span class="co">-- | There is always an identity element for &lt;&gt;:</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a><span class="co">--</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a><span class="co">-- x &lt;&gt; mempty == x</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a><span class="co">-- mempty &lt;&gt; x == x</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a><span class="co">--</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Semigroup</span> m <span class="ot">=&gt;</span> <span class="dt">Monoid</span> m <span class="kw">where</span></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a><span class="ot">    mempty ::</span> m</span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a><span class="co">-- | Every m has an inverse:</span></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a><span class="co">--</span></span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a><span class="co">-- x &lt;&gt; invert x == mempty</span></span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a><span class="co">-- invert x &lt;&gt; x == mempty</span></span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a><span class="co">--</span></span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Monoid</span> m <span class="ot">=&gt;</span> <span class="dt">Group</span> m <span class="kw">where</span></span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a><span class="ot">    invert ::</span> m <span class="ot">-&gt;</span> m</span></code></pre></div>
<p>This means that if <code>Perm</code> is an instance of <code>Group</code> (which has superclasses <code>Semigroup</code> and <code>Monoid</code>), we can:</p>
<ul>
<li>Compose permutations using <code>x &lt;&gt; y</code>, which means “shuffle with strategy <code>y</code>, then with strategy <code>x</code>”</li>
<li>Summon an “identity permutation” where <code>x &lt;&gt; mempty == x</code> (the identity permutation, which is “leave things alone”).</li>
<li>Invert any shuffling (if we have <code>x</code>, we can reverse its effect with <code>invert x</code>)</li>
</ul>
<p>In addition, the standard libraries also give us a useful function <code>stimes</code></p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="ot">stimes ::</span> <span class="dt">Semigroup</span> m <span class="ot">=&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> m <span class="ot">-&gt;</span> m</span></code></pre></div>
<p>which lets us compose <code>x</code> with itself (<code>stimes 5 x == x &lt;&gt; x &lt;&gt; x &lt;&gt; x &lt;&gt; x</code>), but can do it in <em>log(n)</em> time using <a href="https://en.wikipedia.org/wiki/Exponentiation_by_squaring">repeated squaring</a>. It’s extremely efficient in a lot of circumstances (more on that later) — more so than the naive compose-it-n-times implementation. This will definitely become useful in part 2, where we have to do 101741582076661 compositions.</p>
<h2 id="our-gameplan">Our Gameplan</h2>
<p>Just <em>knowing</em> that permutations form a group naturally guides us to these abstractions — we already know what <em>interface</em> our type will have, even before we write any code. We know that no matter <em>what</em> our implementation of permutation will be, we will have <code>(&lt;&gt;)</code>, <code>stimes</code>, <code>mempty</code>, <code>invert</code> available to us to use. So, let’s do just that! We’ll use a stub data type <code>Perm</code> to represent our permutation and “pretend” we have that interface on it. We’ll write our functions first and then fill in the interface later!</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- | Represents a permutation of n cards</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Perm</span> n <span class="ot">=</span> <span class="op">....</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a><span class="co">-- | Given a permutation, find the place where a given index ends up.</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a><span class="ot">runPerm ::</span> <span class="dt">Perm</span> n <span class="ot">-&gt;</span> <span class="dt">Finite</span> n <span class="ot">-&gt;</span> <span class="dt">Finite</span> n</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a><span class="co">-- | Parse a string line into the permutation it represents</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a><span class="ot">parsePerm ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Perm</span> n</span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a><span class="co">-- | Given a permutation list, find the place where 2019 ends up</span></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a><span class="ot">part1 ::</span> [<span class="dt">Perm</span> <span class="dv">10007</span>] <span class="ot">-&gt;</span> <span class="dt">Finite</span> <span class="dv">10007</span></span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a>part1 perms <span class="ot">=</span> runPerm bigPerm <span class="dv">2019</span></span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a>    bigPerm <span class="ot">=</span> <span class="fu">mconcat</span> perms</span></code></pre></div>
<p>(<code>mconcat perms</code> composes all of the permutations one after another: <code>mconcat [x,y,z] = x &lt;&gt; y &lt;&gt; z</code>)</p>
<p>And…that’s it! For the actual “logic” of our part 1! All we need to do is implement <code>runPerm</code> and <code>parsePerm</code>.</p>
<p>Here, I’m using <code>Finite n</code> from the great <em><a href="https://hackage.haskell.org/package/finite-typelits">finite-typelits</a></em> library, where <code>Finite 100</code> represents “an index between 0 and 99”, etc. It’s just exactly the right “shape” to represent the index of a deck of cards. <em>finite-typelits</em> wasn’t designed with group theory in mind, but it’s still a great tool here — which is a testament to how flexible these abstractions can actually be :)</p>
<p>For example, it means that for a <code>Perm 10007</code> (a permutation of 10007 cards), the type of <code>runPerm</code> is <code>Perm 10007 -&gt; Finite 10007 -&gt; Finite 10007</code>, and the type of <code>parsePerm</code> is <code>String -&gt; Perm 10007</code>.</p>
<p>We can plan out our part 2 as well:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- | Given a permutation list, find the index that will end up at 2020</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="ot">part2 ::</span> [<span class="dt">Perm</span> <span class="dv">119315717514047</span>] <span class="ot">-&gt;</span> <span class="dt">Finite</span> <span class="dv">119315717514047</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>part2 perms <span class="ot">=</span> runPerm (invert biiigPerm) <span class="dv">2020</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>    bigPerm   <span class="ot">=</span> <span class="fu">mconcat</span> perms</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>    biiigPerm <span class="ot">=</span> stimes <span class="dv">101741582076661</span> bigPerm</span></code></pre></div>
<p>Part 2, I think, is where the group theory really shines.</p>
<ol type="1">
<li><p>We take advantage of <code>stimes</code>, which uses <a href="https://en.wikipedia.org/wiki/Exponentiation_by_squaring">repeated squaring</a>. That means that to compute <code>stimes 8 x</code>, instead of using</p>
<pre><code>x &lt;&gt; x &lt;&gt; x &lt;&gt; x &lt;&gt; x &lt;&gt; x &lt;&gt; x &lt;&gt; x</code></pre>
<p>it does</p>
<pre><code>let x2 = x &lt;&gt; x
    x4 = x2 &lt;&gt; x2
in  x4 &lt;&gt; x4</code></pre>
<p>essentially cutting down the number of multiplications exponentially. This means that to compute <code>stimes 101741582076661</code>, we only need to do about 47 multiplications (log base 2), and not 101741582076661.</p>
<p>This is only possible because we know that permutation composition is associative, so it doesn’t matter how we associate our parentheses. It is only “safe” to use repeated squaring if you <em>know</em> that your operation is associative. Having a semigroup abstraction <em>in the first place</em> guides us to this efficient solution — in a way that is pre-built just for us! This is made all the more powerful because <em>semigroup</em> is a ubiquitous abstraction in Haskell, so we “think about” it all the time.</p></li>
<li><p>Remember how <code>runPerm p 2019</code> gives us the index that <code>2019</code> is sent to? Well, we want something else in this case. We basically want the index that <em>will be sent to</em> <code>2020</code>. So, we want to <em>reverse the function</em>. Luckily, since our function is just a permutation, it is easy to reverse this: just <code>invert</code> the permutation!</p>
<p>The idea that we can simply invert a permutation instead of having to write a whole new permutation representation just to do “backwards indexing” is something that we are <em>guided to</em>, just by recognizing that permutations form a group.</p></li>
</ol>
<h2 id="a-first-guess-at-implementation">A first guess at implementation</h2>
<p>Now, time to do what we have been putting off and actually write our permutation representation – the definition of <code>Perm n</code>. A good <em>first guess</em> might be to write our permutation as an actual function — a function from index to index, <code>Finite n -&gt; Finite n</code>. Then, we can just use function composition as our permutation composition.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Perm</span> n <span class="ot">=</span> <span class="dt">Perm</span> (<span class="dt">Finite</span> n <span class="ot">-&gt;</span> <span class="dt">Finite</span> n)</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a><span class="ot">runPerm ::</span> <span class="dt">Perm</span> n <span class="ot">-&gt;</span> <span class="dt">Finite</span> n <span class="ot">-&gt;</span> <span class="dt">Finite</span> n</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>runPerm (<span class="dt">Perm</span> f) x  <span class="ot">=</span> f x</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a><span class="ot">parsePerm ::</span> <span class="dt">KnownNat</span> n <span class="ot">=&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Perm</span> n</span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>parsePerm str <span class="ot">=</span> <span class="kw">case</span> <span class="fu">words</span> str <span class="kw">of</span></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>    <span class="st">&quot;cut&quot;</span><span class="op">:</span>n<span class="op">:</span>_           <span class="ot">-&gt;</span> <span class="dt">Perm</span> <span class="op">$</span> \i <span class="ot">-&gt;</span> i <span class="op">-</span> modulo (<span class="fu">read</span> n)</span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>    <span class="st">&quot;deal&quot;</span><span class="op">:</span><span class="st">&quot;into&quot;</span><span class="op">:</span>_     <span class="ot">-&gt;</span> <span class="dt">Perm</span> <span class="op">$</span> \i <span class="ot">-&gt;</span> <span class="fu">maxBound</span> <span class="op">-</span> i</span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a>    <span class="st">&quot;deal&quot;</span><span class="op">:</span><span class="st">&quot;with&quot;</span><span class="op">:</span>_<span class="op">:</span>n<span class="op">:</span>_ <span class="ot">-&gt;</span> <span class="dt">Perm</span> <span class="op">$</span> \i <span class="ot">-&gt;</span> i <span class="op">*</span> modulo (<span class="fu">read</span> n)</span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Semigroup</span> (<span class="dt">Perm</span> n) <span class="kw">where</span></span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Perm</span> f <span class="op">&lt;&gt;</span> <span class="dt">Perm</span> g <span class="ot">=</span> <span class="dt">Perm</span> (f <span class="op">.</span> g)     <span class="co">-- apply g, then apply x</span></span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Monoid</span> (<span class="dt">Perm</span> n) <span class="kw">where</span></span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true" tabindex="-1"></a>    <span class="fu">mempty</span> <span class="ot">=</span> <span class="dt">Perm</span> <span class="fu">id</span></span>
<span id="cb9-16"><a href="#cb9-16" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Group</span> (<span class="dt">Perm</span> n) <span class="kw">where</span></span>
<span id="cb9-17"><a href="#cb9-17" aria-hidden="true" tabindex="-1"></a>    invert (<span class="dt">Perm</span> f) <span class="ot">=</span> <span class="op">?????</span></span></code></pre></div>
<p>Note that <code>Finite n</code>’s <code>Num</code> instance is modular arithmetic, so things like <code>negate</code> and multiplication will “do the right thing”. We use <code>modulo</code>:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="ot">modulo ::</span> <span class="dt">KnownNat</span> n <span class="ot">=&gt;</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Finite</span> n</span></code></pre></div>
<p>which “reads” an <code>Integer</code> into a <code>Finite n</code>, making sure to wrap it in a cyclic way if it is negative or too high. <code>maxBound</code> also gives us the highest index (the highest <code>Finite n</code>).</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> modulo <span class="dv">3</span><span class="ot"> ::</span> <span class="dt">Finite</span> <span class="dv">10</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>finite <span class="dv">3</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> modulo <span class="dv">15</span><span class="ot"> ::</span> <span class="dt">Finite</span> <span class="dv">10</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>finite <span class="dv">5</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> modulo (<span class="op">-</span><span class="dv">1</span>)<span class="ot"> ::</span> <span class="dt">Finite</span> <span class="dv">10</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>finite <span class="dv">9</span></span></code></pre></div>
<p>The <code>KnownNat</code> instance is a constraint that <code>modulo</code> needs in order to know what quotient to modulo into.</p>
<p>This implementation <em>seems</em> to work, except for one apparent major problem: how do we write <code>invert</code>? Also, <code>stimes</code> doesn’t help us <em>too</em> much here, because repeated squaring of function composition is…still a lot of function compositions in the end.<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a> So, while composition with <code>&lt;&gt;</code> is cheap, application with <code>runPerm</code> is expensive (and <code>stimes</code> works best when composition is expensive and application is cheap). So, back to the drawing board.</p>
<h2 id="a-second-implementation-attempt-lookin-affine-today">A Second Implementation Attempt: Lookin’ Affine Today</h2>
<p>If we look carefully at <code>parsePerm</code>, we might start to see a pattern in all of our permutations. In fact, they all seem to follow the same form:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="st">&quot;cut&quot;</span><span class="op">:</span>n<span class="op">:</span>_           <span class="ot">-&gt;</span> <span class="dt">Perm</span> <span class="op">$</span> \i <span class="ot">-&gt;</span> i <span class="op">-</span> modulo (<span class="fu">read</span> n)</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a><span class="st">&quot;deal&quot;</span><span class="op">:</span><span class="st">&quot;into&quot;</span><span class="op">:</span>_     <span class="ot">-&gt;</span> <span class="dt">Perm</span> <span class="op">$</span> \i <span class="ot">-&gt;</span> <span class="fu">negate</span> i <span class="op">+</span> <span class="fu">maxBound</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a><span class="st">&quot;deal&quot;</span><span class="op">:</span><span class="st">&quot;with&quot;</span><span class="op">:</span>_<span class="op">:</span>n<span class="op">:</span>_ <span class="ot">-&gt;</span> <span class="dt">Perm</span> <span class="op">$</span> \i <span class="ot">-&gt;</span> i <span class="op">*</span> modulo (<span class="fu">read</span> n)</span></code></pre></div>
<p>They all seem to be some “scaling” and “adding” of <code>i</code>. If we align things up, this becomes a little more clear:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="st">&quot;cut&quot;</span><span class="op">:</span>n<span class="op">:</span>_           <span class="ot">-&gt;</span> <span class="dt">Perm</span> <span class="op">$</span> \i <span class="ot">-&gt;</span>                <span class="dv">1</span> <span class="op">*</span> i <span class="op">-</span> modulo (<span class="fu">read</span> n)</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a><span class="st">&quot;deal&quot;</span><span class="op">:</span><span class="st">&quot;into&quot;</span><span class="op">:</span>_     <span class="ot">-&gt;</span> <span class="dt">Perm</span> <span class="op">$</span> \i <span class="ot">-&gt;</span>               <span class="op">-</span><span class="dv">1</span> <span class="op">*</span> i <span class="op">+</span> <span class="fu">maxBound</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a><span class="st">&quot;deal&quot;</span><span class="op">:</span><span class="st">&quot;with&quot;</span><span class="op">:</span>_<span class="op">:</span>n<span class="op">:</span>_ <span class="ot">-&gt;</span> <span class="dt">Perm</span> <span class="op">$</span> \i <span class="ot">-&gt;</span>  modulo (<span class="fu">read</span> n) <span class="op">*</span> i</span></code></pre></div>
<p>Each of these seems to be some sort of scaling-and-adding of <code>i</code>…also known as an <a href="https://en.wikipedia.org/wiki/Affine_transformation">Affine Transformation</a>, but modulo some cyclic rotation.</p>
<p>Well…affine transformations on cyclic indices are a subset of permutations in general. More importantly, we know (after some googling) that they are also <em>closed with respect to composition and inversion</em> … which means that they are, themselves, a group! Maybe we can represent this as our permutation type:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/misc/advent-shuffle.hs#L16-L28</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Affine</span> n <span class="ot">=</span> <span class="dt">Aff</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>    {<span class="ot"> aScale ::</span> <span class="dt">Finite</span> n</span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>    ,<span class="ot"> aShift ::</span> <span class="dt">Finite</span> n</span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a><span class="ot">runPerm ::</span> <span class="dt">KnownNat</span> n <span class="ot">=&gt;</span> <span class="dt">Affine</span> n <span class="ot">-&gt;</span> <span class="dt">Finite</span> n <span class="ot">-&gt;</span> <span class="dt">Finite</span> n</span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a>runPerm (<span class="dt">Aff</span> a b) x <span class="ot">=</span> a <span class="op">*</span> x <span class="op">+</span> b</span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true" tabindex="-1"></a><span class="ot">parseAffine ::</span> <span class="dt">KnownNat</span> n <span class="ot">=&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Affine</span> n</span>
<span id="cb14-12"><a href="#cb14-12" aria-hidden="true" tabindex="-1"></a>parseAffine str <span class="ot">=</span> <span class="kw">case</span> <span class="fu">words</span> str <span class="kw">of</span></span>
<span id="cb14-13"><a href="#cb14-13" aria-hidden="true" tabindex="-1"></a>    <span class="st">&quot;cut&quot;</span><span class="op">:</span>n<span class="op">:</span>_           <span class="ot">-&gt;</span> <span class="dt">Aff</span>                <span class="dv">1</span>  (<span class="op">-</span>modulo (<span class="fu">read</span> n))</span>
<span id="cb14-14"><a href="#cb14-14" aria-hidden="true" tabindex="-1"></a>    <span class="st">&quot;deal&quot;</span><span class="op">:</span><span class="st">&quot;into&quot;</span><span class="op">:</span>_     <span class="ot">-&gt;</span> <span class="dt">Aff</span>        (<span class="fu">negate</span> <span class="dv">1</span>)          <span class="fu">maxBound</span></span>
<span id="cb14-15"><a href="#cb14-15" aria-hidden="true" tabindex="-1"></a>    <span class="st">&quot;deal&quot;</span><span class="op">:</span><span class="st">&quot;with&quot;</span><span class="op">:</span>_<span class="op">:</span>n<span class="op">:</span>_ <span class="ot">-&gt;</span> <span class="dt">Aff</span> (modulo (<span class="fu">read</span> n))                 <span class="dv">0</span></span></code></pre></div>
<p>This is “defunctionalization”: if we notice a pattern in our functions, we can instead abstract out the data that defines each instance of that pattern, and work with that data instead.</p>
<p>So far so good! Now to think about how to define composition.</p>
<p>If we want to do <span class="math inline">\(f(x) = a&#39; x + b&#39;\)</span> after <span class="math inline">\(g(x) = a x + b\)</span>, it’s:</p>
<p><span class="math display">\[
\begin{aligned}
(f \circ g)(x) &amp; = a&#39; (a x + b) + b&#39;\\
  (f \circ g)(x) &amp; = a&#39; x + a&#39; b + b&#39;
\end{aligned}
\]</span></p>
<p>So composing <code>a' x + b'</code> after <code>a x + b</code> is is <code>a' a x + a' b + b'</code>:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/misc/advent-shuffle.hs#L30-L31</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">KnownNat</span> n <span class="ot">=&gt;</span> <span class="dt">Semigroup</span> (<span class="dt">Affine</span> n) <span class="kw">where</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Aff</span> a&#39; b&#39; <span class="op">&lt;&gt;</span> <span class="dt">Aff</span> a b <span class="ot">=</span> <span class="dt">Aff</span> (a&#39; <span class="op">*</span> a) (a&#39; <span class="op">*</span> b <span class="op">+</span> b&#39;)</span></code></pre></div>
<p>Neat! We can now compose <em>and</em> run <code>Affine</code>s efficiently, which makes <code>stimes</code> useful! And the <code>Num</code> instance (which requires <code>KnownNat n</code>) for <code>Finite n</code> takes care of automatically doing modular arithmetic for us.</p>
<p>To define a <code>Monoid</code> instance, we need an identity permutation. This would just leave x alone, so it makes sense that it’s <span class="math inline">\(f(x) = 1 x + 0\)</span>, <code>1 x + 0</code>:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/misc/advent-shuffle.hs#L33-L34</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">KnownNat</span> n <span class="ot">=&gt;</span> <span class="dt">Monoid</span> (<span class="dt">Affine</span> n) <span class="kw">where</span></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>    <span class="fu">mempty</span> <span class="ot">=</span> <span class="dt">Aff</span> <span class="dv">1</span> <span class="dv">0</span></span></code></pre></div>
<p>Now let’s define the inverse, which is a bit trickier.</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">KnownNat</span> n <span class="ot">=&gt;</span> <span class="dt">Group</span> (<span class="dt">Affine</span> n) <span class="kw">where</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>    invert (<span class="dt">Aff</span> a b) <span class="ot">=</span> <span class="dt">Aff</span> a&#39; b&#39;</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>      <span class="kw">where</span></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>        a&#39; <span class="ot">=</span> <span class="co">-- ??</span></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>        b&#39; <span class="ot">=</span> <span class="co">-- ??</span></span></code></pre></div>
<p><em>Inverting</em> something means that we want <code>invert p &lt;&gt; p == mempty</code>. That means we want to find <code>a'</code> and <code>b'</code> such that:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>      <span class="dt">Aff</span> a&#39; b&#39; <span class="op">&lt;&gt;</span> <span class="dt">Aff</span> a b <span class="ot">=</span> <span class="dt">Aff</span> <span class="dv">1</span> <span class="dv">0</span></span></code></pre></div>
<p>From our definition of <code>&lt;&gt;</code> earlier, that means we have to find <code>a'</code> and <code>b'</code> where:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="dt">Aff</span> (a&#39; <span class="op">*</span> a) (a&#39; <span class="op">*</span> b <span class="op">+</span> b&#39;) <span class="ot">=</span> <span class="dt">Aff</span> <span class="dv">1</span> <span class="dv">0</span></span></code></pre></div>
<p>So we need <code>a' * a = 1</code>, and <code>a' * b + b' = 0</code>.</p>
<p>To solve <code>a' * a = 1</code>, we can imagine that cycling <code>a</code> through the whole deck gets you back to <code>a</code>. (If <code>n</code> is prime, then <code>a</code>, <code>a*a</code>, <code>a*a*a</code>, etc. will all be unique…so you will keep on getting unique numbers until you exhaust the entire space at <code>a^size</code> to arrive back at <code>a</code>) So:</p>
<pre><code>         a^n = a
=&gt; a^(n-1)*a = a    -- definition of exponentiation
=&gt; a^(n-1)   = 1    -- a^(n-1) leaves a unchanged, so it must be 1
=&gt; a^(n-2)*a = 1    -- definition of exponentiation</code></pre>
<p>From this we can see that if <code>a' * a = 1</code>, then <code>a'</code> must be <code>a^(n-2)</code> for prime <code>n</code>.<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a><a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a></p>
<p>The second case is a little simpler: we can just shuffle around <code>a' * b + b' = 0</code> to get <code>b' = -(a' * b)</code>.</p>
<p>This gives us everything we need to write <code>invert</code>:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/misc/advent-shuffle.hs#L36-L41</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a><span class="co">-- | Group instance only works if n is prime</span></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">KnownNat</span> n <span class="ot">=&gt;</span> <span class="dt">Group</span> (<span class="dt">Affine</span> n) <span class="kw">where</span></span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a>    invert (<span class="dt">Aff</span> a b) <span class="ot">=</span> <span class="dt">Aff</span> a&#39; b&#39;</span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a>      <span class="kw">where</span></span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true" tabindex="-1"></a>        a&#39; <span class="ot">=</span> a <span class="op">^</span> (natVal (<span class="dt">Proxy</span> <span class="op">@</span>n) <span class="op">-</span> <span class="dv">2</span>)</span>
<span id="cb21-8"><a href="#cb21-8" aria-hidden="true" tabindex="-1"></a>        b&#39; <span class="ot">=</span> <span class="fu">negate</span> (a&#39; <span class="op">*</span> b)</span></code></pre></div>
<p>And…we’re done! This actually is pretty efficient with repeated squaring (which is how <code>^</code> is implemented) because we are just squaring numbers. <code>natVal (Proxy @n)</code> is how to get <code>n</code> as an integer at the value level so we can use it as the exponent.</p>
<h2 id="the-full-implementation">The Full Implementation</h2>
<p>Just to close us out, I’ll re-paste the code we planned before, now with the context that we have implemented the appropriate permutation types. We get the <code>[Affine n]</code>s by using <code>parseAffine</code> on the <code>lines</code> of our puzzle input and reversing that list.</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/misc/advent-shuffle.hs#L43-L54</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a><span class="co">-- | Part 1: Given a permutation list, find the place where 2019 ends up</span></span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a><span class="ot">part1 ::</span> [<span class="dt">Affine</span> <span class="dv">10007</span>] <span class="ot">-&gt;</span> <span class="dt">Finite</span> <span class="dv">10007</span></span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a>part1 perms <span class="ot">=</span> runPerm bigPerm <span class="dv">2019</span></span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true" tabindex="-1"></a>    bigPerm <span class="ot">=</span> <span class="fu">mconcat</span> perms</span>
<span id="cb22-8"><a href="#cb22-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-9"><a href="#cb22-9" aria-hidden="true" tabindex="-1"></a><span class="co">-- | Part 2: Given a permutation list, find the index that will end up at 2020</span></span>
<span id="cb22-10"><a href="#cb22-10" aria-hidden="true" tabindex="-1"></a><span class="ot">part2 ::</span> [<span class="dt">Affine</span> <span class="dv">119315717514047</span>] <span class="ot">-&gt;</span> <span class="dt">Finite</span> <span class="dv">119315717514047</span></span>
<span id="cb22-11"><a href="#cb22-11" aria-hidden="true" tabindex="-1"></a>part2 perms <span class="ot">=</span> runPerm (invert biiigPerm) <span class="dv">2020</span></span>
<span id="cb22-12"><a href="#cb22-12" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb22-13"><a href="#cb22-13" aria-hidden="true" tabindex="-1"></a>    bigPerm   <span class="ot">=</span> <span class="fu">mconcat</span> perms</span>
<span id="cb22-14"><a href="#cb22-14" aria-hidden="true" tabindex="-1"></a>    biiigPerm <span class="ot">=</span> stimes <span class="dv">101741582076661</span> bigPerm</span></code></pre></div>
<p>You can load the finished code for this entire challenge <a href="https://github.com/mstksg/inCode/tree/master/code-samples/misc/advent-shuffle.hs">here</a>. I’ve also included the sample input string for my advent of code account, and also parsed it conveniently into a list of properly ordered <code>Affine n</code>s for you to test it yourself:</p>
<pre><code>$ ./advent-shuffle.hs
ghci&gt; part1 myShuffles
finite 6978
ghci&gt; part2 myShuffles
finite 24460989449140</code></pre>
<p>As expected, Haskell performs these ~47 multiplication steps pretty quickly, and part 2 is only about 3 times slower than part 1 (~40μs vs. ~14μs on my machine).</p>
<h2 id="the-big-picture">The Big Picture</h2>
<p>Every time I make a post about how Haskell lets you “use” math, there’s a lot of room for confusion and misunderstanding. A common misconception is that you need to know math to use Haskell, or that writing a Haskell program is like solving a math equation.<a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a></p>
<p>Instead, when we say we “use” math in Haskell, it means that Haskell naturally nudges us to phrase our problems in a way that can help illuminate connections to the groundwork that has already been laid for us through centuries of mathematical discoveries — and in many cases, allow us to translate those insights into making helpful improvements and optimizations in our actual code.</p>
<p>Haskell is “functional programming”, but I think that betrays the major insight here: we got our main conceptual leap when we thought about shuffling not as “a function”, but rather <em>as data</em>: our shuffle is itself <em>data</em> (here, integers), and not an “algorithm”. Had we latched onto an algorithmic approach from the beginning, we might have gotten stuck in the mire of finding a way to “optimize an algorithm”. But because we initially started thinking about permutations and shuffles as <em>data structures</em>, we actually end up thinking about how to most effectively manipulate the data structures themselves. Instead of manipulating the cards, we manipulate the shuffle! We combine and invert the <em>shuffles</em>, not the cards. And math — especially abstract algebra — is all about different properties of how objects can combine and universal properties about certain operations.</p>
<p>As we head into this wonderful season, stay safe and happy haskellings, everyone! :D</p>
<h2 id="special-thanks">Special Thanks</h2>
<p>I am very humbled to be supported by an amazing community, who make it possible for me to devote time to researching and writing these posts. Very special thanks to my supporter at the “Amazing” level on <a href="https://www.patreon.com/justinle/overview">patreon</a>, Josh Vera! :)</p>
<section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes">
<hr />
<ol>
<li id="fn1"><p>We only allocate a few function pointers (once for each <code>&lt;&gt;</code>, where <a href="https://www.reddit.com/r/haskell/comments/jwl93i/shuffling_things_up_solving_advent_of_code_with/gcudwg4?utm_source=share&amp;utm_medium=web2x&amp;context=3">both sides themselves point to the same function pointer</a>), so it’s very efficient in space as well, but to actually “run” that final function, we need to still traverse all of those nested pointers the full number of times.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p>You can also use the <a href="https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm">Extended Euclidean Algorithm</a> to find the multiplicative inverse here as well if you are a (cool) nerd. But I wanted to show a way to do this without requiring knowledge of any ring theory.<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3"><p>As <a href="https://www.reddit.com/r/haskell/comments/jwl93i/shuffling_things_up_solving_advent_of_code_with/gct4ihy/?context=3">pointed out by rogercaptain on reddit</a>, this also “works” in the case where <code>n</code> is not prime too: only <em>some</em> (and not all) <code>Affine n</code>s represent permutations when <code>n</code> is not prime, and for those specific <code>Affine n</code>s (namely, where <code>a</code> is coprime to <code>n</code>), this technique does work.<a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn4"><p>Admittedly, we did do that a few times here. But that’s not <em>all</em> we do :)<a href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section></div><footer><hr><div class="copy-content"><p>Hi, thanks for reading! You can reach me via email at <a href="mailto:justin@jle.im" class="email">justin@jle.im</a>, or at twitter at <a href="https://twitter.com/mstk">@mstk</a>! This post and all others are published under the <a href="https://creativecommons.org/licenses/by-nc-nd/3.0/">CC-BY-NC-ND 3.0</a> license. Corrections and edits via pull request are welcome and encouraged at <a href="https://github.com/mstksg/inCode">the source repository</a>.</p>
<p>If you feel inclined, or this post was particularly helpful for you, why not consider <a href="https://www.patreon.com/justinle/overview">supporting me on Patreon</a>, or a <a href="bitcoin:3D7rmAYgbDnp4gp4rf22THsGt74fNucPDU">BTC donation</a>? :)</p></div><div class="clear"></div><ul class="entry-series"><li><div>This entry is a part of a series called <b>&quot;Advent of Code&quot;</b>.  Find the rest of the entries in this series at its <a href="https://blog.jle.im/entries/series/+advent-of-code.html" class="tag-a-series" title="+Advent of Code"> series history</a>.</div></li></ul><ul class="tag-list"><li><a href="https://blog.jle.im/entries/tagged/abstract-algebra.html" class="tag-a-tag">#abstract algebra</a></li><li><a href="https://blog.jle.im/entries/tagged/advent-of-code.html" class="tag-a-tag">#advent of code</a></li><li><a href="https://blog.jle.im/entries/tagged/group-theory.html" class="tag-a-tag">#group theory</a></li><li><a href="https://blog.jle.im/entries/tagged/haskell.html" class="tag-a-tag">#haskell</a></li><li><a href="https://blog.jle.im/entries/category/@haskell.html" class="tag-a-category">@HASKELL</a></li><li><a href="https://blog.jle.im/entries/category/@math.html" class="tag-a-category">@MATH</a></li><li><a href="https://blog.jle.im/entries/series/+advent-of-code.html" class="tag-a-series">+Advent of Code</a></li></ul><aside class="social-buttons"><div class="addthis_toolbox addthis_default_style addthis-buttons"><a class="addthis_button_facebook_like" fb:like:layout="button_count"></a><a class="addthis_button_tweet"></a><a class="addthis_button_google_plusone" g:plusone:size="medium"></a><a class="addthis_counter addthis_pill_style"></a></div><div class="custom-social-buttons"><div class="custom-social-button"><a href="https://www.reddit.com/submit" onclick="window.location = &#39;https://www.reddit.com/submit?url=&#39;+ encodeURIComponent(window.location); return false"><img src="https://www.reddit.com/static/spreddit7.gif" alt="submit to reddit"></a></div></div></aside><nav class="next-prev-links"><ul><li class="prev-entry-link">&larr; <a href="https://blog.jle.im/entry/enhancing-functor-structures-step-by-step-2.html">Enhancing Functor Structures Step-By-Step (Part 2)</a> (Previous)</li><li class="next-entry-link">(Next) <a href="https://blog.jle.im/entry/holly-jolly-streaming-combinators.html">Roll your own Holly Jolly streaming combinators with Free</a> &rarr;</li></ul></nav></footer></article><div class="post-entry"><div class="tile"><div id="disqus_thread"></div><script type="text/javascript">var disqus_config = function () {
    this.page.url = 'https://blog.jle.im/entry/shuffling-things-up.html';
    this.page.identifier = 'advent-shuffle';
};
(function() {
    var d = document, s = d.createElement('script');
    s.src = '//incode.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
})();
</script><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a><br></noscript><a href="http://disqus.com" class="dsq-brlink">Comments powered by <span class="logo-disqus">Disqus</span></a></div></div></div></div></div><div id="footer-container"><div id="footer-content"><div class="tile"><div class="footer-copyright">&copy; 2020 Justin Le <span class="license-link">(<a href="https://creativecommons.org/licenses/by-nc-nd/3.0/" class="license">CC-BY-NC-ND 3.0</a>)</span></div><div class="footer-follow social-follows"><ul class="social-follows-list"><li><ul class="social-follows-list-social"><li><a class="social-follow-twitter" title="Follow me on Twitter!" href="https://twitter.com/intent/user?user_id=mstk" onclick="window.open(
  &#39;http://twitter.com/intent/user?user_id=907281&#39;,
  &#39;facebook-share-dialog&#39;,
  &#39;width=550,height=520&#39;);
return false;
">Twitter</a></li><li><a class="social-follow-github" title="Fork me on Github!" href="https://github.com/mstksg">Github</a></li><li><a class="social-follow-twitch" title="Watch me on Twitch!" href="https://www.twitch.tv/justin_l">Twitch</a></li><li><a class="social-follow-patreon" title="Support me on Patreon!" href="https://www.patreon.com/justinle/overview">Patreon</a></li><li><a class="social-follow-gplus" title="Add me on Google+!" href="https://plus.google.com/+JustinLe">Google+</a></li><li><a class="social-follow-keybase" title="Track me on Keybase!" href="https://keybase.io/mstksg">Keybase</a></li><li><a class="social-follow-linkedin" title="Connect with me on LinkedIn!" href="https://linkedin.com/in/lejustin">LinkedIn</a></li><li><a class="social-follow-bitcoin" title="Donate via bitcoin!" href="bitcoin:3D7rmAYgbDnp4gp4rf22THsGt74fNucPDU">Bitcoin</a></li></ul></li><li><ul class="social-follows-list-site"><li><a class="social-follow-rss" title="Subscribe to my RSS Feed!" href="http://feeds.feedburner.com/incodeblog">RSS</a></li><li><a class="social-follow-email" title="Subscribe to the mailing list!" href="https://feedburner.google.com/fb/a/mailverify?loc=en_US&amp;uri=incodeblog">Mailing list</a></li></ul></li></ul></div></div></div></div></body></html>