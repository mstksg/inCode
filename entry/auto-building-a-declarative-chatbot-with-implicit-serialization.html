<!DOCTYPE HTML>
<html><head><title>Auto: Building a Declarative Chatbot with Implicit Serialization · in Code</title><meta name="description" content="Weblog of Justin Le, covering various adventures in programming and explorations in the worlds of computation physics, and knowledge.
"><meta http-equiv="Content-Type" content="text/html;charset=utf-8"><meta name="viewport" content="width=device-width,initial-scale=1.0"><meta name="flattr:id" content="3p9jqr"><meta property="og:site_name" content="in Code"><meta property="og:description" content="Today we’re going to continue along with the All About Auto introduction series and look at building a declarative chatbot using the denotational components from the auto library that is modular and has implicit serialization. Most importantly, we’ll look at the “design process”, and principles of architecture that you can apply to your own projects. This post assumes some concepts from the tutorial, or at least my last post or the README. If some of these ideas seem completely new, than looking through the tutorial or the docs might refresh your mind…feel free to also leave a comment, stop by #haskell-auto on freenode where I go by jle`, or tweet me All of the code in this tutorial can be downloaded and run using runghc (with the appropriate dependencies installed). Feel free to play along!"><meta property="og:type" content="article"><meta property="og:title" content="Auto: Building a Declarative Chatbot with Implicit Serialization"><meta property="og:image" content="https://blog.jle.im/img/site_logo.jpg"><meta property="og:locale" content="en_US"><meta property="og:url" content="https://blog.jle.im/entry/auto-building-a-declarative-chatbot-with-implicit-serialization.html"><meta name="twitter:card" content="summary"><meta name="twitter:creator:id" content="mstk"><link rel="author" href="https://plus.google.com/107705320197444500140"><link rel="alternate" type="application/rss+xml" title="in Code (RSS Feed)" href="http://feeds.feedburner.com/incodeblog"><link rel="canonical" href="https://blog.jle.im/entry/auto-building-a-declarative-chatbot-with-implicit-serialization.html"><link href="https://blog.jle.im/favicon.ico" rel="shortcut icon"><link href="https://blog.jle.im/css/toast.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/font.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/main.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/page/entry.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/pygments.css" rel="stylesheet" type="text/css"><script type="text/javascript">var page_data = {};
var disqus_shortname='incode';
</script><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-443711-8', 'jle.im');
ga('send', 'pageview');
</script><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script id="MathJax-script" async="" src="https://cdn.jsdelivr.net/npm/mathjax@3.0.1/es5/tex-mml-chtml.js"></script><script type="text/javascript" src="//ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script><script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5234d67a6b68dcd4"></script><script type="text/javascript" src="https://blog.jle.im/js/page/entry_toc.js"></script><script type="text/javascript" src="https://blog.jle.im/js/disqus_count.js"></script><script type="text/javascript" src="https://blog.jle.im/js/social.js"></script><script type="text/javascript" src="https://blog.jle.im/js/jquery/jquery.toc.js"></script><script type="text/javascript" src="https://blog.jle.im/purescript/entry.js"></script></head><body><div id="fb-root"><script>(function(d, s, id) {
 var js, fjs = d.getElementsByTagName(s)[0];
 if (d.getElementById(id)) return;
 js = d.createElement(s); js.id = id;
 js.src = "//connect.facebook.net/en_US/all.js#xfbml=1&appId=641852699171929";
 fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));
</script></div><div id="header-container"><div id="navbar-container" class="tile"><nav id="navbar-content"><div class="nav-info"><h1 class="site-title"><a href="https://blog.jle.im/" class="nav-title">in Code</a></h1><span class="nav-author">Justin Le</span></div><ul class="nav-links"><li><a href="https://blog.jle.im/">home</a></li><li><a href="https://blog.jle.im/entries.html">archives</a></li><li><a href="https://cv.jle.im">cv</a></li><div class="clear"></div></ul></nav></div><div id="header-content"></div></div><div id="body-container" class="container"><div id="main-container" class="grid"><div class="entry-section unit span-grid" role="main"><article class="tile article"><header><h1 id="title">Auto: Building a Declarative Chatbot with Implicit Serialization</h1><p class="entry-info">by <a class="author" href="https://blog.jle.im/">Justin Le</a><span class="info-separator"> &diams; </span><time datetime="2015-03-25T10:20:17Z" pubdate="" class="pubdate">Wednesday March 25, 2015</time></p><p><span class="source-info"><a class="source-link" href="https://github.com/mstksg/inCode/tree/master/copy/entries/auto-chatbot.md">Source</a><span class="info-separator"> &diams; </span><a class="source-link" href="https://github.com/mstksg/inCode/tree/gh-pages/entry/auto-building-a-declarative-chatbot-with-implicit-serialization.md">Markdown</a><span class="info-separator"> &diams; </span><a class="source-link" href="https://blog.jle.im/entry/auto-building-a-declarative-chatbot-with-implicit-serialization.tex">LaTeX</a><span class="info-separator"> &diams; </span></span>Posted in <a href="https://blog.jle.im/entries/category/@auto.html" class="tag-a-category" title="Posts about the auto library, a library offering a denotative, locally stateful
programming DSL and platform. Check out the README, tutorial, or examples for
more information!
">Auto</a>, <a href="https://blog.jle.im/entries/category/@haskell.html" class="tag-a-category" title="Functional, pure, non-strict, statically and strongly typed, natively
compiled...really just the king of great languages.
">Haskell</a>, <a href="https://blog.jle.im/entries/category/@tutorials.html" class="tag-a-category" title="Technical tutorials/walkthroughs on specific programming processes and problems
that I&#39;ve struggled through in the past.
">Tutorials</a><span class="info-separator"> &diams; </span><a class="comment-link" href="#disqus_thread">Comments</a></p></header><hr><aside class="contents-container"><h5 id="contents-header">Contents</h5><div id="toc"></div></aside><div class="main-content copy-content"><p>Today we’re going to continue along with the <a href="http://blog.jle.im/entries/series/+all-about-auto">All About Auto</a> introduction series and look at building a declarative chatbot using the denotational components from the <a href="http://hackage.haskell.org/package/auto">auto</a> library that is modular and has implicit serialization. Most importantly, we’ll look at the “design process”, and principles of architecture that you can apply to your own projects.</p>
<p>This post assumes <em>some</em> concepts from the <a href="https://github.com/mstksg/auto/blob/master/tutorial/tutorial.md">tutorial</a>, or at least my <a href="http://blog.jle.im/entry/introducing-the-auto-library">last post</a> or the <a href="https://github.com/mstksg/auto/blob/master/README.md">README</a>. If some of these ideas seem completely new, than looking through the <a href="https://github.com/mstksg/auto/blob/master/tutorial/tutorial.md">tutorial</a> or the <a href="http://hackage.haskell.org/package/auto">docs</a> might refresh your mind…feel free to also leave a comment, stop by <em>#haskell-auto</em> on freenode where I go by <em>jle`</em>, or <a href="https://twitter.com/mstk" title="Twitter">tweet me</a></p>
<p>All of the code in this tutorial can be <a href="https://github.com/mstksg/inCode/tree/master/code-samples/auto/chatbot.hs">downloaded and run</a> using <code>runghc</code> (with the appropriate dependencies installed). Feel free to play along!</p>
<h2 id="overall-layout">Overall Layout</h2>
<p><em>auto</em> is a library that at the highest level gives you a stream transformer on streams of values. Transform a stream of input values to a stream of output values. So when we approach a chat bot, we have to think — what are the inputs, and what are the outputs?</p>
<p>The choice should be pretty straightforward – our input stream is a stream of input messages from the irc server, and our output stream is a stream of messages to send to the server. In haskell we like types, so let’s make some types.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- first, our imports</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/auto/chatbot.hs#L25-L43</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Auto</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Auto.Blip</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Auto.Collection</span>  (mux)</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Auto.Run</span>         (runOnChanM)</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Auto.Serialize</span>   (serializing&#39;)</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Auto.Switch</span>      (resetOn)</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Concurrent</span>       (<span class="dt">Chan</span>, newChan, writeChan, forkIO, threadDelay)</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Monad</span>            (void, forever)</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Monad.IO.Class</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Foldable</span>            (forM_)</span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Map</span>                 (<span class="dt">Map</span>)</span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Serialize</span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Text</span> <span class="kw">hiding</span>         (words, unwords, map)</span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Text.Encoding</span></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Text.Encoding.Error</span></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Time</span></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Network.SimpleIRC</span></span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Prelude</span> <span class="kw">hiding</span>           ((.), id)   <span class="co">-- we use (.) and id from `Control.Category`</span></span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Map</span>       <span class="kw">as</span> <span class="dt">M</span></span></code></pre></div>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/auto/chatbot.hs#L51-L66</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Nick</span>    <span class="ot">=</span> <span class="dt">String</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Channel</span> <span class="ot">=</span> <span class="dt">String</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Message</span> <span class="ot">=</span> <span class="dt">String</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">InMessage</span> <span class="ot">=</span> <span class="dt">InMessage</span> {<span class="ot"> _inMessageNick   ::</span> <span class="dt">Nick</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>                           ,<span class="ot"> _inMessageBody   ::</span> <span class="dt">Message</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>                           ,<span class="ot"> _inMessageSource ::</span> <span class="dt">Channel</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>                           ,<span class="ot"> _inMessageTime   ::</span> <span class="dt">UTCTime</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>                           } <span class="kw">deriving</span> <span class="dt">Show</span></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">OutMessages</span> <span class="ot">=</span> <span class="dt">OutMessages</span> (<span class="dt">Map</span> <span class="dt">Channel</span> [<span class="dt">Message</span>]) <span class="kw">deriving</span> <span class="dt">Show</span></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Monoid</span> <span class="dt">OutMessages</span> <span class="kw">where</span></span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a>    <span class="fu">mempty</span>  <span class="ot">=</span> <span class="dt">OutMessages</span> M.empty</span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a>    <span class="fu">mappend</span> (<span class="dt">OutMessages</span> m1) (<span class="dt">OutMessages</span> m2)</span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a>            <span class="ot">=</span> <span class="dt">OutMessages</span> (M.unionWith (<span class="op">++</span>) m1 m2)</span></code></pre></div>
<p>We make some type aliases to make things a bit clearer. Our inputs are going to be a data type/“struct” with a nick, a body, a source, and a time. Our outputs are going to be a <code>Data.Map.Map</code> from <em>containers</em> associating channels with messages to send. I’m just adding here a <code>Monoid</code> instance in case we want to combine <code>OutMessages</code> maps.</p>
<p>The type for a chat bot over a monad <code>m</code> would then be:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/auto/chatbot.hs#L68-L68</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">ChatBot</span> m <span class="ot">=</span> <span class="dt">Auto</span> m <span class="dt">InMessage</span> <span class="dt">OutMessages</span></span></code></pre></div>
<p>A <code>ChatBot</code> takes a stream of <code>InMessage</code>s and returns a stream of <code>OutMessages</code>s…and might have effects in <code>m</code> as it does so.</p>
<p>Note that we get a free instance of <code>Monoid</code> on <code>ChatBot m</code>:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="fu">mappend</span><span class="ot"> ::</span> <span class="dt">ChatBot</span> m <span class="ot">-&gt;</span> <span class="dt">ChatBot</span> m <span class="ot">-&gt;</span> <span class="dt">ChatBot</span> m</span></code></pre></div>
<p>That takes two <code>ChatBot</code>s and creates a new <code>ChatBot</code> that forks the input stream (sends all <code>InMessage</code>s) to both of the original ones, and <code>mappend</code>s the results. So the new <code>ChatBot</code> will send message to both original ones and return a “combined” <code>OutMessages</code>.</p>
<p>However, not all modules really have to “care” about the room of the outputs…they might just always reply directly to the room they received the message on. So it’ll help us to also make another sort of <code>Auto</code>:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/auto/chatbot.hs#L69-L69</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">RoomBot</span> m <span class="ot">=</span> <span class="dt">Auto</span> m <span class="dt">InMessage</span> (<span class="dt">Blip</span> [<span class="dt">Message</span>])</span></code></pre></div>
<p>A <code>RoomBot</code> doesn’t care where its messages go…it just replies to the same room it got its input from. It outputs a blip stream of message lists; when it doesn’t want to send messages out, it doesn’t emit. When it does, it <em>does</em> emit, with the list of messages.</p>
<p>(Remember, a <em>blip stream</em> is just like a normal stream of values, except it only actually <em>has</em> a value every once in a while, when it “emits”. A <code>Blip Bool</code> is a stream that sometimes, occasionally emits with a <code>Bool</code>. We work with them using combinators and <code>Auto</code>s from <a href="http://hackage.haskell.org/package/auto/docs/Control-Auto-Blip.html"><code>Control.Auto.Blip</code></a>)</p>
<h3 id="converting">Converting</h3>
<p>We can write a quick helper function to convert a <code>RoomBot</code> into a full-on <code>ChatBot</code>, so we can merge them together with <code>mappend</code>/<code>(&lt;&gt;)</code>:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/auto/chatbot.hs#L72-L75</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a><span class="ot">perRoom ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">RoomBot</span> m <span class="ot">-&gt;</span> <span class="dt">ChatBot</span> m</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>perRoom rb <span class="ot">=</span> proc inp<span class="op">@</span>(<span class="dt">InMessage</span> _ _ src _) <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>    messages <span class="ot">&lt;-</span> fromBlips [] <span class="op">.</span> rb <span class="op">-&lt;</span> inp</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>    <span class="fu">id</span> <span class="op">-&lt;</span> <span class="dt">OutMessages</span> <span class="op">$</span> M.singleton src messages</span></code></pre></div>
<p>(This example uses proc notation; see this <a href="https://github.com/mstksg/auto/blob/master/tutorial/tutorial.md#brief-primer-on-proc-notation">proc notation primer</a> for a quick run-down of the relevant aspects)</p>
<p>We say that <code>messages</code> is just the output of <code>rb</code> fed with the input, except it “collapses” the blip stream into a normal stream by substituting in <code>[]</code> whenever the stream doesn’t emit. So <code>messages</code> is <code>[]</code> when <code>rb</code> doesn’t emit (it doesn’t want to send anything), and <code>messages</code> is <code>[message1, message2 ...]</code>, with the emitted contents, when it <em>does</em>.</p>
<p>The “output” will be a singleton map with the source of the input and the messages to send to that source.</p>
<p>So now if we have a <code>RoomBot m</code>, we can convert it up into a <code>ChatBot m</code>, and combine it/merge it with other <code>ChatBot m</code>s.</p>
<h3 id="the-whole-deal">The whole deal</h3>
<p>We have enough now then to imagine our entire program architecture:</p>
<ul>
<li>Write a bunch of separate modules, as <code>ChatBot m</code>s or <code>RoomBot m</code>s, which ever one is more convenient. The beauty is that we can merge them all together in the end with our promoter.</li>
<li>Combine all of our modules with <code>mconcat</code> — that is, something like <code>chatBot = mconcat [module1, module2, module3, module 4]</code>. And that’s it, that’s our entire chat bot!</li>
<li>Having an overall <code>chatBot :: ChatBot m</code>, we can use something like <code>runOnChan</code> from <code>Control.Auto.Run</code> to have it exist on a concurrent thread and watch a channel for input, and perform an action on output.</li>
<li>Find an out-of-the-box irc library that can trigger adding something to a concurrent queue when it receives a message, and where you can send messages to rooms.</li>
</ul>
<p>And…that’s it. Program logic in our <code>ChatBot m</code>s, and handling the “view”/input with our backend.</p>
<h4 id="free-serialization">Free Serialization</h4>
<p>Remember that <em>auto</em> gives us the ability to serialize and resume our <code>Auto</code>s for free…so we can at any time save the state of our chat bot to disk, and resume it when we re-load. We don’t have to worry about manually gathering our state between each <code>Auto</code> and writing serialization code.</p>
<p>There’s a “convenience combinator” called <code>serializing'</code> in <code>Control.Auto.Serialize</code> (it’s one of many different ones that can do something like this; <a href="http://hackage.haskell.org/package/auto/docs/Control-Auto-Serialize.html">check out the module</a> to see other ways of varying disciplined-ness!). It’ll take any <code>Auto</code> and turn it into an <code>Auto</code> that “self-serializes” — when you begin running it, it automatically loads its previous state if it exists, and as you run it, it automatically maintains an updated “resume state” on disk.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="ot">serializing&#39; ::</span> <span class="dt">MonadIO</span> m <span class="ot">=&gt;</span> <span class="dt">FilePath</span> <span class="ot">-&gt;</span> <span class="dt">ChatBot</span> m <span class="ot">-&gt;</span> <span class="dt">ChatBot</span> m</span></code></pre></div>
<p>Note that <code>serializing' fp :: MonadIO m =&gt; ChatBot m -&gt; ChatBot m</code>. It looks a lot like an “identity-ish” sort of function, right? That’s because it is meant to behave <em>like</em> <code>id</code>…the returned <code>ChatBot</code> behaves identical to the previous one…except it splices in the serializing action in-between. (We are in <code>MonadIO</code> now, because the <code>Auto</code> has to access <code>IO</code> in order to serialize itself between steps).</p>
<p>So, instead of</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="ot">chatBot ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">ChatBot</span> m</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>chatBot <span class="ot">=</span> <span class="fu">mconcat</span> [module1, module2, module3]</span></code></pre></div>
<p>We can do:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="ot">chatBot ::</span> <span class="dt">MonadIO</span> m <span class="ot">=&gt;</span> <span class="dt">ChatBot</span> m</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>chatBot <span class="ot">=</span> serializing&#39; <span class="st">&quot;state.dat&quot;</span> <span class="op">$</span> <span class="fu">mconcat</span> [module1, module2, module3]</span></code></pre></div>
<p>And now our <code>chatBot</code> will automatically resume itself on program startup, and keep its state backed up on disk at <code>state.dat</code>. We get this for free, without doing anything extra in the composition of our modules.</p>
<p>Note that in practice, with a bot you are actively developing, this might not be the best idea. <code>serializing'</code> <em>analyzes</em> your <code>Auto</code>s to determine a serialization and reloading strategy, and applies that to do its job. However, if you, for example, add a new module to your chat bot…the serialization strategy will change, and your new bot won’t be able to resume old save files.</p>
<p>One solution at this point is just to serialize individual modules that you do not see yourself changing…or even just serializing parts of the modules you don’t see yourself changing. Then you can change each portion separately and not worry about migration issues.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="ot">chatBot ::</span> <span class="dt">MonadIO</span> m <span class="ot">=&gt;</span> <span class="dt">ChatBot</span> m</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>chatBot <span class="ot">=</span> <span class="fu">mconcat</span> [ serializing&#39; <span class="st">&quot;m1.dat&quot;</span> module1</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>                  , module2</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>                  , serializing&#39; <span class="st">&quot;m3.dat&quot;</span> module3</span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>                  ]</span></code></pre></div>
<p>We’re not all-or-nothing now here, either! So, <code>module1</code> gets serialized and auto-resumed from <code>m1.dat</code>, <code>module2</code> is not serialized at all, and <code>module3</code> now gets serialized and auto-resumed from <code>m3.dat</code>.</p>
<h2 id="irc-backend-the-ugly-part">IRC Backend (the ugly part)</h2>
<p>Before we get started on our actual modules, let’s just write out the backend/interface between our <code>ChatBot</code> and irc to get it out of the way. This will vary based on what library you use; I’m going to use the <a href="http://hackage.haskell.org/package/simpleirc-0.3.0">simpleirc-0.3.0</a>, but feel free to use any interface/library you want.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/auto/chatbot.hs#L45-L228</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a><span class="ot">withIrcConf ::</span> <span class="dt">IrcConfig</span> <span class="ot">-&gt;</span> <span class="dt">ChatBot</span> <span class="dt">IO</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>withIrcConf ircconf chatbot <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- chan to receive `InMessage`s</span></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>    inputChan <span class="ot">&lt;- newChan ::</span> <span class="dt">IO</span> (<span class="dt">Chan</span> <span class="dt">InMessage</span>)</span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- configuring IRC</span></span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> events   <span class="ot">=</span> cEvents ircconf <span class="op">++</span> [ <span class="dt">Privmsg</span> (onMessage inputChan) ]</span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a>        ircconf&#39; <span class="ot">=</span> ircconf { cEvents <span class="ot">=</span> events }</span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- connect; simplified for demonstration purposes</span></span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Right</span> server <span class="ot">&lt;-</span> connect ircconf&#39; <span class="dt">True</span> <span class="dt">True</span></span>
<span id="cb11-15"><a href="#cb11-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-16"><a href="#cb11-16" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- run `chatbot` on `inputChan`</span></span>
<span id="cb11-17"><a href="#cb11-17" aria-hidden="true" tabindex="-1"></a>    void <span class="op">.</span> forkIO <span class="op">.</span> void <span class="op">$</span></span>
<span id="cb11-18"><a href="#cb11-18" aria-hidden="true" tabindex="-1"></a>        runOnChanM <span class="fu">id</span> (processOutput server) inputChan chatbot</span>
<span id="cb11-19"><a href="#cb11-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-20"><a href="#cb11-20" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb11-21"><a href="#cb11-21" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- what to do when `chatBot` outputs</span></span>
<span id="cb11-22"><a href="#cb11-22" aria-hidden="true" tabindex="-1"></a><span class="ot">    processOutput ::</span> <span class="dt">MIrc</span> <span class="ot">-&gt;</span> <span class="dt">OutMessages</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">Bool</span></span>
<span id="cb11-23"><a href="#cb11-23" aria-hidden="true" tabindex="-1"></a>    processOutput server (<span class="dt">OutMessages</span> outs) <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb11-24"><a href="#cb11-24" aria-hidden="true" tabindex="-1"></a>      <span class="fu">print</span> outs</span>
<span id="cb11-25"><a href="#cb11-25" aria-hidden="true" tabindex="-1"></a>      _ <span class="ot">&lt;-</span> <span class="fu">flip</span> M.traverseWithKey outs <span class="op">$</span> \channel messages <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb11-26"><a href="#cb11-26" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> channel&#39; <span class="ot">=</span> encodeUtf8 <span class="op">.</span> <span class="fu">pack</span> <span class="op">$</span> channel</span>
<span id="cb11-27"><a href="#cb11-27" aria-hidden="true" tabindex="-1"></a>        forM_ messages <span class="op">$</span> \message <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb11-28"><a href="#cb11-28" aria-hidden="true" tabindex="-1"></a>          <span class="kw">let</span> message&#39; <span class="ot">=</span> encodeUtf8 <span class="op">.</span> <span class="fu">pack</span> <span class="op">$</span> message</span>
<span id="cb11-29"><a href="#cb11-29" aria-hidden="true" tabindex="-1"></a>          sendMsg server channel&#39; message&#39;</span>
<span id="cb11-30"><a href="#cb11-30" aria-hidden="true" tabindex="-1"></a>      <span class="fu">return</span> <span class="dt">True</span>       <span class="co">-- &quot;yes, continue on&quot;</span></span>
<span id="cb11-31"><a href="#cb11-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-32"><a href="#cb11-32" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- what to do when you get a new message</span></span>
<span id="cb11-33"><a href="#cb11-33" aria-hidden="true" tabindex="-1"></a><span class="ot">    onMessage ::</span> <span class="dt">Chan</span> <span class="dt">InMessage</span> <span class="ot">-&gt;</span> <span class="dt">EventFunc</span></span>
<span id="cb11-34"><a href="#cb11-34" aria-hidden="true" tabindex="-1"></a>    onMessage inputChan <span class="ot">=</span> \_ message <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb11-35"><a href="#cb11-35" aria-hidden="true" tabindex="-1"></a>      <span class="kw">case</span> (mNick message, mOrigin message) <span class="kw">of</span></span>
<span id="cb11-36"><a href="#cb11-36" aria-hidden="true" tabindex="-1"></a>        (<span class="dt">Just</span> nick, <span class="dt">Just</span> src) <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb11-37"><a href="#cb11-37" aria-hidden="true" tabindex="-1"></a>          time <span class="ot">&lt;-</span> getCurrentTime</span>
<span id="cb11-38"><a href="#cb11-38" aria-hidden="true" tabindex="-1"></a>          writeChan inputChan <span class="op">$</span> <span class="dt">InMessage</span> (unpack (decodeUtf8 nick))</span>
<span id="cb11-39"><a href="#cb11-39" aria-hidden="true" tabindex="-1"></a>                                          (unpack (decodeUtf8 (mMsg message)))</span>
<span id="cb11-40"><a href="#cb11-40" aria-hidden="true" tabindex="-1"></a>                                          (unpack (decodeUtf8 src))</span>
<span id="cb11-41"><a href="#cb11-41" aria-hidden="true" tabindex="-1"></a>                                          time</span>
<span id="cb11-42"><a href="#cb11-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-43"><a href="#cb11-43" aria-hidden="true" tabindex="-1"></a><span class="ot">channels ::</span> [<span class="dt">Channel</span>]</span>
<span id="cb11-44"><a href="#cb11-44" aria-hidden="true" tabindex="-1"></a>channels <span class="ot">=</span> [<span class="st">&quot;#testchan1&quot;</span>, <span class="st">&quot;#testchan2&quot;</span>]</span>
<span id="cb11-45"><a href="#cb11-45" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-46"><a href="#cb11-46" aria-hidden="true" tabindex="-1"></a><span class="ot">conf ::</span> <span class="dt">IrcConfig</span></span>
<span id="cb11-47"><a href="#cb11-47" aria-hidden="true" tabindex="-1"></a>conf <span class="ot">=</span> (mkDefaultConfig <span class="st">&quot;myserver&quot;</span> <span class="st">&quot;mynick&quot;</span>) { cChannels <span class="ot">=</span> channels }</span>
<span id="cb11-48"><a href="#cb11-48" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-49"><a href="#cb11-49" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb11-50"><a href="#cb11-50" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb11-51"><a href="#cb11-51" aria-hidden="true" tabindex="-1"></a>    withIrcConf conf chatBot</span>
<span id="cb11-52"><a href="#cb11-52" aria-hidden="true" tabindex="-1"></a>    forever (threadDelay <span class="dv">1000000000</span>)</span></code></pre></div>
<p>That should be it…don’t worry if you don’t understand all of it, most of it is just implementation details from <code>simpleirc</code>. The overall loop is <code>runOnChanM</code> waits on a separate thread for <code>inputChan</code>…when it gets input, it runs it through <code>ChatBot</code> and sends the outputs through <em>simpleirc</em>’s interface. Meanwhile, <code>onMessage</code> is triggered whenever <em>simpleirc</em> receives a message, where it prepares an <code>InMessage</code> and drops it off at <code>inputChan</code>.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="ot">runOnChanM ::</span> <span class="dt">Monad</span> m</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>           <span class="ot">=&gt;</span> (<span class="kw">forall</span> c<span class="op">.</span> m c <span class="ot">-&gt;</span> <span class="dt">IO</span> c)   <span class="co">-- convert `m` to `IO`</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>           <span class="ot">-&gt;</span> (b <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">Bool</span>)            <span class="co">-- handle output</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>           <span class="ot">-&gt;</span> <span class="dt">Chan</span> a                    <span class="co">-- chan to await input on</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>           <span class="ot">-&gt;</span> <span class="dt">Auto</span> m a b                <span class="co">-- `Auto` to run</span></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>           <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">Auto</span> m a b)</span></code></pre></div>
<p><code>runOnChanM</code> runs any <code>Auto m a b</code>, as long as there’s a way to convert it to <code>Auto IO a b</code> (we can use a <code>ChatBot IO</code>, so we just put <code>id</code> there). You give it a “handler” <code>b -&gt; IO Bool</code> that it run whenever it outputs; if the handler returns <code>False</code>, then the whole thing stops. You give it the <code>Chan a</code> to await for input <code>a</code>s on, and it takes care of the rest. It blocks until the handler returns <code>False</code>, where it’ll return the “updated” <code>Auto m a b</code> with updated state after running through all of those inputs.</p>
<p>Phew. With that out of the way, let’s get right on to the fun part — building our chat bot modules.</p>
<h2 id="the-modules">The Modules</h2>
<h3 id="seenbot">seenBot</h3>
<p>What’s a common module? Well, we can write a module that keeps track of the last time any user was “seen” (sent a message), and then respond when there is a query.</p>
<p>There are two components here…the part that keeps track of the last seen time, and the part that responds to queries.</p>
<p>Keeping track of our last seen time sounds like a job that takes in a stream of <code>(Nick, UTCTime)</code> pairs and outputs a stream of <code>Map Nick UTCTime</code>, where we could look up the last seen time for a nick by looking up the nick in the map.</p>
<p>Logically, this is pretty straightforward, and anything other than <code>accum</code> (which is like <code>foldl'</code>) would really be a bit overkill; every input would just update the output map.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="ot">trackSeens ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">Auto</span> m (<span class="dt">Nick</span>, <span class="dt">UTCTime</span>) (<span class="dt">Map</span> <span class="dt">Nick</span> <span class="dt">UTCTime</span>)</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>trackSeens <span class="ot">=</span> accum (\mp (nick, time) <span class="ot">-&gt;</span> M.insert nick time mp) M.empty</span></code></pre></div>
<p><code>accum</code> takes the same thing that <code>foldl</code> takes:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="fu">foldl</span><span class="ot"> ::</span>            (b <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> b</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a><span class="ot">accum ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> (b <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> <span class="dt">Auto</span> m a b</span></code></pre></div>
<p>So it basically “folds up” the entire history of inputs, with a starting value. Every time an input comes, the output is the new folded history of inputs. You can sort of think of it as it applying the function to any incoming values to an internal accumulator and updating it at every step.</p>
<p>By the way, because <code>trackSeens</code> is self-serializing, we need a <code>Serialize</code> instance for <code>UTCTime</code>…just for the sake of demonstration, let’s make one now. Let’s also write a <code>Serialize</code> instance for <code>Day</code> (which represents a date) too, while we’re at it.</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/auto/chatbot.hs#L230-L236</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Serialize</span> <span class="dt">UTCTime</span> <span class="kw">where</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>    get <span class="ot">=</span> <span class="fu">read</span> <span class="op">&lt;$&gt;</span> get      <span class="co">-- haha don&#39;t do this in real life.</span></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>    put <span class="ot">=</span> put <span class="op">.</span> <span class="fu">show</span></span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Serialize</span> <span class="dt">Day</span> <span class="kw">where</span></span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a>    get <span class="ot">=</span> <span class="dt">ModifiedJulianDay</span> <span class="op">&lt;$&gt;</span> get</span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a>    put <span class="ot">=</span> put <span class="op">.</span> toModifiedJulianDay</span></code></pre></div>
<p>The next component is just to respond to requests. We want to do something on some “triggering” input. Every once in a while, some input will come that will “trigger” some special response. This is a sign that we can use <em>blip streams</em>.</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="ot">queryBlips ::</span> <span class="dt">Auto</span> m <span class="dt">Message</span> (<span class="dt">Blip</span> <span class="dt">Nick</span>)</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>queryBlips <span class="ot">=</span> emitJusts (getRequest <span class="op">.</span> <span class="fu">words</span>)</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>    getRequest (<span class="st">&quot;@seen&quot;</span><span class="op">:</span>nick<span class="op">:</span>_) <span class="ot">=</span> <span class="dt">Just</span> nick</span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>    getRequest _                <span class="ot">=</span> <span class="dt">Nothing</span></span></code></pre></div>
<p><code>queryBlips</code> takes an input stream of strings and turns it into an output <em>blip stream</em> that emits with a <code>Nick</code> whenever the input stream contains a request in the form of <code>"@seen [nick]"</code>.</p>
<p>With these simple blocks, we can build our <code>seenBot</code>:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- seenBot :: Monad m =&gt; Auto m InMessage (Blip [Message])</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/auto/chatbot.hs#L96-L115</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a><span class="ot">seenBot ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">RoomBot</span> m</span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>seenBot <span class="ot">=</span> proc (<span class="dt">InMessage</span> nick msg _ time) <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a>    seens  <span class="ot">&lt;-</span> trackSeens <span class="op">-&lt;</span> (nick, time)</span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a>    queryB <span class="ot">&lt;-</span> queryBlips <span class="op">-&lt;</span> msg</span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span><span class="ot"> respond ::</span> <span class="dt">Nick</span> <span class="ot">-&gt;</span> [<span class="dt">Message</span>]</span>
<span id="cb17-11"><a href="#cb17-11" aria-hidden="true" tabindex="-1"></a>        respond qry <span class="ot">=</span> <span class="kw">case</span> M.lookup qry seens <span class="kw">of</span></span>
<span id="cb17-12"><a href="#cb17-12" aria-hidden="true" tabindex="-1"></a>                        <span class="dt">Just</span> t  <span class="ot">-&gt;</span> [qry <span class="op">++</span> <span class="st">&quot; last seen at &quot;</span> <span class="op">++</span> <span class="fu">show</span> t <span class="op">++</span> <span class="st">&quot;.&quot;</span>]</span>
<span id="cb17-13"><a href="#cb17-13" aria-hidden="true" tabindex="-1"></a>                        <span class="dt">Nothing</span> <span class="ot">-&gt;</span> [<span class="st">&quot;No record of &quot;</span> <span class="op">++</span> qry <span class="op">++</span> <span class="st">&quot;.&quot;</span>]</span>
<span id="cb17-14"><a href="#cb17-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-15"><a href="#cb17-15" aria-hidden="true" tabindex="-1"></a>    <span class="fu">id</span> <span class="op">-&lt;</span> respond <span class="op">&lt;$&gt;</span> queryB</span>
<span id="cb17-16"><a href="#cb17-16" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb17-17"><a href="#cb17-17" aria-hidden="true" tabindex="-1"></a><span class="ot">    trackSeens ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">Auto</span> m (<span class="dt">Nick</span>, <span class="dt">UTCTime</span>) (<span class="dt">Map</span> <span class="dt">Nick</span> <span class="dt">UTCTime</span>)</span>
<span id="cb17-18"><a href="#cb17-18" aria-hidden="true" tabindex="-1"></a>    trackSeens <span class="ot">=</span> accum (\mp (nick, time) <span class="ot">-&gt;</span> M.insert nick time mp) M.empty</span>
<span id="cb17-19"><a href="#cb17-19" aria-hidden="true" tabindex="-1"></a><span class="ot">    queryBlips ::</span> <span class="dt">Auto</span> m <span class="dt">Message</span> (<span class="dt">Blip</span> <span class="dt">Nick</span>)</span>
<span id="cb17-20"><a href="#cb17-20" aria-hidden="true" tabindex="-1"></a>    queryBlips <span class="ot">=</span> emitJusts (getRequest <span class="op">.</span> <span class="fu">words</span>)</span>
<span id="cb17-21"><a href="#cb17-21" aria-hidden="true" tabindex="-1"></a>      <span class="kw">where</span></span>
<span id="cb17-22"><a href="#cb17-22" aria-hidden="true" tabindex="-1"></a>        getRequest (<span class="st">&quot;@seen&quot;</span><span class="op">:</span>nick<span class="op">:</span>_) <span class="ot">=</span> <span class="dt">Just</span> nick</span>
<span id="cb17-23"><a href="#cb17-23" aria-hidden="true" tabindex="-1"></a>        getRequest _                <span class="ot">=</span> <span class="dt">Nothing</span></span></code></pre></div>
<p>Here we define <code>respond</code> as a function that takes a <code>Nick</code> and returns the output <code>[Message]</code>. We could have also defined it outside as a helper function <code>respond :: Map Nick UTCTime -&gt; Nick -&gt; [Message]</code>…but <code>seens</code> is already in scope, so we might as well just do it there.</p>
<p>For our output, we use the <code>Functor</code> instance of blip streams. <code>respond &lt;$&gt; queryB</code> is a blip stream that emits whenever <code>queryB</code> emits (so, whenever there is a query input), but replaces the emitted value with the result of the function on the value. So whenever <code>queryB</code> emits, this whole thing emits with <code>respond</code> applied to whatever <code>Nick</code> was emitted — in this case, our <code>[Message]</code>.</p>
<p>Short, sweet, simple. In fact, <code>trackSeens</code> and <code>queryBlips</code> are small enough that their definition could really have been inlined. Breaking them down just allowed us to look at them individually for this tutorial.</p>
<p>So that’s it for that; also, if we wanted <code>seenBot</code> to serialize and persist across sessions, all we have to do is use:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>serializing&#39; <span class="st">&quot;seenbot.dat&quot;</span><span class="ot"> seenBot ::</span> <span class="dt">MonadIO</span> m <span class="ot">=&gt;</span> <span class="dt">RoomBot</span> m</span></code></pre></div>
<p>Neat, right?</p>
<p>If we forsee ourselves adding more features to <code>seenBot</code>, we can future-proof our <code>seenBot</code> for now by only serializing <code>trackSeens</code>, meaning replacing that line with:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a>    seens <span class="ot">&lt;-</span> serializing&#39; <span class="st">&quot;seen.dat&quot;</span> trackSeens <span class="op">-&lt;</span> (nick, time)</span></code></pre></div>
<p>Remember, <code>serializing' fp</code> acts as a sort of “identity”, so you can drop it in anywhere and you’d expect it to behave the same.</p>
<h3 id="repbot">repBot</h3>
<p>Another common bot is a “reputation bot”, which allows users to increment or decrement another user’s reputation scores, and look up a user’s total score.</p>
<p>Again there are two components — keeping track of the scores of all of the users, and responding to requests.</p>
<p>This time though, our “score updates” only happen every once in a while, triggered by certain words in the message. Again, this pattern calls for a blip stream:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="ot">updateBlips ::</span> <span class="dt">Auto</span> m (<span class="dt">Nick</span>, <span class="dt">Message</span>) (<span class="dt">Blip</span> (<span class="dt">Nick</span>, <span class="dt">Int</span>))</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>updateBlips <span class="ot">=</span> emitJusts getUpdateCommand</span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- updater is the person triggering the update blip</span></span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a>    getUpdateCommand (updater, msg) <span class="ot">=</span></span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a>      <span class="kw">case</span> <span class="fu">words</span> msg <span class="kw">of</span></span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a>        <span class="st">&quot;@addRep&quot;</span><span class="op">:</span>nick<span class="op">:</span>_ <span class="op">|</span> nick <span class="op">/=</span> updater <span class="ot">-&gt;</span> <span class="dt">Just</span> (nick, <span class="dv">1</span>)</span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true" tabindex="-1"></a>        <span class="st">&quot;@subRep&quot;</span><span class="op">:</span>nick<span class="op">:</span>_                   <span class="ot">-&gt;</span> <span class="dt">Just</span> (nick, <span class="op">-</span><span class="dv">1</span>)</span>
<span id="cb20-9"><a href="#cb20-9" aria-hidden="true" tabindex="-1"></a>        _                                  <span class="ot">-&gt;</span> <span class="dt">Nothing</span></span></code></pre></div>
<p><code>updateBlips</code> takes in a stream of <code>(Nick, Message)</code>, with the person who is sending the message and their message, and outputs a blip stream that and emits with a <code>(Nick, Int)</code> whenever the message is a command. The emitted <code>(Nick, Int)</code> has the person to adjust, and the amount to adjust by. Note that we ignore commands where the person is trying to increase their own reputation because that’s just lame.</p>
<p>We probably want to keep track of the scores as a <code>Map Nick Int</code>, so we can do that with something like <code>accum</code> again. However, <code>accum</code> takes a stream of normal values, but we have a <em>blip stream</em>, so we can use <code>scanB</code> instead. <code>scanB</code> is pretty much the same thing, but it collapses a blip stream into a value stream by holding the “current result” of the fold.<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a></p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="ot">trackReps ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">Auto</span> m (<span class="dt">Blip</span> (<span class="dt">Nick</span>, <span class="dt">Int</span>)) (<span class="dt">Map</span> <span class="dt">Nick</span> <span class="dt">Int</span>)</span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>trackReps <span class="ot">=</span> scanB (\mp (nick, change) <span class="ot">-&gt;</span> M.insertWith (<span class="op">+</span>) nick change mp) M.empty</span></code></pre></div>
<p>And finally, the “response” portion — we want to be able to respond to commands and look up the result. We basically had this identical pattern for <code>seenBot</code>:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="ot">queryBlips ::</span> <span class="dt">Auto</span> m <span class="dt">Message</span> (<span class="dt">Blip</span> <span class="dt">Nick</span>)</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>queryBlips <span class="ot">=</span> emitJusts (getRequest <span class="op">.</span> <span class="fu">words</span>)</span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a>    getRequest (<span class="st">&quot;@rep&quot;</span><span class="op">:</span>nick<span class="op">:</span>_) <span class="ot">=</span> <span class="dt">Just</span> nick</span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a>    getRequest _                <span class="ot">=</span> <span class="dt">Nothing</span></span></code></pre></div>
<p>And…now we can wrap it all together with a nice proc block:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- repBot :: Monad m =&gt; Auto m InMessage (Blip [Message])</span></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/auto/chatbot.hs#L117-L147</span></span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a><span class="ot">repBot ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">RoomBot</span> m</span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a>repBot <span class="ot">=</span> proc (<span class="dt">InMessage</span> nick msg _ _) <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true" tabindex="-1"></a>    updateB <span class="ot">&lt;-</span> updateBlips <span class="op">-&lt;</span> (nick, msg)</span>
<span id="cb23-7"><a href="#cb23-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-8"><a href="#cb23-8" aria-hidden="true" tabindex="-1"></a>    reps    <span class="ot">&lt;-</span> trackReps   <span class="op">-&lt;</span> updateB</span>
<span id="cb23-9"><a href="#cb23-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-10"><a href="#cb23-10" aria-hidden="true" tabindex="-1"></a>    queryB  <span class="ot">&lt;-</span> queryBlips  <span class="op">-&lt;</span> msg</span>
<span id="cb23-11"><a href="#cb23-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-12"><a href="#cb23-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span><span class="ot"> lookupRep ::</span> <span class="dt">Nick</span> <span class="ot">-&gt;</span> [<span class="dt">Message</span>]</span>
<span id="cb23-13"><a href="#cb23-13" aria-hidden="true" tabindex="-1"></a>        lookupRep nick <span class="ot">=</span> [nick <span class="op">++</span> <span class="st">&quot; has a reputation of &quot;</span> <span class="op">++</span> <span class="fu">show</span> rep <span class="op">++</span> <span class="st">&quot;.&quot;</span>]</span>
<span id="cb23-14"><a href="#cb23-14" aria-hidden="true" tabindex="-1"></a>          <span class="kw">where</span></span>
<span id="cb23-15"><a href="#cb23-15" aria-hidden="true" tabindex="-1"></a>            rep <span class="ot">=</span> M.findWithDefault <span class="dv">0</span> nick reps</span>
<span id="cb23-16"><a href="#cb23-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-17"><a href="#cb23-17" aria-hidden="true" tabindex="-1"></a>    <span class="fu">id</span> <span class="op">-&lt;</span> lookupRep <span class="op">&lt;$&gt;</span> queryB</span>
<span id="cb23-18"><a href="#cb23-18" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb23-19"><a href="#cb23-19" aria-hidden="true" tabindex="-1"></a><span class="ot">    updateBlips ::</span> <span class="dt">Auto</span> m (<span class="dt">Nick</span>, <span class="dt">Message</span>) (<span class="dt">Blip</span> (<span class="dt">Nick</span>, <span class="dt">Int</span>))</span>
<span id="cb23-20"><a href="#cb23-20" aria-hidden="true" tabindex="-1"></a>    updateBlips <span class="ot">=</span> emitJusts getUpdateCommand</span>
<span id="cb23-21"><a href="#cb23-21" aria-hidden="true" tabindex="-1"></a>      <span class="kw">where</span></span>
<span id="cb23-22"><a href="#cb23-22" aria-hidden="true" tabindex="-1"></a>        <span class="co">-- updater is the person triggering the update blip</span></span>
<span id="cb23-23"><a href="#cb23-23" aria-hidden="true" tabindex="-1"></a>        getUpdateCommand (updater, msg) <span class="ot">=</span></span>
<span id="cb23-24"><a href="#cb23-24" aria-hidden="true" tabindex="-1"></a>          <span class="kw">case</span> <span class="fu">words</span> msg <span class="kw">of</span></span>
<span id="cb23-25"><a href="#cb23-25" aria-hidden="true" tabindex="-1"></a>            <span class="st">&quot;@addRep&quot;</span><span class="op">:</span>nick<span class="op">:</span>_ <span class="op">|</span> nick <span class="op">/=</span> updater <span class="ot">-&gt;</span> <span class="dt">Just</span> (nick, <span class="dv">1</span>)</span>
<span id="cb23-26"><a href="#cb23-26" aria-hidden="true" tabindex="-1"></a>            <span class="st">&quot;@subRep&quot;</span><span class="op">:</span>nick<span class="op">:</span>_                   <span class="ot">-&gt;</span> <span class="dt">Just</span> (nick, <span class="op">-</span><span class="dv">1</span>)</span>
<span id="cb23-27"><a href="#cb23-27" aria-hidden="true" tabindex="-1"></a>            _                                  <span class="ot">-&gt;</span> <span class="dt">Nothing</span></span>
<span id="cb23-28"><a href="#cb23-28" aria-hidden="true" tabindex="-1"></a><span class="ot">    trackReps ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">Auto</span> m (<span class="dt">Blip</span> (<span class="dt">Nick</span>, <span class="dt">Int</span>)) (<span class="dt">Map</span> <span class="dt">Nick</span> <span class="dt">Int</span>)</span>
<span id="cb23-29"><a href="#cb23-29" aria-hidden="true" tabindex="-1"></a>    trackReps <span class="ot">=</span> scanB (\mp (nick, change) <span class="ot">-&gt;</span> M.insertWith (<span class="op">+</span>) nick change mp) M.empty</span>
<span id="cb23-30"><a href="#cb23-30" aria-hidden="true" tabindex="-1"></a><span class="ot">    queryBlips ::</span> <span class="dt">Auto</span> m <span class="dt">Message</span> (<span class="dt">Blip</span> <span class="dt">Nick</span>)</span>
<span id="cb23-31"><a href="#cb23-31" aria-hidden="true" tabindex="-1"></a>    queryBlips <span class="ot">=</span> emitJusts (getRequest <span class="op">.</span> <span class="fu">words</span>)</span>
<span id="cb23-32"><a href="#cb23-32" aria-hidden="true" tabindex="-1"></a>      <span class="kw">where</span></span>
<span id="cb23-33"><a href="#cb23-33" aria-hidden="true" tabindex="-1"></a>        getRequest (<span class="st">&quot;@rep&quot;</span><span class="op">:</span>nick<span class="op">:</span>_) <span class="ot">=</span> <span class="dt">Just</span> nick</span>
<span id="cb23-34"><a href="#cb23-34" aria-hidden="true" tabindex="-1"></a>        getRequest _                <span class="ot">=</span> <span class="dt">Nothing</span></span></code></pre></div>
<p>Again note that we take advantage of the <code>Functor</code> instance of blip streams to create a new blip stream (<code>lookupRep &lt;$&gt; queryB</code>) that emits whenever <code>queryB</code> emits, but replaces the value with <code>lookupRep</code> applied to whatever <code>Nick</code> was in the query blip. We also take advantage that <code>reps</code> is in scope and define <code>lookupRep</code> right there in the block.</p>
<h3 id="announcebot">announceBot</h3>
<p>Let’s just go over one more module…and I think you’ll be able to use your imagination to think of and implement your own from here.</p>
<p>Let’s make an “announceBot”, that listens for “announcement” messages from anyone (even in private messages) and broadcasts them to all of the channels in the provided list. It rate-limits the announcements, though, so that a user is only limited to three announcements per day.</p>
<p>We can start with our typical “blip stream that emits on a certain command” to start off everything:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="ot">announceBlips ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">Auto</span> m (<span class="dt">Nick</span>, <span class="dt">Message</span>) (<span class="dt">Blip</span> [<span class="dt">Message</span>])</span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a>announceBlips <span class="ot">=</span> emitJusts getAnnounces</span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a>    getAnnounces (nick, msg) <span class="ot">=</span></span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a>      <span class="kw">case</span> <span class="fu">words</span> msg <span class="kw">of</span></span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true" tabindex="-1"></a>        <span class="st">&quot;@ann&quot;</span><span class="op">:</span>ann <span class="ot">-&gt;</span> <span class="dt">Just</span> [nick <span class="op">++</span> <span class="st">&quot; says \&quot;&quot;</span> <span class="op">++</span> <span class="fu">unwords</span> ann <span class="op">++</span> <span class="st">&quot;\&quot;.&quot;</span>]</span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true" tabindex="-1"></a>        _          <span class="ot">-&gt;</span> <span class="dt">Nothing</span></span></code></pre></div>
<p><code>announceBlips</code> takes in a nick-message pair and emits an announcement <code>[Message]</code> whenever the incoming message is an announcement command.</p>
<p>Next, we’d like to keep track of how many times a user has made an announcement today. This is pretty much just <code>scanB</code> again like with <code>repBot</code>:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="ot">trackAnns ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">Auto</span> m (<span class="dt">Blip</span> <span class="dt">Nick</span>) (<span class="dt">Map</span> <span class="dt">Nick</span> <span class="dt">Int</span>)</span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a>trackAnns <span class="ot">=</span> scanB (\mp nick <span class="ot">-&gt;</span> M.insertWith (<span class="op">+</span>) nick <span class="dv">1</span> mp) M.empty</span></code></pre></div>
<p>However, we’d like to be able to “reset” this map whenever a new day arrives. For that, we can use <code>resetOn</code> from <a href="http://hackage.haskell.org/package/auto/docs/Control-Auto-Switch.html"><code>Control.Auto.Switch</code></a>, which takes an <code>Auto</code> and gives it a “reset channel” input blip stream, that resets the whole thing whenever the blip stream emits:</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="ot">resetOn ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">Auto</span> m a b <span class="ot">-&gt;</span> <span class="dt">Auto</span> m (a        , <span class="dt">Blip</span> c) b</span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a>resetOn<span class="ot"> trackAnns ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span>     <span class="dt">Auto</span> m (<span class="dt">Blip</span> <span class="dt">Nick</span>, <span class="dt">Blip</span> c) (<span class="dt">Map</span> <span class="dt">Nick</span> <span class="dt">Int</span>)</span></code></pre></div>
<p>(It doesn’t care about the actual value emitted, so we can leave it as a type variable <code>c</code> conceptually.)</p>
<p>Now the only thing we need is a blip stream that emits whenever there is a new day. For that, we can use <code>onChange</code> from <a href="http://hackage.haskell.org/package/auto/docs/Control-Auto-Blip.html"><code>Control.Auto.Blip</code></a>:</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="ot">newDayBlips ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">Auto</span> m <span class="dt">Day</span> (<span class="dt">Blip</span> <span class="dt">Day</span>)</span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a>newDayBlips <span class="ot">=</span> onChange</span></code></pre></div>
<p><code>newDayBlips</code> takes in a stream of <code>Day</code>s (from <code>Data.Time</code>) that we get from the <code>InMessage</code> and outputs a blip stream that emits whenever the day changes. It emits with the new <code>Day</code>…but we don’t really care about the emitted value, we’re just using it to trigger <code>resetOn trackAnns</code>.</p>
<p>Finally, let’s wrap it all together!</p>
<p>Remember, <code>announceBot</code> is a full on <code>ChatBot m</code>, and not a <code>RoomBot m</code> anymore, so it has to say where it wants to send its messages.</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- announceBot :: Monad m =&gt; [Channel] -&gt; Auto m InMessage OutMessages</span></span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/auto/chatbot.hs#L149-L183</span></span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a><span class="ot">announceBot ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> [<span class="dt">Channel</span>] <span class="ot">-&gt;</span> <span class="dt">ChatBot</span> m</span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true" tabindex="-1"></a>announceBot chans <span class="ot">=</span> proc (<span class="dt">InMessage</span> nick msg src time) <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb28-6"><a href="#cb28-6" aria-hidden="true" tabindex="-1"></a>    announceB <span class="ot">&lt;-</span> announceBlips     <span class="op">-&lt;</span> (nick, msg)</span>
<span id="cb28-7"><a href="#cb28-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-8"><a href="#cb28-8" aria-hidden="true" tabindex="-1"></a>    newDayB   <span class="ot">&lt;-</span> newDayBlips       <span class="op">-&lt;</span> utctDay time</span>
<span id="cb28-9"><a href="#cb28-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-10"><a href="#cb28-10" aria-hidden="true" tabindex="-1"></a>    annCounts <span class="ot">&lt;-</span> resetOn trackAnns <span class="op">-&lt;</span> (nick <span class="op">&lt;$</span> announceB, newDayB)</span>
<span id="cb28-11"><a href="#cb28-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-12"><a href="#cb28-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> hasFlooded  <span class="ot">=</span> M.findWithDefault <span class="dv">0</span> nick annCounts <span class="op">&gt;</span> <span class="dv">3</span></span>
<span id="cb28-13"><a href="#cb28-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-14"><a href="#cb28-14" aria-hidden="true" tabindex="-1"></a><span class="ot">        targetChans ::</span> [<span class="dt">Channel</span>]</span>
<span id="cb28-15"><a href="#cb28-15" aria-hidden="true" tabindex="-1"></a>        targetChans <span class="op">|</span> hasFlooded <span class="ot">=</span> [src]</span>
<span id="cb28-16"><a href="#cb28-16" aria-hidden="true" tabindex="-1"></a>                    <span class="op">|</span> <span class="fu">otherwise</span>  <span class="ot">=</span> chans</span>
<span id="cb28-17"><a href="#cb28-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-18"><a href="#cb28-18" aria-hidden="true" tabindex="-1"></a><span class="ot">        outB        ::</span> <span class="dt">Blip</span> [<span class="dt">Message</span>]</span>
<span id="cb28-19"><a href="#cb28-19" aria-hidden="true" tabindex="-1"></a>        outB        <span class="op">|</span> hasFlooded <span class="ot">=</span> [nick <span class="op">++</span> <span class="st">&quot;: No flooding!&quot;</span>] <span class="op">&lt;$</span> announceB</span>
<span id="cb28-20"><a href="#cb28-20" aria-hidden="true" tabindex="-1"></a>                    <span class="op">|</span> <span class="fu">otherwise</span>  <span class="ot">=</span> announceB</span>
<span id="cb28-21"><a href="#cb28-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-22"><a href="#cb28-22" aria-hidden="true" tabindex="-1"></a><span class="ot">        outMsgsB    ::</span> <span class="dt">Blip</span> <span class="dt">OutMessages</span></span>
<span id="cb28-23"><a href="#cb28-23" aria-hidden="true" tabindex="-1"></a>        outMsgsB    <span class="ot">=</span> (\out <span class="ot">-&gt;</span> <span class="dt">OutMessages</span> (M.fromList (<span class="fu">map</span> (,out) targetChans)))</span>
<span id="cb28-24"><a href="#cb28-24" aria-hidden="true" tabindex="-1"></a>                  <span class="op">&lt;$&gt;</span> outB</span>
<span id="cb28-25"><a href="#cb28-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-26"><a href="#cb28-26" aria-hidden="true" tabindex="-1"></a>    fromBlips <span class="fu">mempty</span> <span class="op">-&lt;</span> outMsgsB</span>
<span id="cb28-27"><a href="#cb28-27" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb28-28"><a href="#cb28-28" aria-hidden="true" tabindex="-1"></a><span class="ot">    announceBlips ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">Auto</span> m (<span class="dt">Nick</span>, <span class="dt">Message</span>) (<span class="dt">Blip</span> [<span class="dt">Message</span>])</span>
<span id="cb28-29"><a href="#cb28-29" aria-hidden="true" tabindex="-1"></a>    announceBlips <span class="ot">=</span> emitJusts getAnnounces</span>
<span id="cb28-30"><a href="#cb28-30" aria-hidden="true" tabindex="-1"></a>      <span class="kw">where</span></span>
<span id="cb28-31"><a href="#cb28-31" aria-hidden="true" tabindex="-1"></a>        getAnnounces (nick, msg) <span class="ot">=</span></span>
<span id="cb28-32"><a href="#cb28-32" aria-hidden="true" tabindex="-1"></a>          <span class="kw">case</span> <span class="fu">words</span> msg <span class="kw">of</span></span>
<span id="cb28-33"><a href="#cb28-33" aria-hidden="true" tabindex="-1"></a>            <span class="st">&quot;@ann&quot;</span><span class="op">:</span>ann <span class="ot">-&gt;</span> <span class="dt">Just</span> [nick <span class="op">++</span> <span class="st">&quot; says \&quot;&quot;</span> <span class="op">++</span> <span class="fu">unwords</span> ann <span class="op">++</span> <span class="st">&quot;\&quot;.&quot;</span>]</span>
<span id="cb28-34"><a href="#cb28-34" aria-hidden="true" tabindex="-1"></a>            _          <span class="ot">-&gt;</span> <span class="dt">Nothing</span></span>
<span id="cb28-35"><a href="#cb28-35" aria-hidden="true" tabindex="-1"></a><span class="ot">    newDayBlips ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">Auto</span> m <span class="dt">Day</span> (<span class="dt">Blip</span> <span class="dt">Day</span>)</span>
<span id="cb28-36"><a href="#cb28-36" aria-hidden="true" tabindex="-1"></a>    newDayBlips <span class="ot">=</span> onChange</span>
<span id="cb28-37"><a href="#cb28-37" aria-hidden="true" tabindex="-1"></a><span class="ot">    trackAnns ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">Auto</span> m (<span class="dt">Blip</span> <span class="dt">Nick</span>) (<span class="dt">Map</span> <span class="dt">Nick</span> <span class="dt">Int</span>)</span>
<span id="cb28-38"><a href="#cb28-38" aria-hidden="true" tabindex="-1"></a>    trackAnns <span class="ot">=</span> scanB (\mp nick <span class="ot">-&gt;</span> M.insertWith (<span class="op">+</span>) nick <span class="dv">1</span> mp) M.empty</span></code></pre></div>
<p>Only slightly more involved, but still pretty readable, right? We find out if things have flooded, and our target channels will be just the original source if true (a message as a reprimand); otherwise, all the channels in <code>chans</code>. If they have flooded, then our <code>outB</code> (blip stream of <code>[Message]</code> to send to each room) will just be <code>["No flooding!"]</code> if yes, or the actual announcement otherwise.</p>
<p>Finally, our <code>Blip OutMessages</code> will be the <code>OutMessage</code> formed by associating all of the channels in <code>targetChans</code> with the message in <code>outB</code>…emitting whenever <code>outB</code> emits.</p>
<p>Note here that we use <code>(&lt;$)</code> from the <code>Functor</code> instance of blip streams. <code>x &lt;$ fooB</code> is a new blip stream that emits whenever <code>fooB</code> emits…but instead <em>replaces the emitted value</em>. So for <code>4 &lt;$ fooB</code>, if <code>fooB</code> emits with <code>"hello"</code>, <code>4 &lt;$ fooB</code> emits with <code>4</code>. “Emit at the same time, but pry out the value and put in your own.”</p>
<p>Finally we use <code>fromBlips</code>, which we met before in the definition of <code>perRoom</code>: the output is the <code>OutMessage</code> in <code>outMsgsB</code> whenever <code>outMsgsB</code> <em>does</em> emit…or it’s <code>mempty</code> (the empty map) when it doesn’t.</p>
<h2 id="wrapping-it-all-up">Wrapping it all up</h2>
<p>We have three nice modules now. Now let’s wrap it all together.</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/auto/chatbot.hs#L83-L88</span></span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a><span class="ot">chatBot ::</span> <span class="dt">MonadIO</span> m <span class="ot">=&gt;</span> <span class="dt">ChatBot</span> m</span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a>chatBot <span class="ot">=</span> serializing&#39; <span class="st">&quot;chatbot.dat&quot;</span></span>
<span id="cb29-5"><a href="#cb29-5" aria-hidden="true" tabindex="-1"></a>        <span class="op">.</span> <span class="fu">mconcat</span> <span class="op">$</span> [ perRoom seenBot</span>
<span id="cb29-6"><a href="#cb29-6" aria-hidden="true" tabindex="-1"></a>                    , perRoom repBot</span>
<span id="cb29-7"><a href="#cb29-7" aria-hidden="true" tabindex="-1"></a>                    , announceBot channels</span>
<span id="cb29-8"><a href="#cb29-8" aria-hidden="true" tabindex="-1"></a>                    ]</span></code></pre></div>
<p>Or, to future-proof, in case we foresee adding new modules:</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/auto/chatbot.hs#L90-L94</span></span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a><span class="ot">chatBot&#39; ::</span> <span class="dt">MonadIO</span> m <span class="ot">=&gt;</span> <span class="dt">ChatBot</span> m</span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true" tabindex="-1"></a>chatBot&#39; <span class="ot">=</span> <span class="fu">mconcat</span> [ perRoom <span class="op">.</span> serializing&#39; <span class="st">&quot;seens.dat&quot;</span> <span class="op">$</span> seenBot</span>
<span id="cb30-5"><a href="#cb30-5" aria-hidden="true" tabindex="-1"></a>                   , perRoom <span class="op">.</span> serializing&#39; <span class="st">&quot;reps.dat&quot;</span>  <span class="op">$</span> repBot</span>
<span id="cb30-6"><a href="#cb30-6" aria-hidden="true" tabindex="-1"></a>                   ,           serializing&#39; <span class="st">&quot;anns.dat&quot;</span>  <span class="op">$</span> announceBot channels</span>
<span id="cb30-7"><a href="#cb30-7" aria-hidden="true" tabindex="-1"></a>                   ]</span></code></pre></div>
<p>And…that’s it!</p>
<p>Feel free to <a href="https://github.com/mstksg/inCode/tree/master/code-samples/auto/chatbot.hs">download and run this all yourself</a> using <code>runghc</code>! (provided you have the appropriate libraries installed)</p>
<div class="note">
<p><strong>Aside</strong></p>
<p>This is a quick diversion! It’s slightly more advanced, so don’t worry if you don’t understand it immediately.</p>
<p>Note that the <code>perRoom</code> upgrade has the same <code>RoomBot m</code> watch <em>all</em> of the channels and send any replies back to the channel that it just received from. Every channel is really interacting with the <em>same</em> <code>RoomBot</code> instance, with one shared state. So <code>perRoom repBot</code> keeps track of reputations between rooms — asking for someone’s reputation in one room will be the same as asking for it in another room.</p>
<p>Another way we could “upgrade” a <code>RoomBot</code> is to give each channel its own little copy, with separate state. We can do this using <code>mux</code>:</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/auto/chatbot.hs#L78-L81</span></span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a><span class="ot">isolatedRooms ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">RoomBot</span> m <span class="ot">-&gt;</span> <span class="dt">ChatBot</span> m</span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true" tabindex="-1"></a>isolatedRooms rb <span class="ot">=</span> proc inp<span class="op">@</span>(<span class="dt">InMessage</span> _ _ src _) <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb31-5"><a href="#cb31-5" aria-hidden="true" tabindex="-1"></a>    messages <span class="ot">&lt;-</span> fromBlips [] <span class="op">.</span> mux (<span class="fu">const</span> rb) <span class="op">-&lt;</span> (src, inp)</span>
<span id="cb31-6"><a href="#cb31-6" aria-hidden="true" tabindex="-1"></a>    <span class="fu">id</span> <span class="op">-&lt;</span> <span class="dt">OutMessages</span> <span class="op">$</span> M.singleton src messages</span></code></pre></div>
<p><code>mux</code> is an “<code>Auto</code> multiplexer”:</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="ot">mux ::</span> (k <span class="ot">-&gt;</span> <span class="dt">Auto</span> m a b) <span class="ot">-&gt;</span> <span class="dt">Auto</span> m (k, a) b</span></code></pre></div>
<p><code>mux f</code> associates a separate/different <code>Auto</code>, with its own isolated state, with every key <code>k</code>. It takes in a stream of key-input pairs <code>(k, a)</code> and feeds the <code>a</code> into the <code>Auto</code> it has associated with that key <code>k</code>. The function <code>f</code> is what <code>Auto</code> initialize if the <code>k</code> has not yet been seen before.</p>
<p>So we feed it a <code>(Channel, InMessage)</code>, and it feeds in that <code>InMessage</code> to the <code>RoomBot m</code> associated with that <code>Channel</code>…and the output is the <code>Blip [Message]</code> blip stream that the <code>RoomBot</code> at that <code>Channel</code> popped out.</p>
<p>Our “auto initialization function” is <code>const rb</code>, because no matter what channel we’re in, we always want to initialize with the same <code>rb</code>.</p>
<p>So, for example, if we had <code>isolatedRooms repBot</code>, if a message came from channel <em>#foo</em> saying <code>"@rep john"</code>, <em>only the <code>repBot</code> associated with #foo</em> would get the message, and only that <code>repBot</code>’s output will be displayed. If here is not yet a <code>repBot</code> instance associated with <em>#foo</em>, then a new one will be created by calling <code>const repBot</code> on <code>"#foo"</code>…initializing a new <code>repBot</code> that only knows about <em>#foo</em> messages.</p>
<p>So now every channel has its own <code>repBot</code>, and maintains its own independent reputation database.</p>
</div>
<h2 id="fin">Fin</h2>
<p>Hopefully, going over this project, you’re starting to see some common and powerful idioms and tools. I hope that a clear picture of how to approach and finish a program with the <em>auto</em> library looks…and how beneficial the platform and what it offers is to streamlining the development process.</p>
<p>Also, hopefully the “declarative” nature of everything is apparent. Especially for <em>proc</em> blocks…everything just “looks like” a graph of relationships. This quantity is related to this quantity in this way, this quantity is related to that in that way, etc. It looks like you’re just specifying a graph of relationships, which is really what the core of <em>auto</em> is all about. We assemble complex relationships by putting together small, simple relationships.</p>
<p>Another interesting thing is that we never really explicitly managed any sort of state or state type. All of our <code>Auto</code>s handled their state on their own. We didn’t need to make a giant massive aggregate bulky “global state” type…and we can add new “aspects” of state (new modules) without ever having to change any data type. The state all manages itself!</p>
<p>And yeah, we didn’t just implement “easy” modules/components…these are actual working components that you might see in real bots, and not just toy ones.</p>
<p>Where can we go from here? Well, you might actually want to maybe write “subscription” <code>Auto</code>s that are updated every minute or so:</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">ChronBot</span> m <span class="ot">=</span> <span class="dt">Auto</span> m <span class="dt">UTCTime</span> <span class="dt">OutMessages</span></span></code></pre></div>
<p>You feed them inputs every minute with the time, and it’s allowed to react with the time and output an <code>OutMessages</code>. You can use this bot to implement things like rss feed watchers/subscribers, for instance.</p>
<p>So, instead of using an input channel waiting for <code>InMessage</code>, you might wait for <code>Either InMessage UTCTime</code>…and drop in <code>Left im</code> whenever you get a message, and <code>Right time</code> from a thread that just waits a minute and repeatedly throws in times.</p>
<p>We can do this with minimal extra work by using the <code>(|||)</code> combinator from <code>Control.Arrow</code>:</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a><span class="ot">(|||) ::</span> <span class="dt">Auto</span> m a c <span class="ot">-&gt;</span> <span class="dt">Auto</span> m b c <span class="ot">-&gt;</span> <span class="dt">Auto</span> m (<span class="dt">Either</span> a         b      ) c</span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a><span class="ot">(|||) ::</span> <span class="dt">ChatBot</span> m  <span class="ot">-&gt;</span> <span class="dt">ChronBot</span> m <span class="ot">-&gt;</span> <span class="dt">Auto</span> m (<span class="dt">Either</span> <span class="dt">InMessage</span> <span class="dt">UTCTime</span>) <span class="dt">OutMessages</span></span></code></pre></div>
<p>And…you get it all for free! No extra work. Now both the <code>ChatBot</code> and the <code>ChronBot</code> will wait on the input stream, and the <code>Left</code>s will be fed to the <code>ChatBot</code> and the <code>Right</code>s will be fed to the <code>ChronBot</code>.</p>
<p>Anyway, this post is long enough. Have fun exploring <em>auto</em> on your own; expect more tutorials soon as I continue the <a href="http://blog.jle.im/entries/series/+all-about-auto">All About Auto</a> series, too. I’m always happy to hear about any project you might be working on! You can find me on twitter as <a href="https://twitter.com/mstk" title="Twitter">mstk</a>. If you have any questions or comments/suggestions, feel free to leave a comment down below or drop by freenode’s <em>#haskell-auto</em> or <em>#haskell-game</em>, where I go by <em>jle`</em>! And, as always, happy Haskelling!</p>
<section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes">
<hr />
<ol>
<li id="fn1"><p><code>scanB f x0 :: Auto m (Blip a) b</code>, but there’s also <code>accumB f x0 :: Auto m a (Blip a) (Blip b)</code>, which emits whenever the input emits only.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section></div><footer><hr><div class="copy-content"><p>Hi, thanks for reading! You can reach me via email at <a href="mailto:justin@jle.im" class="email">justin@jle.im</a>, or at twitter at <a href="https://twitter.com/mstk">@mstk</a>! This post and all others are published under the <a href="https://creativecommons.org/licenses/by-nc-nd/3.0/">CC-BY-NC-ND 3.0</a> license. Corrections and edits via pull request are welcome and encouraged at <a href="https://github.com/mstksg/inCode">the source repository</a>.</p>
<p>If you feel inclined, or this post was particularly helpful for you, why not consider <a href="https://www.patreon.com/justinle/overview">supporting me on Patreon</a>, or a <a href="bitcoin:3D7rmAYgbDnp4gp4rf22THsGt74fNucPDU">BTC donation</a>? :)</p></div><div class="clear"></div><ul class="entry-series"><li><div>This entry is a part of a series called <b>&quot;All About Auto&quot;</b>.  Find the rest of the entries in this series at its <a href="https://blog.jle.im/entries/series/+all-about-auto.html" class="tag-a-series" title="Series of introductions and tutorials for my auto library, a library offering a
denotative, locally stateful programming DSL and platform.
"> series history</a>.</div></li><li><div>This entry is a part of a series called <b>&quot;Beginner/Intermediate Haskell Projects&quot;</b>.  Find the rest of the entries in this series at its <a href="https://blog.jle.im/entries/series/+beginner-intermediate-haskell-projects.html" class="tag-a-series" title="+Beginner/Intermediate Haskell Projects"> series history</a>.</div></li></ul><ul class="tag-list"><li><a href="https://blog.jle.im/entries/tagged/auto.html" class="tag-a-tag">#auto</a></li><li><a href="https://blog.jle.im/entries/tagged/haskell.html" class="tag-a-tag">#haskell</a></li><li><a href="https://blog.jle.im/entries/category/@auto.html" class="tag-a-category">@AUTO</a></li><li><a href="https://blog.jle.im/entries/category/@haskell.html" class="tag-a-category">@HASKELL</a></li><li><a href="https://blog.jle.im/entries/category/@tutorials.html" class="tag-a-category">@TUTORIALS</a></li><li><a href="https://blog.jle.im/entries/series/+all-about-auto.html" class="tag-a-series">+All About Auto</a></li><li><a href="https://blog.jle.im/entries/series/+beginner-intermediate-haskell-projects.html" class="tag-a-series">+Beginner/Intermediate Haskell Projects</a></li></ul><aside class="social-buttons"><div class="addthis_toolbox addthis_default_style addthis-buttons"><a class="addthis_button_facebook_like" fb:like:layout="button_count"></a><a class="addthis_button_tweet"></a><a class="addthis_button_google_plusone" g:plusone:size="medium"></a><a class="addthis_counter addthis_pill_style"></a></div><div class="custom-social-buttons"><div class="custom-social-button"><a href="https://www.reddit.com/submit" onclick="window.location = &#39;https://www.reddit.com/submit?url=&#39;+ encodeURIComponent(window.location); return false"><img src="https://www.reddit.com/static/spreddit7.gif" alt="submit to reddit"></a></div></div></aside><nav class="next-prev-links"><ul><li class="prev-entry-link">&larr; <a href="https://blog.jle.im/entry/introducing-the-auto-library.html">Introducing: the Auto library!</a> (Previous)</li><li class="next-entry-link">(Next) <a href="https://blog.jle.im/entry/auto-a-todo-gui-application-with-auto-on.html">Auto: A Todo GUI application with Auto (on GHCJS, etc.)</a> &rarr;</li></ul></nav></footer></article><div class="post-entry"><div class="tile"><div id="disqus_thread"></div><script type="text/javascript">var disqus_config = function () {
    this.page.url = 'https://blog.jle.im/entry/auto-building-a-declarative-chatbot-with-implicit-serialization.html';
    this.page.identifier = 'auto-chatbot';
};
(function() {
    var d = document, s = d.createElement('script');
    s.src = '//incode.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
})();
</script><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a><br></noscript><a href="http://disqus.com" class="dsq-brlink">Comments powered by <span class="logo-disqus">Disqus</span></a></div></div></div></div></div><div id="footer-container"><div id="footer-content"><div class="tile"><div class="footer-copyright">&copy; 2020 Justin Le <span class="license-link">(<a href="https://creativecommons.org/licenses/by-nc-nd/3.0/" class="license">CC-BY-NC-ND 3.0</a>)</span></div><div class="footer-follow social-follows"><ul class="social-follows-list"><li><ul class="social-follows-list-social"><li><a class="social-follow-twitter" title="Follow me on Twitter!" href="https://twitter.com/intent/user?user_id=mstk" onclick="window.open(
  &#39;http://twitter.com/intent/user?user_id=907281&#39;,
  &#39;facebook-share-dialog&#39;,
  &#39;width=550,height=520&#39;);
return false;
">Twitter</a></li><li><a class="social-follow-github" title="Fork me on Github!" href="https://github.com/mstksg">Github</a></li><li><a class="social-follow-twitch" title="Watch me on Twitch!" href="https://www.twitch.tv/justin_l">Twitch</a></li><li><a class="social-follow-patreon" title="Support me on Patreon!" href="https://www.patreon.com/justinle/overview">Patreon</a></li><li><a class="social-follow-gplus" title="Add me on Google+!" href="https://plus.google.com/+JustinLe">Google+</a></li><li><a class="social-follow-keybase" title="Track me on Keybase!" href="https://keybase.io/mstksg">Keybase</a></li><li><a class="social-follow-linkedin" title="Connect with me on LinkedIn!" href="https://linkedin.com/in/lejustin">LinkedIn</a></li><li><a class="social-follow-bitcoin" title="Donate via bitcoin!" href="bitcoin:3D7rmAYgbDnp4gp4rf22THsGt74fNucPDU">Bitcoin</a></li></ul></li><li><ul class="social-follows-list-site"><li><a class="social-follow-rss" title="Subscribe to my RSS Feed!" href="http://feeds.feedburner.com/incodeblog">RSS</a></li><li><a class="social-follow-email" title="Subscribe to the mailing list!" href="https://feedburner.google.com/fb/a/mailverify?loc=en_US&amp;uri=incodeblog">Mailing list</a></li></ul></li></ul></div></div></div></div></body></html>