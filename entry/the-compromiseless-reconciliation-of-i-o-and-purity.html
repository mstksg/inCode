<!DOCTYPE HTML>
<html><head><title>The Compromiseless Reconciliation of I/O and Purity · in Code</title><meta name="description" content="Weblog of Justin Le, covering various adventures in programming and explorations in the worlds of computation physics, and knowledge.
"><meta http-equiv="Content-Type" content="text/html;charset=utf-8"><meta name="viewport" content="width=device-width,initial-scale=1.0"><meta name="flattr:id" content="3p9jqr"><meta property="og:site_name" content="in Code"><meta property="og:description" content="One of the crazy ideals of functional programming is the idea that your program is simply a list of definitions of mathematical functions. And like real math functions, FP functions are pure. That means that (1) they cannot affect any state, and (2) that they must return the same thing every time they are called with the same arguments. When you first learn functional programming, this manifests as “your variables are immutable and you can’t do loops; use recursion instead.” And if you do that, everything is “fine”. However, there is an apparent glaring problem with this adherence to purity: I/O. Input and output are inherently stateful."><meta property="og:type" content="article"><meta property="og:title" content="The Compromiseless Reconciliation of I/O and Purity"><meta property="og:image" content="https://blog.jle.im/img/site_logo.jpg"><meta property="og:locale" content="en_US"><meta property="og:url" content="https://blog.jle.im/entry/the-compromiseless-reconciliation-of-i-o-and-purity.html"><meta name="twitter:card" content="summary"><meta name="twitter:creator:id" content="mstk"><link rel="author" href="https://plus.google.com/107705320197444500140"><link rel="alternate" type="application/rss+xml" title="in Code (RSS Feed)" href="http://feeds.feedburner.com/incodeblog"><link rel="canonical" href="https://blog.jle.im/entry/the-compromiseless-reconciliation-of-i-o-and-purity.html"><link href="https://blog.jle.im/favicon.ico" rel="shortcut icon"><link href="https://blog.jle.im/css/toast.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/font.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/main.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/page/entry.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/pygments.css" rel="stylesheet" type="text/css"><script type="text/javascript">var page_data = {};
var disqus_shortname='incode';
</script><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-443711-8', 'jle.im');
ga('send', 'pageview');
</script><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script id="MathJax-script" async="" src="https://cdn.jsdelivr.net/npm/mathjax@3.0.1/es5/tex-mml-chtml.js"></script><script type="text/javascript" src="//ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script><script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5234d67a6b68dcd4"></script><script type="text/javascript" src="https://blog.jle.im/js/page/entry_toc.js"></script><script type="text/javascript" src="https://blog.jle.im/js/disqus_count.js"></script><script type="text/javascript" src="https://blog.jle.im/js/social.js"></script><script type="text/javascript" src="https://blog.jle.im/js/jquery/jquery.toc.js"></script><script type="text/javascript" src="https://blog.jle.im/purescript/entry.js"></script></head><body><div id="fb-root"><script>(function(d, s, id) {
 var js, fjs = d.getElementsByTagName(s)[0];
 if (d.getElementById(id)) return;
 js = d.createElement(s); js.id = id;
 js.src = "//connect.facebook.net/en_US/all.js#xfbml=1&appId=641852699171929";
 fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));
</script></div><div id="header-container"><div id="navbar-container" class="tile"><nav id="navbar-content"><div class="nav-info"><h1 class="site-title"><a href="https://blog.jle.im/" class="nav-title">in Code</a></h1><span class="nav-author">Justin Le</span></div><ul class="nav-links"><li><a href="https://blog.jle.im/">home</a></li><li><a href="https://blog.jle.im/entries.html">archives</a></li><li><a href="https://cv.jle.im">cv</a></li><div class="clear"></div></ul></nav></div><div id="header-content"></div></div><div id="body-container" class="container"><div id="main-container" class="grid"><div class="entry-section unit span-grid" role="main"><article class="tile article"><header><h1 id="title">The Compromiseless Reconciliation of I/O and Purity</h1><p class="entry-info">by <a class="author" href="https://blog.jle.im/">Justin Le</a><span class="info-separator"> &diams; </span><time datetime="2013-11-12T11:37:27Z" pubdate="" class="pubdate">Tuesday November 12, 2013</time></p><p><span class="source-info"><a class="source-link" href="https://github.com/mstksg/inCode/tree/master/copy/entries/io-purity.md">Source</a><span class="info-separator"> &diams; </span><a class="source-link" href="https://github.com/mstksg/inCode/tree/gh-pages/entry/the-compromiseless-reconciliation-of-i-o-and-purity.md">Markdown</a><span class="info-separator"> &diams; </span><a class="source-link" href="https://blog.jle.im/entry/the-compromiseless-reconciliation-of-i-o-and-purity.tex">LaTeX</a><span class="info-separator"> &diams; </span></span>Posted in <a href="https://blog.jle.im/entries/category/@haskell.html" class="tag-a-category" title="Functional, pure, non-strict, statically and strongly typed, natively
compiled...really just the king of great languages.
">Haskell</a>, <a href="https://blog.jle.im/entries/category/@ramblings.html" class="tag-a-category" title="My slight ramblings on subjects of interest (to me and hopefully to you too!).
Lots of surveys and introducts to new subjects.
">Ramblings</a><span class="info-separator"> &diams; </span><a class="comment-link" href="#disqus_thread">Comments</a></p></header><hr><aside class="contents-container"><h5 id="contents-header">Contents</h5><div id="toc"></div></aside><div class="main-content copy-content"><p>One of the crazy ideals of functional programming is the idea that your program is simply a list of definitions of mathematical functions. And like real math functions, FP functions are <strong>pure</strong>. That means that (1) they cannot affect any state, and (2) that they must return the same thing every time they are called with the same arguments.</p>
<p>When you first learn functional programming, this manifests as “your variables are immutable and you can’t do loops; use recursion instead.” And if you do that, everything is “fine”.</p>
<p>However, there is an apparent glaring problem with this adherence to purity: <strong>I/O</strong>. Input and output are inherently stateful.</p>
<h2 id="the-problem">The Problem</h2>
<p>For the obvious (input) example, consider <code>getchar()</code> in C. It returns the character that a user enters. Obviously, if <code>getchar()</code> returned the same thing every time, you’d have an extraordinarily useless function. Input <em>inherently violates</em> purity, it seems. (Also, consider a <a href="http://xkcd.com/221/">function generating random numbers</a>)</p>
<p>The idea of output violates purity as well. Consider calling <code>printf()</code> in C. You’re going to change the state of the terminal. A benign example, of course; but what about a function <code>add_database_row()</code> that adds a row to your database? A call of <code>get_database_row()</code> will now return something different than it would have returned before. <code>get_database_row()</code> now returns two different things when run at two different times — impure! Blasphemy!</p>
<p>Of course, it should be obvious that not being able to perform IO means that your program is essentially useless in most real world applications. But purity is pretty cool, and it gives us guarantees that let us <a href="http://u.jle.im/19JxV5S">reason with our code</a> in ways that are impossible with impure code, and with unprecedented safety. It opens the doors to previously inaccessible models of parallel, concurrent, and distributed programming. It allows the compiler to do crazy optimization tricks. It allows for powerful mathematical analysis of our programs. The full benefits of purity are beyond the scope of this article, but you can trust me when they say that they are too much to give up over a technicality.</p>
<p>So how can we reconcile the idea of a pure language with <del>anything useful</del> I/O?</p>
<h2 id="a-functional-program">A Functional “Program”</h2>
<h3 id="declarations">Declarations</h3>
<p>Let’s look at an almost-typical Haskell program.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co">--  factorial n: n!</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="ot">factorial ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>factorial <span class="dv">0</span> <span class="ot">=</span> <span class="dv">1</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>factorial n <span class="ot">=</span> n <span class="op">*</span> factorial (n<span class="op">-</span><span class="dv">1</span>)</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="co">--  fib n: the nth Fibonacci number</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="ot">fib ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>fib <span class="dv">0</span> <span class="ot">=</span> <span class="dv">1</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>fib <span class="dv">1</span> <span class="ot">=</span> <span class="dv">1</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>fib n <span class="ot">=</span> fib (n<span class="op">-</span><span class="dv">2</span>) <span class="op">+</span> fib (n<span class="op">-</span><span class="dv">1</span>)</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a><span class="co">--  first_n_fibs n: a list of the first n Fibonacci numbers</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a><span class="ot">first_n_fibs ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> [<span class="dt">Int</span>]</span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>first_n_fibs n <span class="ot">=</span> <span class="fu">map</span> fib [<span class="dv">1</span><span class="op">..</span>n]</span></code></pre></div>
<p>One of the first things you should notice is that this looks strikingly similar to a list of math equations…and almost not like a program.</p>
<p>Notice one important thing about this (at least, in Haskell): there is no inherent ordering in any of these statements. By this, I mean that <code>factorial</code>, <code>fib</code>, and <code>first_n_fibs</code> can be defined in any order. When you write declarations of mathematical objects on paper, the order in which you declare them should have no bearing on what they represent. These are functions. Immortal, unchanging, ethereal, separate from time and space. It is simply nonsensical to talk about order in this context.<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a></p>
<p>Also note that these declarations don’t always declare integers/numbers. <code>first_n_fibs</code> actually declares a data structure — a list that contains integers. Of course this is no big problem…mathematical functions can map integers to matrices, or matrices to functions, anything you can think of. We aren’t limited to simply defining primitive things. We can also define structures that contain things.</p>
<p>Of course, this “program” doesn’t actually <em>do</em> anything. Let’s look at some more programs and see if we can address this.</p>
<h3 id="representing-actions">Representing Actions</h3>
<p>There are a lot of data structures/data types that may be expressed in Haskell. One in particular is called <code>IO</code>. <code>IO a</code> represents a computation that returns something of type <code>a</code>. There are a couple of pre-packaged computations included in the standard library. Let’s write another almost-typical Haskell program with some.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="co">--  getStringFromStdin: returns a computation that represents the act of</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="co">--      getting a string from stdin.  or rather, a series of instructions on</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="co">--      interacting with the computer and generating a String.</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="ot">getStringFromStdin ::</span> <span class="dt">IO</span> <span class="dt">String</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>getStringFromStdin <span class="ot">=</span> <span class="fu">getLine</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a><span class="co">--  printFibN: returns a computation that represents the act of printing the</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a><span class="co">--      nth Fibonacci number to stdout and returns () (Nothing).  or rather,</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a><span class="co">--      a series of instruction on interacting with the computer to get it to</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a><span class="co">--      print a Fibonacci number and returning nothing.</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a><span class="ot">printFibN ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>printFibN n <span class="ot">=</span> <span class="fu">print</span> (fib n)</span></code></pre></div>
<p>Let’s look at these.</p>
<p>These are simply functions/declarations, just like the ones above. Although instead of returning an integer or a list data structure, it returns a special data structure that represents a computation. <code>[a]</code> represents a list of <code>a</code>’s. <code>IO a</code> represents an abstract computation (or a series of system instructions) that returns an <code>a</code>.</p>
<p>These declarations and functions are also simply “math” functions. Instead of returning a set or a matrix or a vector, it returns another type of object.</p>
<p>Note that this has nothing to do with execution. <code>printFibN</code> does <em>not</em> execute a print statement. No more than writing <code>printFibN</code> on a piece of paper will cause it to magically evaluate. It does not execute anything: it is simply an abstract data structure representing a computation.</p>
<p>Note again that there is no inherent ordering involved. Whether you define one or the other first, it does not change what the two names really <em>represent</em>. Just like if you defined two matrices on a piece of paper in a different order, it does not change the matrices they represent.</p>
<p>Also note that all of these declarations are completely pure. <code>getStringFromStdin</code> will return the exact same <em>representation of a computation</em> every single time. <code>printFibN n</code> will return the exact same <em>computation representation</em> for every <code>n</code> every single time. The exact same instruction sequence every single time for every <code>n</code>.</p>
<p>And yes, the objects themselves don’t actually execute anything. That’s like saying writing down a matrix executes something in the real world.</p>
<h3 id="data-structures-not-commands">Data Structures, Not Commands</h3>
<p>To illustrate the difference between a data structure representing a computation and a computation itself, let’s look at a possible confusion that might arise from mixing up the two.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="ot">getStringAndPrint ::</span> <span class="dt">IO</span> ()</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>getStringAndPrint <span class="ot">=</span> <span class="fu">print</span> (getStringFromStdin)</span></code></pre></div>
<p>What would you expect to happen here?</p>
<p>Remember, <code>print</code> is an IO instruction prints out what it is passed. <code>getStringFromStdin</code> is a computation object that gives a string when executed.</p>
<p>In another language, which deals with computations (and not representations of them), you would expect it to get a string from stdin and then print it. Sort of like an echo.</p>
<p>However, this is not the case in Haskell. What is <code>getStringFromStdin</code>? It is <em>not</em> a string — it is a computation object.</p>
<p>What will happen is that <code>print</code> (when executed by a computer) won’t print the result of <code>getStringFromStdin</code>. <code>print</code> will print out the <strong>representation of the computation</strong>! It’ll print out the <em>data structure representing the computation</em>, or some string “representing” the act of the computation!</p>
<p>(At least, that’s what it’s supposed to do. Unfortunately, <code>IO</code> data structures do not come built-in with a method for their string representation in vanilla Haskell. But the point remains that <code>print</code> would <em>try</em> to print out the data structure itself somehow, and not the actual result of the computation)</p>
<h2 id="instructions-as-data-structures">Instructions as Data Structures</h2>
<p>Let’s take a step back and think about what it even means to have a data structure representing computation.</p>
<p>You can think about it as some kind of list/nested tree (or more accurately, a graph) of instructions for someone to follow. For the case of <code>IO Int</code>, you can see it as, internally, some kind of tree/nested instruction set for someone to follow in order to produce an <code>Int</code>. In the case of <code>IO</code>, for GHC, the “someone” is a computer. Or more specifically, a processor. GHC directly translates any standalone IO object into assembly code (or even a less optimal C code).</p>
<p>Technically, you <em>could</em> “think” of every IO object as a self-contained and encapsulated little packet of assembly or C code that you can compose and nest and merge, etc. with other such packets, without worrying about the lower level code itself. But don’t do this, or you risk confusing a possible representation of an object for the actual abstract object itself. (Think about it like saying that a mathematical matrix is a series of pencil swirls on a piece of paper.) But yes, at any time, you can “compile”/make concrete an IO object into standalone C code with GHC. This is actually a fact, and every IO object can be said to correspond directly with a chunk of C code.</p>
<p>Really, though, there are many ways to “translate” this data structure into instructions for anyone to follow. <a href="http://hackage.haskell.org/package/haste-compiler">Haste</a>, for example, takes <code>IO</code> data structure and turns it into something that can be run in a Javascript interpreter. That is, it takes something like <code>printFibN n</code>, takes the internal tree instruction set, and writes it out concretely in javascript.</p>
<p>In fact it would not be too hard to imagine a compiler that would take any arbitrary <code>IO</code> structure and translate it into human-followable (yet very verbose) instructions on a piece of paper, written in plain English. Or French, for that matter.</p>
<p>That is because that’s all <code>IO</code> <em>is</em> — a tree/graph data structure representing an instruction series, that we assemble/build/compose using Haskell code. The same way you would assemble/build an array, or a dictionary, or a linked list in any other language.</p>
<h3 id="other-examples">Other Examples</h3>
<p>It might help to think about similar “instruction-like” data structures.</p>
<p>Take <a href="http://hackage.haskell.org/package/persistent">Persistent</a>, which (in some variants) provides the <code>SqlPersistM</code> data structure. This data structure represents an interaction with an SQL Database. In other words, it represents a tree of instructions for interacting with one. When you give it to the Persistent library, it’ll translate that <code>SqlPersistM</code> into a series of <strong>SQL queries</strong>! Yes, it produces actual SQL query strings, using the instructions from the data structure, executes them, and returns the result. An <code>SqlPersistM Int</code> is an SQL interaction that returns an Int when run with the Persistent library.</p>
<p>Then you have <a href="http://hackage.haskell.org/package/parsec">Parsec</a>, which provides a <code>Parsec</code> data structure, which are <em>instructions for Parsec to parse a string</em>. A <code>Parsec Int</code> structure<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a> represents instructions for parsing a string into an <code>Int</code>. When you give a <code>Parsec Int</code> and a string to parse to the Parsec library, it will run the parse specified by the <code>Parsec</code> object and return (hopefully) a parsed <code>Int</code>. Remember, a <code>Parsec Int</code> object does <em>not</em> actually “parse” anything; It is <em>used by Parsec</em> to parse a string and return an <code>Int</code>!</p>
<p>The reason why we use these data structures in Haskell, instead of actually writing SQL queries and parsing rules from scratch, is because they become <em>composable</em>. SQL queries? Not very composable. Parsing rules? Not exactly, either. In this way, you can build complex SQL queries without ever touching a query string by composing simple queries. You can create very complex and intricate parsing rules without every having to “worry” about actually writing the parser: you just compose simple, smaller parsers.</p>
<p>And this is really what Haskell “does best” (and possibly what Haskell was really made for): assembling and composing these possibly complex instruction data structures in a pure way and “passing them on” to things that can take them and use them to do great things. An <code>SqlPersistM</code> is used by Persistent, a <code>Parsec</code> is used by Parsec, and an <code>IO</code> is used by…well, what? A computer!</p>
<h2 id="the-main-point">The “Main” Point</h2>
<p>So now we see that Haskell has no problems returning a data structure that represents computer instructions (well, at least, Haskell’s standard library handles all of it for us by giving us useful instruction primitives that we can build more complex instructions from).</p>
<p>Now we have an instruction object. How do we actually get a computer to use and execute it?</p>
<p>For this, we rely on convention (or arbitrary specification, however you like to see it). A Haskell compiler will “understand” your data structures, and it picks <strong>one</strong> of them to compile into a binary format for your computer (or whatever format your executing environment reads best). Out of all of the IO objects you can return/represent, the Haskell compiler chooses one of them to be the one it actually compiles into computer-readable code.</p>
<p>And by convention/specification, it is the IO object with the name “main”:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="co">--  printFibN: returns a computation that represents the act of printing the</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="co">--      nth Fibonacci number to stdout and returns () (Nothing).</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="ot">printFibN ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>printFibN n <span class="ot">=</span> <span class="fu">print</span> (fib n)</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a><span class="co">--  main: The IO object that we agree that the compiler will actually compile.</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> printFibN <span class="dv">10</span></span></code></pre></div>
<p>And here we are. A full, executable Haskell program. You can <a href="https://github.com/mstksg/inCode/blob/master/code-samples/io-purity/IO-Purity.hs">download and run it yourself</a>.</p>
<p>As we can see, every function or declaration that makes up our program is completely pure and side-effectless. In fact, the assembly of <code>main</code> itself is side-effectless and pure. We assemble the <code>IO ()</code> that <code>main</code> returns in a pure way. <code>printFibN 10</code> will return the exact same computation representation every single time we run it.</p>
<p><code>printFibN 10</code> is <strong>pure</strong>. Every time we <em>evaluate</em> <code>printFibN 10</code>, we get the exact same computation representation/instruction list.</p>
<p>Therefore, <code>main</code> is pure, as well. Every time we evaluate <code>main</code>, we get the exact same computational data structure.</p>
<h3 id="purity-challenged">Purity challenged?</h3>
<p>Now consider:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="co">--  getStringFromStdin: returns a computation that represents the act of</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="co">--      getting a string from stdin</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span class="ot">getStringFromStdin ::</span> <span class="dt">IO</span> <span class="dt">String</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>getStringFromStdin <span class="ot">=</span> <span class="fu">getLine</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a><span class="co">--  main: The IO object that we agree that the compiler will actually compile.</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> getStringFromStdin <span class="op">&gt;&gt;=</span> (\result <span class="ot">-&gt;</span> <span class="fu">print</span> result)</span></code></pre></div>
<p>(Sample can be <a href="https://github.com/mstksg/inCode/blob/master/code-samples/io-purity/Challenge.hs">downloaded and run</a>)</p>
<p>(An aside: <code>&gt;&gt;=</code> here is an operator that takes the result of the left hand side’s computation and passes it as a parameter to the right hand side. Essentially, it turns two IO computation data structures and combines/chains them into one big one. The <code>(\x -&gt; print x)</code> syntax says “take the <code>x</code> passed to you and use it in <code>print x</code>”)</p>
<p><code>main</code> gets something from the standard input, and then prints it.</p>
<p>Oh wait. This means that if I type something different into standard input, the program will return something different, right? How is this pure?</p>
<p>Here is the crucial difference between <strong>evaluation</strong> and <strong>execution</strong>:</p>
<p><code>main</code> will always <strong>evaluate</strong> to the exact same computation data structure.</p>
<p><code>main</code> will always be the <em>exact</em> same program, no matter when you run it. (In particular, the program that gets a string from stdin and prints it)</p>
<p>The computer/processor — which is given a binary representation of the IO data structure, and is completely separate from the language itself — now <strong>executes</strong> this binary/compiled data structure/program. Its execution of this binary is, of course, potentially unpredictable and in general non-deterministic, and can depend on things like the temperature, the network connection, the person at the keyboard, the database contents, etc. The <em>instructions/binary</em> that it follows will be the same every time. The <em>result</em> of those instructions will be different every time (as someone who has ever attempted to bake a cake can testify).</p>
<p><code>main</code> is a function that returns/evaluates deterministically to a data structure representing a computation.</p>
<p>The computation that it represents is not necessarily deterministic.</p>
<p>This distinction between <strong>evaluation</strong> and <strong>execution</strong> is what sets apart this I/O model that permits its purity.</p>
<p><code>main</code> is a pure value. The instruction data structure <code>main</code> represents impure instructions.</p>
<p>And <em>that</em> is how we can deal with I/O in Haskell while remaining a pure language.</p>
<h3 id="illustrating-the-difference">Illustrating the difference</h3>
<p>To really understand the difference between evaluation and execution, let’s look at this example:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="ot">ignoreAndSayHello ::</span> <span class="dt">IO</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>ignoreAndSayHello to_ignore <span class="ot">=</span> <span class="fu">print</span> <span class="st">&quot;Hello!&quot;</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> ignoreAndSayHello getStringFromStdin</span></code></pre></div>
<p>What does this program do?</p>
<p>Naively, we expect it to ask for a string from standard input, ignore the result, and print “Hello!”.</p>
<p>Actually, this is <strong>not</strong> what it does.</p>
<p>This is because <code>ignoreAndSayHello getStringFromStdin</code> will evaluate to <code>print "Hello"</code> (remember, it ignores its argument). So <code>main</code> evaluates to one single IO action: <code>print "Hello!"</code>.</p>
<p>So your program returns the simple IO action <code>print "Hello!"</code> — the computation returned by <code>main</code> therefore simply prints “Hello!”. This computation does not represent anything that would ask for input.</p>
<p>The “real” way to do this would be:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="ot">ignoreAndSayHello ::</span> <span class="dt">IO</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>ignoreAndSayHello to_ignore <span class="ot">=</span> to_ignore <span class="op">&gt;&gt;=</span> (\result <span class="ot">-&gt;</span> <span class="fu">print</span> <span class="st">&quot;Hello!&quot;</span>)</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> ignoreAndSayHello getStringFromStdin</span></code></pre></div>
<p>Remember, <code>&gt;&gt;=</code> “combines” two IO objects into one. It returns a new IO object that takes the result of the left-hand side and uses it as an argument to the right hand side. Easy, right?</p>
<h2 id="ordering">Ordering</h2>
<p>One major implication that is apparent throughout this entire process is that statements in Haskell have <strong>no inherent order</strong>. As we saw, we had a list of declaration of many different IO actions — none of which were necessarily evaluated or executed. There is no sense of “this function is ‘first’, this function is ‘second’”. Indeed, the idea of ordering makes no sense when you think of things as mathematical functions.</p>
<p>While there is no “first” or “second”, there is a <code>main</code>, which is the function the compiler/interpreter passes to the runtime environment as the computation we agree to run. “Order” arrives at this point. We explicitly “create” an IO data structure and specify the ordering implicitly with <code>&gt;&gt;=</code>. More specifically, <code>print</code> requires the result of <code>getStringFromStdin</code>, so there arises the first semblances of “ordering”: in the explicit composition of different IO actions into one big one.</p>
<p>As it turns out, there is a <a href="http://chris-taylor.github.io/blog/2013/02/09/io-is-not-a-side-effect/">nice blog post</a> by Chris Taylor illustrating how this wordering ordering could be implemented in the internal data structure of IO.</p>
<p>Long story short, <code>IO</code>’s interface provides features to chain and combine IO actions into one big IO action, as we did before with <code>&gt;&gt;=</code>. This interface creates dependency trees in the internal IO data structure that enforces ordering.</p>
<p>But the real story is that outside of the internals of a single <code>IO</code>, there is no inherent ordering — not even between different <code>IO</code> objects!</p>
<h2 id="resolution">Resolution</h2>
<p>In retrospect, the solution seems obvious. A functional program does what it does best — return an object, purely. This object is the actual computation itself, which can be pure or impure, deterministic or nondeterministic — we just pass it off, and the execution environment can do whatever it wants with it. Not our problem anymore! This is the difference between evaluation (the pure process) and execution (the impure one).</p>
<p>We have the best of both worlds. Purity and…well, usefulness!</p>
<p>In fact, because of how Haskell is structured…an impure function does not even make sense. How would one even write a traditional “impure” function in this language? The language itself is centered around the idea of composing computation instruction data types. What would an impure function even look like? Even if it were possible, impurity would be a jarring, unnatural adjustment to the language that doesn’t even really “make sense”.</p>
<p>More importantly, however, there isn’t really any other way Haskell could handle this and still feel Haskell. The reason for this is that this is why Haskell succeeds where other languages struggle: Though we have only seen a glimpse of this in this in this article, Haskell provides very specialized tools for assembling and composing complex instruction data structures that make it extremely simple, expressive, and elegant. Tools for combining two parsing rules into one. Tools for combining two SQL operations into one. For a language that handles computational data structures so well, <em>not</em> handling IO this way would be a real shame!</p>
<h3 id="why">Why?</h3>
<p>One might ask about the usefulness of this whole thing. After all, don’t most languages “compile” to the same assembly code every time? Why this game?</p>
<p>The reason is that we can now deal with programs — entire chunks of assembly code — as first-class objects. You can pass in computational instruction objects to a function the same way you can pass any normal object. You can have two separate little “assembly code chunks” in complete isolation…and then you can combine them if you want, as well. You can easily introduce parallel forks — you can always pass in an “assembly code chunk”, so why not pass an IO object into a fork function? Every separate IO object is self-contained and manipulatable. This fact is also true for the other “instruction set”-like objects mentioned earlier. You can build them up and compose them and pass them as first-class things.</p>
<p>And like we said before, you get all the benefits of <a href="http://u.jle.im/19JxV5S">equational reasoning</a> because you’re dealing with pure “inert” compositions — this is something you could never get if you dealt with executing the actual functions themselves!</p>
<section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes">
<hr />
<ol>
<li id="fn1"><p>So, the astute reader will note that I am slightly blurring the line between purity and non-strictness/laziness. While it is true that pure languages can be strict, and ordering <em>can</em> matter, this demonstration is to mostly illustrate that declarations of items and objects don’t <em>necessarily</em> have to correspond to evaluation, execution and IO — an important point for the next section.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p>Technically, the full type would be <code>ParsecT s u m Int</code>.<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section></div><footer><hr><div class="copy-content"><p>Hi, thanks for reading! You can reach me via email at <a href="mailto:justin@jle.im" class="email">justin@jle.im</a>, or at twitter at <a href="https://twitter.com/mstk">@mstk</a>! This post and all others are published under the <a href="https://creativecommons.org/licenses/by-nc-nd/3.0/">CC-BY-NC-ND 3.0</a> license. Corrections and edits via pull request are welcome and encouraged at <a href="https://github.com/mstksg/inCode">the source repository</a>.</p>
<p>If you feel inclined, or this post was particularly helpful for you, why not consider <a href="https://www.patreon.com/justinle/overview">supporting me on Patreon</a>, or a <a href="bitcoin:3D7rmAYgbDnp4gp4rf22THsGt74fNucPDU">BTC donation</a>? :)</p></div><div class="clear"></div><ul class="entry-series"></ul><ul class="tag-list"><li><a href="https://blog.jle.im/entries/tagged/functional-programming.html" class="tag-a-tag">#functional programming</a></li><li><a href="https://blog.jle.im/entries/tagged/haskell.html" class="tag-a-tag">#haskell</a></li><li><a href="https://blog.jle.im/entries/tagged/io.html" class="tag-a-tag">#io</a></li><li><a href="https://blog.jle.im/entries/category/@haskell.html" class="tag-a-category">@HASKELL</a></li><li><a href="https://blog.jle.im/entries/category/@ramblings.html" class="tag-a-category">@RAMBLINGS</a></li></ul><aside class="social-buttons"><div class="addthis_toolbox addthis_default_style addthis-buttons"><a class="addthis_button_facebook_like" fb:like:layout="button_count"></a><a class="addthis_button_tweet"></a><a class="addthis_button_google_plusone" g:plusone:size="medium"></a><a class="addthis_counter addthis_pill_style"></a></div><div class="custom-social-buttons"><div class="custom-social-button"><a href="https://www.reddit.com/submit" onclick="window.location = &#39;https://www.reddit.com/submit?url=&#39;+ encodeURIComponent(window.location); return false"><img src="https://www.reddit.com/static/spreddit7.gif" alt="submit to reddit"></a></div></div></aside><nav class="next-prev-links"><ul><li class="prev-entry-link">&larr; <a href="https://blog.jle.im/entry/log-sh-lightweight-command-line-note-logging.html">log.sh: Lightweight Command Line Note &amp; Logging</a> (Previous)</li><li class="next-entry-link">(Next) <a href="https://blog.jle.im/entry/a-brief-primer-on-classical-and-quantum-mechanics.html">A Brief Primer on Classical and Quantum Mechanics for Numerical Techniques</a> &rarr;</li></ul></nav></footer></article><div class="post-entry"><div class="tile"><div id="disqus_thread"></div><script type="text/javascript">var disqus_config = function () {
    this.page.url = 'https://blog.jle.im/entry/the-compromiseless-reconciliation-of-i-o-and-purity.html';
    this.page.identifier = 'io-purity';
};
(function() {
    var d = document, s = d.createElement('script');
    s.src = '//incode.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
})();
</script><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a><br></noscript><a href="http://disqus.com" class="dsq-brlink">Comments powered by <span class="logo-disqus">Disqus</span></a></div></div></div></div></div><div id="footer-container"><div id="footer-content"><div class="tile"><div class="footer-copyright">&copy; 2020 Justin Le <span class="license-link">(<a href="https://creativecommons.org/licenses/by-nc-nd/3.0/" class="license">CC-BY-NC-ND 3.0</a>)</span></div><div class="footer-follow social-follows"><ul class="social-follows-list"><li><ul class="social-follows-list-social"><li><a class="social-follow-twitter" title="Follow me on Twitter!" href="https://twitter.com/intent/user?user_id=mstk" onclick="window.open(
  &#39;http://twitter.com/intent/user?user_id=907281&#39;,
  &#39;facebook-share-dialog&#39;,
  &#39;width=550,height=520&#39;);
return false;
">Twitter</a></li><li><a class="social-follow-github" title="Fork me on Github!" href="https://github.com/mstksg">Github</a></li><li><a class="social-follow-twitch" title="Watch me on Twitch!" href="https://www.twitch.tv/justin_l">Twitch</a></li><li><a class="social-follow-patreon" title="Support me on Patreon!" href="https://www.patreon.com/justinle/overview">Patreon</a></li><li><a class="social-follow-gplus" title="Add me on Google+!" href="https://plus.google.com/+JustinLe">Google+</a></li><li><a class="social-follow-keybase" title="Track me on Keybase!" href="https://keybase.io/mstksg">Keybase</a></li><li><a class="social-follow-linkedin" title="Connect with me on LinkedIn!" href="https://linkedin.com/in/lejustin">LinkedIn</a></li><li><a class="social-follow-bitcoin" title="Donate via bitcoin!" href="bitcoin:3D7rmAYgbDnp4gp4rf22THsGt74fNucPDU">Bitcoin</a></li></ul></li><li><ul class="social-follows-list-site"><li><a class="social-follow-rss" title="Subscribe to my RSS Feed!" href="http://feeds.feedburner.com/incodeblog">RSS</a></li><li><a class="social-follow-email" title="Subscribe to the mailing list!" href="https://feedburner.google.com/fb/a/mailverify?loc=en_US&amp;uri=incodeblog">Mailing list</a></li></ul></li></ul></div></div></div></div></body></html>