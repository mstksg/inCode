<!DOCTYPE HTML>
<html><head><title>Intro to Machines &amp; Arrows (Part 1: Stream and Auto) · in Code</title><meta name="description" content="Weblog of Justin Le, covering various adventures in programming and explorations in the worlds of computation physics, and knowledge.
"><meta http-equiv="Content-Type" content="text/html;charset=utf-8"><meta name="viewport" content="width=device-width,initial-scale=1.0"><meta name="flattr:id" content="3p9jqr"><meta property="og:site_name" content="in Code"><meta property="og:description" content="So I’m going to be running a series soon on computation and (physical) simulations using AFRP (Arrowized Functional Reactive Programming) principles. I consider (A)FRP to actually be a pretty game changing paradigm. It provides us with semantics by which to compose and build time-varying, reactive behaviors and completely changes the way we approach any sort of simulation/state-like project. AFRP has its own elegant way of approaching problems, but to be able to properly use it for simulations, we’re going to have to start by learning about the fundamental abstraction behind its implementation: machines. (This post will assume a somewhat basic knowledge of Haskell. I’ll try explaining concepts here and there if I feel that they might not be very commonly known. But if you have any questions, feel free to leave a comment or stop by freenode’s #haskell on irc!) (A short disclaimer: this article has not too much to do with the great machines library by Rúnar Bjarnason and Edward Kmett)"><meta property="og:type" content="article"><meta property="og:title" content="Intro to Machines &amp; Arrows (Part 1: Stream and Auto)"><meta property="og:image" content="https://blog.jle.im/img/site_logo.jpg"><meta property="og:locale" content="en_US"><meta property="og:url" content="https://blog.jle.im/entry/intro-to-machines-arrows-part-1-stream-and.html"><meta name="twitter:card" content="summary"><meta name="twitter:creator:id" content="mstk"><link rel="author" href="https://plus.google.com/107705320197444500140"><link rel="alternate" type="application/rss+xml" title="in Code (RSS Feed)" href="http://feeds.feedburner.com/incodeblog"><link rel="canonical" href="https://blog.jle.im/entry/intro-to-machines-arrows-part-1-stream-and.html"><link href="https://blog.jle.im/favicon.ico" rel="shortcut icon"><link href="https://blog.jle.im/css/toast.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/font.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/main.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/page/entry.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/pygments.css" rel="stylesheet" type="text/css"><script type="text/javascript">var page_data = {};
var disqus_shortname='incode';
</script><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-443711-8', 'jle.im');
ga('send', 'pageview');
</script><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script id="MathJax-script" async="" src="https://cdn.jsdelivr.net/npm/mathjax@3.0.1/es5/tex-mml-chtml.js"></script><script type="text/javascript" src="//ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script><script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5234d67a6b68dcd4"></script><script type="text/javascript" src="https://blog.jle.im/js/page/entry_toc.js"></script><script type="text/javascript" src="https://blog.jle.im/js/disqus_count.js"></script><script type="text/javascript" src="https://blog.jle.im/js/social.js"></script><script type="text/javascript" src="https://blog.jle.im/js/jquery/jquery.toc.js"></script><script type="text/javascript" src="https://blog.jle.im/purescript/entry.js"></script></head><body><div id="fb-root"><script>(function(d, s, id) {
 var js, fjs = d.getElementsByTagName(s)[0];
 if (d.getElementById(id)) return;
 js = d.createElement(s); js.id = id;
 js.src = "//connect.facebook.net/en_US/all.js#xfbml=1&appId=641852699171929";
 fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));
</script></div><div id="header-container"><div id="navbar-container" class="tile"><nav id="navbar-content"><div class="nav-info"><h1 class="site-title"><a href="https://blog.jle.im/" class="nav-title">in Code</a></h1><span class="nav-author">Justin Le</span></div><ul class="nav-links"><li><a href="https://blog.jle.im/">home</a></li><li><a href="https://blog.jle.im/entries.html">archives</a></li><li><a href="https://cv.jle.im">cv</a></li><div class="clear"></div></ul></nav></div><div id="header-content"></div></div><div id="body-container" class="container"><div id="main-container" class="grid"><div class="entry-section unit span-grid" role="main"><article class="tile article"><header><h1 id="title">Intro to Machines &amp; Arrows (Part 1: Stream and Auto)</h1><p class="entry-info">by <a class="author" href="https://blog.jle.im/">Justin Le</a><span class="info-separator"> &diams; </span><time datetime="2014-02-03T09:13:28Z" pubdate="" class="pubdate">Monday February 3, 2014</time></p><p><span class="source-info"><a class="source-link" href="https://github.com/mstksg/inCode/tree/master/copy/entries/machines-1.md">Source</a><span class="info-separator"> &diams; </span><a class="source-link" href="https://github.com/mstksg/inCode/tree/gh-pages/entry/intro-to-machines-arrows-part-1-stream-and.md">Markdown</a><span class="info-separator"> &diams; </span><a class="source-link" href="https://blog.jle.im/entry/intro-to-machines-arrows-part-1-stream-and.tex">LaTeX</a><span class="info-separator"> &diams; </span></span>Posted in <a href="https://blog.jle.im/entries/category/@haskell.html" class="tag-a-category" title="Functional, pure, non-strict, statically and strongly typed, natively
compiled...really just the king of great languages.
">Haskell</a>, <a href="https://blog.jle.im/entries/category/@ramblings.html" class="tag-a-category" title="My slight ramblings on subjects of interest (to me and hopefully to you too!).
Lots of surveys and introducts to new subjects.
">Ramblings</a><span class="info-separator"> &diams; </span><a class="comment-link" href="#disqus_thread">Comments</a></p></header><hr><aside class="contents-container"><h5 id="contents-header">Contents</h5><div id="toc"></div></aside><div class="main-content copy-content"><p>So I’m going to be running a series soon on computation and (physical) simulations using AFRP (Arrowized Functional Reactive Programming) principles.</p>
<p>I consider (A)FRP to actually be a pretty game changing paradigm. It provides us with semantics by which to <em>compose</em> and build time-varying, reactive behaviors and completely changes the way we approach any sort of simulation/state-like project.</p>
<p>AFRP has its own elegant way of approaching problems, but to be able to properly use it for simulations, we’re going to have to start by learning about the fundamental abstraction behind its <strong>implementation</strong>: machines.<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a></p>
<p>(This post will assume a somewhat basic knowledge of Haskell. I’ll try explaining concepts here and there if I feel that they might not be very commonly known. But if you have any questions, feel free to leave a comment or stop by freenode’s #haskell on irc!)</p>
<p>(A short disclaimer: this article has not too much to do with the great <a href="http://hackage.haskell.org/package/machines">machines</a> library by Rúnar Bjarnason and Edward Kmett)</p>
<h2 id="why-frp">Why FRP?</h2>
<p>This series doesn’t directly deal with FRP, but implementing FRP is one of the motivating factors for what we are discussing.</p>
<p>So why do we even bother with FRP? Why not just just program imperatively and mutate a state? It’s just as easy in a functional/pure language (with a trivial State monad wrapper) as it is in an imperative language.</p>
<p>The answer is the full power of functional programming: <strong><a href="http://www.haskellforall.com/2012/08/the-category-design-pattern.html">composition</a></strong>. Anyone who has dabbled in functional programming (or who has even used Unix pipes) has had a glimpse into the power of composition. We start with simple, fundamental, self-contained behaviors and compose them piece-by-piece into a complex one.</p>
<p>So why FRP? FRP provides for us meaningful semantics by which to <em>compose</em> time-varying and reactive behaviors, and create complex ones from smaller ones. You reason about a self-contained behavior “wire”…and then use tools to build complex behaviors from simple ones. You don’t specify what happens when, you specify how things <em>should behave</em>, from a top-down level. And then compose those behaviors.</p>
<p>So to proceed, in this post we are going to introduce Streams and (more importantly) Autos. In the next, we will be looking at Autos as a member of the powerful Category and Arrow typeclasses. In the final post, we’ll really be throwing in a lot of useful enhancements to the <code>Auto</code> type in hopes that you may be prepared for anything you encounter in the real world involving it, including the popular AFRP library <a href="http://hackage.haskell.org/package/netwire">netwire</a>.</p>
<h2 id="streams">Streams</h2>
<p>(All the code for Streams can be downloaded <a href="https://github.com/mstksg/inCode/tree/master/code-samples/machines/Stream.hs">from github</a> and tried interactively online <a href="https://www.fpcomplete.com/user/jle/machines">at FPComplete</a>)</p>
<p>Let’s start with streams, one of the simpler of machines.</p>
<p>Streams are basically infinitely long linked lists.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Stream</span> b <span class="ot">=</span> <span class="dt">SCons</span> (b, <span class="dt">Stream</span> b)</span></code></pre></div>
<p>(<code>SCons</code> for “Stream cons”)</p>
<p>Compare that with the linked list data type, which is a Stream with an Ending (<code>Nil</code>):</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/machines/Stream.hs#L7-L7</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="co">-- interactive: https://www.fpcomplete.com/user/jle/machines</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">List</span> a <span class="ot">=</span> <span class="dt">Cons</span> (a, <span class="dt">List</span> a) <span class="op">|</span> <span class="dt">Nil</span></span></code></pre></div>
<p>or, as is more traditionally written:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> [a] <span class="ot">=</span> (<span class="op">:</span>) a [a] <span class="op">|</span> []</span></code></pre></div>
<p>It’s pretty easy to build lists:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/machines/Stream.hs#L36-L37</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="co">-- interactive: https://www.fpcomplete.com/user/jle/machines</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span class="ot">myList ::</span> <span class="dt">List</span> <span class="dt">Int</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>myList <span class="ot">=</span> <span class="dt">Cons</span> ( <span class="dv">1</span>, <span class="dt">Cons</span> ( <span class="dv">2</span>, <span class="dt">Cons</span> (<span class="dv">3</span>, <span class="dt">Nil</span>) ) )</span></code></pre></div>
<p>which is just, in the more traditional (infix) form:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/machines/Stream.hs#L40-L41</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="co">-- interactive: https://www.fpcomplete.com/user/jle/machines</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a><span class="ot">myList&#39; ::</span> [<span class="dt">Int</span>]</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>myList&#39; <span class="ot">=</span> <span class="dv">1</span><span class="op">:</span>(<span class="dv">2</span><span class="op">:</span>(<span class="dv">3</span><span class="op">:</span>[]))</span></code></pre></div>
<p>Let’s see if <code>myList</code> does what we want: (a list from 1 to 3):</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> <span class="kw">let</span> (<span class="dt">Cons</span> (x,xs)) <span class="ot">=</span> myList</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> x</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a><span class="dv">1</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> <span class="op">:</span>t xs</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a><span class="ot">xs ::</span> <span class="dt">List</span> <span class="dt">Int</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> <span class="kw">let</span> (<span class="dt">Cons</span> (y,ys)) <span class="ot">=</span> xs</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> y</span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a><span class="dv">2</span></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> <span class="kw">let</span> (<span class="dt">Cons</span> (z,zs)) <span class="ot">=</span> ys</span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> z</span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a><span class="dv">3</span></span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> zs</span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a><span class="dt">Nil</span></span></code></pre></div>
<p>Yes! Perfect. We can “traverse” down our linked list by repeatedly pattern matching out the “head” (the <code>x</code>, the first part of the tuple) and the “tail” (the <code>xs</code>, the second part of the tuple).</p>
<p>But how are we going to build a stream…? We don’t have access to <code>Nil</code>, so do we have to manually type out an infinite stream?</p>
<p>Let’s try defining the stream <code>[1..]</code> — a stream that contains every natural number starting from 1.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="ot">myStream&#39; ::</span> <span class="dt">Stream</span> <span class="dt">Int</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>myStream&#39; <span class="ot">=</span> <span class="dt">SCons</span> ( <span class="dv">1</span>, <span class="dt">SCons</span> ( <span class="dv">2</span>, <span class="dt">SCons</span> ( <span class="dv">3</span>, <span class="op">...</span> ) ) )</span></code></pre></div>
<p>Hm. This is going to take a while. I wonder if there’s an easier way?</p>
<p>We can take advantage of Haskell’s “lazy-by-default”-ness and leave the “rest” of the stream as an unevaluated function call. And then we can recurse!</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/machines/Stream.hs#L46-L50</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="co">-- interactive: https://www.fpcomplete.com/user/jle/machines</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a><span class="ot">myStream ::</span> <span class="dt">Stream</span> <span class="dt">Int</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>myStream <span class="ot">=</span> streamFrom <span class="dv">1</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a><span class="ot">    streamFrom ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Stream</span> <span class="dt">Int</span></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>    streamFrom n <span class="ot">=</span> <span class="dt">SCons</span> ( n, streamFrom (n<span class="op">+</span><span class="dv">1</span>) )</span></code></pre></div>
<p>Cool! Let’s see if this <code>myStream</code> really does what we want, the same way we tested <code>myList</code>:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> <span class="kw">let</span> (<span class="dt">SCons</span> (x, xs)) <span class="ot">=</span> myStream</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> x</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a><span class="dv">1</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> <span class="op">:</span>t xs</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a><span class="ot">xs ::</span> <span class="dt">Stream</span> <span class="dt">Int</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> <span class="kw">let</span> (<span class="dt">SCons</span> (y, ys)) <span class="ot">=</span> xs</span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> y</span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a><span class="dv">2</span></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> <span class="kw">let</span> (<span class="dt">SCons</span> (z, zs)) <span class="ot">=</span> ys</span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> z</span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a><span class="dv">3</span></span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> <span class="kw">let</span> (<span class="dt">SCons</span> (j,js)) <span class="ot">=</span> zs</span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> j</span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a><span class="dv">4</span></span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> <span class="kw">let</span> (<span class="dt">SCons</span> (k,ks)) <span class="ot">=</span> js</span>
<span id="cb9-16"><a href="#cb9-16" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> k</span>
<span id="cb9-17"><a href="#cb9-17" aria-hidden="true" tabindex="-1"></a><span class="dv">5</span></span></code></pre></div>
<p>Yes, it works perfectly! Just like in the case of List, we can “traverse” down the stream by pattern matching out the “head” of the stream (the first part of the tuple) and the “tail” of the stream (the second part of the tuple).</p>
<p>Note that we can have some fun with Haskell syntax <code>Stream</code> by adding a record label to the first (and only) field:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Stream</span> b <span class="ot">=</span> <span class="dt">SCons</span> {<span class="ot"> runStream ::</span> (b, <span class="dt">Stream</span> b) }</span></code></pre></div>
<p>so that we can do fancy things like:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> <span class="op">:</span>t runStream</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span class="ot">runStream ::</span> <span class="dt">Stream</span> b <span class="ot">-&gt;</span> (b, <span class="dt">Stream</span> b)</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> <span class="kw">let</span> (x, xs) <span class="ot">=</span> runStream myStream</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> x</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a><span class="dv">1</span></span></code></pre></div>
<p>Basically, we get for free the function <code>runStream</code>, a function that yanks the tuple out of the stream.</p>
<p>One minor final touch — because <code>Stream</code> has only one constructor and one field, we can make it a <code>newtype</code>, which has similar usage patterns/syntax as a <code>data</code>, but which the compiler can more easily optimize:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/machines/Stream.hs#L10-L10</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a><span class="co">-- interactive: https://www.fpcomplete.com/user/jle/machines</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">Stream</span> b <span class="ot">=</span> <span class="dt">SCons</span> {<span class="ot"> runStream ::</span> (b, <span class="dt">Stream</span> b) }</span></code></pre></div>
<h4 id="automating-traversal">Automating Traversal</h4>
<p>The repeated pattern matching we’ve been doing is kind of tedious, and it’ll only get more annoying over time, so let’s make a function that can automate the pattern matching for us really quickly so that we can test it more easily.</p>
<p><code>streamToList</code> will take a Stream and perform the very straightforward conversion into an infinite list.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/machines/Stream.hs#L15-L16</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a><span class="co">-- interactive: https://www.fpcomplete.com/user/jle/machines</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a><span class="ot">streamToList ::</span> <span class="dt">Stream</span> b <span class="ot">-&gt;</span> [b]</span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>streamToList (<span class="dt">SCons</span> (x, xs)) <span class="ot">=</span> x <span class="op">:</span> streamToList xs</span></code></pre></div>
<p>So now we can do:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> <span class="fu">take</span> <span class="dv">10</span> <span class="op">$</span> streamToList myStream</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>,<span class="dv">7</span>,<span class="dv">8</span>,<span class="dv">9</span>,<span class="dv">10</span>]</span></code></pre></div>
<p>Alternatively (and for reasons which will later become clear), we can also define <code>testStream</code>, which takes a specified amount of elements and returns also the “resulting” stream after all of those steps, and <code>testStream_</code>, which is the same thing except that we throw away the modified stream.</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/machines/Stream.hs#L20-L30</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a><span class="co">-- interactive: https://www.fpcomplete.com/user/jle/machines</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a><span class="ot">testStream ::</span> <span class="dt">Stream</span> b <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> ([b], <span class="dt">Stream</span> b)</span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>testStream strm <span class="dv">0</span> <span class="ot">=</span> ([]  , strm )</span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a>testStream strm n <span class="ot">=</span> (y<span class="op">:</span>ys, final)</span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a>    (y , next )   <span class="ot">=</span> runStream  strm</span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a>    (ys, final)   <span class="ot">=</span> testStream next (n<span class="op">-</span><span class="dv">1</span>)</span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true" tabindex="-1"></a><span class="ot">testStream_ ::</span> <span class="dt">Stream</span> b <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> [b]</span>
<span id="cb15-12"><a href="#cb15-12" aria-hidden="true" tabindex="-1"></a>testStream_ <span class="ot">=</span> (<span class="fu">fst</span> <span class="op">.</span>) <span class="op">.</span> testStream</span></code></pre></div>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> testStream_ myStream <span class="dv">10</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>,<span class="dv">7</span>,<span class="dv">8</span>,<span class="dv">9</span>,<span class="dv">10</span>]</span></code></pre></div>
<h3 id="streams-are-nice">Streams are nice</h3>
<p>Streams are nice! If you’ve been using Haskell for any stretch of time, you’ll know that we use infinite lists all the time and to great usefulness for the ends of expressiveness and abstraction.</p>
<p>In mathematics, streams are known as a form of <a href="http://en.wikipedia.org/wiki/Moore_machine">Moore machines</a> (albeit with potentially infinite sets of state and output values). They are machines that basically internally progress from state to state to state to state. They just keep on marching on…like a machine. In <code>myStream</code>, the initial state is 1. The next state is 2; the next is 3, etc. What is important is that the next state <em>is a function of the current state</em>.</p>
<p>This is made very apparent in our definition of <code>streamFrom</code>:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/machines/Stream.hs#L49-L50</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a><span class="co">-- interactive: https://www.fpcomplete.com/user/jle/machines</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a><span class="ot">    streamFrom ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Stream</span> <span class="dt">Int</span></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>    streamFrom n <span class="ot">=</span> <span class="dt">SCons</span> ( n, streamFrom (n<span class="op">+</span><span class="dv">1</span>) )</span></code></pre></div>
<p>The “current state” whenever we call <code>streamFrom n</code> is <code>n</code>…the “next state” (the “initial state” of the “tail”) is <code>n+1</code>. We could have provided any function <code>:: Int -&gt; Int</code> there (say, <code>n+2</code>), that would be for us our “next state” function.</p>
<p>So <code>myStream</code> is a Moore-like machine whose “next state” function is “the current state plus one”, and whose output is just the state itself.</p>
<h4 id="state-your-purpose">State your purpose!</h4>
<p>Did you catch that last sentence? It’s a subtle point. In general, streams can have outputs that are different than their states. As a trivial example, let’s have a stream whose state is an integer, yet whose output is a character:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/machines/Stream.hs#L53-L57</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a><span class="co">-- interactive: https://www.fpcomplete.com/user/jle/machines</span></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a><span class="ot">charStream ::</span> <span class="dt">Stream</span> <span class="dt">Char</span></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>charStream <span class="ot">=</span> charStreamFrom <span class="dv">65</span></span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a><span class="ot">    charStreamFrom ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Stream</span> <span class="dt">Char</span></span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a>    charStreamFrom n <span class="ot">=</span> <span class="dt">SCons</span> ( <span class="fu">chr</span> n, charStreamFrom (n<span class="op">+</span><span class="dv">1</span>) )</span></code></pre></div>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> <span class="fu">take</span> <span class="dv">10</span> <span class="op">$</span> streamToList charStream</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a><span class="st">&quot;ABCDEFGHIJ&quot;</span></span></code></pre></div>
<p>Wait, this is kind of weird. The type of our stream is <code>Stream Char</code>…<code>Char</code> is the type of output/elements in the stream, the “head” when we pattern match. But where is the <code>Int</code> that is the state of our stream in the type <code>Stream Char</code>…?</p>
<p>Can we even write a function <code>getState :: Stream b -&gt; s</code> that works in general for all streams?</p>
<p>Hm. If the state of our stream can have a type totally unrelated to the type of the stream…that means that we probably can’t even know what it type is. And that even if we could “force” it out somehow, we would not even be able to work with it in a type-safe way!</p>
<p>In fact…couldn’t the state even <em><a href="https://github.com/mstksg/inCode/tree/master/code-samples/machines/Stream.hs#L60-L70">vary dynamically</a></em> as the stream progresses?</p>
<h3 id="continuing-on">Continuing on</h3>
<p>The problem with streams, as you might have guessed, is that you can’t really affect their progress once they start. Once you start <code>myStream</code>, it’ll keep on marching on, and on, and on…you have no way to “influence” its progression <em>during</em> its march. The <em>behavior</em> of our stream <em>can’t be influenced</em> by the outside world in any way, once it has started. This is a bit limiting, because we want behaviors that we can have interact with each other.</p>
<p>And so, we have the natural generalization of streams (and the machine we will be spending the most time looking at): Auto.</p>
<h2 id="auto">Auto</h2>
<p>(All the code for Autos can be downloaded <a href="https://github.com/mstksg/inCode/tree/master/code-samples/machines/Auto.hs">from github</a> and tried interactively online <a href="https://www.fpcomplete.com/user/jle/machines">at FPComplete</a>)</p>
<p>Let’s upgrade our streams, and introduce a way to affect how they progress. Let’s call it an Auto.</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/machines/Auto.hs#L12-L12</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a><span class="co">-- interactive: https://www.fpcomplete.com/user/jle/machines</span></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">Auto</span> a b <span class="ot">=</span> <span class="dt">ACons</span> {<span class="ot"> runAuto ::</span> a <span class="ot">-&gt;</span> (b, <span class="dt">Auto</span> a b) }</span></code></pre></div>
<p>Now, instead of an <code>SCons</code> containing just a tuple (a head-tails), an <code>ACons</code> contains a <em>function</em> that <em>produces</em> your head-tails tuple. Before, all of our <code>runStreams</code> produced the same tuple no matter what. Now, our <code>runAuto</code> can produce a different tuple based on an outside input.</p>
<p>This is cool!</p>
<p>Let’s look at the type signature of Auto before we go too much further.</p>
<p>In <code>Auto a b</code>, <code>b</code> is (just like for a Stream) the type of your “head” and the type of the items in your “tail”. It’s the type of your “stream”.</p>
<p><code>a</code> is the type of the “influencing input”.</p>
<p>So now, we basically have a <code>Stream b</code>, except at every “step”, we can “influence” the Stream with something of type <code>a</code>.</p>
<h3 id="a-trivial-auto">A Trivial Auto</h3>
<p>Let’s look at a direct “port” of our <code>myStream</code>:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/machines/Auto.hs#L40-L44</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a><span class="co">-- interactive: https://www.fpcomplete.com/user/jle/machines</span></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a><span class="ot">myStreamAuto ::</span> <span class="dt">Auto</span> a <span class="dt">Int</span></span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a>myStreamAuto <span class="ot">=</span> streamAutoFrom <span class="dv">1</span></span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true" tabindex="-1"></a><span class="ot">    streamAutoFrom ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Auto</span> a <span class="dt">Int</span></span>
<span id="cb21-8"><a href="#cb21-8" aria-hidden="true" tabindex="-1"></a>    streamAutoFrom n <span class="ot">=</span> <span class="dt">ACons</span> <span class="op">$</span> \_ <span class="ot">-&gt;</span> ( n, streamAutoFrom (n<span class="op">+</span><span class="dv">1</span>) )</span></code></pre></div>
<p>This is kind of a dumb example, but <code>myStreamAuto</code> is just the exact same as <code>myStream</code>. It’s an Auto, but it <em>ignores its influencing input</em>.</p>
<p>Let’s try it out.</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> <span class="op">:</span>t runAuto</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a><span class="ot">runAuto ::</span> <span class="dt">Auto</span> a b <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> (b, <span class="dt">Auto</span> a b))</span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> <span class="kw">let</span> (x, xs) <span class="ot">=</span> runAuto myStreamAuto <span class="fu">undefined</span></span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> x</span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a><span class="dv">1</span></span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> <span class="op">:</span>t xs</span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true" tabindex="-1"></a><span class="ot">xs ::</span> <span class="dt">Auto</span> a <span class="dt">Int</span></span>
<span id="cb22-8"><a href="#cb22-8" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> <span class="kw">let</span> (y, ys) <span class="ot">=</span> runAuto xs <span class="fu">undefined</span></span>
<span id="cb22-9"><a href="#cb22-9" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> y</span>
<span id="cb22-10"><a href="#cb22-10" aria-hidden="true" tabindex="-1"></a><span class="dv">2</span></span>
<span id="cb22-11"><a href="#cb22-11" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> <span class="kw">let</span> (z, zs) <span class="ot">=</span> runAuto ys <span class="fu">undefined</span></span>
<span id="cb22-12"><a href="#cb22-12" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> z</span>
<span id="cb22-13"><a href="#cb22-13" aria-hidden="true" tabindex="-1"></a><span class="dv">3</span></span></code></pre></div>
<p>Remember that we are really doing <code>(runAuto myStreamAuto) undefined</code>, but because of how Haskell associates function calls, the parentheses are unnecessary. And hey, it kind of looks like <code>runAuto</code> is a two-parameter function with an Auto as the first parameter and the “influence”/“input” as its second. Which, due to the magic of currying-by-default, it basically is, in Haskell!</p>
<h3 id="a-non-trivial-auto">A Non-trivial Auto</h3>
<p>Okay, that was fun I guess. But now let’s take a first look at an auto which <em>can</em> be influenced.</p>
<p>Let’s have a stream where at every step, we can choose to “reset” the counter to whatever integer we like.</p>
<p>We can do this by having the influence/input be a <code>Maybe Int</code>. If we want the counter to progress normally, we pass in a <code>Nothing</code>. If we want the counter to reset to a number <code>n</code> of our choosing, we pass in a <code>Just n</code></p>
<div class="sourceCode" id="cb23"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/machines/Auto.hs#L48-L54</span></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a><span class="co">-- interactive: https://www.fpcomplete.com/user/jle/machines</span></span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a><span class="ot">settableAuto ::</span> <span class="dt">Auto</span> (<span class="dt">Maybe</span> <span class="dt">Int</span>) <span class="dt">Int</span></span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a>settableAuto <span class="ot">=</span> counterFrom <span class="dv">1</span></span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb23-7"><a href="#cb23-7" aria-hidden="true" tabindex="-1"></a><span class="ot">    counterFrom ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Auto</span> (<span class="dt">Maybe</span> <span class="dt">Int</span>) <span class="dt">Int</span></span>
<span id="cb23-8"><a href="#cb23-8" aria-hidden="true" tabindex="-1"></a>    counterFrom n <span class="ot">=</span> <span class="dt">ACons</span> <span class="op">$</span> \reset <span class="ot">-&gt;</span></span>
<span id="cb23-9"><a href="#cb23-9" aria-hidden="true" tabindex="-1"></a>      <span class="kw">let</span> c <span class="ot">=</span> fromMaybe n reset</span>
<span id="cb23-10"><a href="#cb23-10" aria-hidden="true" tabindex="-1"></a>      <span class="kw">in</span>  ( c, counterFrom (c <span class="op">+</span> <span class="dv">1</span>) )</span></code></pre></div>
<p>Remember that <code>fromMaybe :: a -&gt; Maybe a -&gt; a</code> takes a “default” value, a Maybe value, and then returns the value inside the Maybe if it’s a <code>Just</code>, or the default value if it’s a <code>Nothing</code>.</p>
<p>So basically, when you <code>runAuto</code> with the Auto, if you give it a <code>Nothing</code>, it’ll give you <code>( n, counterFrom (n+1) )</code>. If you give it <code>Just m</code>, it’ll give you <code>( m, counterFrom (m+1) )</code>.</p>
<p>Cool — let’s try it out.</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> <span class="kw">let</span> (x, xs) <span class="ot">=</span> runAuto settableAuto <span class="dt">Nothing</span></span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> x</span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a><span class="dv">1</span></span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> <span class="kw">let</span> (y, ys) <span class="ot">=</span> runAuto xs <span class="dt">Nothing</span></span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> y</span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true" tabindex="-1"></a><span class="dv">2</span></span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> <span class="kw">let</span> (z, zs) <span class="ot">=</span> runAuto ys (<span class="dt">Just</span> <span class="dv">10</span>)</span>
<span id="cb24-8"><a href="#cb24-8" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> z</span>
<span id="cb24-9"><a href="#cb24-9" aria-hidden="true" tabindex="-1"></a><span class="dv">10</span></span>
<span id="cb24-10"><a href="#cb24-10" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> <span class="kw">let</span> (j, js) <span class="ot">=</span> runAuto zs <span class="dt">Nothing</span></span>
<span id="cb24-11"><a href="#cb24-11" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> j</span>
<span id="cb24-12"><a href="#cb24-12" aria-hidden="true" tabindex="-1"></a><span class="dv">11</span></span>
<span id="cb24-13"><a href="#cb24-13" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> <span class="kw">let</span> (k, ks) <span class="ot">=</span> runAuto js <span class="dt">Nothing</span></span>
<span id="cb24-14"><a href="#cb24-14" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> k</span>
<span id="cb24-15"><a href="#cb24-15" aria-hidden="true" tabindex="-1"></a><span class="dv">12</span></span>
<span id="cb24-16"><a href="#cb24-16" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> <span class="kw">let</span> (l, ls) <span class="ot">=</span> runAuto ks (<span class="dt">Just</span> (<span class="op">-</span><span class="dv">1</span>))</span>
<span id="cb24-17"><a href="#cb24-17" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> l</span>
<span id="cb24-18"><a href="#cb24-18" aria-hidden="true" tabindex="-1"></a><span class="op">-</span><span class="dv">1</span></span>
<span id="cb24-19"><a href="#cb24-19" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> <span class="kw">let</span> (m, ms) <span class="ot">=</span> runAuto ls <span class="dt">Nothing</span></span>
<span id="cb24-20"><a href="#cb24-20" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> m</span>
<span id="cb24-21"><a href="#cb24-21" aria-hidden="true" tabindex="-1"></a><span class="dv">0</span></span></code></pre></div>
<p>And there ya go.</p>
<h4 id="automatic-traversals-for-our-autos">Automatic traversals for our Autos</h4>
<p>Again, the manual pattern matching is a little tedious so let’s write us a function to automate “progressing” down an Auto.</p>
<p>Like our <code>testStream</code>, <code>testAuto</code> takes an Auto. But because every “step” needs an input, <code>testAuto auto</code> takes a <em>list</em> that specifies the input for every step. <code>testAuto</code> returns the resulting collection of results, and also the modified Auto. <code>testAuto_</code> throws away the new Auto and just gives us the collection.</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/machines/Auto.hs#L17-L25</span></span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a><span class="co">-- interactive: https://www.fpcomplete.com/user/jle/machines</span></span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a><span class="ot">testAuto ::</span> <span class="dt">Auto</span> a b <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> ([b], <span class="dt">Auto</span> a b)</span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a>testAuto auto []      <span class="ot">=</span> ([]  , auto )</span>
<span id="cb25-6"><a href="#cb25-6" aria-hidden="true" tabindex="-1"></a>testAuto auto (x<span class="op">:</span>xs)  <span class="ot">=</span> (y<span class="op">:</span>ys, final)</span>
<span id="cb25-7"><a href="#cb25-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb25-8"><a href="#cb25-8" aria-hidden="true" tabindex="-1"></a>    (y,  next ) <span class="ot">=</span> runAuto  auto x</span>
<span id="cb25-9"><a href="#cb25-9" aria-hidden="true" tabindex="-1"></a>    (ys, final) <span class="ot">=</span> testAuto next xs</span>
<span id="cb25-10"><a href="#cb25-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-11"><a href="#cb25-11" aria-hidden="true" tabindex="-1"></a><span class="ot">testAuto_ ::</span> <span class="dt">Auto</span> a b <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [b]</span>
<span id="cb25-12"><a href="#cb25-12" aria-hidden="true" tabindex="-1"></a>testAuto_ a <span class="ot">=</span> <span class="fu">fst</span> <span class="op">.</span> testAuto a</span></code></pre></div>
<p>Trying it out on <code>settableAuto</code>:</p>
<pre><code>ghci&gt; testAuto_ settableAuto [ Nothing, Nothing, Just 10
                             , Nothing, Nothing, Just (-1)
                             , Nothing ]
[1,2,10,11,12,-1,0]</code></pre>
<p>Alternatively, here is a fun way to test an Auto interactively, where you ask for input at each iteration from the user —</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/machines/Auto.hs#L27-L32</span></span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a><span class="co">-- interactive: https://www.fpcomplete.com/user/jle/machines</span></span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a><span class="ot">interactAuto ::</span> (<span class="dt">Read</span> a, <span class="dt">Show</span> b) <span class="ot">=&gt;</span> <span class="dt">Auto</span> a b <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true" tabindex="-1"></a>interactAuto a0 <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb27-6"><a href="#cb27-6" aria-hidden="true" tabindex="-1"></a>    inp <span class="ot">&lt;-</span> <span class="fu">getLine</span></span>
<span id="cb27-7"><a href="#cb27-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> (x,a1) <span class="ot">=</span> runAuto a0 (<span class="fu">read</span> inp)</span>
<span id="cb27-8"><a href="#cb27-8" aria-hidden="true" tabindex="-1"></a>    <span class="fu">print</span> x</span>
<span id="cb27-9"><a href="#cb27-9" aria-hidden="true" tabindex="-1"></a>    interactAuto a1</span></code></pre></div>
<div class="sourceCode" id="cb28"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> interactAuto settableAuto</span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;</span> <span class="dt">Nothing</span></span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a><span class="dv">1</span></span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;</span> <span class="dt">Nothing</span></span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true" tabindex="-1"></a><span class="dv">2</span></span>
<span id="cb28-6"><a href="#cb28-6" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;</span> <span class="dt">Just</span> <span class="dv">10</span></span>
<span id="cb28-7"><a href="#cb28-7" aria-hidden="true" tabindex="-1"></a><span class="dv">10</span></span>
<span id="cb28-8"><a href="#cb28-8" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;</span> <span class="dt">Nothing</span></span>
<span id="cb28-9"><a href="#cb28-9" aria-hidden="true" tabindex="-1"></a><span class="dv">11</span></span></code></pre></div>
<h3 id="a-shift">A Shift</h3>
<p>Let’s shift our thinking a bit. Instead of seeing Autos as “streams you can influence”, we can think about them as “functions with state”. That is, they are functions that carry self-contained encapsulated state <em>inside</em> themselves. They are still <em>functions</em> of some kind — you put in an “input” of type <code>a</code> and get in an “output” (the head) of type <code>b</code>. However, every “time” you do this, you get a different output depending on what you have already passed in and what the internal state is. As we will see, this internal state is completely opaque to the world. The world only has access to the “output”, the result.</p>
<p>(Remember that, because we’re in a functional language, nothing is technically actually really “mutable”. When we say that we have a stateful function, we really mean that every time we “call” the function, we get back an “updated” function with the new state that behaves differently when “called”).</p>
<p>To put it in terms of <code>settableAuto</code>:</p>
<ul>
<li>The “input” of <code>settableAuto</code> is our <code>Maybe Int</code> by which we convey or decision to reset or allow to increment by one as normal.</li>
<li>The “output” of <code>settableAuto</code> is the “head” of the <code>ACons</code> that is returned — the <code>x</code>, <code>y</code>, etc. It’s the <code>Int</code>, the counter.</li>
<li>The “state” of <code>settableAuto</code> is, in essence, the <code>n</code> of <code>counterFrom n</code>. It’s the internal value by which the behavior is determined. The behavior of <code>runAuto</code> depends on the <code>n</code> — it either yields <code>n</code> itself and increments <code>n</code>, or ignores it.</li>
</ul>
<h4 id="the-opaque-state">The opaque state</h4>
<p>It’s a little tricky because the “output” and the “state” in our example function seem to be exactly the same (just like for <code>myStream</code>), but let’s whip up a quick example where it’s a little more obvious that the state and the output are different things, and that the state is completely opaque and encapsulated.</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/machines/Auto.hs#L58-L64</span></span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a><span class="co">-- interactive: https://www.fpcomplete.com/user/jle/machines</span></span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a><span class="ot">isEvenAuto ::</span> <span class="dt">Auto</span> (<span class="dt">Maybe</span> <span class="dt">Int</span>) <span class="dt">Bool</span></span>
<span id="cb29-5"><a href="#cb29-5" aria-hidden="true" tabindex="-1"></a>isEvenAuto <span class="ot">=</span> isEvenAutoFrom <span class="dv">1</span></span>
<span id="cb29-6"><a href="#cb29-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb29-7"><a href="#cb29-7" aria-hidden="true" tabindex="-1"></a><span class="ot">    isEvenAutoFrom ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Auto</span> (<span class="dt">Maybe</span> <span class="dt">Int</span>) <span class="dt">Bool</span></span>
<span id="cb29-8"><a href="#cb29-8" aria-hidden="true" tabindex="-1"></a>    isEvenAutoFrom n <span class="ot">=</span> <span class="dt">ACons</span> <span class="op">$</span> \reset <span class="ot">-&gt;</span></span>
<span id="cb29-9"><a href="#cb29-9" aria-hidden="true" tabindex="-1"></a>      <span class="kw">let</span> c <span class="ot">=</span> fromMaybe n reset</span>
<span id="cb29-10"><a href="#cb29-10" aria-hidden="true" tabindex="-1"></a>      <span class="kw">in</span>  ( <span class="fu">even</span> c, isEvenAutoFrom (c <span class="op">+</span> <span class="dv">1</span>) )</span></code></pre></div>
<p>So <code>isEvenAuto</code> is the same as <code>settableCounterFrom</code>, except instead of “yielding”/“outputting” <code>n</code>, it outputs <code>even n</code> — <code>True</code> if <code>n</code> is even and <code>False</code> if <code>n</code> is odd.</p>
<p>Here is a demonstration of its behavior —</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> testAuto isEvenAuto  [ <span class="dt">Nothing</span>, <span class="dt">Nothing</span>, <span class="dt">Just</span> <span class="dv">10</span></span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a>                           , <span class="dt">Nothing</span>, <span class="dt">Nothing</span>, <span class="dt">Just</span> (<span class="op">-</span><span class="dv">1</span>)</span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a>                           , <span class="dt">Nothing</span> ]</span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true" tabindex="-1"></a>[<span class="dt">False</span>,<span class="dt">True</span>,<span class="dt">True</span>,<span class="dt">False</span>,<span class="dt">True</span>]</span></code></pre></div>
<p>Note that there is in general really no way to ever access the <code>n</code> internally (in fact, like we said before, it is in theory possible because we can’t even know its type). It is completely sealed off from the world, except by our explicit design. Here, we choose to only “offer” a way to “set” it using our input.</p>
<p>Now it the three distinct concepts — the input, output, and state — should be clear.</p>
<ul>
<li>The “input” again is a <code>Maybe Int</code> where we can choose to reset the march of the state.</li>
<li>The “output” here is now a <code>Bool</code> that says whether or not the internal state is even.</li>
<li>The “state” here is still that <code>n</code> (an <code>Int</code>), and was the same as in the last example. But here it is more clear that the state is inaccessible in general. We can only modify it in ways that the Auto <em>itself</em> allows our “input” (in this case, a setter) to modify it. And we certainly can’t arbitrarily “read” it.</li>
</ul>
<h3 id="autos-are-nice">Autos are nice!</h3>
<p>It should be clear now that Autos are a more or less straightforward extension of Streams.</p>
<p>In fact, you might see that every <code>Stream b</code> is equivalent to <code>Auto () b</code>, where the input is always unit.</p>
<p>Autos correspond loosely to the mathematical <a href="http://en.wikipedia.org/wiki/Mealy_machine">Mealy machine</a>, but again with technically potentially infinitely many possible states, input, and output values.</p>
<p>Now, we have a way to model behaviors that can somehow interact with the outside world.</p>
<h4 id="more-on-state">More on state</h4>
<p>As we have seen, Auto’s carry all of the hidden-internal-state features of Streams. The type of an Auto (<code>Auto a b</code>) reveals the type of the “input” and the “ouput”…but it never reveals nor fixes the type of the “state”. The type of the state is not only unknown, by possibly dynamically changing over the course of the Auto’s progression.</p>
<p>What Auto offers over Stream is then a way for the outside world to access and modify the state <em>if the Auto wants it to</em>. Now, we can design Autos that, like we have seen with <code>settableAuto</code>, we can offer limited ways to allow the world to modify the state on our own terms.</p>
<h3 id="the-accumulator">The Accumulator</h3>
<p>Let’s try our hand at another Auto, but instead of looking at things as an influencable and eternally marching stream, we’re going to try to look at things as a function with state that affects its output.</p>
<p>How about an Auto that “accumulates” and “sums up” all of its incoming inputs, starting at 0? More correctly, an Auto that, given any int, “returns” the sum of that int with all of the previous ints it has received in its lifetime.</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/machines/Auto.hs#L67-L73</span></span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a><span class="co">-- interactive: https://www.fpcomplete.com/user/jle/machines</span></span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true" tabindex="-1"></a><span class="ot">summer ::</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> <span class="dt">Auto</span> a a</span>
<span id="cb31-5"><a href="#cb31-5" aria-hidden="true" tabindex="-1"></a>summer <span class="ot">=</span> sumFrom <span class="dv">0</span></span>
<span id="cb31-6"><a href="#cb31-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb31-7"><a href="#cb31-7" aria-hidden="true" tabindex="-1"></a><span class="ot">    sumFrom ::</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Auto</span> a a</span>
<span id="cb31-8"><a href="#cb31-8" aria-hidden="true" tabindex="-1"></a>    sumFrom n <span class="ot">=</span> <span class="dt">ACons</span> <span class="op">$</span> \input <span class="ot">-&gt;</span></span>
<span id="cb31-9"><a href="#cb31-9" aria-hidden="true" tabindex="-1"></a>      <span class="kw">let</span> s <span class="ot">=</span> n <span class="op">+</span> input</span>
<span id="cb31-10"><a href="#cb31-10" aria-hidden="true" tabindex="-1"></a>      <span class="kw">in</span>  ( s , sumFrom s )</span></code></pre></div>
<div class="sourceCode" id="cb32"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> <span class="kw">let</span> (out1, auto1) <span class="ot">=</span> runAuto summer <span class="dv">10</span></span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> out1</span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a><span class="dv">10</span></span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> <span class="kw">let</span> (out2, auto2) <span class="ot">=</span> runAuto auto1 <span class="dv">3</span></span>
<span id="cb32-5"><a href="#cb32-5" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> out2</span>
<span id="cb32-6"><a href="#cb32-6" aria-hidden="true" tabindex="-1"></a><span class="dv">13</span></span>
<span id="cb32-7"><a href="#cb32-7" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> testAuto_ auto2 [<span class="dv">15</span>,<span class="op">-</span><span class="dv">17</span>,<span class="dv">6</span>,<span class="dv">0</span>,<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb32-8"><a href="#cb32-8" aria-hidden="true" tabindex="-1"></a>[<span class="dv">28</span>,<span class="dv">11</span>,<span class="dv">17</span>,<span class="dv">17</span>,<span class="dv">16</span>]</span></code></pre></div>
<ul>
<li>The “input” is our incoming <code>Int</code> — 10, 3, 15, -17, etc.</li>
<li>The “output” is the accumulated sum/integral – 10, 13, 28, 11, etc.</li>
<li>The “state” in this case is the accumulator, which in this case stays in sync with the output. But remember that this is not the case in general.</li>
</ul>
<p>Just for kicks, let’s generalize this and make an Auto version of <code>foldl</code> (technically, more like <code>scanl</code>): give us an operator and an initial value, and we’ll “fold up” all of our inputs.</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/machines/Auto.hs#L78-L84</span></span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a><span class="co">-- interactive: https://www.fpcomplete.com/user/jle/machines</span></span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true" tabindex="-1"></a><span class="ot">autoFold ::</span> <span class="kw">forall</span> a b<span class="op">.</span> (b <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> <span class="dt">Auto</span> a b</span>
<span id="cb33-5"><a href="#cb33-5" aria-hidden="true" tabindex="-1"></a>autoFold op <span class="fu">init</span> <span class="ot">=</span> foldFrom <span class="fu">init</span></span>
<span id="cb33-6"><a href="#cb33-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb33-7"><a href="#cb33-7" aria-hidden="true" tabindex="-1"></a><span class="ot">    foldFrom ::</span> b <span class="ot">-&gt;</span> <span class="dt">Auto</span> a b</span>
<span id="cb33-8"><a href="#cb33-8" aria-hidden="true" tabindex="-1"></a>    foldFrom x <span class="ot">=</span> <span class="dt">ACons</span> <span class="op">$</span> \input <span class="ot">-&gt;</span></span>
<span id="cb33-9"><a href="#cb33-9" aria-hidden="true" tabindex="-1"></a>      <span class="kw">let</span> y <span class="ot">=</span> x <span class="ot">`op`</span> input</span>
<span id="cb33-10"><a href="#cb33-10" aria-hidden="true" tabindex="-1"></a>      <span class="kw">in</span>  ( y, foldFrom y )</span></code></pre></div>
<p>(the <code>forall</code> is used with the <a href="http://www.haskell.org/haskellwiki/Scoped_type_variables">Scoped Type Variables</a> extension to let us say that the <code>b</code> we mention in the type of <code>foldFrom</code> is the same as the <code>b</code> in the type of <code>autoFold</code>. If we leave off the type signature of <code>foldFrom</code>, this is not necessary)</p>
<p>Note that <code>summer</code> then is just <code>autoFold (+) 0</code>.</p>
<p>You can probably imagine lots of different folds you can turn into <code>autoFold</code>s…and indeed a lot of practical Autos are just <code>autoFold</code>s. Here are some cute ones:</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/machines/Auto.hs#L92-L107</span></span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a><span class="co">-- interactive: https://www.fpcomplete.com/user/jle/machines</span></span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-4"><a href="#cb34-4" aria-hidden="true" tabindex="-1"></a><span class="ot">accumulateIntoList ::</span> <span class="dt">Auto</span> a [a]</span>
<span id="cb34-5"><a href="#cb34-5" aria-hidden="true" tabindex="-1"></a>accumulateIntoList <span class="ot">=</span> autoFold (<span class="fu">flip</span> (<span class="op">:</span>)) []</span>
<span id="cb34-6"><a href="#cb34-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-7"><a href="#cb34-7" aria-hidden="true" tabindex="-1"></a><span class="ot">productor ::</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> <span class="dt">Auto</span> a a</span>
<span id="cb34-8"><a href="#cb34-8" aria-hidden="true" tabindex="-1"></a>productor <span class="ot">=</span> autoFold (<span class="op">*</span>) <span class="dv">1</span></span>
<span id="cb34-9"><a href="#cb34-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-10"><a href="#cb34-10" aria-hidden="true" tabindex="-1"></a><span class="ot">accumulateStrings ::</span> <span class="dt">Auto</span> <span class="dt">String</span> <span class="dt">String</span></span>
<span id="cb34-11"><a href="#cb34-11" aria-hidden="true" tabindex="-1"></a>accumulateStrings <span class="ot">=</span> autoFold (<span class="op">++</span>) <span class="st">&quot;&quot;</span></span>
<span id="cb34-12"><a href="#cb34-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-13"><a href="#cb34-13" aria-hidden="true" tabindex="-1"></a><span class="ot">monoidAccum ::</span> <span class="dt">Monoid</span> a <span class="ot">=&gt;</span> <span class="dt">Auto</span> a a</span>
<span id="cb34-14"><a href="#cb34-14" aria-hidden="true" tabindex="-1"></a>monoidAccum <span class="ot">=</span> autoFold <span class="fu">mappend</span> <span class="fu">mempty</span></span></code></pre></div>
<p>Cool, huh?</p>
<h4 id="parallels-with-list-folds">Parallels with list folds</h4>
<p>Let’s look very carefully at a comparison between the type signature of Prelude’s <code>foldl</code> and the type signature of <code>autoFold</code>:</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a><span class="fu">foldl</span><span class="ot">      ::</span> (b <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> ([a] <span class="ot">-&gt;</span> b)</span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a><span class="ot">autoFold   ::</span> (b <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span>  <span class="dt">Auto</span> a b</span></code></pre></div>
<p>Hm. Let’s do some rearranging. Remember that in Haskell, <code>(-&gt;)</code> is just an infix type operator. So we can always rewrite <code>a -&gt; b</code> as <code>(-&gt;) a b</code></p>
<div class="sourceCode" id="cb36"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a><span class="fu">foldl</span><span class="ot">      ::</span> (b <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> ( (<span class="ot">-&gt;</span>) [a] b )</span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a><span class="ot">autoFold   ::</span> (b <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> ( <span class="dt">Auto</span>  a  b )</span></code></pre></div>
<p>Let’s get rid of some of the points, too:</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a><span class="fu">foldl</span>    op<span class="ot"> initial  ::</span> (<span class="ot">-&gt;</span>) [a] b</span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a>autoFold op<span class="ot"> initial  ::</span> <span class="dt">Auto</span>  a  b</span></code></pre></div>
<p>So both <code>foldl</code> and <code>autoFold</code> have very similar behaviors:</p>
<p>Give <code>foldl</code> or <code>autoFold</code> an <em>accumulating function</em> and an <em>initial value</em>, and they return <em>a new “function thing”</em>.</p>
<p>For <code>foldl op initial</code>, this “function thing” takes a <em>list</em> of <code>a</code> values and condenses them into a <code>b</code> value.</p>
<p>For <code>autoFold op initial</code>, the “function thing” takes <em>one</em> <code>a</code> value and returns a <code>b</code> value based on the previous <code>a</code>’s it has seen.</p>
<p>The main point here is that <code>autoFold</code> is a sort of “function” in a way…just like the others before it. It’s a….”function-like thing”.</p>
<div class="note">
<p><strong>Aside</strong></p>
<p>Here is a quick diversion, if you’re up for it. This doesn’t really have too much to do with the rest of the post, but it’ll help you test your intuition a bit with Autos.</p>
<p>As an exercise, compare (and contrast) these three functions of identical type signatures:</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a><span class="fu">map</span><span class="ot">       f          ::</span> [a] <span class="ot">-&gt;</span> [b]</span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true" tabindex="-1"></a><span class="fu">scanl</span>     op<span class="ot"> initial ::</span> [a] <span class="ot">-&gt;</span> [b]</span>
<span id="cb38-3"><a href="#cb38-3" aria-hidden="true" tabindex="-1"></a>testAuto_<span class="ot"> auto       ::</span> [a] <span class="ot">-&gt;</span> [b]</span></code></pre></div>
<p>(Assume that <code>scanl</code> does not include the initial accumulator…that is, we are really talking about <code>drop 1 . scanl op init</code>)</p>
<p>Compare what they do conceptually. Then, for fun, try implementing some of them in terms of the other. Which re-implementations are possible? Which ones aren’t?</p>
</div>
<h3 id="more-auto-examples">More Auto examples</h3>
<p><a href="https://github.com/mstksg/inCode/tree/master/code-samples/machines/Auto.hs#L111-L176">I’ve thrown up a few auto examples</a> <a href="https://www.fpcomplete.com/user/jle/machines">that you can run online</a> so you can try it out and see how different ones work. Don’t get too attached to them, because we will later be re-implementing them as compositions of smaller, simpler building blocks.</p>
<dl>
<dt><a href="https://github.com/mstksg/inCode/tree/master/code-samples/machines/Auto.hs#L111-L122">rollingAverage</a></dt>
<dd>
<code>rollingAverage n :: Fractional a =&gt; Auto a a</code> outputs a rolling average of the last <code>n</code> values it has encountered
</dd>
</dl>
<div class="sourceCode" id="cb39"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> testAuto_ (rollingAverage <span class="dv">4</span>) [<span class="dv">2</span>,<span class="dv">8</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">1</span>,<span class="dv">8</span>,<span class="dv">3</span>,<span class="dv">5</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">8</span>,<span class="dv">3</span>,<span class="dv">5</span>,<span class="dv">9</span>,<span class="dv">2</span>]</span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true" tabindex="-1"></a>[<span class="fl">2.0</span> ,<span class="fl">5.0</span> ,<span class="fl">4.67</span>,<span class="fl">4.75</span>,<span class="fl">4.5</span></span>
<span id="cb39-3"><a href="#cb39-3" aria-hidden="true" tabindex="-1"></a>,<span class="fl">4.5</span> ,<span class="fl">4.25</span>,<span class="fl">4.25</span>,<span class="fl">4.25</span>,<span class="fl">2.5</span></span>
<span id="cb39-4"><a href="#cb39-4" aria-hidden="true" tabindex="-1"></a>,<span class="fl">3.75</span>,<span class="fl">3.25</span>,<span class="fl">4.25</span>,<span class="fl">6.25</span>,<span class="fl">4.75</span>]</span></code></pre></div>
<dl>
<dt><a href="https://github.com/mstksg/inCode/tree/master/code-samples/machines/Auto.hs#L125-L146">onFor</a></dt>
<dd>
<code>onFor p i :: Auto a Bool</code> normally outputs <code>False</code>…except whenever the input matches the given predicate <code>p :: a -&gt; Bool</code>. Then it stays “on” (<code>True</code>) for <code>i</code> steps.
</dd>
</dl>
<div class="sourceCode" id="cb40"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> <span class="op">:</span>t onFor <span class="fu">even</span> <span class="dv">3</span></span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a>onFor <span class="fu">even</span> <span class="dv">3</span><span class="ot"> ::</span> <span class="dt">Auto</span> <span class="dt">Int</span> <span class="dt">Bool</span></span>
<span id="cb40-3"><a href="#cb40-3" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> testAuto_ (onFor <span class="fu">even</span> <span class="dv">3</span>) [<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">4</span>,<span class="dv">1</span>,<span class="dv">6</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>]</span>
<span id="cb40-4"><a href="#cb40-4" aria-hidden="true" tabindex="-1"></a>[ <span class="dt">False</span>, <span class="dt">False</span>, <span class="dt">True</span> , <span class="dt">True</span> , <span class="dt">True</span></span>
<span id="cb40-5"><a href="#cb40-5" aria-hidden="true" tabindex="-1"></a>, <span class="dt">False</span>, <span class="dt">False</span>, <span class="dt">True</span> , <span class="dt">True</span> , <span class="dt">True</span></span>
<span id="cb40-6"><a href="#cb40-6" aria-hidden="true" tabindex="-1"></a>, <span class="dt">True</span> , <span class="dt">True</span> , <span class="dt">False</span>, <span class="dt">False</span> ]</span></code></pre></div>
<dl>
<dt><a href="https://github.com/mstksg/inCode/tree/master/code-samples/machines/Auto.hs#L149-L176">autoMap</a></dt>
<dd>
<p><code>autoMap cap :: Auto (Command k v) (Maybe v)</code> is a neat one. It internally holds a <a href="http://hackage.haskell.org/package/containers-0.5.4.0/docs/Data-Map.html">Map</a> (a key-value store) — you can give it <code>[Command][]</code> data types that tell it to insert, lookup, and delete values. However, it enforces a maximum of items.</p>
<p>The main thing to note here is that you get to completely encapsulate your “state”, and allow it only to be “modified” or “viewed” under your own terms. In OOP terms, it is like exposing only a few public methods to modify your private state with discrimination. If you were passed an <code>autoMap</code> with items already inside, you would have no way to have full “access” to the map — you would never be able to perform general operations (such as getting a list of all of the keys).</p>
</dd>
</dl>
<div class="sourceCode" id="cb41"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> testAuto_ (autoMap <span class="dv">3</span>)</span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span>   [ <span class="dt">Insert</span> <span class="st">&quot;hello&quot;</span> <span class="dv">7</span></span>
<span id="cb41-3"><a href="#cb41-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span>   , <span class="dt">Insert</span> <span class="st">&quot;world&quot;</span> <span class="dv">10</span></span>
<span id="cb41-4"><a href="#cb41-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span>   , <span class="dt">Insert</span> <span class="st">&quot;foo&quot;</span> <span class="dv">12</span></span>
<span id="cb41-5"><a href="#cb41-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span>   , <span class="dt">Insert</span> <span class="st">&quot;bar&quot;</span> <span class="dv">15</span></span>
<span id="cb41-6"><a href="#cb41-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span>   , <span class="dt">Delete</span> <span class="st">&quot;baz&quot;</span></span>
<span id="cb41-7"><a href="#cb41-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span>   , <span class="dt">Delete</span> <span class="st">&quot;world&quot;</span></span>
<span id="cb41-8"><a href="#cb41-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span>   , <span class="dt">Insert</span> <span class="st">&quot;haskell&quot;</span> <span class="dv">19</span></span>
<span id="cb41-9"><a href="#cb41-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span>   , <span class="dt">Lookup</span> <span class="st">&quot;world&quot;</span></span>
<span id="cb41-10"><a href="#cb41-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span>   , <span class="dt">Lookup</span> <span class="st">&quot;hello&quot;</span></span>
<span id="cb41-11"><a href="#cb41-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span>   ]</span>
<span id="cb41-12"><a href="#cb41-12" aria-hidden="true" tabindex="-1"></a>[ <span class="dt">Just</span> <span class="dv">7</span> , <span class="dt">Just</span> <span class="dv">10</span>, <span class="dt">Just</span> <span class="dv">12</span></span>
<span id="cb41-13"><a href="#cb41-13" aria-hidden="true" tabindex="-1"></a>, <span class="dt">Nothing</span>, <span class="dt">Nothing</span>, <span class="dt">Just</span> <span class="dv">10</span></span>
<span id="cb41-14"><a href="#cb41-14" aria-hidden="true" tabindex="-1"></a>, <span class="dt">Just</span> <span class="dv">19</span>, <span class="dt">Nothing</span>, <span class="dt">Just</span> <span class="dv">7</span>  ]</span></code></pre></div>
<h2 id="function-things">“Function Things”</h2>
<p>Anyways, back to our main point of emphasis:</p>
<p><em>Autos are function-like things</em>.</p>
<p>They are functions…<em>with (self-contained) state</em>.</p>
<p>Let’s do an analysis for <code>isEvenAuto</code> like the one we did with <code>foldAuto</code>. Our “input” was a <code>Maybe Int</code> and our “output” was a <code>Bool</code>.</p>
<p>You can think of <code>isEvenAuto</code> as a “function thing” from <code>Maybe Int</code> to <code>Bool</code>.</p>
<p>Here’s another function from <code>Maybe Int</code> to <code>Bool</code>: (I’m going to be using the prefix form of <code>(-&gt;)</code> a lot from now on)</p>
<div class="sourceCode" id="cb42"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/machines/Auto.hs#L181-L182</span></span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-3"><a href="#cb42-3" aria-hidden="true" tabindex="-1"></a><span class="ot">maybeIsEven ::</span> (<span class="ot">-&gt;</span>) (<span class="dt">Maybe</span> <span class="dt">Int</span>) <span class="dt">Bool</span></span>
<span id="cb42-4"><a href="#cb42-4" aria-hidden="true" tabindex="-1"></a>maybeIsEven <span class="ot">=</span> <span class="fu">even</span> <span class="op">.</span> fromMaybe <span class="dv">1</span></span></code></pre></div>
<p><code>maybeIsEven</code> returns <code>True</code> when value inside the <code>Just</code> is even, or <code>False</code> if the value is odd or it’s a <code>Nothing</code>.</p>
<p>Compare that type signature to that of our <code>isEvenAuto</code></p>
<div class="sourceCode" id="cb43"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a><span class="ot">maybeIsEven ::</span> (<span class="ot">-&gt;</span>) (<span class="dt">Maybe</span> <span class="dt">Int</span>) <span class="dt">Bool</span></span>
<span id="cb43-2"><a href="#cb43-2" aria-hidden="true" tabindex="-1"></a><span class="ot">isEvenAuto  ::</span> <span class="dt">Auto</span> (<span class="dt">Maybe</span> <span class="dt">Int</span>) <span class="dt">Bool</span></span></code></pre></div>
<p><code>maybeIsEven</code> and <code>isEvenAuto</code> are <em>both</em> “function-like things”. But whereas <code>maybeIsEven</code> is “memoryless” (it’s the same every time you call it), <code>isEvenAuto</code> <em>has memory</em> — it returns a different Boolean based on its history.</p>
<p>Contrast this with a Stream, which as we have seen is just an <code>Auto () b</code>. Streams are then “function like things” analogous to some <code>(-&gt;) () b</code>, or <code>() -&gt; b</code>. We can call functions like <code>() -&gt; b</code> “constants”, or “producers”. They are the same every time you call them or ask for them. Streams, however, “return” a potentially different <code>b</code> value every time they are “asked for”. So, just like an Auto is a “function” that has memory, a Stream is like a “constant” that has memory. A stateful generator. A “constant” that returns something different every time you ask for it.</p>
<p>Anyway, you should be able to guess that, after vaguely using the phrase “function things” several times…I’m going to surprise you all with the revelation that the general class of these “function things” have a name! And maybe even…a typeclass?</p>
<h2 id="onward">Onward</h2>
<p>So far we haven’t really made too convincing of an argument for the advantages of using machines (like Auto and the related Wire). Yeah, they provide encapsulation and a changing state…but these things come for free in most good Object-Oriented Programming languages. So what gives?</p>
<p>As it turns out, as we suggested before, Autos are potentially more “composable” than the objects of OOP. That is because, at their heart, they are just functions. And what do functions do best (as every functional programmer knows)? They compose! Complex object built seamlessly from simpler ones.</p>
<p>Now, I haven’t really been able to back this up so far. We’ve only scratched the surface, and we haven’t even considered function-like things that can return other function-like things. But in the next post, as we explore more the function-like nature of these things, we will be able to witness more of the full power of machine composition. And we’ll even be able to re-implement <em>many</em> of the complex machines of this post with compositions of smaller, simpler Autos.</p>
<section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes">
<hr />
<ol>
<li id="fn1"><p>It is somewhat important to note here that the semantics of FRP do not inherently involve machines. We’ll learn more about this later. For now, remember that this series will chiefly study the low-level <em>implementation</em> of AFRP, which may or may not be related to the <em>semantics</em>/abstractions of FRP — in an ideal world we wouldn’t even have to worry about implementation and just work on the level of the abstractions. Unfortunately, we don’t live in an ideal world :(<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section></div><footer><hr><div class="copy-content"><p>Hi, thanks for reading! You can reach me via email at <a href="mailto:justin@jle.im" class="email">justin@jle.im</a>, or at twitter at <a href="https://twitter.com/mstk">@mstk</a>! This post and all others are published under the <a href="https://creativecommons.org/licenses/by-nc-nd/3.0/">CC-BY-NC-ND 3.0</a> license. Corrections and edits via pull request are welcome and encouraged at <a href="https://github.com/mstksg/inCode">the source repository</a>.</p>
<p>If you feel inclined, or this post was particularly helpful for you, why not consider <a href="https://www.patreon.com/justinle/overview">supporting me on Patreon</a>, or a <a href="bitcoin:3D7rmAYgbDnp4gp4rf22THsGt74fNucPDU">BTC donation</a>? :)</p></div><div class="clear"></div><ul class="entry-series"><li><div>This entry is a part of a series called <b>&quot;Intro to Machines and Arrows&quot;</b>.  Find the rest of the entries in this series at its <a href="https://blog.jle.im/entries/series/+intro-to-machines-and-arrows.html" class="tag-a-series" title="+Intro to Machines and Arrows"> series history</a>.</div></li></ul><ul class="tag-list"><li><a href="https://blog.jle.im/entries/tagged/arrows.html" class="tag-a-tag">#arrows</a></li><li><a href="https://blog.jle.im/entries/tagged/auto-machines.html" class="tag-a-tag">#auto-machines</a></li><li><a href="https://blog.jle.im/entries/tagged/functional-reactive-programming.html" class="tag-a-tag">#functional reactive programming</a></li><li><a href="https://blog.jle.im/entries/tagged/haskell.html" class="tag-a-tag">#haskell</a></li><li><a href="https://blog.jle.im/entries/tagged/machines.html" class="tag-a-tag">#machines</a></li><li><a href="https://blog.jle.im/entries/category/@haskell.html" class="tag-a-category">@HASKELL</a></li><li><a href="https://blog.jle.im/entries/category/@ramblings.html" class="tag-a-category">@RAMBLINGS</a></li><li><a href="https://blog.jle.im/entries/series/+intro-to-machines-and-arrows.html" class="tag-a-series">+Intro to Machines and Arrows</a></li></ul><aside class="social-buttons"><div class="addthis_toolbox addthis_default_style addthis-buttons"><a class="addthis_button_facebook_like" fb:like:layout="button_count"></a><a class="addthis_button_tweet"></a><a class="addthis_button_google_plusone" g:plusone:size="medium"></a><a class="addthis_counter addthis_pill_style"></a></div><div class="custom-social-buttons"><div class="custom-social-button"><a href="https://www.reddit.com/submit" onclick="window.location = &#39;https://www.reddit.com/submit?url=&#39;+ encodeURIComponent(window.location); return false"><img src="https://www.reddit.com/static/spreddit7.gif" alt="submit to reddit"></a></div></div></aside><nav class="next-prev-links"><ul><li class="prev-entry-link">&larr; <a href="https://blog.jle.im/entry/blog-engine-updates-markdown-preprocessor-fay-scripts.html">Blog engine updates: Markdown Preprocessor &amp; Fay Scripts</a> (Previous)</li><li class="next-entry-link">(Next) <a href="https://blog.jle.im/entry/streaming-huffman-compression-in-haskell-part-1-trees.html">Streaming Huffman Compression in Haskell (Part 1: Trees and State)</a> &rarr;</li></ul></nav></footer></article><div class="post-entry"><div class="tile"><div id="disqus_thread"></div><script type="text/javascript">var disqus_config = function () {
    this.page.url = 'https://blog.jle.im/entry/intro-to-machines-arrows-part-1-stream-and.html';
    this.page.identifier = 'machines-1';
};
(function() {
    var d = document, s = d.createElement('script');
    s.src = '//incode.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
})();
</script><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a><br></noscript><a href="http://disqus.com" class="dsq-brlink">Comments powered by <span class="logo-disqus">Disqus</span></a></div></div></div></div></div><div id="footer-container"><div id="footer-content"><div class="tile"><div class="footer-copyright">&copy; 2020 Justin Le <span class="license-link">(<a href="https://creativecommons.org/licenses/by-nc-nd/3.0/" class="license">CC-BY-NC-ND 3.0</a>)</span></div><div class="footer-follow social-follows"><ul class="social-follows-list"><li><ul class="social-follows-list-social"><li><a class="social-follow-twitter" title="Follow me on Twitter!" href="https://twitter.com/intent/user?user_id=mstk" onclick="window.open(
  &#39;http://twitter.com/intent/user?user_id=907281&#39;,
  &#39;facebook-share-dialog&#39;,
  &#39;width=550,height=520&#39;);
return false;
">Twitter</a></li><li><a class="social-follow-github" title="Fork me on Github!" href="https://github.com/mstksg">Github</a></li><li><a class="social-follow-twitch" title="Watch me on Twitch!" href="https://www.twitch.tv/justin_l">Twitch</a></li><li><a class="social-follow-patreon" title="Support me on Patreon!" href="https://www.patreon.com/justinle/overview">Patreon</a></li><li><a class="social-follow-gplus" title="Add me on Google+!" href="https://plus.google.com/+JustinLe">Google+</a></li><li><a class="social-follow-keybase" title="Track me on Keybase!" href="https://keybase.io/mstksg">Keybase</a></li><li><a class="social-follow-linkedin" title="Connect with me on LinkedIn!" href="https://linkedin.com/in/lejustin">LinkedIn</a></li><li><a class="social-follow-bitcoin" title="Donate via bitcoin!" href="bitcoin:3D7rmAYgbDnp4gp4rf22THsGt74fNucPDU">Bitcoin</a></li></ul></li><li><ul class="social-follows-list-site"><li><a class="social-follow-rss" title="Subscribe to my RSS Feed!" href="http://feeds.feedburner.com/incodeblog">RSS</a></li><li><a class="social-follow-email" title="Subscribe to the mailing list!" href="https://feedburner.google.com/fb/a/mailverify?loc=en_US&amp;uri=incodeblog">Mailing list</a></li></ul></li></ul></div></div></div></div></body></html>