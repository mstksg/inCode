<!DOCTYPE HTML>
<html><head><title>Functors to Monads: A Story of Shapes · in Code</title><meta name="description" content="Weblog of Justin Le, covering various adventures in programming and explorations in the worlds of computation physics, and knowledge.
"><meta http-equiv="Content-Type" content="text/html;charset=utf-8"><meta name="viewport" content="width=device-width,initial-scale=1.0"><meta name="flattr:id" content="3p9jqr"><meta property="og:site_name" content="in Code"><meta property="og:description" content="For many years now I’ve been using a mental model and intuition that has guided me well for understanding and teaching and using functors, applicatives, monads, and other related Haskell abstractions, as well as for approaching learning new ones. Sometimes when teaching Haskell I talk about this concept and assume everyone already has heard it, but I realize that it’s something universal yet easy to miss depending on how you’re learning it. So, here it is: how I understand the Functor and other related abstractions and free constructions in Haskell. The crux is this: instead of thinking about what fmap changes, ask: what does fmap keep constant? This isn’t a rigorous understanding and isn’t going to explain every aspect about every Functor, and will probably only be useful if you already know a little bit about Functors in Haskell. But it’s a nice intuition trick that has yet to majorly mislead me."><meta property="og:type" content="article"><meta property="og:title" content="Functors to Monads: A Story of Shapes"><meta property="og:image" content="https://blog.jle.im/img/site_logo.jpg"><meta property="og:locale" content="en_US"><meta property="og:url" content="https://blog.jle.im/entry/functors-to-monads-a-story-of-shapes.html"><meta name="twitter:card" content="summary"><meta name="twitter:creator:id" content="mstk"><link rel="author" href="https://plus.google.com/107705320197444500140"><link rel="alternate" type="application/rss+xml" title="in Code (RSS Feed)" href="http://feeds.feedburner.com/incodeblog"><link rel="canonical" href="https://blog.jle.im/entry/functors-to-monads-a-story-of-shapes.html"><link href="https://blog.jle.im/favicon.ico" rel="shortcut icon"><link href="https://blog.jle.im/css/toast.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/font.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/main.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/page/entry.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/pygments.css" rel="stylesheet" type="text/css"><script type="text/javascript">var page_data = {};
var disqus_shortname='incode';
</script><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-443711-8', 'jle.im');
ga('send', 'pageview');
</script><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script id="MathJax-script" async="" src="https://cdn.jsdelivr.net/npm/mathjax@3.0.1/es5/tex-mml-chtml.js"></script><script type="text/javascript" src="//ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script><script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5234d67a6b68dcd4"></script><script type="text/javascript" src="https://blog.jle.im/js/page/entry_toc.js"></script><script type="text/javascript" src="https://blog.jle.im/js/disqus_count.js"></script><script type="text/javascript" src="https://blog.jle.im/js/social.js"></script><script type="text/javascript" src="https://blog.jle.im/js/jquery/jquery.toc.js"></script><script type="text/javascript" src="https://blog.jle.im/purescript/entry.js"></script></head><body><div id="fb-root"><script>(function(d, s, id) {
 var js, fjs = d.getElementsByTagName(s)[0];
 if (d.getElementById(id)) return;
 js = d.createElement(s); js.id = id;
 js.src = "//connect.facebook.net/en_US/all.js#xfbml=1&appId=641852699171929";
 fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));
</script></div><div id="header-container"><div id="navbar-container" class="tile"><nav id="navbar-content"><div class="nav-info"><h1 class="site-title"><a href="https://blog.jle.im/" class="nav-title">in Code</a></h1><span class="nav-author">Justin Le</span></div><ul class="nav-links"><li><a href="https://blog.jle.im/">home</a></li><li><a href="https://blog.jle.im/entries.html">archives</a></li><li><a href="https://cv.jle.im">cv</a></li><div class="clear"></div></ul></nav></div><div id="header-content"></div></div><div id="body-container" class="container"><div id="main-container" class="grid"><div class="entry-section unit span-grid" role="main"><article class="tile article"><header><h1 id="title">Functors to Monads: A Story of Shapes</h1><p class="entry-info">by <a class="author" href="https://blog.jle.im/">Justin Le</a><span class="info-separator"> &diams; </span><time datetime="2024-11-04T11:44:50Z" pubdate="" class="pubdate">Monday November 4, 2024</time></p><p><span class="source-info"><a class="source-link" href="https://github.com/mstksg/inCode/tree/master/copy/entries/story-of-shapes.md">Source</a><span class="info-separator"> &diams; </span><a class="source-link" href="https://github.com/mstksg/inCode/tree/gh-pages/entry/functors-to-monads-a-story-of-shapes.md">Markdown</a><span class="info-separator"> &diams; </span><a class="source-link" href="https://blog.jle.im/entry/functors-to-monads-a-story-of-shapes.tex">LaTeX</a><span class="info-separator"> &diams; </span></span>Posted in <a href="https://blog.jle.im/entries/category/@haskell.html" class="tag-a-category" title="Functional, pure, non-strict, statically and strongly typed, natively
compiled...really just the king of great languages.
">Haskell</a><span class="info-separator"> &diams; </span><a class="comment-link" href="#disqus_thread">Comments</a></p></header><hr><aside class="contents-container"><h5 id="contents-header">Contents</h5><div id="toc"></div></aside><div class="main-content copy-content"><p>For many years now I’ve been using a mental model and intuition that has guided me well for understanding and teaching and using functors, applicatives, monads, and other related Haskell abstractions, as well as for approaching learning new ones. Sometimes when teaching Haskell I talk about this concept and assume everyone already has heard it, but I realize that it’s something universal yet easy to miss depending on how you’re learning it. So, here it is: how I understand the Functor and other related abstractions and free constructions in Haskell.</p>
<p>The crux is this: instead of thinking about what <code>fmap</code> changes, ask: what does <code>fmap</code> keep <em>constant</em>?</p>
<p>This isn’t a rigorous understanding and isn’t going to explain <em>every</em> aspect about <em>every</em> Functor, and will probably only be useful if you already know a little bit about Functors in Haskell. But it’s a nice intuition trick that has yet to majorly mislead me.</p>
<h2 id="the-secret-of-functors">The Secret of Functors</h2>
<p>First of all, <em>what is a Functor</em>? A capital-F Functor, that is, the Haskell typeclass and abstraction. Ask a random Haskeller on the street and they’ll tell you that it’s something that can be “mapped over”, like a list or an optional. Maybe some of those random Haskellers will feel compelled to mention that this mapping should follow some laws…they might even list the laws. Ask them why these laws are so important and maybe you’ll spend a bit of time on this rhetorical street of Haskellers before finding one confident enough to give an answer.</p>
<p>So I’m going to make a bit of a tautological leap: a <em>Functor</em> gives you a way to “map over” values in a way that <em>preserves shape</em>. And what is “shape”? A shape is <em>the thing that fmap preserves</em>.</p>
<p>The Functor typeclass is simple enough: for <code>Functor f</code>, you have a function <code>fmap :: (a -&gt; b) -&gt; f a -&gt; f b</code>, along with <code>fmap id = id</code> and <code>fmap f . fmap g = fmap (f . g)</code>. Cute things you can drop into quickcheck to prove for your instance, but it seems like those laws are hiding some sort of deeper, fundamental truth.</p>
<p>The more Functors you learn about, the more you see that <code>fmap</code> seems to always preserve “something”:</p>
<ul>
<li>For lists, <code>fmap</code> preserves length and relative orderings.</li>
<li>For optionals (<code>Maybe</code>), <code>fmap</code> preserves <em>presence</em> (the fact that something is there or not). It cannot flip a <code>Just</code> to a <code>Nothing</code> or vice versa.</li>
<li>For <code>Either e</code>, <code>fmap</code> preserves <em>the error</em> (if it exists) or the fact that it was succesful.</li>
<li>For <code>Map k</code>, <code>fmap</code> preserves <em>the keys</em>: which keys exist, how many there are, their relative orderings, etc.</li>
<li>For <code>IO</code>, <code>fmap</code> preserves <em>the IO effect</em>. Every bit of external I/O that an IO action represents is unchanged by an <code>fmap</code>, as well as exceptions.</li>
<li>For <code>Writer w</code> or <code>(,) w</code>, <code>fmap</code> preserves the “logged” <code>w</code> value, leaving it unchanged. Same for <code>Const w</code>.</li>
<li>For <code>Tree</code>, <code>fmap</code> preserves <em>the tree structure</em>: how many layers, how big they are, how deep they are, etc.</li>
<li>For <code>State s</code>, <code>fmap</code> preserves what happens to the input state <code>s</code>. How a <code>State s</code> transform a state value <code>s</code> is unchanged by <code>fmap</code></li>
<li>For <code>ConduitT i o m</code> from <em><a href="https://hackage.haskell.org/package/conduit">conduit</a></em>, <code>fmap</code> preserves what the conduit pulls upstream and what it yields downstream. <code>fmap</code> will not cause the conduit to yield more or different objects, nor cause it to consume/pull more or less.</li>
<li>For parser-combinator <code>Parser</code>, <code>fmap</code> preserves what input is consumed or would fail to be consumed. <code>fmap</code> cannot change whether an input string would fail or succeed, and it cannot change how much it consumes.</li>
<li>For <em><a href="https://hackage.haskell.org/package/optparse-applicative">optparse-applicative</a></em> <code>Parser</code>s, <code>fmap</code> preserves the command line arguments available. It leaves the <code>--help</code> message of your program unchanged.</li>
</ul>
<p>It seems like as soon as you define a <code>Functor</code> instance, or as soon as you find out that some type has a <code>Functor</code> instance, it magically induces some sort of … “thing” that must be preserved.<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a> A <em>conserved quantity must exist</em>. It reminds me a bit of <a href="https://en.wikipedia.org/wiki/Noether%27s_theorem">Noether’s Theorem</a> in Physics, where any continuous symmetry “induces” a conserved quantity (like how translation symmetry “causes” conservation of momentum). In Haskell, every lawful <code>Functor</code> instance induces a conserved quantity. I don’t know if there is a canonical name for this conserved quantity, but I like to call it “shape”.</p>
<h2 id="a-story-of-shapes">A Story of Shapes</h2>
<p>The word “shape” is chosen to be as devoid of external baggage/meaning as possible while still having <em>some</em>. The word isn’t important as much as saying that there is <em>some</em> “thing” preserved by <code>fmap</code>, and not exactly the nature of that “thing”. The <em>nature</em> of that thing changes a lot from Functor to Functor, where we might better call it an “effect” or a “structure” specifically, but that <em>some</em> “thing” exists is almost universal.</p>
<p>Of course, the value if this “thing” having a canonical name at all is debatable. I were to coin a completely new term I might call it a “conserved charge” or “gauge” in allusion to physics. But the most useful name probably would be shape.</p>
<p>For some <code>Functor</code> instances, the word shape is more literal than others. For trees, for instance, you have the literal shape of the tree preserved. For lists, the “length” could be considered a literal shape. <code>Map k</code>’s shape is also fairly literal: it describes the structure of keys that exist in the map. But for <code>Writer w</code> and <code>Const w</code>, shape can be interpreted as some information outside of the values you are mapping that is left unchanged by mapping. For <code>Maybe</code> and <code>Either e</code> shape also considers if there has been any short-circuiting. For <code>State s</code> and <code>IO</code> and <code>Parser</code>, “shape” involves some sort of side-computation or consumption that is left unchanged by <code>fmap</code>, often called an effect. For <em>optparse-applicative</em>, “shape” involves some sort of inspectable and observable static aspects of a program. “Shape” comes in all forms.</p>
<p>But, this intuition of “looking for that conserved quantity” is very helpful for learning <em>new</em> Functors. If you stumble onto a new type that you know is a <code>Functor</code> instance, you can immediately ask “What <em>shape</em> is this <code>fmap</code> preserving?”, and it will almost always yield insight into that type.</p>
<p>This viewpoint also sheds insight onto why <code>Set.map</code> isn’t a good candidate for <code>fmap</code> for <em><a href="https://hackage.haskell.org/package/containers/docs/Data-Set.html">Data.Set</a></em>: What “thing” does <code>Set.map f</code> preserve? Not size, for sure. In a hypothetical world where we had <code>ordfmap :: Ord b =&gt; (a -&gt; b) -&gt; f a -&gt; f b</code>, we would still need <code>Set.map</code> to preserve <em>something</em> for it to be useful as an “Ord-restricted Functor”.<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a></p>
<h3 id="a-result">A Result</h3>
<p>Before we move on, let’s look at another related and vague concept that is commonly used when discussing functors: <code>fmap</code> is a way to map a function that <em>preserves the shape</em> and <em>changes the result</em>.</p>
<p>If <em>shape</em> is the thing that is <em>preserved</em> by <code>fmap</code>, <em>result</em> is the thing that is <em>changed</em> by it. <code>fmap</code> cleanly splits the two.</p>
<p>Interestingly, most introduction to Functors begin with describing functor values as having a result and <code>fmap</code> as the thing that changes it, in some way. Ironically, though it’s a more common term, it’s by far the more vague and hard-to-intuit concept.</p>
<p>For something like <code>Maybe</code>, “result” is easy enough: it’s the value present if it exists. For parser-combinator <code>Parser</code>s too it’s relatively simple: the “shape” is the input consumed but the “result” is the Haskell value you get as a result of the consumption. For <em>optparse-applicative</em> parser, it’s the actual parsed command line arguments given by the user at runtime. But sometimes it’s more complicated: for the technical List functor, the “non-determinism” functor, the “shape” is the number of options to choose from and the order you get them in, and the “result” (to use precise semantics) is the non-deterministic choice that you eventually pick or iterate over.</p>
<p>So, the “result” can become a bit confusing to generalize. So, in my mind, I usually reduce the definitions to:</p>
<ul>
<li><em>Shape</em>: the “thing” that <code>fmap</code> preserves: the <code>f</code> in <code>f a</code></li>
<li><em>Result</em>: the “thing” that <code>fmap</code> changes: the <code>a</code> in <code>f a</code></li>
</ul>
<p>With this you could “derive” the Functor laws:</p>
<ul>
<li><code>fmap id == id</code>: <code>fmap</code> leaves the shape unchanged, <code>id</code> leaves the result unchanged. So entire thing must remain unchanged!</li>
<li><code>fmap f . fmap g == fmap (f . g)</code>. In both cases the shape remains unchanged, but one changes the result by f after g, and the other changes the result by <code>f . g</code>. They must be the same transformation!</li>
</ul>
<p>All neat and clean, right? So, maybe the big misdirection is focusing too much on the “result” when learning Functors, when we <em>should</em> really be focusing more on the “shape”, or at least the two together.</p>
<p>Once you internalize “<code>Functor</code> gives you shape-preservation”, this helps you understand the value of the other common typeclass abstractions in Haskell as well, and how they function based on how they manipulate “shape” and “result”.</p>
<h2 id="traversable">Traversable</h2>
<p>For example, what does the <code>Traversable</code> typeclass give us? Well, if <code>Functor</code> gives us a way to map <em>pure</em> functions and preserve shape, then <code>Traversable</code> gives us a way to map <em>effectful</em> functions and preserve shape.</p>
<p>Whenever someone asks me about my favorite <code>Traversable</code> instance, I always say it’s the <code>Map k</code> traversable:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="fu">traverse</span><span class="ot"> ::</span> <span class="dt">Applicative</span> f <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> f b) <span class="ot">-&gt;</span> <span class="dt">Map</span> k a <span class="ot">-&gt;</span> f (<span class="dt">Map</span> k b)</span></code></pre></div>
<p>Notice how it has no constraints on <code>k</code>? Amazing isn’t it? <code>Map k b</code> lets us map an <code>(a -&gt; f b)</code> over the values at each key in a map, and collects the results under the key the <code>a</code> was originally under.</p>
<p>In essence, you can be assured that the result map has the <em>same keys</em> as the original map, perfectly preserving the “shape” of the map. The <code>Map k</code> instance is the epitome of beautiful <code>Traversable</code> instances. We can recognize this by identifying the “shape” that <code>traverse</code> is forced to preserve.</p>
<h2 id="applicative">Applicative</h2>
<p>What does the <code>Applicative</code> typeclass give us? It has <code>ap</code> and <code>pure</code>, but <a href="https://hackage.haskell.org/package/base/docs/Control-Applicative.html#t:Applicative">its laws</a> are infamously difficult to understand.</p>
<p>But, look at <code>liftA2 (,)</code>:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>liftA2 (,)<span class="ot"> ::</span> <span class="dt">Applicative</span> f <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> f b <span class="ot">-&gt;</span> f (a, b)</span></code></pre></div>
<p>It lets us take “two things” and <em>combine their shapes</em>. And, more importantly, it combines the shapes <em>without considering the results</em>.</p>
<ul>
<li>For <code>Writer w</code>, <code>&lt;*&gt;</code> lets us combine the two logged values using <code>mappend</code> while ignoring the actual <code>a</code>/<code>b</code> results.</li>
<li>For list, <code>&lt;*&gt;</code> (the cartesian product) lets us multiply the lengths of the input lists together. The <em>length</em> of the new list ignores the actual <em>contents</em> of the list.</li>
<li>For <code>State s</code>, <code>&lt;*&gt;</code> lets you <em>compose</em> the <code>s -&gt; s</code> state functions together, ignoring the <code>a</code>/<code>b</code>s</li>
<li>For <code>Parser</code>, <code>&lt;*&gt;</code> lets you sequence input consumption in a way that doesn’t depend on the actual values you parse: it’s “context-free” in a sense, aside from <a href="https://byorgey.wordpress.com/2012/01/05/parsing-context-sensitive-languages-with-applicative/">some caveats</a>.</li>
<li>For <em>optparse-applicative</em>, <code>&lt;*&gt;</code> lets you combine your command line argument specs together, without depending on the actual values provided at runtime by the caller.</li>
</ul>
<p>The key takeaway is that the “final shape” <em>only depends</em> on the input shapes, and not the results. You can know the length of <code>&lt;*&gt;</code>-ing two lists together with only knowing the length of the input lists, and you can also know the relative ordering of inputs to outputs. Within the specific context of the semantics of <code>IO</code>, you can know what “effect” <code>&lt;*&gt;</code>-ing two IO actions would produce only knowing the effects of the input IO actions<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a>. You can know what command line arguments <code>&lt;*&gt;</code>-ing two <em>optparse-applicative</em> parsers would have only knowing the command line arguments in the input parsers. You can know what strings <code>&lt;*&gt;</code>-ing two parser-combinator parsers would consume or reject, based only on the consumption/rejection of the input parsers. You can know the final log of <code>&lt;*&gt;</code>-ing two <code>Writer w a</code>s together by only knowing the logs of the input writer actions.</p>
<p>And hey…some of these combinations feel “monoidal”, don’t they?</p>
<ul>
<li><code>Writer w</code> sequences using <code>mappend</code></li>
<li>List lengths sequence by multiplication</li>
<li><code>State s</code> functions sequence by composition</li>
</ul>
<p>You can also imagine “no-op” actions:</p>
<ul>
<li><code>Writer w</code>’s no-op action would log <code>mempty</code>, the identity of <code>mappend</code></li>
<li>List’s no-op action would have a length 1, the identity of multiplication</li>
<li><code>State s</code>’s no-op action would be <code>id</code>, the identity of function composition</li>
</ul>
<p>That might sound familiar — these are all <code>pure</code> from the <code>Applicative</code> typeclass!</p>
<p>So, the Applicative typeclass laws aren’t that mysterious at all. If you understand the “shape” that a Functor induces, <code>Applicative</code> gives you a <em>monoid</em> on that shape! This is why <code>Applicative</code> is often called the “higher-kinded” <code>Monoid</code>.</p>
<p>This intuition takes you pretty far, I believe. Look at the examples above where we clearly identify specific <code>Applicative</code> instances with specific <code>Monoid</code> instances (<code>Monoid w</code>, <code>Monoid (Product Int)</code>, <code>Monoid (Endo s)</code>).</p>
<p>Put in code:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- A part of list&#39;s shape is its length and the monoid is (*, 1)</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="fu">length</span> (xs <span class="op">&lt;*&gt;</span> ys) <span class="op">==</span> <span class="fu">length</span> xs <span class="op">*</span> <span class="fu">length</span> ys</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="fu">length</span> (<span class="fu">pure</span> r) <span class="op">==</span> <span class="dv">1</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a><span class="co">-- Maybe&#39;s shape is isJust and the monoid is (&amp;&amp;, True)</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>isJust (mx <span class="op">&lt;*&gt;</span> my) <span class="op">==</span> isJust mx <span class="op">&amp;&amp;</span> isJust my</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>isJust (<span class="fu">pure</span> r) <span class="ot">=</span> <span class="dt">True</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a><span class="co">-- State&#39;s shape is execState and the monoid is (flip (.), id)</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>execState (sx <span class="op">&lt;*&gt;</span> sy) <span class="op">==</span> execState sy <span class="op">.</span> execState sx</span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>execState (<span class="fu">pure</span> r) <span class="op">==</span> <span class="fu">id</span></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a><span class="co">-- Writer&#39;s shape is execWriter and the monoid is (&lt;&gt;, mempty)</span></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>execWriter (wx <span class="op">&lt;*&gt;</span> wy) <span class="op">==</span> execWriter wx <span class="op">&lt;&gt;</span> execWriter wy</span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a>execWriter (<span class="fu">pure</span> r) <span class="op">==</span> <span class="fu">mempty</span></span></code></pre></div>
<p>We can also extend this to non-standard <code>Applicative</code> instances: the <code>ZipList</code> newtype wrapper gives us an <code>Applicative</code> instance for lists where <code>&lt;*&gt;</code> is <code>zipWith</code>. These two have the same <code>Functor</code> instances, so their “shape” (length) is the same. And for both the normal <code>Applicative</code> and the <code>ZipList</code> <code>Applicative</code>, you can know the length of the result based on the lengths of the input, but <code>ZipList</code> combines shapes using the <code>Min</code> monoid, instead of the <code>Product</code> monoid. And the identity of <code>Min</code> is positive infinity, so <code>pure</code> for <code>ZipList</code> is an infinite list.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- A part of ZipList&#39;s shape is length and its monoid is (min, infinity)</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="fu">length</span> (xs <span class="op">&lt;*&gt;</span> ys) <span class="op">==</span> <span class="fu">length</span> xs <span class="ot">`min`</span> <span class="fu">length</span> ys</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="fu">length</span> (<span class="fu">pure</span> r) <span class="op">==</span> infinity</span></code></pre></div>
<p>The “know-the-shape-without-knowing-the-results” property is actually leveraged by many libraries. It’s how <em>optparse-applicative</em> can give you <code>--help</code> output: the <em>shape</em> of the optparse-applicative parser (the command line arguments list) can be computed <em>without knowing the results</em> (the actual arguments themselves at runtime). You can list out what arguments are expecting without ever getting any input from the user.</p>
<p>This is also leveraged by the <em><a href="https://hackage.haskell.org/package/async">async</a></em> library to give us the <code>Concurrently</code> <code>Applicative</code> instance. Normally <code>&lt;*&gt;</code> for IO gives us sequential combination of IO effects. But, <code>&lt;*&gt;</code> for <code>Concurrently</code> gives us <em>parallel</em> combination of IO effects. We can launch all of the IO effects in parallel at the same time because <em>we know what the IO effects are</em> before we actually have to execute them to get the results. If we needed to know the results, this wouldn’t be possible.</p>
<p>This also gives some insight into the <a href="https://hackage.haskell.org/package/transformers-0.6.1.2/docs/Control-Applicative-Backwards.html"><code>Backwards</code> Applicative wrapper</a> — because the shape of the final does not depend on the <em>result</em> of either, we are free to combine the shapes in whatever order we want. In the same way that every monoid gives rise to <a href="https://hackage.haskell.org/package/base-4.20.0.1/docs/Data-Monoid.html#t:Dual">a “backwards” monoid</a>:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> <span class="st">&quot;hello&quot;</span> <span class="op">&lt;&gt;</span> <span class="st">&quot;world&quot;</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="st">&quot;helloworld&quot;</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> getDual <span class="op">$</span> <span class="dt">Dual</span> <span class="st">&quot;hello&quot;</span> <span class="op">&lt;&gt;</span> <span class="dt">Dual</span> <span class="st">&quot;world&quot;</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a><span class="st">&quot;worldhello&quot;</span></span></code></pre></div>
<p>Every <code>Applicative</code> gives rise to a “backwards” <code>Applicative</code> that does the shape “mappending” in reverse order:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> <span class="fu">putStrLn</span> <span class="st">&quot;hello&quot;</span> <span class="op">*&gt;</span> <span class="fu">putStrLn</span> <span class="st">&quot;world&quot;</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>hello</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>world</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> forwards <span class="op">$</span> <span class="dt">Backwards</span> (<span class="fu">putStrLn</span> <span class="st">&quot;hello&quot;</span>) <span class="op">*&gt;</span> <span class="dt">Backwards</span> (<span class="fu">putStrLn</span> <span class="st">&quot;world&quot;</span>)</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>world</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>hello</span></code></pre></div>
<p>The monoidal nature of Applicative with regards to shapes and effects is the heart of the original intent, and I’ve discussed this <a href="https://blog.jle.im/entry/const-applicative-and-monoids.html">in earlier blog posts</a>.</p>
<h2 id="alternative">Alternative</h2>
<p>The main function of the <em><a href="https://hackage.haskell.org/package/base-4.20.0.1/docs/Control-Applicative.html#g:2">Alternative</a></em> typeclass is <code>&lt;|&gt;</code>:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="ot">(&lt;|&gt;) ::</span> <span class="dt">Alternative</span> f <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f a</span></code></pre></div>
<p>At first this might look a lot like <code>&lt;*&gt;</code> or <code>liftA2 (,)</code></p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>liftA2 (,)<span class="ot"> ::</span> <span class="dt">Applicative</span> f <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> f b <span class="ot">-&gt;</span> f (a, b)</span></code></pre></div>
<p>Both of them take two <code>f a</code> values and squish them into a single one. Both of these are also monoidal on the shape, independent of the result. They have a <em>different</em> monoidal action on <code>&lt;|&gt;</code> than as <code>&lt;*&gt;</code>:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- A part of list&#39;s shape is its length:</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="co">-- the Ap monoid is (*, 1), the Alt monoid is (+, 0)</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a><span class="fu">length</span> (xs <span class="op">&lt;*&gt;</span> ys) <span class="op">==</span> <span class="fu">length</span> xs <span class="op">*</span> <span class="fu">length</span> ys</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a><span class="fu">length</span> (<span class="fu">pure</span> r) <span class="op">==</span> <span class="dv">1</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a><span class="fu">length</span> (xs <span class="op">&lt;|&gt;</span> ys) <span class="op">==</span> <span class="fu">length</span> xs <span class="op">+</span> <span class="fu">length</span> ys</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a><span class="fu">length</span> empty <span class="op">==</span> <span class="dv">0</span></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a><span class="co">-- Maybe&#39;s shape is isJust:</span></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a><span class="co">-- The Ap monoid is (&amp;&amp;, True), the Alt monoid is (||, False)</span></span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a>isJust (mx <span class="op">&lt;*&gt;</span> my) <span class="op">==</span> isJust mx <span class="op">&amp;&amp;</span> isJust my</span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a>isJust (<span class="fu">pure</span> r) <span class="ot">=</span> <span class="dt">True</span></span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a>isJust (mx <span class="op">&lt;|&gt;</span> my) <span class="op">==</span> isJust mx <span class="op">||</span> isJust my</span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a>isJust empty <span class="ot">=</span> <span class="dt">False</span></span></code></pre></div>
<p>If we understand that functors have a “shape”, <code>Applicative</code> implies that the shapes are monoidal, and <code>Alternative</code> implies that the shapes are a “double-monoid”. The exact nature of how the two monoids relate to each other, however, is not universally agreed upon. For many instances, however, it does happen to form a <a href="https://en.wikipedia.org/wiki/Semiring">semiring</a>, where <code>empty</code> “annihilates” via <code>empty &lt;*&gt; x == empty</code>, and <code>&lt;*&gt;</code> distributes over <code>&lt;|&gt;</code> like <code>x &lt;*&gt; (y &lt;|&gt; z) == (x &lt;*&gt; y) &lt;|&gt; (x &lt;*&gt; z)</code>. But this is not universal.</p>
<p>However, what does <code>Alternative</code> bring to our shape/result dichotomy that <code>Applicative</code> did not? Notice the subtle difference between the two:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>liftA2 (,)<span class="ot"> ::</span> <span class="dt">Applicative</span> f <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> f b <span class="ot">-&gt;</span> f (a, b)</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="ot">(&lt;|&gt;) ::</span> <span class="dt">Alternative</span> f <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f a</span></code></pre></div>
<p>For <code>Applicative</code>, the “result” comes from the results of both inputs. For <code>Alternative</code>, the “result” could come from one or the other input. So, this introduces a fundamental data dependency for the <em>results</em>:</p>
<ul>
<li>Applicative: Shapes merge monoidally independent of the results, but to get the result of the final, you need to produce the results of both of the two inputs in the general case.</li>
<li>Alternative: Shapes merge monoidally independent of the results, but to get the result of the final, you need the results of one or the other input in the general case.</li>
</ul>
<p>This also implies that choice of combination method for shapes in <code>Applicative</code> vs <code>Alternative</code> aren’t arbitrary: the former has to be “conjoint” in a sense, and the latter has to be “disjoint”.</p>
<p>See again that clearly separating the shape and the result gives us the vocabulary to say precisely what the different data dependencies are.</p>
<h2 id="monad">Monad</h2>
<p>Understanding shapes and results also help us appreciate more the sheer <em>power</em> that Monad gives us. Look at <code>&gt;&gt;=</code>:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="ot">(&gt;&gt;=) ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> m a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> m b) <span class="ot">-&gt;</span> m b</span></code></pre></div>
<p>Using <code>&gt;&gt;=</code> means that the shape of the final action is allowed to <em>depend on the result</em> of the first action! We are no longer in the Applicative/Alternative world where shape only depends on shape.</p>
<p>Now we can write things like:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>greet <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">putStrLn</span> <span class="st">&quot;What is your name?&quot;</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>  n <span class="ot">&lt;-</span> <span class="fu">getLine</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">putStrLn</span> (<span class="st">&quot;Hello, &quot;</span> <span class="op">++</span> n <span class="op">++</span> <span class="st">&quot;!&quot;</span>)</span></code></pre></div>
<p>Remember that for “IO”, the shape is the IO effects (In this case, what exactly gets sent to the terminal) and the “result” is the haskell value computed from the execution of that IO effect. In our case, the <em>action</em> of the result (what values are printed) depends on the <em>result</em> of of the intermediate actions (the <code>getLine</code>). You can no longer know in advance what action the program will have without actually running it and getting the results.</p>
<p>The same thing happens when you start sequencing parser-combinator parsers: you can’t know what counts as a valid parse or how much a parser will consume until you actually start parsing and getting your intermediate parse results.</p>
<p><code>Monad</code> is also what makes <code>guard</code> and co. useful. Consider the purely Applicative:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="ot">evenProducts ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> [<span class="dt">Bool</span>]</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>evenProducts xs ys <span class="ot">=</span> (\x y <span class="ot">-&gt;</span> <span class="fu">even</span> (x <span class="op">*</span> y)) <span class="op">&lt;$&gt;</span> xs <span class="op">&lt;*&gt;</span> ys</span></code></pre></div>
<p>If you passed in a list of 100 items and a list of 200 items, you can know that the result has 100 * 200 = 20000 items, without actually knowing any of the items in the list.</p>
<p>But, consider an alternative formulation where we are allowed to use Monad operations:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="ot">evenProducts ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> [(<span class="dt">Int</span>, <span class="dt">Int</span>)]</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>evenProducts xs ys <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>  x <span class="ot">&lt;-</span> xs</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>  y <span class="ot">&lt;-</span> ys</span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>  guard (<span class="fu">even</span> (x <span class="op">*</span> y))</span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>  <span class="fu">pure</span> (x, y)</span></code></pre></div>
<p>Now, <em>even if you knew</em> the lengths of the input lists, you can <em>not</em> know the length of the output list without actually knowing what’s inside your lists. You need to actually start “sampling”.</p>
<p>That’s why there is no <code>Monad</code> instance for <code>Backwards</code> or <em>optparse-applicative</em> parsers. For <code>Backwards</code> doesn’t work because we’ve now introduced an asymmetry (the <code>m b</code> depends on the <code>a</code> of the <code>m a</code>) that can’t be reversed. For <em>optparse-applicative</em>, it’s because we want to be able to inspect the shape without knowing the results at runtime (so we can show a useful <code>--help</code> without getting any actual arguments): but, with <code>Monad</code>, we can’t know the shape without knowing the results!</p>
<p>In a way, Monad simply “is” the way to combine <code>Functor</code> shapes together where the final shape is allowed to depend on the results. Hah, I tricked you into reading a monad tutorial!</p>
<h2 id="free-structures">Free Structures</h2>
<p>I definitely write <a href="https://blog.jle.im/entry/functor-combinatorpedia.html">way too much about free structures</a> on this blog. But this “shapeful” way of thinking also gives rise to why free structures are so compelling and interesting to work with in Haskell.</p>
<p>Before, we were describing shapes of Functors and Applicatives and Monads that already existed. We had <em>this</em> <code>Functor</code>, what was <em>its</em> shape?</p>
<p>However, what if we had a shape that we had in mind, and wanted to <em>create</em> an <code>Applicative</code> or <code>Monad</code> that manipulated that shape?</p>
<p>For example, let’s roll our own version of <em>optparse-applicative</em> that only supported <code>--myflag somestring</code> options. We could say that the “shape” is the list of supported option and parsers. So a single element of this shape would be the specification of a single option:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Option</span> a <span class="ot">=</span> <span class="dt">Option</span> {<span class="ot"> optionName ::</span> <span class="dt">String</span>,<span class="ot"> optionParse ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a }</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">deriving</span> <span class="dt">Functor</span></span></code></pre></div>
<p>The “shape” here is the name and also what values it would parse, essentially. <code>fmap</code> won’t affect the name of the option and won’t affect what would succeed or fail.</p>
<p>Now, to create a full-fledged multi-argument parser, we can use <a href="https://hackage.haskell.org/package/free/docs/Control-Applicative-Free.html"><code>Ap</code> from the <em>free</em> library</a>:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Parser</span> <span class="ot">=</span> <span class="dt">Ap</span> <span class="dt">Option</span></span></code></pre></div>
<p>We specified the shape we wanted, now we get the <code>Applicative</code> of that shape for free! We can now combine our shapes monoidally using the <code>&lt;*&gt;</code> instance, and then use <code>runAp_</code> to inspect it:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Args</span> <span class="ot">=</span> <span class="dt">Args</span> {<span class="ot"> myStringOpt ::</span> <span class="dt">String</span>,<span class="ot"> myIntOpt ::</span> <span class="dt">Int</span> }</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a><span class="ot">parseTwo ::</span> <span class="dt">Parser</span> args</span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>parseTwo <span class="ot">=</span> <span class="dt">Args</span> <span class="op">&lt;$&gt;</span> liftAp stringOpt <span class="op">&lt;*&gt;</span> liftAp intOpt</span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a>    stringOpt <span class="ot">=</span> <span class="dt">Option</span> <span class="st">&quot;string-opt&quot;</span> <span class="dt">Just</span></span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a>    intOpt <span class="ot">=</span> <span class="dt">Option</span> <span class="st">&quot;int-opt&quot;</span> readMaybe</span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true" tabindex="-1"></a><span class="ot">getAllOptions ::</span> <span class="dt">Parser</span> a <span class="ot">-&gt;</span> [<span class="dt">String</span>]</span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true" tabindex="-1"></a>getAllOptions <span class="ot">=</span> runAp_ (\o <span class="ot">-&gt;</span> [optionName o])</span></code></pre></div>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> getAllOptions parseTwo</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>[<span class="st">&quot;string-opt&quot;</span>, <span class="st">&quot;int-opt&quot;</span>]</span></code></pre></div>
<p>Remember that <code>Applicative</code> is like a “monoid” for shapes, so <code>Ap</code> gives you a free “monoid” on your custom shape: you can now create list-like “sequences” of your shape that merge via concatenation through <code>&lt;*&gt;</code>. You can also know that <code>fmap</code> on <code>Ap Option</code> will not add or remove options: it’ll leave the actual options unchanged. It’ll also not affect what options would fail or succeed to parse.</p>
<p>You could also write a parser combinator library this way too! Remember that the “shape” of a parser combinator <code>Parser</code> is the string that it consumes or rejects. The single element might be a parser that consumes and rejects a single <code>Char</code>:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">Single</span> a <span class="ot">=</span> <span class="dt">Single</span> {<span class="ot"> satisfies ::</span> <span class="dt">Char</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a }</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">deriving</span> <span class="dt">Functor</span></span></code></pre></div>
<p>The “shape” is whether or not it consumes or rejects a char. Notice that <code>fmap</code> for this cannot <em>change</em> whether or not a char is rejected or accepted: it can only change the Haskell result <code>a</code> value. <code>fmap</code> can’t flip the <code>Maybe</code> into a <code>Just</code> or <code>Nothing</code>.</p>
<p>Now we can create a full monadic parser combinator library by using <a href="https://hackage.haskell.org/package/free/docs/Control-Monad-Free.html"><code>Free</code> from the <em>free</em> library</a>:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Parser</span> <span class="ot">=</span> <span class="dt">Free</span> <span class="dt">Single</span></span></code></pre></div>
<p>Again, we specified the shape we wanted, and now we have a Monad for that shape! For more information on using this, I’ve written <a href="https://blog.jle.im/entry/free-alternative-regexp.html">a blog post in the past</a>. <code>Ap</code> gives you a free “monoid” on your shapes, but in a way <code>Free</code> gives you a “tree” for your shapes, where the sequence of shapes depends on which way you go down their results. And, again, <code>fmap</code> won’t ever change what would or would not be parsed.</p>
<p>How do we know what free structure to pick? Well, we ask questions about what we want to be able to do with our shape. If we want to inspect the shape without knowing the results, we’d use the free Applicative or free Alternative. As discussed earlier, using the free Applicative means that our final result must require producing all of the input results, but using the free Alternative means it doesn’t. If we wanted to allow the shape to depend on the results (like for a context-sensitive parser), we’d use the free Monad. Understanding the concept of the “shape” makes this choice very intuitive.</p>
<h2 id="the-shape-of-you">The Shape of You</h2>
<p>Next time you encounter a new Functor, I hope these insights can be useful. Ask yourself, what is <code>fmap</code> preserving? What is <code>fmap</code> changing? And from there, its secrets will unfold before you. <a href="https://en.wikipedia.org/wiki/Noether%27s_theorem">Emmy Noether</a> would be proud.</p>
<h2 id="special-thanks">Special Thanks</h2>
<p>I am very humbled to be supported by an amazing community, who make it possible for me to devote time to researching and writing these posts. Very special thanks to my supporter at the “Amazing” level on <a href="https://www.patreon.com/justinle/overview">patreon</a>, Josh Vera! :)</p>
<section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes">
<hr />
<ol>
<li id="fn1"><p>There are <em>some</em> exceptions, especially degenerate cases like <code>Writer ()</code> aka <code>Identity</code> which add no meaningful structure. So for these this mental model isn’t that useful.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p>Incidentally, <code>Set.map</code> <em>does</em> preserve one thing: non-emptiness. You can’t <code>Set.map</code> an empty set into a non-empty one and vice versa. So, maybe if we recontextualized <code>Set</code> as a “search for at least one result” <code>Functor</code> or <code>Monad</code> where you could only ever observe a single value, <code>Set.map</code> would work for Ord-restricted versions of those abstractions, assuming lawful <code>Ord</code> instances.<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3"><p>That is, if we take the sum consideration of all input-output with the outside world, independent of what happens within the Haskell results, we can say the combination of effects is deterministic.<a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section></div><footer><hr><div class="copy-content"><p>Hi, thanks for reading! You can reach me via email at <a href="mailto:justin@jle.im" class="email">justin@jle.im</a>, or at twitter at <a href="https://twitter.com/mstk">@mstk</a>! This post and all others are published under the <a href="https://creativecommons.org/licenses/by-nc-nd/3.0/">CC-BY-NC-ND 3.0</a> license. Corrections and edits via pull request are welcome and encouraged at <a href="https://github.com/mstksg/inCode">the source repository</a>.</p>
<p>If you feel inclined, or this post was particularly helpful for you, why not consider <a href="https://www.patreon.com/justinle/overview">supporting me on Patreon</a>, or a <a href="bitcoin:3D7rmAYgbDnp4gp4rf22THsGt74fNucPDU">BTC donation</a>? :)</p></div><div class="clear"></div><ul class="entry-series"></ul><ul class="tag-list"><li><a href="https://blog.jle.im/entries/tagged/functional-programming.html" class="tag-a-tag">#functional programming</a></li><li><a href="https://blog.jle.im/entries/tagged/functor-combinators.html" class="tag-a-tag">#functor combinators</a></li><li><a href="https://blog.jle.im/entries/tagged/functors.html" class="tag-a-tag">#functors</a></li><li><a href="https://blog.jle.im/entries/tagged/haskell.html" class="tag-a-tag">#haskell</a></li><li><a href="https://blog.jle.im/entries/tagged/interpreters.html" class="tag-a-tag">#interpreters</a></li><li><a href="https://blog.jle.im/entries/tagged/monads.html" class="tag-a-tag">#monads</a></li><li><a href="https://blog.jle.im/entries/category/@haskell.html" class="tag-a-category">@HASKELL</a></li></ul><aside class="social-buttons"><div class="addthis_toolbox addthis_default_style addthis-buttons"><a class="addthis_button_facebook_like" fb:like:layout="button_count"></a><a class="addthis_button_tweet"></a><a class="addthis_button_google_plusone" g:plusone:size="medium"></a><a class="addthis_counter addthis_pill_style"></a></div><div class="custom-social-buttons"><div class="custom-social-button"><a href="https://www.reddit.com/submit" onclick="window.location = &#39;https://www.reddit.com/submit?url=&#39;+ encodeURIComponent(window.location); return false"><img src="https://www.reddit.com/static/spreddit7.gif" alt="submit to reddit"></a></div></div></aside><nav class="next-prev-links"><ul><li class="prev-entry-link">&larr; <a href="https://blog.jle.im/entry/physics-math-heritage.html">My Physics and Math Heritage</a> (Previous)</li><li class="next-entry-link">(Next) <a href="https://blog.jle.im/entry/advent-of-code-2024.html">Advent of Code 2024: Haskell Solution Reflections for all 25 Days</a> &rarr;</li></ul></nav></footer></article><div class="post-entry"><div class="tile"><div id="disqus_thread"></div><script type="text/javascript">var disqus_config = function () {
    this.page.url = 'https://blog.jle.im/entry/functors-to-monads-a-story-of-shapes.html';
    this.page.identifier = 'story-of-shapes';
};
(function() {
    var d = document, s = d.createElement('script');
    s.src = '//incode.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
})();
</script><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a><br></noscript><a href="http://disqus.com" class="dsq-brlink">Comments powered by <span class="logo-disqus">Disqus</span></a></div></div></div></div></div><div id="footer-container"><div id="footer-content"><div class="tile"><div class="footer-copyright">&copy; 2020 Justin Le <span class="license-link">(<a href="https://creativecommons.org/licenses/by-nc-nd/3.0/" class="license">CC-BY-NC-ND 3.0</a>)</span></div><div class="footer-follow social-follows"><ul class="social-follows-list"><li><ul class="social-follows-list-social"><li><a class="social-follow-twitter" title="Follow me on Twitter!" href="https://twitter.com/intent/user?user_id=mstk" onclick="window.open(
  &#39;http://twitter.com/intent/user?user_id=907281&#39;,
  &#39;facebook-share-dialog&#39;,
  &#39;width=550,height=520&#39;);
return false;
">Twitter</a></li><li><a class="social-follow-github" title="Fork me on Github!" href="https://github.com/mstksg">Github</a></li><li><a class="social-follow-twitch" title="Watch me on Twitch!" href="https://www.twitch.tv/justin_l">Twitch</a></li><li><a class="social-follow-patreon" title="Support me on Patreon!" href="https://www.patreon.com/justinle/overview">Patreon</a></li><li><a class="social-follow-gplus" title="Add me on Google+!" href="https://plus.google.com/+JustinLe">Google+</a></li><li><a class="social-follow-keybase" title="Track me on Keybase!" href="https://keybase.io/mstksg">Keybase</a></li><li><a class="social-follow-linkedin" title="Connect with me on LinkedIn!" href="https://linkedin.com/in/lejustin">LinkedIn</a></li><li><a class="social-follow-bitcoin" title="Donate via bitcoin!" href="bitcoin:3D7rmAYgbDnp4gp4rf22THsGt74fNucPDU">Bitcoin</a></li></ul></li><li><ul class="social-follows-list-site"><li><a class="social-follow-rss" title="Subscribe to my RSS Feed!" href="http://feeds.feedburner.com/incodeblog">RSS</a></li><li><a class="social-follow-email" title="Subscribe to the mailing list!" href="https://feedburner.google.com/fb/a/mailverify?loc=en_US&amp;uri=incodeblog">Mailing list</a></li></ul></li></ul></div></div></div></div></body></html>