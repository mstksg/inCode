<!DOCTYPE HTML>
<html><head><title>The Const Applicative and Monoids · in Code</title><meta name="description" content="Weblog of Justin Le, covering various adventures in programming and explorations in the worlds of computation physics, and knowledge.
"><meta http-equiv="Content-Type" content="text/html;charset=utf-8"><meta name="viewport" content="width=device-width,initial-scale=1.0"><meta name="flattr:id" content="3p9jqr"><meta property="og:site_name" content="in Code"><meta property="og:description" content="The Applicative typeclass has a somewhat infamous reputation for having opaque laws. There are a lot of great alternative rephrasing of these laws, from many different approaches. For this post, however, I want to talk about Applicative in terms of one of my favorites: Const."><meta property="og:type" content="article"><meta property="og:title" content="The Const Applicative and Monoids"><meta property="og:image" content="https://blog.jle.im/img/site_logo.jpg"><meta property="og:locale" content="en_US"><meta property="og:url" content="https://blog.jle.im/entry/const-applicative-and-monoids.html"><meta name="twitter:card" content="summary"><meta name="twitter:creator:id" content="mstk"><link rel="author" href="https://plus.google.com/107705320197444500140"><link rel="alternate" type="application/rss+xml" title="in Code (RSS Feed)" href="http://feeds.feedburner.com/incodeblog"><link rel="canonical" href="https://blog.jle.im/entry/const-applicative-and-monoids.html"><link href="https://blog.jle.im/favicon.ico" rel="shortcut icon"><link href="https://blog.jle.im/css/toast.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/font.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/main.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/page/entry.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/pygments.css" rel="stylesheet" type="text/css"><script type="text/javascript">var page_data = {};
var disqus_shortname='incode';
</script><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-443711-8', 'jle.im');
ga('send', 'pageview');
</script><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script id="MathJax-script" async="" src="https://cdn.jsdelivr.net/npm/mathjax@3.0.1/es5/tex-mml-chtml.js"></script><script type="text/javascript" src="//ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script><script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5234d67a6b68dcd4"></script><script type="text/javascript" src="https://blog.jle.im/js/page/entry_toc.js"></script><script type="text/javascript" src="https://blog.jle.im/js/disqus_count.js"></script><script type="text/javascript" src="https://blog.jle.im/js/social.js"></script><script type="text/javascript" src="https://blog.jle.im/js/jquery/jquery.toc.js"></script><script type="text/javascript" src="https://blog.jle.im/purescript/entry.js"></script></head><body><div id="fb-root"><script>(function(d, s, id) {
 var js, fjs = d.getElementsByTagName(s)[0];
 if (d.getElementById(id)) return;
 js = d.createElement(s); js.id = id;
 js.src = "//connect.facebook.net/en_US/all.js#xfbml=1&appId=641852699171929";
 fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));
</script></div><div id="header-container"><div id="navbar-container" class="tile"><nav id="navbar-content"><div class="nav-info"><h1 class="site-title"><a href="https://blog.jle.im/" class="nav-title">in Code</a></h1><span class="nav-author">Justin Le</span></div><ul class="nav-links"><li><a href="https://blog.jle.im/">home</a></li><li><a href="https://blog.jle.im/entries.html">archives</a></li><li><a href="https://cv.jle.im">cv</a></li><div class="clear"></div></ul></nav></div><div id="header-content"></div></div><div id="body-container" class="container"><div id="main-container" class="grid"><div class="entry-section unit span-grid" role="main"><article class="tile article"><header><h1 id="title">The Const Applicative and Monoids</h1><p class="entry-info">by <a class="author" href="https://blog.jle.im/">Justin Le</a><span class="info-separator"> &diams; </span><time datetime="2018-05-08T12:20:16Z" pubdate="" class="pubdate">Tuesday May 8, 2018</time></p><p><span class="source-info"><a class="source-link" href="https://github.com/mstksg/inCode/tree/master/copy/entries/const.md">Source</a><span class="info-separator"> &diams; </span><a class="source-link" href="https://github.com/mstksg/inCode/tree/gh-pages/entry/const-applicative-and-monoids.md">Markdown</a><span class="info-separator"> &diams; </span><a class="source-link" href="https://blog.jle.im/entry/const-applicative-and-monoids.tex">LaTeX</a><span class="info-separator"> &diams; </span></span>Posted in <a href="https://blog.jle.im/entries/category/@haskell.html" class="tag-a-category" title="Functional, pure, non-strict, statically and strongly typed, natively
compiled...really just the king of great languages.
">Haskell</a><span class="info-separator"> &diams; </span><a class="comment-link" href="#disqus_thread">Comments</a></p></header><hr><aside class="contents-container"><h5 id="contents-header">Contents</h5><div id="toc"></div></aside><div class="main-content copy-content"><p>The Applicative typeclass has a somewhat infamous reputation for having opaque laws. There are a lot of great <a href="https://wiki.haskell.org/Typeclassopedia#Alternative_formulation">alternative</a> <a href="https://www.reddit.com/r/haskell/comments/2lompe/where_do_the_applicative_laws_come_from/clws90h/">rephrasing</a> of these laws, from many different approaches. For this post, however, I want to talk about Applicative in terms of one of my favorites: <code>Const</code>.</p>
<h2 id="const">Const</h2>
<p>The <code>Const</code> data type from the standard libraries is relatively simple as far as newtypes go:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">Const</span> w a <span class="ot">=</span> <span class="dt">Const</span> {<span class="ot"> getConst ::</span> w }</span></code></pre></div>
<p>However, let’s look at a less polymorphic version, <code>IntConst</code>, which is essentially <code>Const Int</code>:<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a></p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">IntConst</span> a <span class="ot">=</span> <span class="dt">IntConst</span> {<span class="ot"> getIntConst ::</span> <span class="dt">Int</span> }</span></code></pre></div>
<p>For a <code>IntConst a</code>, the <code>a</code> is a <em>phantom</em> type parameter. This means that there are not necessarily any values of type <code>a</code> in a value of type <code>IntConst a</code>. In modern GHC with PolyKinds, this means that <code>a</code> might not even be a type that can have values — you might have, say, a value of type <code>IntConst Maybe</code>, or a value of type <code>IntConst Monad</code>, and GHC would be perfectly happy.</p>
<p><code>IntConst</code> admits a straightforward <code>Functor</code> instance that is a lot like the <code>Functor</code> instance for <code>Proxy</code> and <code>Either e</code>:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Functor</span> <span class="dt">IntConst</span> <span class="kw">where</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>    <span class="fu">fmap</span> _ (<span class="dt">IntConst</span> w) <span class="ot">=</span> <span class="dt">IntConst</span> w</span></code></pre></div>
<p>In fact, sometimes I like to refer to <code>Const w a</code> as “an <code>Either w a</code> with only <code>Left</code>, no <code>Right</code>”. The <code>Functor</code> instance reflects this pretty well:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Functor</span> (<span class="dt">Either</span> e) <span class="kw">where</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>    <span class="fu">fmap</span> _ (<span class="dt">Left</span> e)  <span class="ot">=</span> <span class="dt">Left</span> e        <span class="co">-- just like &#39;Const&#39;</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>    <span class="fu">fmap</span> f (<span class="dt">Right</span> x) <span class="ot">=</span> <span class="dt">Right</span> (f x)   <span class="co">-- who cares</span></span></code></pre></div>
<p>However, the <code>Applicative</code> instance of <code>IntConst</code> is one of my favorite things about it. Let’s try to imagine how we’d write it.</p>
<p>First of all, let’s look at the types of the functions we need:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="fu">pure</span><span class="ot">  ::</span> a <span class="ot">-&gt;</span> <span class="dt">IntConst</span> a</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="ot">(&lt;*&gt;) ::</span> <span class="dt">IntConst</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">IntConst</span> a <span class="ot">-&gt;</span> <span class="dt">IntConst</span> b</span></code></pre></div>
<p>Now, remember that <code>IntConst</code>’s type parameter is phantom, so we don’t have any actual values of type <code>a -&gt; b</code>, <code>a</code>, or <code>b</code> involved. An <code>IntConst a</code>, for any <code>a</code>, is really just an <code>Int</code>. Essentially, once we strip out the newtype wrapper shenanigans (replacing <code>IntConst a</code> with its contents, <code>Int</code>), we just get:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="fu">pure</span><span class="ot">  ::</span> a <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="ot">(&lt;*&gt;) ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span></code></pre></div>
<p>We now have a few options on how to implement these. Let’s try one and see if it works:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Applicative</span> <span class="dt">IntConst</span> <span class="kw">where</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>    <span class="fu">pure</span> _                    <span class="ot">=</span> <span class="dt">IntConst</span> <span class="dv">42</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">IntConst</span> x <span class="op">&lt;*&gt;</span> <span class="dt">IntConst</span> _ <span class="ot">=</span> <span class="dt">IntConst</span> x</span></code></pre></div>
<p>A perfectly reasonable implementation, right? Our Applicative instance type-checks. And if it type-checks, ship it! Time to call it a day and go home, right?</p>
<p>Not quite.</p>
<h2 id="applicative">Applicative</h2>
<p>Let’s take a detour through the essense of the <code>Applicative</code> typeclass. Or, at least, one particular interpretation of it that makes sense for instances that represent some sort of effectful action.</p>
<p>The essence of Applicative, to me, is a way to combine values representing some sort of “effect” in a sane way. In Haskell, we often talk about data types as representing/describing some sort of effects. Applicative lets us combine (“sequence”) them in a way that allows us to write powerful generic combinators.</p>
<p>One way to look at it is as a generalization of <code>fmap</code> to taking two parameters:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="ot">fmap1 ::</span> (a <span class="ot">-&gt;</span> b     ) <span class="ot">-&gt;</span> <span class="dt">F</span> a <span class="ot">-&gt;</span> <span class="dt">F</span> b</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="ot">fmap2 ::</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> <span class="dt">F</span> a <span class="ot">-&gt;</span> <span class="dt">F</span> b <span class="ot">-&gt;</span> <span class="dt">F</span> c</span></code></pre></div>
<p><code>fmap</code> alone lets you take a single <code>F a</code> and transform it into an <code>F b</code>. <code>fmap2</code> (or, <code>liftA2</code> in the standard libraries) is a way of taking <em>two</em> <code>F</code>-values and squishing them into one fat <code>F</code> value.</p>
<p>It does this by letting us talk about combining the <em>effects</em> of an <code>F a</code>, independent of the <code>a</code> (the result). For example, <code>sequenceA_</code>:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="ot">sequenceA_ ::</span> <span class="dt">Applicative</span> f <span class="ot">=&gt;</span> [f a] <span class="ot">-&gt;</span> f ()</span></code></pre></div>
<p>Basically will take a list of <code>f a</code>s, and return a new <code>f ()</code> that has <em>all</em> of the effects of the <code>f a</code>s in the list.</p>
<p>To do this sensibly, we need also to talk about a “no-op” value:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="fu">pure</span><span class="ot"> ::</span> a <span class="ot">-&gt;</span> <span class="dt">F</span> a</span></code></pre></div>
<p><code>pure x</code> is intended to be a no-op with “no effects”.</p>
<p>With this, we can say something about the behavior of <code>&lt;*&gt;</code> or <code>fmap2</code> or <code>liftA2</code>. Namely:</p>
<ol type="1">
<li><p>The effects of <code>f &lt;*&gt; x</code> must have the effects of <code>f</code> once <em>and</em> the effects of <code>x</code> once – no more, and no less.</p></li>
<li><p><code>pure</code>’s results must have no “effects”, and so if used with <code>&lt;*&gt;</code>, introduces no extra effects:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="fu">pure</span> f <span class="op">&lt;*&gt;</span> x <span class="ot">=</span> <span class="fu">fmap</span> f x</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>f <span class="op">&lt;*&gt;</span> <span class="fu">pure</span> x <span class="ot">=</span> <span class="fu">fmap</span> (<span class="op">$</span> x) f</span></code></pre></div>
<p>(Remember that <code>fmap</code> is not allowed to affect “effects” in any way)</p></li>
<li><p>Combining effects must be associative.</p></li>
</ol>
<p>With this guarantee, we can write <code>sequenceA_</code> in a polymorphic way:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="ot">sequenceA_ ::</span> <span class="dt">Applicative</span> f <span class="ot">=&gt;</span> [f a] <span class="ot">-&gt;</span> f ()</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>sequenceA_ []     <span class="ot">=</span> <span class="fu">pure</span> ()</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>sequenceA_ (x<span class="op">:</span>xs) <span class="ot">=</span> x <span class="op">*&gt;</span> sequenceA_ xs</span></code></pre></div>
<p>And we can say with certainty that:</p>
<ol type="1">
<li>Each “effect” of each value in the <code>[f a]</code> will be executed <em>exactly</em> once: no more, and no less.</li>
<li><code>sequenceA_</code> of an empty list has no effects.</li>
</ol>
<p>This makes <code>sequenceA_</code> a <em>useful</em> combinator. The fact that we can talk about how <code>sequenceA_</code> behaves for all Applicative instances makes it something that is <em>worth</em> defining. If you use <code>sequenceA_</code> for your type, you can do it knowing that it will behave in a well-defined way: it <em>must</em> execute every action once (no more, and no less), and sequencing an empty list <em>must</em> have no effects.</p>
<p>If it weren’t for those Applicative laws and expectations, <code>sequenceA_</code> would be a pretty useless function. It might completely ignore all effects, or it might perform some of the effects multiple times…who knows! The fact that we have Applicative laws and expectations means we can look at the implementation of <code>sequenceA_</code> and know with certainty (and make bold claims about) how <code>sequenceA_</code> combines effects.</p>
<p>For example, we can always make the program substitution:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>sequenceA_ xs <span class="op">*&gt;</span> sequenceA_ ys</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a><span class="co">-- can be substituted with</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>sequenceA_ (xs <span class="op">++</span> ys)</span></code></pre></div>
<p>If <code>sequenceA_</code> combines all the effects in <code>xs</code> once, and <code>sequenceA_</code> combines all the effects in <code>ys</code> once, and <code>*&gt;</code> combines the effects of either side once, then this is a <em>legal substitution</em> that doesn’t change what your program does.</p>
<p>However, if the <code>Applicative</code> instance doesn’t have any rules, we can’t do this. For example, the original form uses <code>pure ()</code> <em>twice</em> (once for each list’s <code>[]</code> end), and the second form uses <code>pure ()</code> <em>once</em> (since there’s only one list). If <code>pure ()</code> was allowed to have effects…then the first version would have more effects than the second.</p>
<h2 id="back-to-const">Back to Const</h2>
<p>With this new information in mind, let’s revisit our instance for <code>IntConst</code>.</p>
<p>In order for <code>IntConst</code>’s Applicative instance to behave meaningfully, and in order to be able to match with user expectations of <code>Applicative</code> instance, you need to make sure it follows the basic principles I mentioned earlier (the effects of <code>f &lt;*&gt; x</code> has the effects of <code>f</code> and <code>x</code> exactly once, and the properties about <code>pure</code>).</p>
<p>We haven’t defined what the “effects” of <code>IntConst</code> are yet, but let’s at least look at if our <code>pure</code> behaves sensibly with <code>&lt;*&gt;</code>. Namely, let’s check <code>pure f &lt;*&gt; x = fmap f x</code>.</p>
<p>Note that this is a meaningful starting point because <code>fmap</code>’s definition is <em>fixed</em>. For any type, there is <em>at most one</em> possible <code>fmap</code> that is legal and lawful — and in Haskell, we only have to check that <code>fmap id</code> leaves all inputs unchanged.<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a></p>
<p>With that out of the way, let’s check our <code>pure f &lt;*&gt; x = fmap f x</code> law with a simple example for <code>x</code>…say, <code>IntConst 5</code>. On the left hand side, we have:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- pure _                     = IntConst 42</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a><span class="co">-- IntConst x &lt;*&gt; InstConst _ = IntConst x</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a><span class="fu">pure</span> f <span class="op">&lt;*&gt;</span> <span class="dt">IntConst</span> <span class="dv">5</span> <span class="ot">=</span> <span class="dt">IntConst</span> <span class="dv">42</span> <span class="op">&lt;*&gt;</span> <span class="dt">IntConst</span> <span class="dv">5</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>                      <span class="ot">=</span> <span class="dt">IntConst</span> <span class="dv">42</span></span></code></pre></div>
<p>On the right hand side, we have:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- fmap f (IntConst x) = IntConst x</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a><span class="fu">fmap</span> f (<span class="dt">IntConst</span> <span class="dv">5</span>) <span class="ot">=</span> <span class="dt">IntConst</span> <span class="dv">5</span></span></code></pre></div>
<p>It is clear that this definition does not work, since <code>IntConst 42</code> is not the same as <code>IntConst 5</code>.</p>
<p>What if we defined:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Applicative</span> <span class="dt">IntConst</span> <span class="kw">where</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>    <span class="fu">pure</span> _                    <span class="ot">=</span> <span class="dt">IntConst</span> <span class="dv">42</span></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">IntConst</span> _ <span class="op">&lt;*&gt;</span> <span class="dt">IntConst</span> y <span class="ot">=</span> <span class="dt">IntConst</span> y</span></code></pre></div>
<p>Is that any better? Well, <code>pure f &lt;*&gt; IntConst 5</code> is now equal to <code>IntConst 5</code>, so that works out. But what about <code>f &lt;*&gt; pure x = fmap ($ x) f</code>? Let’s use <code>IntConst 3</code> as our <code>f</code>. On the left hand side:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- pure _                    = IntConst 42</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a><span class="co">-- IntConst _ &lt;*&gt; IntConst y = IntConst y</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a><span class="dt">IntConst</span> <span class="dv">3</span> <span class="op">&lt;*&gt;</span> <span class="fu">pure</span> x <span class="ot">=</span> <span class="dt">IntConst</span> <span class="dv">3</span> <span class="op">&lt;*&gt;</span> <span class="dt">IntConst</span> <span class="dv">42</span></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>                      <span class="ot">=</span> <span class="dt">IntConst</span> <span class="dv">42</span></span></code></pre></div>
<p>And on the right hand side:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- fmap f (IntConst x) = IntConst x</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a><span class="fu">fmap</span> (<span class="op">$</span> x) (<span class="dt">IntConst</span> <span class="dv">3</span>) <span class="ot">=</span> <span class="dt">IntConst</span> <span class="dv">3</span></span></code></pre></div>
<p>Ah, that’s wrong too, then.</p>
<p>At this point it might seem like I am facetiously moving very slowly to an answer that has to use <em>both</em> inputs. After all, my earlier statement claimed that <code>f &lt;*&gt; x</code> has to use both the effects of <code>f</code> and the effects of <code>x</code>, each exactly once. Because we didn’t really know what the “effects” of <code>IntConst</code> are, we don’t know exactly “how” to combine them…but we can probably guess it has to use both <code>Int</code>s. So, with that in mind, let’s try another definition:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Applicative</span> <span class="dt">IntConst</span> <span class="kw">where</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>    <span class="fu">pure</span> _                    <span class="ot">=</span> <span class="dt">IntConst</span> <span class="dv">42</span></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">IntConst</span> x <span class="op">&lt;*&gt;</span> <span class="dt">IntConst</span> y <span class="ot">=</span> <span class="dt">IntConst</span> (x <span class="op">+</span> y)</span></code></pre></div>
<p>Alright, now we use both <code>x</code> and <code>y</code> in the result. Let’s see again if this follows our expectations about <code>pure</code> – if <code>pure f &lt;*&gt; x</code> is the same as <code>fmap f x</code>. Using <code>IntConst 5</code> again as <code>x</code>:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- pure _                     = IntConst 42</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a><span class="co">-- IntConst x &lt;*&gt; InstConst y = IntConst (x + y)</span></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a><span class="fu">pure</span> f <span class="op">&lt;*&gt;</span> <span class="dt">IntConst</span> <span class="dv">5</span> <span class="ot">=</span> <span class="dt">IntConst</span> <span class="dv">42</span> <span class="op">&lt;*&gt;</span> <span class="dt">IntConst</span> <span class="dv">5</span></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a>                      <span class="ot">=</span> <span class="dt">IntConst</span> <span class="dv">47</span></span></code></pre></div>
<p>On the right hand side, we have:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- fmap f (IntConst x) = IntConst x</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a><span class="fu">fmap</span> f (<span class="dt">IntConst</span> <span class="dv">5</span>) <span class="ot">=</span> <span class="dt">IntConst</span> <span class="dv">5</span></span></code></pre></div>
<p>Another dead end. It looks like it isn’t just enough that we <em>use</em> both <code>Int</code>s…we have to use them in a way such that the <code>Int</code> we use as the result of <code>pure f</code> as to be an <em>identity</em> to our operation. Whatever <code>Int</code> is returned by <code>pure f</code> has to leave any other <code>Int</code> unchanged when used with <code>&lt;*&gt;</code>.</p>
<p>Thinking back, we remember that if our operation is <code>+</code>, we can use <code>0</code>, since <code>0 + x = x</code> and <code>x + 0 = x</code>, for all <code>x</code>. Luckily, our operation <code>x + y</code> is one that even <em>has</em> an identity. If we had chosen another operation (like <code>x + 2 * y</code>), we wouldn’t be so lucky. Finally:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Applicative</span> <span class="dt">IntConst</span> <span class="kw">where</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>    <span class="fu">pure</span> _                    <span class="ot">=</span> <span class="dt">IntConst</span> <span class="dv">0</span></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">IntConst</span> x <span class="op">&lt;*&gt;</span> <span class="dt">IntConst</span> y <span class="ot">=</span> <span class="dt">IntConst</span> (x <span class="op">+</span> y)</span></code></pre></div>
<p>At last this feels like something that should make sense. And, does it? Testing out, again, <code>pure f &lt;*&gt; x = fmap f x</code>:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- pure _                     = IntConst 0</span></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a><span class="co">-- IntConst x &lt;*&gt; InstConst y = IntConst (x + y)</span></span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a><span class="fu">pure</span> f <span class="op">&lt;*&gt;</span> <span class="dt">IntConst</span> <span class="dv">5</span> <span class="ot">=</span> <span class="dt">IntConst</span> <span class="dv">0</span> <span class="op">&lt;*&gt;</span> <span class="dt">IntConst</span> <span class="dv">5</span></span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a>                      <span class="ot">=</span> <span class="dt">IntConst</span> <span class="dv">5</span></span></code></pre></div>
<div class="sourceCode" id="cb24"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- fmap f (IntConst x) = IntConst x</span></span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a><span class="fu">fmap</span> f (<span class="dt">IntConst</span> <span class="dv">5</span>) <span class="ot">=</span> <span class="dt">IntConst</span> <span class="dv">5</span></span></code></pre></div>
<p>Perfect! And, checking now <code>f &lt;*&gt; pure x = fmap ($ x) f</code>:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- pure _                    = IntConst 0</span></span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a><span class="co">-- IntConst x &lt;*&gt; IntConst y = IntConst (x + y)</span></span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a><span class="dt">IntConst</span> <span class="dv">3</span> <span class="op">&lt;*&gt;</span> <span class="fu">pure</span> x <span class="ot">=</span> <span class="dt">IntConst</span> <span class="dv">3</span> <span class="op">&lt;*&gt;</span> <span class="dt">IntConst</span> <span class="dv">0</span></span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a>                      <span class="ot">=</span> <span class="dt">IntConst</span> <span class="dv">3</span></span></code></pre></div>
<div class="sourceCode" id="cb26"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- fmap f (IntConst x) = IntConst x</span></span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a><span class="fu">fmap</span> (<span class="op">$</span> x) (<span class="dt">IntConst</span> <span class="dv">3</span>) <span class="ot">=</span> <span class="dt">IntConst</span> <span class="dv">3</span></span></code></pre></div>
<p>This definition works for both<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a>!</p>
<h3 id="the-effect-of-const">The Effect of Const</h3>
<p>With our definition picked out, what do we think <code>sequenceA_</code> does for <code>IntConst</code>?</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="ot">sequenceA_ ::</span> [<span class="dt">IntConst</span> a] <span class="ot">-&gt;</span> <span class="dt">IntConst</span> ()</span></code></pre></div>
<p>Well, if each application of <code>&lt;*&gt;</code> adds together the <code>Int</code> in the <code>IntConst a</code>, and <code>sequenceA_</code> uses <code>&lt;*&gt;</code> once per every <code>IntConst a</code>…we can guess that <code>sequenceA_</code> for <code>IntConst</code> is just <code>sum</code>!</p>
<p>This might be more clear if we strip away the newtype wrappers (replacing <code>IntConst a</code> with its contents, <code>Int</code>):</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="ot">sequenceA_ ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">Int</span></span></code></pre></div>
<p>From this definition of <code>&lt;*&gt;</code>, we can form an idea of what the effects of the <code>IntConst</code> Applicative are: they <em>add</em> to some accumulator environment! And <code>pure _ = IntConst 0</code> means that <code>pure _</code> adds zero to our accumulator – it leaves our accumulator <em>unchanged</em>, and so effectively has no effect.</p>
<p>That’s why <code>sequenceA_</code> is <code>sum</code> – it sequences every effect of the <code>IntConst</code>, which means that it sequences all of those “add to the accumulator” effects one after the other.</p>
<h3 id="alternative-pictures">Alternative Pictures</h3>
<p>Note that the requirements we gave for the <code>Applicative</code> instance doesn’t necessarily imply that the one we have is the only instance. For example, the following instance is also valid:</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Applicative</span> <span class="dt">IntConst</span> <span class="kw">where</span></span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a>    <span class="fu">pure</span> _                    <span class="ot">=</span> <span class="dt">IntConst</span> <span class="dv">1</span></span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">IntConst</span> x <span class="op">&lt;*&gt;</span> <span class="dt">IntConst</span> y <span class="ot">=</span> <span class="dt">IntConst</span> (x <span class="op">*</span> y)</span></code></pre></div>
<p>If our “combining” action is <code>*</code>, then <code>pure</code> has to be an identity. So, <code>pure _ = IntConst 1</code> works fine as an identity here, since <code>1 * x = x</code> and <code>x * 1 = x</code>, for all <code>x</code>.</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- pure _                     = IntConst 1</span></span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a><span class="co">-- IntConst x &lt;*&gt; InstConst y = IntConst (x * y)</span></span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a><span class="fu">pure</span> f <span class="op">&lt;*&gt;</span> <span class="dt">IntConst</span> <span class="dv">5</span> <span class="ot">=</span> <span class="dt">IntConst</span> <span class="dv">1</span> <span class="op">&lt;*&gt;</span> <span class="dt">IntConst</span> <span class="dv">5</span></span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true" tabindex="-1"></a>                      <span class="ot">=</span> <span class="dt">IntConst</span> <span class="dv">5</span></span></code></pre></div>
<div class="sourceCode" id="cb31"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- fmap f (IntConst x) = IntConst x</span></span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a><span class="fu">fmap</span> f (<span class="dt">IntConst</span> <span class="dv">5</span>) <span class="ot">=</span> <span class="dt">IntConst</span> <span class="dv">5</span></span></code></pre></div>
<h3 id="a-general-alternative">A General Alternative</h3>
<p>It looks like the Applicative for <code>IntConst</code> has to follow some pattern:</p>
<ul>
<li><code>&lt;*&gt;</code> has to combine the <code>Int</code>s inside somehow using some operation <code>f</code>. (<code>f</code> also has to be associative, which is a point we didn’t touch on specifically)</li>
<li>The <code>Int</code> that <code>pure</code> returns has to be an <em>identity</em> to <code>f</code>.</li>
</ul>
<p>Sound familiar?</p>
<p>This is all satisfied if and only if <code>f</code> and the result of <code>pure</code> form a <strong><a href="https://www.schoolofhaskell.com/user/mgsloan/monoids-tour">monoid</a></strong> on the integers!</p>
<p>There is a very fundamental link here: the <code>Applicative</code> laws for <code>IntConst</code> are satisfied if and only if <code>&lt;*&gt;</code> acts monoidally on the contents, with <code>pure</code>’s result as the identity of that monoid.</p>
<p>(For those unfamiliar with monoids, a <code>Monoid</code> in Haskell is a type <code>w</code> that has an associative operation <code>(&lt;&gt;) :: w -&gt; w -&gt; w</code> along with an identity <code>mempty :: w</code> that leaves values unchanged when used with <code>&lt;&gt;</code>.)</p>
<p>So, <em>any</em> <code>f</code> and <code>pure</code> works, as long as they form a <em>monoid</em>. And any monoid in the Integers is a valid <code>Applicative</code> instance for <code>IntConst</code>!</p>
<h2 id="general-const">General Const</h2>
<p>Let’s revisit our original <code>Const</code> type:</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">Const</span> w a <span class="ot">=</span> <span class="dt">Const</span> {<span class="ot"> getConst ::</span> w }</span></code></pre></div>
<p>The <code>Functor</code> instance is unique, so there isn’t any leeway we have (<code>fmap</code> is always fixed for every type):</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Functor</span> (<span class="dt">Const</span> w) <span class="kw">where</span></span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a>    <span class="fu">fmap</span> _ (<span class="dt">Const</span> w) <span class="ot">=</span> <span class="dt">Const</span> w</span></code></pre></div>
<p>This is the only definition that preserves <code>fmap id = id</code>.</p>
<p>Now we can actually write an <code>Applicative</code> instance for <code>Const w</code>…as long as we provide a <code>Monoid</code> to use with <code>w</code><a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a>!</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Monoid</span> w <span class="ot">=&gt;</span> <span class="dt">Applicative</span> (<span class="dt">Const</span> w) <span class="kw">where</span></span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a>    <span class="fu">pure</span> _              <span class="ot">=</span> <span class="dt">Const</span> <span class="fu">mempty</span></span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Const</span> x <span class="op">&lt;*&gt;</span> <span class="dt">Const</span> y <span class="ot">=</span> <span class="dt">Const</span> (x <span class="op">&lt;&gt;</span> y)</span></code></pre></div>
<p>Like how we said, as long as the “combining” function for <code>x</code> and <code>y</code> have the identity that is given by the result of <code>pure</code>, this is a valid Applicative.</p>
<p>The “effects” of this Applicative instance are “accumulate to some accumulator”. If this sounds familiar, this is because this is exactly the effect of the <code>Writer w</code> Applicative instance. <code>Const w</code> and <code>Writer w</code> have the same effects (“accumulate to some accumulator”), and this can be seen clearly by comparing the two types:</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Const</span>  w a <span class="ot">=</span> <span class="dt">Const</span>  w</span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Writer</span> w a <span class="ot">=</span> <span class="dt">Writer</span> w a</span></code></pre></div>
<p>(<code>Const</code> is just <code>Writer</code> without the <code>a</code> value)</p>
<h2 id="what-is-applicative-really">What is Applicative Really?</h2>
<p>If you think about this, this seems like a bit of a crazy coincidence. Applicatives are an interesting concept, and Monoids are a different one.</p>
<p>But it looks like in order to make an <code>Applicative</code> instance for <code>Const w</code>, the behavior of <code>&lt;*&gt;</code> and <code>pure</code> have to follow some certain properties in order to fit the Applicative laws…and those properties are <em>exactly</em> monoidal properties and the Monoid laws.</p>
<p>To illustrate this link, we can see the type of <code>pure</code> and <code>&lt;*&gt;</code> for <code>Const w</code>, without the newtype wrappers (and ignored arguments)</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Monoid</span> w <span class="ot">=&gt;</span> <span class="dt">Applicative</span> (<span class="dt">Const</span> w) <span class="kw">where</span></span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a><span class="ot">    pure  ::</span> w</span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true" tabindex="-1"></a><span class="ot">    (&lt;*&gt;) ::</span> w <span class="ot">-&gt;</span> w <span class="ot">-&gt;</span> w</span></code></pre></div>
<p>And let’s look at the <code>Monoid</code> typeclass:</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Monoid</span> w <span class="kw">where</span></span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a><span class="ot">    mempty ::</span> w</span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true" tabindex="-1"></a><span class="ot">    (&lt;&gt;)   ::</span> w <span class="ot">-&gt;</span> w <span class="ot">-&gt;</span> w</span></code></pre></div>
<p>It seems like <code>Const</code> is nothing more than a (type-level) function on a Monoid. As an <code>* -&gt; (k -&gt; *)</code>, it takes a <code>*</code>-kinded Monoid and turns it into a <code>k -&gt; *</code>-kinded Monoid:</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Monoid</span> (<span class="ot">w ::</span> <span class="op">*</span>) <span class="ot">=&gt;</span> <span class="dt">Applicative</span> (<span class="dt">Const</span><span class="ot"> w ::</span> k <span class="ot">-&gt;</span> <span class="op">*</span>)</span></code></pre></div>
<p>“Give me a <code>Monoid</code> and I’ll give you something <code>k -&gt; *</code> that is also a monoid!”</p>
<p><code>Const</code> is a <em><a href="https://bartoszmilewski.com/2015/07/21/free-monoids/">monoid homomorphism</a></em>: it takes a monoid <code>w</code> with <code>mempty</code> and <code>(&lt;&gt;)</code>, and turns it into a monoid <code>Const w</code> with <code>pure _</code> and <code>&lt;*&gt;</code>:</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a><span class="dt">Const</span> (x <span class="op">&lt;&gt;</span> y) <span class="ot">=</span> <span class="dt">Const</span> x <span class="op">&lt;*&gt;</span> <span class="dt">Const</span> y</span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true" tabindex="-1"></a><span class="dt">Const</span> <span class="fu">mempty</span>   <span class="ot">=</span> <span class="fu">pure</span> ()</span></code></pre></div>
<p>Meaning “<code>&lt;&gt;</code> then <code>Const</code>” is the same as “<code>Const</code> then <code>&lt;*&gt;</code>”, and “<code>Const</code> the <code>mempty</code>” is the same as <code>pure ()</code>. Both things essentially convey the exact same monoid – one with <code>&lt;&gt;</code> and <code>mempty</code>, and the other with <code>&lt;*&gt;</code> and <code>pure ()</code>. In fact, it’s a bit more than a monoid homomorphism – it’s a <strong>monoid isomorphism</strong>:</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a>getConst x <span class="op">&lt;&gt;</span> getConst y <span class="ot">=</span> getConst (x <span class="op">&lt;*&gt;</span> y)</span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a><span class="fu">mempty</span>                   <span class="ot">=</span> getConst (<span class="fu">pure</span> ())</span></code></pre></div>
<p>Which means “<code>getConst</code> then <code>&lt;&gt;</code>” is the same as “<code>&lt;*&gt;</code> then <code>getConst</code>”, and <code>mempty</code> is the same as <code>getConst (pure ())</code>. <code>getConst</code> takes you from one monoid (with <code>&lt;*&gt;</code> and <code>pure ()</code>) to another (with <code>&lt;&gt;</code> and <code>mempty</code>).</p>
<p>One incidental observation – <code>sequenceA_</code> for <code>Const w</code> might look familiar:</p>
<div class="sourceCode" id="cb41"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a><span class="ot">sequenceA_ ::</span> <span class="dt">Monoid</span> w <span class="ot">=&gt;</span> [<span class="dt">Const</span> w a] <span class="ot">-&gt;</span> <span class="dt">Const</span> w ()</span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-3"><a href="#cb41-3" aria-hidden="true" tabindex="-1"></a><span class="co">-- strip out newtype wrappers</span></span>
<span id="cb41-4"><a href="#cb41-4" aria-hidden="true" tabindex="-1"></a><span class="ot">sequenceA_ ::</span> <span class="dt">Monoid</span> w <span class="ot">=&gt;</span> [w] <span class="ot">-&gt;</span> w</span></code></pre></div>
<p>It’s just <code>mconcat</code>!</p>
<p>As an exercise, see if you can understand this definition of <code>mconcat</code> in terms of <code>Const</code> and <code>traverse</code>:</p>
<div class="sourceCode" id="cb42"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a><span class="fu">mconcat</span><span class="ot"> ::</span> <span class="dt">Monoid</span> w <span class="ot">=&gt;</span> [w] <span class="ot">-&gt;</span> w</span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true" tabindex="-1"></a><span class="fu">mconcat</span> <span class="ot">=</span> getConst <span class="op">.</span> traverse_ <span class="dt">Const</span></span></code></pre></div>
<p><code>traverse_</code>, if you aren’t familiar with it, an “effectful” function (in our case, <code>Const :: w -&gt; Const w w</code>) over all values in a container, and sequences all of their effects.</p>
<h3 id="monoid-is-the-key">Monoid is the Key</h3>
<p>All of this actually witnesses the core of Applicative. A lot of people describe Applicative as a “lax monoidal functor”.</p>
<p>In this post, I was really handwavey with how I talked about “effects” (“<code>f &lt;*&gt; x</code> must use the effects of <code>f</code> and <code>x</code> each once and only once”, I claimed, without defining what an effect was). The notion of what an “effect” is really comes from each individual Applicative, and each type really has its own conceptual picture of what counts as an effect. The rigorous test of what is a meaningful way to have an effect that can be combined comes from those laws (<code>pure f &lt;*&gt; x = fmap f x</code>, etc.) and the overall sentiment that the combination of effects is <em>monoidal</em>.</p>
<p>At its heart, Applicative enforces that <code>liftA2</code> and <code>&lt;*&gt;</code> are supposed to be “monoidal” in some way. This fact is hidden by the normal form of the Applicative laws, but I feel like seeing this play out in the <code>Applicative</code> instance for <code>Const</code> — how <code>Monoid</code> is exactly the constraint necessary to implement the instance, and how <code>Const</code> forms a monoid isomorphism — really helps hammer in the monoidal nature of <em>all</em> Applicative instances.</p>
<p>Applicative instances must be monoidal in how they sequence their effects. Because <code>Const</code>’s effects are so simple (“accumulate a value”), this makes it an especially obvious demonstration of this.</p>
<p>Hopefully this helps you gain some sense of appreciation between the link between <code>Applicative</code> and <code>Monoid</code>, and also why <code>Const</code>’s Applicative instance is defined the way it is!</p>
<section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes">
<hr />
<ol>
<li id="fn1"><p>Note that if you want to play along in ghci, you should give this a <code>Show</code> instance by typing <code>deriving (Show)</code> after the data declaration<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p>There are other laws, but because of parametric polymorphism in Haskell, we know they must be true if and only if <code>fmap id = id</code>.<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3"><p>Note that in the real world we also have to verify that our definition combines effects in an <em>associative</em> way, but we won’t go too deeply into this for this article.<a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn4"><p>Note that the Applicative laws are loose enough to allow a different definition, with the same <code>pure</code>, but with <code>Const x &lt;*&gt; Const y = Const (y &lt;&gt; x</code>). But, this is just a different <code>Monoid</code> (<code>Const (Dual w)</code>).<a href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section></div><footer><hr><div class="copy-content"><p>Hi, thanks for reading! You can reach me via email at <a href="mailto:justin@jle.im" class="email">justin@jle.im</a>, or at twitter at <a href="https://twitter.com/mstk">@mstk</a>! This post and all others are published under the <a href="https://creativecommons.org/licenses/by-nc-nd/3.0/">CC-BY-NC-ND 3.0</a> license. Corrections and edits via pull request are welcome and encouraged at <a href="https://github.com/mstksg/inCode">the source repository</a>.</p>
<p>If you feel inclined, or this post was particularly helpful for you, why not consider <a href="https://www.patreon.com/justinle/overview">supporting me on Patreon</a>, or a <a href="bitcoin:3D7rmAYgbDnp4gp4rf22THsGt74fNucPDU">BTC donation</a>? :)</p></div><div class="clear"></div><ul class="entry-series"></ul><ul class="tag-list"><li><a href="https://blog.jle.im/entries/tagged/applicatives.html" class="tag-a-tag">#applicatives</a></li><li><a href="https://blog.jle.im/entries/tagged/functional-programming.html" class="tag-a-tag">#functional programming</a></li><li><a href="https://blog.jle.im/entries/tagged/haskell.html" class="tag-a-tag">#haskell</a></li><li><a href="https://blog.jle.im/entries/tagged/monoids.html" class="tag-a-tag">#monoids</a></li><li><a href="https://blog.jle.im/entries/category/@haskell.html" class="tag-a-category">@HASKELL</a></li></ul><aside class="social-buttons"><div class="addthis_toolbox addthis_default_style addthis-buttons"><a class="addthis_button_facebook_like" fb:like:layout="button_count"></a><a class="addthis_button_tweet"></a><a class="addthis_button_google_plusone" g:plusone:size="medium"></a><a class="addthis_counter addthis_pill_style"></a></div><div class="custom-social-buttons"><div class="custom-social-button"><a href="https://www.reddit.com/submit" onclick="window.location = &#39;https://www.reddit.com/submit?url=&#39;+ encodeURIComponent(window.location); return false"><img src="https://www.reddit.com/static/spreddit7.gif" alt="submit to reddit"></a></div></div></aside><nav class="next-prev-links"><ul><li class="prev-entry-link">&larr; <a href="https://blog.jle.im/entry/you-could-have-invented-matrices.html">You Could Have Invented Matrices!</a> (Previous)</li><li class="next-entry-link">(Next) <a href="https://blog.jle.im/entry/purely-functional-typed-models-1.html">A Purely Functional Typed Approach to Trainable Models (Part 1)</a> &rarr;</li></ul></nav></footer></article><div class="post-entry"><div class="tile"><div id="disqus_thread"></div><script type="text/javascript">var disqus_config = function () {
    this.page.url = 'https://blog.jle.im/entry/const-applicative-and-monoids.html';
    this.page.identifier = 'const';
};
(function() {
    var d = document, s = d.createElement('script');
    s.src = '//incode.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
})();
</script><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a><br></noscript><a href="http://disqus.com" class="dsq-brlink">Comments powered by <span class="logo-disqus">Disqus</span></a></div></div></div></div></div><div id="footer-container"><div id="footer-content"><div class="tile"><div class="footer-copyright">&copy; 2020 Justin Le <span class="license-link">(<a href="https://creativecommons.org/licenses/by-nc-nd/3.0/" class="license">CC-BY-NC-ND 3.0</a>)</span></div><div class="footer-follow social-follows"><ul class="social-follows-list"><li><ul class="social-follows-list-social"><li><a class="social-follow-twitter" title="Follow me on Twitter!" href="https://twitter.com/intent/user?user_id=mstk" onclick="window.open(
  &#39;http://twitter.com/intent/user?user_id=907281&#39;,
  &#39;facebook-share-dialog&#39;,
  &#39;width=550,height=520&#39;);
return false;
">Twitter</a></li><li><a class="social-follow-github" title="Fork me on Github!" href="https://github.com/mstksg">Github</a></li><li><a class="social-follow-twitch" title="Watch me on Twitch!" href="https://www.twitch.tv/justin_l">Twitch</a></li><li><a class="social-follow-patreon" title="Support me on Patreon!" href="https://www.patreon.com/justinle/overview">Patreon</a></li><li><a class="social-follow-gplus" title="Add me on Google+!" href="https://plus.google.com/+JustinLe">Google+</a></li><li><a class="social-follow-keybase" title="Track me on Keybase!" href="https://keybase.io/mstksg">Keybase</a></li><li><a class="social-follow-linkedin" title="Connect with me on LinkedIn!" href="https://linkedin.com/in/lejustin">LinkedIn</a></li><li><a class="social-follow-bitcoin" title="Donate via bitcoin!" href="bitcoin:3D7rmAYgbDnp4gp4rf22THsGt74fNucPDU">Bitcoin</a></li></ul></li><li><ul class="social-follows-list-site"><li><a class="social-follow-rss" title="Subscribe to my RSS Feed!" href="http://feeds.feedburner.com/incodeblog">RSS</a></li><li><a class="social-follow-email" title="Subscribe to the mailing list!" href="https://feedburner.google.com/fb/a/mailverify?loc=en_US&amp;uri=incodeblog">Mailing list</a></li></ul></li></ul></div></div></div></div></body></html>