<!DOCTYPE HTML>
<html><head><title>Lazy Patterns, Strict Matches, and All That: My Mental Model of Haskell
Evaluation · in Code</title><meta name="description" content="Weblog of Justin Le, covering various adventures in programming and explorations in the worlds of computation physics, and knowledge.
"><meta http-equiv="Content-Type" content="text/html;charset=utf-8"><meta name="viewport" content="width=device-width,initial-scale=1.0"><meta name="flattr:id" content="3p9jqr"><meta property="og:site_name" content="in Code"><meta property="og:description" content="Every once in a while I get questions about “what does this ~ do in a pattern”, what strict pattern matching does, etc. And while you can understand code like case x of ~(a,b) -&gt; ... in terms of one-off special cases, I think that having a good mental model of how evaluation with ADTs work in Haskell will allow you to answer these questions with confidence, and without second-guessing yourself. This is less an article on formal semantics as it as an article trying to explain some of the heuristics and mental models I’ve developed over my years of writing Haskell to help me understand how things work. It’s not a textbook, but an experience report :)"><meta property="og:type" content="article"><meta property="og:title" content="Lazy Patterns, Strict Matches, and All That: My Mental Model of Haskell
Evaluation"><meta property="og:image" content="https://blog.jle.im/img/site_logo.jpg"><meta property="og:locale" content="en_US"><meta property="og:url" content="https://blog.jle.im/entry/lazy-strict-mental-model.html"><meta name="twitter:card" content="summary"><meta name="twitter:creator:id" content="mstk"><link rel="author" href="https://plus.google.com/107705320197444500140"><link rel="alternate" type="application/rss+xml" title="in Code (RSS Feed)" href="http://feeds.feedburner.com/incodeblog"><link rel="canonical" href="https://blog.jle.im/entry/lazy-strict-mental-model.html"><link href="https://blog.jle.im/favicon.ico" rel="shortcut icon"><link href="https://blog.jle.im/css/toast.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/font.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/main.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/page/entry.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/pygments.css" rel="stylesheet" type="text/css"><script type="text/javascript">var page_data = {};
var disqus_shortname='incode';
</script><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-443711-8', 'jle.im');
ga('send', 'pageview');
</script><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script id="MathJax-script" async="" src="https://cdn.jsdelivr.net/npm/mathjax@3.0.1/es5/tex-mml-chtml.js"></script><script type="text/javascript" src="//ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script><script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5234d67a6b68dcd4"></script><script type="text/javascript" src="https://blog.jle.im/js/page/entry_toc.js"></script><script type="text/javascript" src="https://blog.jle.im/js/disqus_count.js"></script><script type="text/javascript" src="https://blog.jle.im/js/social.js"></script><script type="text/javascript" src="https://blog.jle.im/js/jquery/jquery.toc.js"></script><script type="text/javascript" src="https://blog.jle.im/purescript/entry.js"></script></head><body><div id="fb-root"><script>(function(d, s, id) {
 var js, fjs = d.getElementsByTagName(s)[0];
 if (d.getElementById(id)) return;
 js = d.createElement(s); js.id = id;
 js.src = "//connect.facebook.net/en_US/all.js#xfbml=1&appId=641852699171929";
 fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));
</script></div><div id="header-container"><div id="navbar-container" class="tile"><nav id="navbar-content"><div class="nav-info"><h1 class="site-title"><a href="https://blog.jle.im/" class="nav-title">in Code</a></h1><span class="nav-author">Justin Le</span></div><ul class="nav-links"><li><a href="https://blog.jle.im/">home</a></li><li><a href="https://blog.jle.im/entries.html">archives</a></li><li><a href="https://cv.jle.im">cv</a></li><div class="clear"></div></ul></nav></div><div id="header-content"></div></div><div id="body-container" class="container"><div id="main-container" class="grid"><div class="entry-section unit span-grid" role="main"><article class="tile article"><header><div class="unposted-banner">Unposted entry</div><h1 id="title">Lazy Patterns, Strict Matches, and All That: My Mental Model of Haskell
Evaluation</h1><p class="entry-info">by <a class="author" href="https://blog.jle.im/">Justin Le</a></p><p><span class="source-info"><a class="source-link" href="https://github.com/mstksg/inCode/tree/master/copy/entries/lazy.md">Source</a><span class="info-separator"> &diams; </span><a class="source-link" href="https://github.com/mstksg/inCode/tree/gh-pages/entry/lazy-strict-mental-model.md">Markdown</a><span class="info-separator"> &diams; </span><a class="source-link" href="https://blog.jle.im/entry/lazy-strict-mental-model.tex">LaTeX</a><span class="info-separator"> &diams; </span></span>Posted in <a href="https://blog.jle.im/entries/category/@haskell.html" class="tag-a-category" title="Functional, pure, non-strict, statically and strongly typed, natively
compiled...really just the king of great languages.
">Haskell</a><span class="info-separator"> &diams; </span><a class="comment-link" href="#disqus_thread">Comments</a></p></header><hr><aside class="contents-container"><h5 id="contents-header">Contents</h5><div id="toc"></div></aside><div class="main-content copy-content"><p>Every once in a while I get questions about “what does this <code>~</code> do in a pattern”, what strict pattern matching does, etc. And while you can understand code like <code>case x of ~(a,b) -&gt; ...</code> in terms of one-off special cases, I think that having a good mental model of how evaluation with ADTs work in Haskell will allow you to answer these questions with confidence, and without second-guessing yourself.</p>
<p>This is less an article on formal semantics as it as an article trying to explain some of the heuristics and mental models I’ve developed over my years of writing Haskell to help me understand how things work. It’s not a textbook, but an experience report :)</p>
<h2 id="let-and-case">Let and Case</h2>
<p>A lot of the distinction between lazy and strict matching can be illustrated by comparing the semantics of <code>let</code> vs. <code>case</code>. (We’re going to be ignoring type checking here and assuming all values are nice monomorphic values).</p>
<p>For example, let’s see the distinction between:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> (x, y) <span class="ot">=</span> <span class="fu">undefined</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="kw">in</span>  <span class="dt">True</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="kw">case</span> <span class="fu">undefined</span> <span class="kw">of</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    (x, y) <span class="ot">-&gt;</span> <span class="dt">True</span></span></code></pre></div>
<p>What will either of these return, when you try to run it?</p>
<p>Small note — here, we are using <code>undefined</code> as a way to directly observe evaluation in Haskell. This is a common trick people use when discussing evaluation in Haskell — it works because <code>undefined :: a</code> can take on any type, and any attempt to evaluate <code>undefined</code> can be immediately detected:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> <span class="fu">sum</span> [<span class="dv">1</span>,<span class="dv">2</span>,<span class="fu">undefined</span>,<span class="dv">100</span>]</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="op">***</span> <span class="dt">Exception</span><span class="op">:</span> Prelude.undefined</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> <span class="fu">sum</span> (<span class="fu">take</span> <span class="dv">2</span> [<span class="dv">1</span>,<span class="dv">2</span>,<span class="fu">undefined</span>,<span class="dv">100</span>])</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="dv">3</span></span></code></pre></div>
<p>Think of it like laying a mine for poor old GHC to encounter. GHC tries to evaluate things, but when it tries to evaluate <code>undefined</code>, it immediately explodes and tells you that it has a boo-boo. Our investigation becomes reframed as “is this mine ever tripped, or not?”</p>
<div class="note">
<p><strong>Alternatives to <code>undefined</code></strong></p>
<p>Admittedly, the idea that <code>undefined</code> can take on any type can seem a little spooky – so often I like to use something within the correct type to make things feel a little more concrete. For example, instead of <code>undefined</code>, we can write:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="ot">myTuple ::</span> (<span class="dt">Int</span>, <span class="dt">String</span>)</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>myTuple</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="fu">sum</span> [<span class="dv">1</span><span class="op">..</span>] <span class="op">&lt;</span> <span class="dv">1000</span> <span class="ot">=</span> (<span class="dv">3</span>, <span class="st">&quot;hi&quot;</span>)</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="fu">otherwise</span>        <span class="ot">=</span> (<span class="dv">5</span>, <span class="st">&quot;bye&quot;</span>)</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> (x, y) <span class="ot">=</span> myTuple</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a><span class="kw">in</span>  <span class="dt">True</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a><span class="kw">case</span> myTuple <span class="kw">of</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>    (x, y) <span class="ot">-&gt;</span> <span class="dt">True</span></span></code></pre></div>
<p>This example should display all of the same nuances of using <code>undefined</code> — the only practical difference is that instead of seeing <code>Exception: Prelude.undefined</code> if the value is ever evaluated, you’ll instead just see a program locking up if a value is evaluated.</p>
</div>
<p>With that in mind, let’s find the answer to our previous question:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> <span class="kw">let</span> (x,y) <span class="ot">=</span> <span class="fu">undefined</span> <span class="kw">in</span> <span class="dt">True</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="dt">True</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> <span class="kw">case</span> <span class="fu">undefined</span> <span class="kw">of</span> (x,y) <span class="ot">-&gt;</span> <span class="dt">True</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span class="op">***</span> <span class="dt">Exception</span><span class="op">:</span> Prelude.undefined</span></code></pre></div>
<p>So, there’s a difference! What’s going on here?</p>
<p>In my mind, this is how I see things:</p>
<ol type="1">
<li><em>let</em> is <strong>aliasing</strong></li>
<li><em>case</em> is <strong>control flow</strong></li>
</ol>
<p>To apply this to what we just saw:</p>
<ol type="1">
<li><p><em>let</em> is just aliasing <code>x</code> and <code>y</code> to whatever is in the body. If you don’t use the alias, it’s no big deal, really. It’s just like if you used <code>alias abc rm -rf /</code> in <em>bash</em>. Aliasing <code>abc</code> to <code>rm -rf /</code> doesn’t actually erase your entire file system, it’s only something that does it if you decide to use the alias.</p></li>
<li><p><em>case</em> here <em>decides</em> what to do based on what the input is. <em>If</em> you are given <code>(x, y)</code>, <em>then</em> return <code>True</code>. It’s used to direct the flow of how a program executes, so it <em>has</em> to look at the value to see what to do.</p></li>
</ol>
<p>So, the reason that the <code>case</code> version explodes when you attempt to evaluate it is because it has to ask the question “Does this value match this pattern?” — and in the process of investigating it, it has to touch <code>undefined</code> and so sets off the mine.</p>
<p>The <em>let</em> situation never has to answer the question “does this value match this pattern?”, and so never needs to investigate it and so doesn’t explode.</p>
<h3 id="option-one-of-one">Option One of One</h3>
<p>To someone new to Haskell (or unfamiliar with its semantics), it kind of seems silly that <code>case</code> would “have” to check <em>which</em> constructor is being used…since there is really only one option, <code>,</code>. Why can’t <code>case</code> just know that it <em>has</em> to be <code>,</code> and move on, without checking? Surely that would be more sensible.</p>
<p>For example, let’s look at a situation that is uncontroversial</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> <span class="kw">case</span> <span class="fu">undefined</span> <span class="kw">of</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>        <span class="dt">Left</span> x <span class="ot">-&gt;</span> <span class="dt">False</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>        <span class="dt">Right</span> y <span class="ot">-&gt;</span> <span class="dt">True</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a><span class="op">***</span> <span class="dt">Exception</span><span class="op">:</span> Prelude.undefined</span></code></pre></div>
<p>Of <em>course</em> that one has to explode, because it has to check if the <code>Either</code> is <code>Left</code> or <code>Right</code>. But in the case of <code>(x, y)</code>, it’s always going to be <code>,</code>, so why can’t it just “know” you are <code>(x, y)</code> since there isn’t any other situation?</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> <span class="kw">case</span> <span class="fu">undefined</span> <span class="kw">of</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>        (x, y) <span class="ot">-&gt;</span> <span class="dt">False</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a><span class="op">***</span> <span class="dt">Exception</span><span class="op">:</span> Prelude.undefined</span></code></pre></div>
<p>We know the answer will be <code>False</code> no matter what, so why bother checking? Why can’t we just have it skip the check and return <code>False</code>?</p>
<p>There are a couple of ways to approach this answer…and I think all approaches illustrate something important about the philosophy of writing Haskell.</p>
<ol type="1">
<li><p>If you shift your question from “which constructor is it?” to “which constructor was it <em>made</em> with?”, then it starts to make sense.</p>
<p>Pattern matching isn’t about asking “which constructor does this value match?”, but rather “which constructor was this value <em>made</em> with?”</p>
<p>So, it would be unwise to just have GHC skip the check. When we are doing</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">case</span> blahblah <span class="kw">of</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>  (x, y) <span class="ot">-&gt;</span> <span class="co">-- ...</span></span></code></pre></div>
<p>We don’t <em>really</em> care “what is <code>blahblah</code>”? We care “how was <code>blahblah</code> made?”</p>
<p>Under this light, we see that there actually are many ways to make a tuple value <em>without</em> ever using <code>(,)</code>:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="ot">tup1 ::</span> (<span class="dt">Int</span>, <span class="dt">Bool</span>)</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>tup1 <span class="ot">=</span> <span class="fu">undefined</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a><span class="ot">tup2 ::</span> (<span class="dt">Int</span>, <span class="dt">Bool</span>)</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>tup2 <span class="ot">=</span> go <span class="dv">0</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>    go n <span class="ot">=</span> go (n <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a><span class="ot">tup3 ::</span> (<span class="dt">Int</span>, <span class="dt">Bool</span>)</span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>tup3</span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="fu">even</span> (<span class="fu">sum</span> [<span class="dv">1</span><span class="op">..</span>]) <span class="ot">=</span> (<span class="dv">3</span>, <span class="dt">True</span>)</span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="fu">otherwise</span>        <span class="ot">=</span> <span class="fu">undefined</span></span></code></pre></div>
<p>We can see here three perfectly valid values of type <code>(Int, Bool)</code> that are <em>not</em> constructed with <code>(,)</code>, or at least where the question is ambiguous and up in the air. So <em>skipping</em> checking the constructor here is skipping the real question – not “what pattern does it match”, but “what was it made with”.</p></li>
<li><p>Haskell <code>data</code> declarations with boxed fields all follow the same general schema in memory:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">MyType</span> <span class="ot">=</span> <span class="dt">A</span> <span class="dt">Int</span> <span class="dt">Bool</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>            <span class="op">|</span> <span class="dt">B</span> <span class="dt">String</span> <span class="dt">Double</span></span></code></pre></div>
<pre><code>+--------+------------------------+-------------------------+
| A or B | pointer to first field | pointer to second field |
+--------+------------------------+-------------------------+</code></pre>
<p>So, for example, a value like <code>A 3 True</code> would look like:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>    <span class="op">+---+---+---+</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span class="op">--&gt;</span> <span class="op">|</span> <span class="dt">A</span> <span class="op">|</span> o <span class="op">|</span> o <span class="op">|</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">+---+-|-+-|-+</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>      <span class="op">|</span>   <span class="op">|</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>      v   v</span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>      <span class="dv">3</span>   <span class="dt">True</span></span></code></pre></div>
<p>For a type with a single constructor, that initial “which constructor” field is still there. This just makes things a little more consistent — there is no special-case for a single-constructor situation.</p>
<p>When considering sematics, there is no fundamental difference between a single-constructor type and a multi-constructor type. A single-constructor type is just an n-constructor type where n = 1. This means that a type like:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">MyType</span> <span class="ot">=</span> <span class="dt">A</span> <span class="dt">Int</span> <span class="dt">Bool</span></span></code></pre></div>
<p>will still have the constructor byte at the front:</p>
<pre><code>+---+------------------------+-------------------------+
| A | pointer to first field | pointer to second field |
+---+------------------------+-------------------------+</code></pre></li>
</ol>
<p>To me, the underlying reason is <em>consistency</em>. A lot of beginners, when starting Haskell, come to the impression that Haskell is <em>magical</em>: it just does the best thing in every situation. For example, a lot of Haskell learners somehow all independently arrive at the assumption that using the same function on the same argument will only compute it once, and cache the result. After all, it’s possible (because all functions are pure, so calling the same function on the same value will always return the same result), so why not have it magically be true?</p>
<p>However, as you learn more Haskell, you start to realize that what might have seemed magical at first is just the straightforward application of a few rules that apply generally, with rare special-cases. That’s because for a language to be useful, it’s not about <em>magic</em>, but <em>predictability</em>.</p>
<p>So, case matching on a single-constructor type should not be special-cased from the mechanics of a two-constructor type. To check for a match, you always have to peek at the constructor — no matter how many there might be.</p>
<p>Another way you can look at it is that ADTs are stored in haskell as a <code>(ConstructorTag, Fields)</code> tuple — and all <code>data</code>-defined ADTs are stored in that way, without special-case exceptions.</p>
<p>(Of course, the exception to this rule is <code>newtype</code>s, which follow different rules from <code>data</code> in general)</p>
<p>And, of course, it’s also possible to show “All tuples must match the <code>(x,y)</code> pattern and be constructed with <code>(,)</code>” as false — <code>undefined :: (Int, Bool)</code> is an example of a tuple that isn’t constructed with <code>(,)</code> and so doesn’t match the <code>(x, y)</code> pattern.</p></div><footer><hr><div class="copy-content"><p>Hi, thanks for reading! You can reach me via email at <a href="mailto:justin@jle.im" class="email">justin@jle.im</a>, or at twitter at <a href="https://twitter.com/mstk">@mstk</a>! This post and all others are published under the <a href="https://creativecommons.org/licenses/by-nc-nd/3.0/">CC-BY-NC-ND 3.0</a> license. Corrections and edits via pull request are welcome and encouraged at <a href="https://github.com/mstksg/inCode">the source repository</a>.</p>
<p>If you feel inclined, or this post was particularly helpful for you, why not consider <a href="https://www.patreon.com/justinle/overview">supporting me on Patreon</a>, or a <a href="bitcoin:3D7rmAYgbDnp4gp4rf22THsGt74fNucPDU">BTC donation</a>? :)</p></div><div class="clear"></div><ul class="entry-series"></ul><ul class="tag-list"><li><a href="https://blog.jle.im/entries/tagged/functional-programming.html" class="tag-a-tag">#functional programming</a></li><li><a href="https://blog.jle.im/entries/tagged/haskell.html" class="tag-a-tag">#haskell</a></li><li><a href="https://blog.jle.im/entries/category/@haskell.html" class="tag-a-category">@HASKELL</a></li></ul><aside class="social-buttons"><div class="addthis_toolbox addthis_default_style addthis-buttons"><a class="addthis_button_facebook_like" fb:like:layout="button_count"></a><a class="addthis_button_tweet"></a><a class="addthis_button_google_plusone" g:plusone:size="medium"></a><a class="addthis_counter addthis_pill_style"></a></div><div class="custom-social-buttons"><div class="custom-social-button"><a href="https://www.reddit.com/submit" onclick="window.location = &#39;https://www.reddit.com/submit?url=&#39;+ encodeURIComponent(window.location); return false"><img src="https://www.reddit.com/static/spreddit7.gif" alt="submit to reddit"></a></div></div></aside><nav class="next-prev-links"><ul><li class="next-entry-link">(Next) <a href="https://blog.jle.im/entry/introducing-in-code.html">Introducing &quot;in Code&quot;!</a> &rarr;</li></ul></nav></footer></article><div class="post-entry"><div class="tile"><div id="disqus_thread"></div><script type="text/javascript">var disqus_config = function () {
    this.page.url = 'https://blog.jle.im/entry/lazy-strict-mental-model.html';
    this.page.identifier = 'lazy';
};
(function() {
    var d = document, s = d.createElement('script');
    s.src = '//incode.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
})();
</script><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a><br></noscript><a href="http://disqus.com" class="dsq-brlink">Comments powered by <span class="logo-disqus">Disqus</span></a></div></div></div></div></div><div id="footer-container"><div id="footer-content"><div class="tile"><div class="footer-copyright">&copy; 2020 Justin Le <span class="license-link">(<a href="https://creativecommons.org/licenses/by-nc-nd/3.0/" class="license">CC-BY-NC-ND 3.0</a>)</span></div><div class="footer-follow social-follows"><ul class="social-follows-list"><li><ul class="social-follows-list-social"><li><a class="social-follow-twitter" title="Follow me on Twitter!" href="https://twitter.com/intent/user?user_id=mstk" onclick="window.open(
  &#39;http://twitter.com/intent/user?user_id=907281&#39;,
  &#39;facebook-share-dialog&#39;,
  &#39;width=550,height=520&#39;);
return false;
">Twitter</a></li><li><a class="social-follow-github" title="Fork me on Github!" href="https://github.com/mstksg">Github</a></li><li><a class="social-follow-twitch" title="Watch me on Twitch!" href="https://www.twitch.tv/justin_l">Twitch</a></li><li><a class="social-follow-patreon" title="Support me on Patreon!" href="https://www.patreon.com/justinle/overview">Patreon</a></li><li><a class="social-follow-gplus" title="Add me on Google+!" href="https://plus.google.com/+JustinLe">Google+</a></li><li><a class="social-follow-keybase" title="Track me on Keybase!" href="https://keybase.io/mstksg">Keybase</a></li><li><a class="social-follow-linkedin" title="Connect with me on LinkedIn!" href="https://linkedin.com/in/lejustin">LinkedIn</a></li><li><a class="social-follow-bitcoin" title="Donate via bitcoin!" href="bitcoin:3D7rmAYgbDnp4gp4rf22THsGt74fNucPDU">Bitcoin</a></li></ul></li><li><ul class="social-follows-list-site"><li><a class="social-follow-rss" title="Subscribe to my RSS Feed!" href="http://feeds.feedburner.com/incodeblog">RSS</a></li><li><a class="social-follow-email" title="Subscribe to the mailing list!" href="https://feedburner.google.com/fb/a/mailverify?loc=en_US&amp;uri=incodeblog">Mailing list</a></li></ul></li></ul></div></div></div></div></body></html>