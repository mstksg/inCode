<!DOCTYPE HTML>
<html><head><title>Effectful, Recursive, Real-World Autos: Intro to Machine/Auto Part 3 · in Code</title><meta name="description" content="Weblog of Justin Le, covering various adventures in programming and explorations in the worlds of computation physics, and knowledge.
"><meta http-equiv="Content-Type" content="text/html;charset=utf-8"><meta name="viewport" content="width=device-width,initial-scale=1.0"><meta name="flattr:id" content="3p9jqr"><meta property="og:site_name" content="in Code"><meta property="og:description" content="Hi! I have to apologize a bit for the long delay; starting grad school and things like that have made me have to scramble to adjust to the new life. But a couple of people have asked me to finish up and wrap up this series, and I think I owe it to them then :) Welcome to the final chapter. In the last post, we looked deeper into the Auto type, played around with instancing it as familiar typeclasses, saw it as a member of the powerful Category and Arrow typeclasses, and took advantage of this by composing Autos both manually and using proc/do notation, and were freed from the murk and mire of explicit recursion. We observed the special nature of this composition, and saw some neat properties, like local statefulness. At this point I consider most of the important concepts about working with Auto covered, but now, we are going to push this abstraction further, to the limits of real-world industrial usage. We’re going to be exploring mechanisms for adding effects and, making the plain ol’ Auto into something more rich and featureful. We’ll see how to express denotative and declarative compositions using recursively binded Autos, and what that even means. It’ll be a trip down several avenues to motivate and see practical Auto usage. Basically, it’ll be a “final hurrah”. A fair bit of warning — if the last post is not fresh in your mind, or you still have some holes, I recommend going back and reading through them again. This one is going to hit hard and fast :) (Also, it’s admittedly kind of long for a single post, but I didn’t want to break things up into two really short parts.) As always, feel free to leave a comment if you have any questions, drop by freenode’s #haskell, or find me on twitter :) All of the code in this post is available for download and to load up into ghci for playing along!"><meta property="og:type" content="article"><meta property="og:title" content="Effectful, Recursive, Real-World Autos: Intro to Machine/Auto Part 3"><meta property="og:image" content="https://blog.jle.im/img/site_logo.jpg"><meta property="og:locale" content="en_US"><meta property="og:url" content="https://blog.jle.im/entry/effectful-recursive-real-world-autos-intro-to-machine.html"><meta name="twitter:card" content="summary"><meta name="twitter:creator:id" content="mstk"><link rel="author" href="https://plus.google.com/107705320197444500140"><link rel="alternate" type="application/rss+xml" title="in Code (RSS Feed)" href="http://feeds.feedburner.com/incodeblog"><link rel="canonical" href="https://blog.jle.im/entry/effectful-recursive-real-world-autos-intro-to-machine.html"><link href="https://blog.jle.im/favicon.ico" rel="shortcut icon"><link href="https://blog.jle.im/css/toast.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/font.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/main.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/page/entry.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/pygments.css" rel="stylesheet" type="text/css"><script type="text/javascript">var page_data = {};
var disqus_shortname='incode';
</script><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-443711-8', 'jle.im');
ga('send', 'pageview');
</script><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script id="MathJax-script" async="" src="https://cdn.jsdelivr.net/npm/mathjax@3.0.1/es5/tex-mml-chtml.js"></script><script type="text/javascript" src="//ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script><script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5234d67a6b68dcd4"></script><script type="text/javascript" src="https://blog.jle.im/js/page/entry_toc.js"></script><script type="text/javascript" src="https://blog.jle.im/js/disqus_count.js"></script><script type="text/javascript" src="https://blog.jle.im/js/social.js"></script><script type="text/javascript" src="https://blog.jle.im/js/jquery/jquery.toc.js"></script><script type="text/javascript" src="https://blog.jle.im/purescript/entry.js"></script></head><body><div id="fb-root"><script>(function(d, s, id) {
 var js, fjs = d.getElementsByTagName(s)[0];
 if (d.getElementById(id)) return;
 js = d.createElement(s); js.id = id;
 js.src = "//connect.facebook.net/en_US/all.js#xfbml=1&appId=641852699171929";
 fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));
</script></div><div id="header-container"><div id="navbar-container" class="tile"><nav id="navbar-content"><div class="nav-info"><h1 class="site-title"><a href="https://blog.jle.im/" class="nav-title">in Code</a></h1><span class="nav-author">Justin Le</span></div><ul class="nav-links"><li><a href="https://blog.jle.im/">home</a></li><li><a href="https://blog.jle.im/entries.html">archives</a></li><li><a href="https://cv.jle.im">cv</a></li><div class="clear"></div></ul></nav></div><div id="header-content"></div></div><div id="body-container" class="container"><div id="main-container" class="grid"><div class="entry-section unit span-grid" role="main"><article class="tile article"><header><h1 id="title">Effectful, Recursive, Real-World Autos: Intro to Machine/Auto Part 3</h1><p class="entry-info">by <a class="author" href="https://blog.jle.im/">Justin Le</a><span class="info-separator"> &diams; </span><time datetime="2015-02-09T10:19:03Z" pubdate="" class="pubdate">Monday February 9, 2015</time></p><p><span class="source-info"><a class="source-link" href="https://github.com/mstksg/inCode/tree/master/copy/entries/machines-3.md">Source</a><span class="info-separator"> &diams; </span><a class="source-link" href="https://github.com/mstksg/inCode/tree/gh-pages/entry/effectful-recursive-real-world-autos-intro-to-machine.md">Markdown</a><span class="info-separator"> &diams; </span><a class="source-link" href="https://blog.jle.im/entry/effectful-recursive-real-world-autos-intro-to-machine.tex">LaTeX</a><span class="info-separator"> &diams; </span></span>Posted in <a href="https://blog.jle.im/entries/category/@haskell.html" class="tag-a-category" title="Functional, pure, non-strict, statically and strongly typed, natively
compiled...really just the king of great languages.
">Haskell</a>, <a href="https://blog.jle.im/entries/category/@ramblings.html" class="tag-a-category" title="My slight ramblings on subjects of interest (to me and hopefully to you too!).
Lots of surveys and introducts to new subjects.
">Ramblings</a><span class="info-separator"> &diams; </span><a class="comment-link" href="#disqus_thread">Comments</a></p></header><hr><aside class="contents-container"><h5 id="contents-header">Contents</h5><div id="toc"></div></aside><div class="main-content copy-content"><p>Hi! I have to apologize a bit for the long delay; starting grad school and things like that have made me have to scramble to adjust to the new life. But a couple of people have asked me to finish up and wrap up this series, and I think I owe it to them then :) Welcome to the final chapter.</p>
<p>In the <a href="http://blog.jle.im/entry/auto-as-category-applicative-arrow-intro-to-machines">last post</a>, we looked deeper into the Auto type, played around with instancing it as familiar typeclasses, saw it as a member of the powerful <em>Category</em> and <em>Arrow</em> typeclasses, and took advantage of this by composing Autos both manually and using proc/do notation, and were freed from the murk and mire of explicit recursion. We observed the special nature of this composition, and saw some neat properties, like local statefulness.</p>
<p>At this point I consider most of the important concepts about working with <code>Auto</code> covered, but now, we are going to push this abstraction further, to the limits of real-world industrial usage. We’re going to be exploring mechanisms for adding effects and, making the plain ol’ <code>Auto</code> into something more rich and featureful. We’ll see how to express denotative and declarative compositions using recursively binded <code>Auto</code>s, and what that even means. It’ll be a trip down several avenues to motivate and see practical Auto usage.<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a> Basically, it’ll be a “final hurrah”.</p>
<p>A fair bit of warning — if the last post is not fresh in your mind, or you still have some holes, I recommend going back and reading through them again. This one is going to hit hard and fast :) (Also, it’s admittedly kind of long for a single post, but I didn’t want to break things up into two really short parts.)</p>
<p>As always, feel free to leave a comment if you have any questions, drop by freenode’s <em>#haskell</em>, or find me on <a href="https://twitter.com/mstk" title="Twitter">twitter</a> :)</p>
<p>All of the code in this post is <a href="http://blog.jle.im/source/code-samples/machines">available for download</a> and to load up into ghci for playing along!</p>
<h2 id="effectful-stepping">Effectful Stepping</h2>
<p>Recall our original definition of <code>Auto a b</code> as a newtype wrapper over a function:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>a <span class="ot">-&gt;</span> (b, <span class="dt">Auto</span> a b)</span></code></pre></div>
<p>This can be read as saying, “feed the <code>Auto</code> an <code>a</code>, and (purely) get a resulting <code>b</code>, and a ‘next stepper’” — the <code>b</code> is the result, and the <code>Auto a b</code> contains the information on how to proceed from then on.</p>
<p>If you’ve been doing Haskell for any decent amount of time, you can probably guess what’s going to happen next!</p>
<p>Instead of “purely” creating a naked result and a “next step”…we’re going to return it in a context.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>a <span class="ot">-&gt;</span> f (b, <span class="dt">Auto</span> a b)</span></code></pre></div>
<p>What, you say? What good does that do?</p>
<p>Well, what does returning things in a context <em>ever</em> let you do?</p>
<p>In Haskell, contexts like these are usually meant to be able to defer the process of “getting the value” until the end, after you’ve built up your contextual computation. This process can be complicated, or simple, or trivial.</p>
<p>For example, a function like:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>a <span class="ot">-&gt;</span> b</span></code></pre></div>
<p>means that it simply creates a <code>b</code> from an <code>a</code>. But a function like:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>a <span class="ot">-&gt;</span> <span class="dt">State</span> s b</span></code></pre></div>
<p>Means that, given an <code>a</code>, you get a state machine that can <em>create a <code>b</code></em> using a stateful process, once given an initial state. The <code>b</code> doesn’t “exist” yet; all you’ve given is instructions for creating that <code>b</code>…and the <code>b</code> that is eventually created will in general depend on whatever initial <code>s</code> you give the state machine.</p>
<p>A function like:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>a <span class="ot">-&gt;</span> <span class="dt">IO</span> b</span></code></pre></div>
<p>Means that, given an <code>a</code>, you’re given <em>a computer program</em> that, when executed by a computer, will generate a <code>b</code>. The <code>b</code> doesn’t “exist” yet; depending on how the world is and how IO processes interact, how you are feeling that day…the <code>b</code> generated will be different. The process of IO execution has the ability to <em>choose</em> the <code>b</code>.</p>
<p>So how about something like:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>a <span class="ot">-&gt;</span> <span class="dt">State</span> s (b, <span class="dt">Auto</span> a b)</span></code></pre></div>
<p>This means that, given <code>a</code>, “running” the <code>Auto</code> with an <code>a</code> will give you <em>a state machine</em> that gives you, using a stateful process, both the <em>result</em> and the <em>next step</em>. The crazy thing is that now you are given the state machine <em>the ability to decide the next <code>Auto</code></em>, the next “step”.</p>
<p>Something like:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>a <span class="ot">-&gt;</span> <span class="dt">IO</span> (b, <span class="dt">Auto</span> a b)</span></code></pre></div>
<p>means that your new <code>Auto</code>-running function will give you a result and a “next step” that is going to be dependent on IO actions.</p>
<p>Let’s jump straight to abstracting over this and explore a new type, shall we?</p>
<h3 id="monadic-auto">Monadic Auto</h3>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/machines/Auto3.hs#L27-L27</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">AutoM</span> m a b <span class="ot">=</span> <span class="dt">AConsM</span> {<span class="ot"> runAutoM ::</span> a <span class="ot">-&gt;</span> m (b, <span class="dt">AutoM</span> m a b) }</span></code></pre></div>
<p>We already explained earlier the new power of this type. Let’s see if we can write our favorite instances with it. First of all, what would a <code>Category</code> instance even do?</p>
<p>Recall that the previous <code>Category</code> instance “ticked” each <code>Auto</code> one after the other and gave the final results, and then the “next Auto” was the compositions of the ticked autos.</p>
<p>In our new type, the “ticking” happens <em>in a context</em>. And we need to tick twice; and the second one is dependent on the result of the first. This means that your context has to be <em>monadic</em> in order to allow you to do this.</p>
<p>So we sequence two “ticks” inside the monadic context, and then return the result afterwards, with the new composed autos.</p>
<p>The neat thing is that Haskell’s built-in syntax for handling monadic sequencing is nice, so you might be surprised when you write the <code>Category</code> instance:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/machines/Auto3.hs#L43-L48</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">Category</span> (<span class="dt">AutoM</span> m) <span class="kw">where</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>    <span class="fu">id</span>    <span class="ot">=</span> <span class="dt">AConsM</span> <span class="op">$</span> \x <span class="ot">-&gt;</span> <span class="fu">return</span> (x, <span class="fu">id</span>)</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>    g <span class="op">.</span> f <span class="ot">=</span> <span class="dt">AConsM</span> <span class="op">$</span> \x <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>              (y, f&#39;) <span class="ot">&lt;-</span> runAutoM f x</span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>              (z, g&#39;) <span class="ot">&lt;-</span> runAutoM g y</span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>              <span class="fu">return</span> (z, g&#39; <span class="op">.</span> f&#39;)</span></code></pre></div>
<p>Does it look familiar?</p>
<p>It should! Remember the logic from the <code>Auto</code> Category instance?</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/machines/Auto2.hs#L13-L18</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Category</span> <span class="dt">Auto</span> <span class="kw">where</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>    <span class="fu">id</span>    <span class="ot">=</span> <span class="dt">ACons</span> <span class="op">$</span> \x <span class="ot">-&gt;</span> (x, <span class="fu">id</span>)</span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>    g <span class="op">.</span> f <span class="ot">=</span> <span class="dt">ACons</span> <span class="op">$</span> \x <span class="ot">-&gt;</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>              <span class="kw">let</span> (y, f&#39;) <span class="ot">=</span> runAuto f x</span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>                  (z, g&#39;) <span class="ot">=</span> runAuto g y</span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>              <span class="kw">in</span>  (z, g&#39; <span class="op">.</span> f&#39;)</span></code></pre></div>
<p>It’s basically <em>identical</em> and exactly the same :O The only difference is that instead of <code>let</code>, we have <code>do</code>…instead of <code>=</code> we have <code>&lt;-</code>, and instead of <code>in</code> we have <code>return</code>. :O</p>
<p>The takeaway here is that when you have monadic functions, their sequencing and application and composition can really be abstracted away to look pretty much like application and composition of normal values. And Haskell is one of the few languages that gives you language features and a culture to be able to fully realize the symmetry and similarities.</p>
<p>Check out the <code>Functor</code> and <code>Arrow</code> instances, too — they’re exactly the same!</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/machines/Auto2.hs#L20-L47</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Functor</span> (<span class="dt">Auto</span> r) <span class="kw">where</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>    <span class="fu">fmap</span> f a <span class="ot">=</span> <span class="dt">ACons</span> <span class="op">$</span> \x <span class="ot">-&gt;</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>                 <span class="kw">let</span> (y, a&#39;) <span class="ot">=</span> runAuto a x</span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>                 <span class="kw">in</span>  (f y, <span class="fu">fmap</span> f a&#39;)</span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Arrow</span> <span class="dt">Auto</span> <span class="kw">where</span></span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a>    arr f     <span class="ot">=</span> <span class="dt">ACons</span> <span class="op">$</span> \x <span class="ot">-&gt;</span> (f x, arr f)</span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a>    first a   <span class="ot">=</span> <span class="dt">ACons</span> <span class="op">$</span> \(x, z) <span class="ot">-&gt;</span></span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a>                  <span class="kw">let</span> (y, a&#39;) <span class="ot">=</span> runAuto a x</span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a>                  <span class="kw">in</span>  ((y, z), first a&#39;)</span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true" tabindex="-1"></a>    second a  <span class="ot">=</span> <span class="dt">ACons</span> <span class="op">$</span> \(z, x) <span class="ot">-&gt;</span></span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true" tabindex="-1"></a>                  <span class="kw">let</span> (y, a&#39;) <span class="ot">=</span> runAuto a x</span>
<span id="cb11-15"><a href="#cb11-15" aria-hidden="true" tabindex="-1"></a>                  <span class="kw">in</span>  ((z, y), second a&#39;)</span>
<span id="cb11-16"><a href="#cb11-16" aria-hidden="true" tabindex="-1"></a>    a1 <span class="op">***</span> a2 <span class="ot">=</span> <span class="dt">ACons</span> <span class="op">$</span> \(x1, x2) <span class="ot">-&gt;</span></span>
<span id="cb11-17"><a href="#cb11-17" aria-hidden="true" tabindex="-1"></a>                  <span class="kw">let</span> (y1, a1&#39;) <span class="ot">=</span> runAuto a1 x1</span>
<span id="cb11-18"><a href="#cb11-18" aria-hidden="true" tabindex="-1"></a>                      (y2, a2&#39;) <span class="ot">=</span> runAuto a2 x2</span>
<span id="cb11-19"><a href="#cb11-19" aria-hidden="true" tabindex="-1"></a>                  <span class="kw">in</span>  ((y1, y2), a1&#39; <span class="op">***</span> a2&#39;)</span>
<span id="cb11-20"><a href="#cb11-20" aria-hidden="true" tabindex="-1"></a>    a1 <span class="op">&amp;&amp;&amp;</span> a2 <span class="ot">=</span> <span class="dt">ACons</span> <span class="op">$</span> \x <span class="ot">-&gt;</span></span>
<span id="cb11-21"><a href="#cb11-21" aria-hidden="true" tabindex="-1"></a>                  <span class="kw">let</span> (y1, a1&#39;) <span class="ot">=</span> runAuto a1 x</span>
<span id="cb11-22"><a href="#cb11-22" aria-hidden="true" tabindex="-1"></a>                      (y2, a2&#39;) <span class="ot">=</span> runAuto a2 x</span>
<span id="cb11-23"><a href="#cb11-23" aria-hidden="true" tabindex="-1"></a>                  <span class="kw">in</span>  ((y1, y2), a1&#39; <span class="op">&amp;&amp;&amp;</span> a2&#39;)</span></code></pre></div>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/machines/Auto3.hs#L50-L77</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">Functor</span> (<span class="dt">AutoM</span> m r) <span class="kw">where</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>    <span class="fu">fmap</span> f a <span class="ot">=</span> <span class="dt">AConsM</span> <span class="op">$</span> \x <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>                 (y, a&#39;) <span class="ot">&lt;-</span> runAutoM a x</span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>                 <span class="fu">return</span> (f y, <span class="fu">fmap</span> f a&#39;)</span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">Arrow</span> (<span class="dt">AutoM</span> m) <span class="kw">where</span></span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a>    arr f     <span class="ot">=</span> <span class="dt">AConsM</span> <span class="op">$</span> \x <span class="ot">-&gt;</span> <span class="fu">return</span> (f x, arr f)</span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a>    first a   <span class="ot">=</span> <span class="dt">AConsM</span> <span class="op">$</span> \(x, z) <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a>                  (y, a&#39;) <span class="ot">&lt;-</span> runAutoM a x</span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a>                  <span class="fu">return</span> ((y, z), first a&#39;)</span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true" tabindex="-1"></a>    second a  <span class="ot">=</span> <span class="dt">AConsM</span> <span class="op">$</span> \(z, x) <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb12-14"><a href="#cb12-14" aria-hidden="true" tabindex="-1"></a>                  (y, a&#39;) <span class="ot">&lt;-</span> runAutoM a x</span>
<span id="cb12-15"><a href="#cb12-15" aria-hidden="true" tabindex="-1"></a>                  <span class="fu">return</span> ((z, y), second a&#39;)</span>
<span id="cb12-16"><a href="#cb12-16" aria-hidden="true" tabindex="-1"></a>    a1 <span class="op">***</span> a2 <span class="ot">=</span> <span class="dt">AConsM</span> <span class="op">$</span> \(x1, x2) <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb12-17"><a href="#cb12-17" aria-hidden="true" tabindex="-1"></a>                  (y1, a1&#39;) <span class="ot">&lt;-</span> runAutoM a1 x1</span>
<span id="cb12-18"><a href="#cb12-18" aria-hidden="true" tabindex="-1"></a>                  (y2, a2&#39;) <span class="ot">&lt;-</span> runAutoM a2 x2</span>
<span id="cb12-19"><a href="#cb12-19" aria-hidden="true" tabindex="-1"></a>                  <span class="fu">return</span> ((y1, y2), a1&#39; <span class="op">***</span> a2&#39;)</span>
<span id="cb12-20"><a href="#cb12-20" aria-hidden="true" tabindex="-1"></a>    a1 <span class="op">&amp;&amp;&amp;</span> a2 <span class="ot">=</span> <span class="dt">AConsM</span> <span class="op">$</span> \x <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb12-21"><a href="#cb12-21" aria-hidden="true" tabindex="-1"></a>                  (y1, a1&#39;) <span class="ot">&lt;-</span> runAutoM a1 x</span>
<span id="cb12-22"><a href="#cb12-22" aria-hidden="true" tabindex="-1"></a>                  (y2, a2&#39;) <span class="ot">&lt;-</span> runAutoM a2 x</span>
<span id="cb12-23"><a href="#cb12-23" aria-hidden="true" tabindex="-1"></a>                  <span class="fu">return</span> ((y1, y2), a1&#39; <span class="op">&amp;&amp;&amp;</span> a2&#39;)</span></code></pre></div>
<p>(I’ve left the rest of the instances from the previous part as an exercise; the solutions are available in the downloadable.)</p>
<p>Neat, huh? Instead of having to learn over again the logic of <code>Functor</code>, <code>Applicative</code>, <code>Arrow</code>, <code>ArrowPlus</code>, etc., you can directly use the intuition that you gained from the past part and apply it to here, if you abstract away function application and composition to application and composition in a context.</p>
<p>Our previous instances were then just a “specialized” version of <code>AutoM</code>, one where we used naked application and composition,<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a></p>
<div class="note">
<p><strong>Aside</strong></p>
<p>If you look at the instances we wrote out, you might see that for some of them, <code>Monad</code> is a bit overkill. For example, for the <code>Functor</code> instance,</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Functor</span> m <span class="ot">=&gt;</span> <span class="dt">Functor</span> (<span class="dt">AutoM</span> m r) <span class="kw">where</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>    <span class="fu">fmap</span> f a <span class="ot">=</span> <span class="dt">AConsM</span> <span class="op">$</span> (f <span class="op">***</span> <span class="fu">fmap</span> f) <span class="op">.</span> runAutoM a</span></code></pre></div>
<p>is just fine. We only need <code>Functor</code> to make <code>AutoM m r</code> a <code>Functor</code>. Cool, right?</p>
<p>If you try, how much can we “generalize” our other instances to? Which ones can be generalized to <code>Functor</code>, which ones <code>Applicative</code>…and which ones can’t?</p>
</div>
<p>By the way, it might be worth noting that our original <code>Auto</code> type is identical to <code>AutoM Identity</code> — all of the instances do the exact same thing.</p>
<h3 id="putting-it-to-use">Putting it to use</h3>
<p>Now let’s try using these!</p>
<p>First some utility functions just for playing around: <code>autoM</code>, which upgrades an <code>Auto a b</code> to an <code>AutoM m a b</code> for any <code>Monad</code> <code>m</code><a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a>, and <code>arrM</code>, which is like <code>arr</code>, but instead of turning an <code>a -&gt; b</code> into an <code>Auto a b</code>, it turns an <code>a -&gt; m b</code> into an <code>AutoM m a b</code>:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/machines/Auto3.hs#L97-L107</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a><span class="ot">autoM ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">Auto</span> a b <span class="ot">-&gt;</span> <span class="dt">AutoM</span> m a b</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>autoM a <span class="ot">=</span> <span class="dt">AConsM</span> <span class="op">$</span> \x <span class="ot">-&gt;</span> <span class="kw">let</span> (y, a&#39;) <span class="ot">=</span> runAuto a x</span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>                         <span class="kw">in</span>  <span class="fu">return</span> (y, autoM a&#39;)</span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a><span class="ot">arrM ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> m b) <span class="ot">-&gt;</span> <span class="dt">AutoM</span> m a b</span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a>arrM f <span class="ot">=</span> <span class="dt">AConsM</span> <span class="op">$</span> \x <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a>                    y <span class="ot">&lt;-</span> f x</span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a>                    <span class="fu">return</span> (y, arrM f)</span></code></pre></div>
<p>We will need to of course re-write our trusty <a href="https://github.com/mstksg/inCode/tree/master/code-samples/machines/Auto.hs#L17-L25"><code>testAuto</code></a> functions from the first entry, which is again a direct translation of the original ones:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/machines/Auto3.hs#L31-L39</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a><span class="ot">testAutoM ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">AutoM</span> m a b <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> m ([b], <span class="dt">AutoM</span> m a b)</span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>testAutoM a []      <span class="ot">=</span> <span class="fu">return</span> ([], a)</span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>testAutoM a (x<span class="op">:</span>xs)  <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a>    (y , a&#39; ) <span class="ot">&lt;-</span> runAutoM a x</span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a>    (ys, a&#39;&#39;) <span class="ot">&lt;-</span> testAutoM a&#39; xs</span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a>    <span class="fu">return</span> (y<span class="op">:</span>ys, a&#39;&#39;)</span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a><span class="ot">testAutoM_ ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">AutoM</span> m a b <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> m [b]</span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true" tabindex="-1"></a>testAutoM_ a <span class="ot">=</span> liftM <span class="fu">fst</span> <span class="op">.</span> testAutoM a</span></code></pre></div>
<p>First, let’s test <code>arrM</code> —</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> <span class="op">:</span>t arrM <span class="fu">putStrLn</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>arrM<span class="ot"> putStrLn ::</span> <span class="dt">AutoM</span> <span class="dt">IO</span> <span class="dt">String</span> ()</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> res <span class="ot">&lt;-</span> testAutoM_ (arrM <span class="fu">putStrLn</span>) [<span class="st">&quot;hello&quot;</span>, <span class="st">&quot;world&quot;</span>]</span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a><span class="st">&quot;hello&quot;</span></span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a><span class="st">&quot;world&quot;</span></span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> res</span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a>[(), ()]</span></code></pre></div>
<p><code>arrM putStrLn</code> is, like <code>arr show</code>, just an <code>Auto</code> with no internal state. It outputs <code>()</code> for every single input string, except, in the process of getting the “next Auto” (and producing the <code>()</code>), it emits a side-effect — in our case, printing the string.</p>
<h4 id="in-io">in IO</h4>
<p>We can sort of abuse this to get an <code>Auto</code> with “two input streams”: one from the normal input, and the other from <code>IO</code>:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/machines/Auto3.hs#L119-L123</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a><span class="ot">replicateGets ::</span> <span class="dt">AutoM</span> <span class="dt">IO</span> <span class="dt">Int</span> <span class="dt">String</span></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>replicateGets <span class="ot">=</span> proc n <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>    ioString <span class="ot">&lt;-</span> arrM (\_ <span class="ot">-&gt;</span> <span class="fu">getLine</span>) <span class="op">-&lt;</span> ()</span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> inpStr <span class="ot">=</span> <span class="fu">concat</span> (<span class="fu">replicate</span> n ioString)</span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a>    autoM monoidAccum <span class="op">-&lt;</span> inpStr</span></code></pre></div>
<p>So, <code>replicateGets</code> uses <a href="https://github.com/mstksg/inCode/tree/master/code-samples/machines/Auto.hs#L106-L107"><code>monoidAccum</code></a> (or, an <code>AutoM</code> version) to accumulate a string. At every step, it adds <code>inpStr</code> to the running accumulated string. <code>inpStr</code> is the result of repeating the the string that <code>getLine</code> returns replicated <code>n</code> times — <code>n</code> being the official “input” to the <code>AutoM</code> when we eventually run it.</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> testAutoM_ replicateGets [<span class="dv">3</span>,<span class="dv">1</span>,<span class="dv">5</span>]</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;</span> hello</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;</span> world</span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;</span> bye</span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>[ <span class="st">&quot;hellohellohello&quot;</span>         <span class="co">-- added &quot;hello&quot; three times</span></span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a>, <span class="st">&quot;hellohellohelloworld&quot;</span>    <span class="co">-- added &quot;world&quot; once</span></span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a>, <span class="st">&quot;hellohellohelloworldbyebyebyebyebye&quot;</span>     <span class="co">-- added &quot;bye&quot; five times</span></span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a>]</span></code></pre></div>
<p>Here, we used <code>IO</code> to get a “side channel input”. The main input is the number of times we repeat the string, and the side input is what we get from sequencing the <code>getLine</code> effect.</p>
<p>You can also use this to “tack on” effects into your pipeline.</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/machines/Auto3.hs#L127-L131</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a><span class="ot">logging ::</span> <span class="dt">Show</span> b <span class="ot">=&gt;</span> <span class="dt">Auto</span> a b <span class="ot">-&gt;</span> <span class="dt">AutoM</span> <span class="dt">IO</span> a b</span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>logging a <span class="ot">=</span> proc x <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>    y <span class="ot">&lt;-</span> autoM a <span class="op">-&lt;</span> x</span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a>    arrM (<span class="fu">appendFile</span> <span class="st">&quot;log.txt&quot;</span>) <span class="op">-&lt;</span> <span class="fu">show</span> y <span class="op">++</span> <span class="st">&quot;\n&quot;</span></span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a>    <span class="fu">id</span> <span class="op">-&lt;</span> y</span></code></pre></div>
<p>Here, <code>logging a</code> will “run” <code>a</code> with the input like normal (no side-channel inputs), but then also log the results line-by-line to <em>log.txt</em>.</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> testAutoM_ (logging summer) [<span class="dv">6</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">1</span>]</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>[<span class="dv">6</span>,<span class="dv">8</span>,<span class="dv">11</span>,<span class="dv">15</span>,<span class="dv">16</span>]</span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> <span class="fu">putStrLn</span> <span class="op">=&lt;&lt;</span> <span class="fu">readFile</span> <span class="st">&quot;log.txt&quot;</span></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a><span class="dv">6</span></span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a><span class="dv">8</span></span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a><span class="dv">11</span></span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a><span class="dv">15</span></span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true" tabindex="-1"></a><span class="dv">16</span></span></code></pre></div>
<p>(By the way, as a side note, <code>logging :: Auto a b -&gt; AutoM IO a b</code> here can be looked at as an “<code>Auto</code> transformer”. It takes a normal <code>Auto</code> and transforms it into an otherwise identical <code>Auto</code>, yet which logs its results as it ticks on.)</p>
<h4 id="motivations">Motivations</h4>
<p>At this point, hopefully you are either excited about the possibilities that monadic <code>Auto</code> composition/ticking offers, or are horribly revolted at how we mixed IO and unconstrained effects and “implicit side channel” inputs. Or both!</p>
<p>After all, if all we were doing in <code>replicateGets</code> was having two inputs, we could have just used:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="ot">replicateGets&#39; ::</span> <span class="dt">Auto</span> (<span class="dt">String</span>, <span class="dt">Int</span>) <span class="dt">String</span></span></code></pre></div>
<p>And have the user “get” the string before they run the <code>Auto</code>.</p>
<p>And hey, if all we were doing in <code>logging</code> was having an extra logging channel, we could have just manually logged all of the outputs as they popped out.</p>
<p>All valid suggestions. Separate the pure from the impure. We went out of our way to avoid <em>global</em> states and side-effects, so why bother to bring it all back?</p>
<p>Superficially, it might seem like just moving the burden from one place to the other. Instead of having the user having to worry about getting the string, or writing the log, the <code>Auto</code> can just handle it itself internally without the “running” code having to worry.</p>
<p>The real, deep advantage in <code>AutoM</code>, however, is — like in <code>Auto</code> — its (literal) <em>composability</em>.</p>
<p>Imagine <code>replicateGets'</code> was not our “final <code>Auto</code>” that we run…imagine it was in fact an <code>Auto</code> used in a composition inside the definition of an <code>Auto</code> used several times inside a composition inside the definition of another <code>Auto</code>. All of a sudden, having to “manually thread” the extra channel of input in is a real nightmare. In addition, you can’t even statically guarantee that the <code>String</code> <code>replicateGets</code> eventually was the same <code>String</code> that the user originally passed in. When composing/calling it, who knows if the Auto that composes <code>replicateGets'</code> passes in the same initially gotten String?<a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a></p>
<p>Imagine that the <code>Auto</code> whose results we wanted to log actually was not the final output of the entire <code>Auto</code> we run (maybe we want to log a small internal portion of a big <code>Auto</code>). Again, now you have to manually thread the <em>output</em>. And if you’re logging several things through several layers — it gets ugly very fast.</p>
<p>And now, all of your other <code>Auto</code>s in the composition get to (and <em>have</em> to) see the values of the log! So much for “locally stateful”!</p>
<p>As you can see, there is a trade-off in either decision we make. But these monadic compositions really just give us another tool in our toolset that we can (judiciously) use.</p>
<h4 id="other-contexts">Other contexts</h4>
<p>It’s fun to imagine what sort of implications the different popular monads in Haskell can provide. <code>Writer</code> gives you a running log that all <code>Auto</code>s can append to, for example. <code>Reader</code> gives you every composed <code>Auto</code> the ability to access a shared global environment…and has an advantage over manual “passing in” of parameters because every composed <code>Auto</code> is guaranteed to “see” the same global environment per tick.</p>
<p><code>State</code> gives every composed <code>Auto</code> the ability to access and modify a globally shared state. We talk a lot about every <code>Auto</code> having their own local, internal state; usually, it is impossible for two composed <code>Auto</code>s to directly access each other’s state (except by communicating through output and input). With <code>State</code>, we now give the opportunity for every <code>Auto</code> to share and modify a collective and global state, which they can use to determine how to proceed, etc.</p>
<p>Good? Bad? Uncontrollable, unpredictable? Perhaps. You now bring in all of the problems of shared state and reasoning with shared mutable state…and avoiding these problems was one of the things that originally motivated the usage of <code>Auto</code> in the first place! But, we can make sound and judicious decisions without resorting to “never do this” dogma.<a href="#fn5" class="footnote-ref" id="fnref5" role="doc-noteref"><sup>5</sup></a> Remember, these are just tools we can possibly explore. Whether or not they work in the real world — or whether or not they are self-defeating — is a complex story!</p>
<h4 id="in-state">in State</h4>
<p>Here is a toy state example to demonstrate different autos talking to each other; here, the state is a measure of “fuel”; we can take any <code>Auto a b</code> and give it a “cost” using the <code>limit</code> function defined here. Here, every <code>Auto</code> consumes fuel from the same pool, given at the initial <code>runState</code> running.</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/machines/Auto3.hs#L139-L175</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a><span class="ot">limit ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Auto</span> a b <span class="ot">-&gt;</span> <span class="dt">AutoM</span> (<span class="dt">State</span> <span class="dt">Int</span>) a (<span class="dt">Maybe</span> b)</span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a>limit cost a <span class="ot">=</span> proc x <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a>    fuel <span class="ot">&lt;-</span> arrM (\_ <span class="ot">-&gt;</span> get) <span class="op">-&lt;</span> ()</span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span> fuel <span class="op">&gt;=</span> cost</span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true" tabindex="-1"></a>      <span class="kw">then</span> <span class="kw">do</span></span>
<span id="cb22-8"><a href="#cb22-8" aria-hidden="true" tabindex="-1"></a>        arrM (\_ <span class="ot">-&gt;</span> modify (<span class="fu">subtract</span> cost)) <span class="op">-&lt;</span> ()</span>
<span id="cb22-9"><a href="#cb22-9" aria-hidden="true" tabindex="-1"></a>        y <span class="ot">&lt;-</span> autoM a <span class="op">-&lt;</span> x</span>
<span id="cb22-10"><a href="#cb22-10" aria-hidden="true" tabindex="-1"></a>        <span class="fu">id</span> <span class="op">-&lt;</span> <span class="dt">Just</span> y</span>
<span id="cb22-11"><a href="#cb22-11" aria-hidden="true" tabindex="-1"></a>      <span class="kw">else</span></span>
<span id="cb22-12"><a href="#cb22-12" aria-hidden="true" tabindex="-1"></a>        <span class="fu">id</span> <span class="op">-&lt;</span> <span class="dt">Nothing</span></span>
<span id="cb22-13"><a href="#cb22-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-14"><a href="#cb22-14" aria-hidden="true" tabindex="-1"></a><span class="ot">sumSqDiff ::</span> <span class="dt">AutoM</span> (<span class="dt">State</span> <span class="dt">Int</span>) <span class="dt">Int</span> <span class="dt">Int</span></span>
<span id="cb22-15"><a href="#cb22-15" aria-hidden="true" tabindex="-1"></a>sumSqDiff <span class="ot">=</span> proc x <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb22-16"><a href="#cb22-16" aria-hidden="true" tabindex="-1"></a>  sums   <span class="ot">&lt;-</span> fromMaybe <span class="dv">0</span> <span class="op">&lt;$&gt;</span> limit <span class="dv">3</span> summer <span class="op">-&lt;</span> x</span>
<span id="cb22-17"><a href="#cb22-17" aria-hidden="true" tabindex="-1"></a>  sumSqs <span class="ot">&lt;-</span> fromMaybe <span class="dv">0</span> <span class="op">&lt;$&gt;</span> limit <span class="dv">1</span> summer <span class="op">-&lt;</span> x<span class="op">^</span><span class="dv">2</span></span>
<span id="cb22-18"><a href="#cb22-18" aria-hidden="true" tabindex="-1"></a>  <span class="fu">id</span> <span class="op">-&lt;</span> sumSqs <span class="op">-</span> sums</span>
<span id="cb22-19"><a href="#cb22-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-20"><a href="#cb22-20" aria-hidden="true" tabindex="-1"></a><span class="ot">stuff ::</span> <span class="dt">AutoM</span> (<span class="dt">State</span> <span class="dt">Int</span>) <span class="dt">Int</span> (<span class="dt">Maybe</span> <span class="dt">Int</span>, <span class="dt">Maybe</span> <span class="dt">Int</span>, <span class="dt">Int</span>)</span>
<span id="cb22-21"><a href="#cb22-21" aria-hidden="true" tabindex="-1"></a>stuff <span class="ot">=</span> proc x <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb22-22"><a href="#cb22-22" aria-hidden="true" tabindex="-1"></a>    doubled <span class="ot">&lt;-</span> limit <span class="dv">1</span> <span class="fu">id</span> <span class="op">-&lt;</span> x <span class="op">*</span> <span class="dv">2</span></span>
<span id="cb22-23"><a href="#cb22-23" aria-hidden="true" tabindex="-1"></a>    tripled <span class="ot">&lt;-</span> <span class="kw">if</span> <span class="fu">even</span> x</span>
<span id="cb22-24"><a href="#cb22-24" aria-hidden="true" tabindex="-1"></a>                 <span class="kw">then</span> limit <span class="dv">2</span> <span class="fu">id</span> <span class="op">-&lt;</span> x <span class="op">*</span> <span class="dv">3</span></span>
<span id="cb22-25"><a href="#cb22-25" aria-hidden="true" tabindex="-1"></a>                 <span class="kw">else</span> <span class="fu">id</span>         <span class="op">-&lt;</span> <span class="dt">Just</span> (x <span class="op">*</span> <span class="dv">3</span>)</span>
<span id="cb22-26"><a href="#cb22-26" aria-hidden="true" tabindex="-1"></a>    sumSqD  <span class="ot">&lt;-</span> sumSqDiff <span class="op">-&lt;</span> x</span>
<span id="cb22-27"><a href="#cb22-27" aria-hidden="true" tabindex="-1"></a>    <span class="fu">id</span> <span class="op">-&lt;</span> (doubled, tripled, sumSqD)</span></code></pre></div>
<div class="sourceCode" id="cb23"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- a State machine returning the result and the next Auto</span></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> <span class="kw">let</span> stuffState  <span class="ot">=</span> runAutoM stuff <span class="dv">4</span></span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a><span class="co">-- a State machine returning the result</span></span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> <span class="kw">let</span> stuffState_ <span class="ot">=</span> <span class="fu">fst</span> <span class="op">&lt;$&gt;</span> stuffState</span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> <span class="op">:</span>t stuffState_</span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true" tabindex="-1"></a><span class="ot">stuffState_ ::</span> <span class="dt">State</span> <span class="dt">Int</span> (<span class="dt">Maybe</span> <span class="dt">Int</span>, <span class="dt">Maybe</span> <span class="dt">Int</span>, <span class="dt">Int</span>)</span>
<span id="cb23-7"><a href="#cb23-7" aria-hidden="true" tabindex="-1"></a><span class="co">-- start with 10 fuel</span></span>
<span id="cb23-8"><a href="#cb23-8" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> runState stuffState_ <span class="dv">10</span></span>
<span id="cb23-9"><a href="#cb23-9" aria-hidden="true" tabindex="-1"></a>((<span class="dt">Just</span> <span class="dv">8</span>, <span class="dt">Just</span> <span class="dv">12</span>, <span class="dv">12</span>),   <span class="dv">3</span>)        <span class="co">-- end up with 3 fuel left</span></span>
<span id="cb23-10"><a href="#cb23-10" aria-hidden="true" tabindex="-1"></a><span class="co">-- start with 2 fuel</span></span>
<span id="cb23-11"><a href="#cb23-11" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> runState stuffState_ <span class="dv">2</span></span>
<span id="cb23-12"><a href="#cb23-12" aria-hidden="true" tabindex="-1"></a>((<span class="dt">Just</span> <span class="dv">8</span>, <span class="dt">Nothing</span>, <span class="dv">16</span>),   <span class="dv">0</span>)        <span class="co">-- poop out halfway</span></span></code></pre></div>
<p>You can see that an initial round with an even number should cost you seven fuel…if you can get to the end. In the case where we only started with two fuel, we only were able to get to the “doubled” part before running out of fuel.</p>
<p>Let’s see what happens if we run it several times:</p>
<pre class="hasell"><code>ghci&gt; let stuffStateMany = testAutoM_ stuff [3..6]
ghci&gt; :t stuffStateMany
stuffStateMany :: State Int [(Maybe Int, Maybe Int, Int)]
ghci&gt; runState stuffStateMany 9
( [ (Just 6 , Just 9 , 6 )
  , (Just 8 , Just 12, 25)
  , (Nothing, Just 15, 0 )
  , (Nothing, Nothing, 0 ) ]
, 0 )</code></pre>
<p>So starting with nine fuel, we seem to run out halfway through the second step. The third field should be the sum of the squares so far, minus the sum so far…at <code>25</code>, it’s probably just the sum of the squares so far. So it couldn’t even subtract out the sum so far. Note that the <code>Just 15</code> on the third step goes through because for <em>odd</em> inputs (5, in this case), the second field doesn’t require any fuel.</p>
<p>Anyways, imagine having to thread this global state through by hand. Try it. It’d be a disaster! Everything would have to take an extra parameter and get and extra parameter…it really is quite a headache. Imagine the source for <code>stuff</code> being written out in <code>Auto</code> with manual state threading.</p>
<p>But hey, if your program needs global state, then it’s probably a good sign that you might have had a design flaw somewhere along the way, right?</p>
<h4 id="in-reader">in Reader</h4>
<p>Here we use <code>Reader</code> to basically give a “second argument” to an <code>Auto</code> when we eventually run it, but we use the fact that every composed <code>Auto</code> gets the <em>exact same</em> input to great effect:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/machines/Auto3.hs#L199-L234</span></span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a><span class="ot">integral ::</span> <span class="dt">Double</span> <span class="ot">-&gt;</span> <span class="dt">AutoM</span> (<span class="dt">Reader</span> <span class="dt">Double</span>) <span class="dt">Double</span> <span class="dt">Double</span></span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a>integral x0 <span class="ot">=</span> <span class="dt">AConsM</span> <span class="op">$</span> \dx <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a>                dt <span class="ot">&lt;-</span> ask</span>
<span id="cb25-6"><a href="#cb25-6" aria-hidden="true" tabindex="-1"></a>                <span class="kw">let</span> x1 <span class="ot">=</span> x0 <span class="op">+</span> dx <span class="op">*</span> dt</span>
<span id="cb25-7"><a href="#cb25-7" aria-hidden="true" tabindex="-1"></a>                <span class="fu">return</span> (x1, integral x1)</span>
<span id="cb25-8"><a href="#cb25-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-9"><a href="#cb25-9" aria-hidden="true" tabindex="-1"></a><span class="ot">derivative ::</span> <span class="dt">AutoM</span> (<span class="dt">Reader</span> <span class="dt">Double</span>) <span class="dt">Double</span> (<span class="dt">Maybe</span> <span class="dt">Double</span>)</span>
<span id="cb25-10"><a href="#cb25-10" aria-hidden="true" tabindex="-1"></a>derivative <span class="ot">=</span> <span class="dt">AConsM</span> <span class="op">$</span> \x <span class="ot">-&gt;</span> <span class="fu">return</span> (<span class="dt">Nothing</span>, derivative&#39; x)</span>
<span id="cb25-11"><a href="#cb25-11" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb25-12"><a href="#cb25-12" aria-hidden="true" tabindex="-1"></a>                 <span class="co">-- x0 is the &quot;previous input&quot;</span></span>
<span id="cb25-13"><a href="#cb25-13" aria-hidden="true" tabindex="-1"></a>    derivative&#39; x0 <span class="ot">=</span> <span class="dt">AConsM</span> <span class="op">$</span> \x1 <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb25-14"><a href="#cb25-14" aria-hidden="true" tabindex="-1"></a>                       <span class="kw">let</span> dx <span class="ot">=</span> x1 <span class="op">-</span> x0</span>
<span id="cb25-15"><a href="#cb25-15" aria-hidden="true" tabindex="-1"></a>                       dt <span class="ot">&lt;-</span> ask</span>
<span id="cb25-16"><a href="#cb25-16" aria-hidden="true" tabindex="-1"></a>                       <span class="fu">return</span> (<span class="dt">Just</span> (dx<span class="op">/</span>dt), derivative&#39; x1)</span>
<span id="cb25-17"><a href="#cb25-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-18"><a href="#cb25-18" aria-hidden="true" tabindex="-1"></a><span class="ot">fancyCalculus ::</span> <span class="dt">AutoM</span> (<span class="dt">Reader</span> <span class="dt">Double</span>) <span class="dt">Double</span> (<span class="dt">Double</span>, <span class="dt">Double</span>)</span>
<span id="cb25-19"><a href="#cb25-19" aria-hidden="true" tabindex="-1"></a>fancyCalculus <span class="ot">=</span> proc x <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb25-20"><a href="#cb25-20" aria-hidden="true" tabindex="-1"></a>    deriv  <span class="ot">&lt;-</span> fromMaybe <span class="dv">0</span> <span class="op">&lt;$&gt;</span> derivative <span class="op">-&lt;</span> x</span>
<span id="cb25-21"><a href="#cb25-21" aria-hidden="true" tabindex="-1"></a>    deriv2 <span class="ot">&lt;-</span> fromMaybe <span class="dv">0</span> <span class="op">&lt;$&gt;</span> derivative <span class="op">-&lt;</span> deriv</span>
<span id="cb25-22"><a href="#cb25-22" aria-hidden="true" tabindex="-1"></a>    intdev <span class="ot">&lt;-</span>                 integral <span class="dv">0</span> <span class="op">-&lt;</span> deriv</span>
<span id="cb25-23"><a href="#cb25-23" aria-hidden="true" tabindex="-1"></a>    <span class="fu">id</span> <span class="op">-&lt;</span> (deriv2, intdev)</span></code></pre></div>
<p>Now, we are treating our input stream as time-varying values, and the “Reader environment” contains the “time passed since the last tick” — The time step or sampling rate, so to speak, of the input stream. We have two stateful <code>Auto</code>s (“locally stateful”, internal state) that compute the time integral and time derivative of the input stream of numbers…but in order to do so, it needs the time step. We get it using <code>ask</code>. (Note that the time step doesn’t have to be the same between every different tick … <code>integral</code> and <code>derivative</code> should work just fine with a new timestep every tick.) (Also note that <code>derivative</code> is <code>Nothing</code> on its first step, because there is not yet any meaningful derivative on the first input)</p>
<p>In <code>fancyCalculus</code>, we calculate the integral, the derivative, the second derivative, and the integral of the derivative, and return the second derivative and the integral of the derivative.</p>
<p>In order for us to even <em>meaningfully say</em> “the second derivative” or “the integral of the derivative”, the double derivative has to be calculated with the same time step, and the integral and the derivative have to be calculated with the same time step. If they are fed different time steps, then we aren’t really calculating a real second derivative or a real integral of a derivative anymore. We’re just calculating arbitrary numbers.</p>
<p>Anyways, if you have taken any introduction to calculus course, you’ll know that the integral of a derivative is the original function — so the integral of the derivative, if we pick the right <code>x0</code>, should just be an “id” function:</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a>integral x0 <span class="op">.</span> derivative <span class="op">==</span> <span class="fu">id</span>      <span class="co">-- or off by a constant difference</span></span></code></pre></div>
<p>Let’s try this out with some input streams where we know what the second derivative should be, too.</p>
<p>We’ll try it first with <code>x^2</code>, where we know the second derivative will just be 2, the entire time:</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> <span class="kw">let</span> x2s <span class="ot">=</span> <span class="fu">map</span> (<span class="op">^</span><span class="dv">2</span>) [<span class="dv">0</span>,<span class="fl">0.05</span><span class="op">..</span><span class="dv">1</span>]</span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> <span class="kw">let</span> x2Reader <span class="ot">=</span> testAutoM_ fancyCalculus x2s</span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> <span class="op">:</span>t x2Reader</span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a><span class="ot">x2Reader ::</span> <span class="dt">Reader</span> <span class="dt">Double</span> [(<span class="dt">Double</span>, <span class="dt">Double</span>)]</span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> <span class="fu">map</span> <span class="fu">fst</span> (runReader x2Reader <span class="fl">0.05</span>)</span>
<span id="cb27-6"><a href="#cb27-6" aria-hidden="true" tabindex="-1"></a>[ <span class="op">...</span> <span class="fl">2.0</span>, <span class="fl">2.0</span> <span class="op">...</span> ]    <span class="co">-- with a couple of &quot;stabilizing&quot; first terms</span></span>
<span id="cb27-7"><a href="#cb27-7" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> <span class="fu">map</span> <span class="fu">snd</span> (runReader x2Reader <span class="fl">0.05</span>)</span>
<span id="cb27-8"><a href="#cb27-8" aria-hidden="true" tabindex="-1"></a>[ <span class="fl">0.0</span>, <span class="fl">0.0025</span>, <span class="fl">0.01</span>, <span class="fl">0.0225</span>, <span class="fl">0.04</span> <span class="op">...</span>]</span>
<span id="cb27-9"><a href="#cb27-9" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> x2s</span>
<span id="cb27-10"><a href="#cb27-10" aria-hidden="true" tabindex="-1"></a>[ <span class="fl">0.0</span>, <span class="fl">0.0025</span>, <span class="fl">0.01</span>, <span class="fl">0.0225</span>, <span class="fl">0.04</span> <span class="op">...</span>]</span></code></pre></div>
<p>Perfect! The second derivative we expected (all 2’s) showed up, and the integral of the derivative is pretty much exactly the original function.</p>
<p>For fun, try running it with a <code>sin</code> function. The second derivative of <code>sin</code> is <code>netage . sin</code>. Does it end up as expected?</p>
<p>The alternative to using <code>AutoM</code> and <code>Reader</code> here would be to have each composed Auto be manually “passed” the <code>dt</code> timestep. But then we really don’t have any “guarantees”, besides checking ourselves, that every <code>Auto</code> down the road, down every composition, will have the same <code>dt</code>. We can’t say that we really are calculating integrals or derivatives. And plus, it’s pretty messy when literally every one of your composed <code>Auto</code> needs <code>dt</code>.</p>
<h4 id="mixing-worlds">Mixing Worlds</h4>
<p>We talked about a huge drawback of <code>State s</code> — global mutable state is really something that we originally looked to <code>Auto</code> to avoid in the first place. But some portions of logic are much more convenient to write with autos that all have access to a global state.</p>
<p>What if we wanted the best of both worlds? What would that look like?</p>
<p>In Haskell, one common technique we like to use, eloquently stated by Gabriella Gonzalez in her post <a href="http://www.haskellforall.com/2012/09/the-functor-design-pattern.html">the Functor design pattern</a>, is to pick a “common denominator” type, and push all of our other types into it.</p>
<p>We have two fundamentally different options here. We can pick our “main type” to be <code>AutoM (State s)</code> and have global state, and “push” all of our non-global-state Autos into it, or we can pick our “main type” to be <code>Auto</code>, and “seal” our global-state-Autos into non-global-state ones.</p>
<p>For the former, we’d use <code>autoM</code>’s whenever we want to bring our <code>Auto</code>s into <code>AutoM (State s)</code>…or we can always write <code>AutoM</code>’s parameterized over <code>m</code>:</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="ot">summer ::</span> (<span class="dt">Monad</span> m, <span class="dt">Num</span> a) <span class="ot">=&gt;</span> <span class="dt">AutoM</span> m a a</span></code></pre></div>
<p>It is statically guaranteed that <code>summer</code> <em>cannot touch any global state</em>.</p>
<p>For the latter option, we take <code>AutoM (State s)</code>’s that operate on global state and then basically “seal off” their access to be just within their local worlds, as we turn them into <code>Auto</code>’s.</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/machines/Auto3.hs#L182-L192</span></span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a><span class="ot">sealStateAuto ::</span> <span class="dt">AutoM</span> (<span class="dt">State</span> s) a b <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> <span class="dt">Auto</span> a b</span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a>sealStateAuto a s0 <span class="ot">=</span> <span class="dt">ACons</span> <span class="op">$</span> \x <span class="ot">-&gt;</span></span>
<span id="cb29-5"><a href="#cb29-5" aria-hidden="true" tabindex="-1"></a>                       <span class="kw">let</span> ((y, a&#39;), s1) <span class="ot">=</span> runState (runAutoM a x) s0</span>
<span id="cb29-6"><a href="#cb29-6" aria-hidden="true" tabindex="-1"></a>                       <span class="kw">in</span>  (y, sealStateAuto a&#39; s1)</span>
<span id="cb29-7"><a href="#cb29-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-8"><a href="#cb29-8" aria-hidden="true" tabindex="-1"></a><span class="ot">runStateAuto ::</span> <span class="dt">AutoM</span> (<span class="dt">State</span> s) a b <span class="ot">-&gt;</span> <span class="dt">Auto</span> (a, s) (b, s)</span>
<span id="cb29-9"><a href="#cb29-9" aria-hidden="true" tabindex="-1"></a>runStateAuto a <span class="ot">=</span> <span class="dt">ACons</span> <span class="op">$</span> \(x, s) <span class="ot">-&gt;</span></span>
<span id="cb29-10"><a href="#cb29-10" aria-hidden="true" tabindex="-1"></a>                   <span class="kw">let</span> ((y, a&#39;), s&#39;) <span class="ot">=</span> runState (runAutoM a x) s</span>
<span id="cb29-11"><a href="#cb29-11" aria-hidden="true" tabindex="-1"></a>                   <span class="kw">in</span>  ((y, s&#39;), runStateAuto a&#39;)</span></code></pre></div>
<p><code>sealStateAuto</code> does exactly this. Give it an initial state, and the <code>Auto</code> will just continuously feed in its output state at every tick back in as the input state. Every <code>Auto</code> inside now has access to a local state, untouchable from the outside.</p>
<p><code>runStateAuto</code> is a way to do this were you can pass in a new initial state every time you “step” the <code>Auto</code>, and observe how it changes — also another useful use case.</p>
<div class="note">
<p><strong>Aside</strong></p>
<p>We can even pull this trick to turn any <code>AutoM (StateT s m)</code> into an <code>AutoM m</code>. See if you can write it :)</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="ot">sealStateAutoM ::</span> <span class="dt">AutoM</span> (<span class="dt">StateT</span> s m) a b <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> <span class="dt">AutoM</span> m a b</span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a>sealStateAutoM <span class="ot">=</span> <span class="op">...</span></span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true" tabindex="-1"></a><span class="ot">runStateAutoM ::</span> <span class="dt">AutoM</span> (<span class="dt">StateT</span> s m) a b <span class="ot">-&gt;</span> <span class="dt">AutoM</span> m (a, s) (b, s)</span>
<span id="cb30-5"><a href="#cb30-5" aria-hidden="true" tabindex="-1"></a>runStateAutoM <span class="ot">=</span> <span class="op">...</span></span></code></pre></div>
</div>
<p>In both of these methods, what is the real win? The big deal is that you can now chose to “work only in the world of non-global-state”, combining non-global <code>Auto</code>s like we did in part 1 and part 2 to create non-global algorithms. And then you can also chose to “work in the world of global state”, combining global <code>Auto</code>s like we did in the previous section, where having <code>State s</code> made everything more clear.</p>
<p>We’re allowed to live and compose (using <code>Category</code>, proc notation, etc.) in whatever world we like — create as complex compositions as we could even imagine — and at the end of it all, we take the final complex product and “glue it on” to our big overall type so everything can work together.</p>
<p>This discussion is about <code>State</code>, but the ramifications work with almost any <code>Auto</code> or type of <code>Auto</code> or underlying monad we talk about.</p>
<p>We can simulate an “immutable local environment”, for example:</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/machines/Auto3.hs#L248-L251</span></span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a><span class="ot">runReaderAuto ::</span> <span class="dt">AutoM</span> (<span class="dt">Reader</span> r) a b <span class="ot">-&gt;</span> <span class="dt">Auto</span> (a, r) b</span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true" tabindex="-1"></a>runReaderAuto a <span class="ot">=</span> <span class="dt">ACons</span> <span class="op">$</span> \(x, e) <span class="ot">-&gt;</span></span>
<span id="cb31-5"><a href="#cb31-5" aria-hidden="true" tabindex="-1"></a>                    <span class="kw">let</span> (y, a&#39;) <span class="ot">=</span> runReader (runAutoM a x) e</span>
<span id="cb31-6"><a href="#cb31-6" aria-hidden="true" tabindex="-1"></a>                    <span class="kw">in</span>  (y, runReaderAuto a&#39;)</span></code></pre></div>
<p>Now you can use a <code>Reader</code> — composed with “global environment” semantics — inside a normal <code>Auto</code>! Just give it the new environment very step! (Can you write a <code>sealReaderAuto</code> that just takes an initial <code>r</code> and feeds it back in forever?)</p>
<h2 id="recursive-auto">Recursive Auto</h2>
<p>Let’s move back to our normal <code>Auto</code> for now, and imagine a very common use case that might come up.</p>
<p>What if you wanted two chained <code>Auto</code>s to “talk to each other” — for their inputs to depend on the other’s outputs?</p>
<p>Here’s a common example — in control theory, you often have to have adjust an input to a system to get it to “respond” to a certain desired output (a control).</p>
<p>One way is to start with a test input, at every step, observe the resulting response and adjust it up or down until we get the response we want. We call the difference between the response and the control the “error”.</p>
<p>How do you think you would calculate the adjustment? Well…if the error is big, we probably want a big adjustment. And, the longer we are away from the error, we also might want to make a bigger adjustment accordingly, too.</p>
<p>In other words, we might want our adjustment to have a term <em>proportional</em> to the error, and a term that is <em>the sum of all</em> errors so far.</p>
<p>This system is known as <a href="http://en.wikipedia.org/wiki/PID_controller">PI</a>, and is actually used in many industrial control systems today, for controlling things like lasers and other super important stuff. Congrats, you are now a control theorist!</p>
<p>Let’s see how we might write this using our <code>Auto</code>s:</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="ot">piTargeter ::</span> <span class="dt">Auto</span> <span class="dt">Double</span> <span class="dt">Double</span></span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a>piTargeter <span class="ot">=</span> proc control <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> err <span class="ot">=</span> control <span class="op">-</span> response</span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true" tabindex="-1"></a>    errSums  <span class="ot">&lt;-</span> summer         <span class="op">-&lt;</span> err</span>
<span id="cb32-5"><a href="#cb32-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-6"><a href="#cb32-6" aria-hidden="true" tabindex="-1"></a>    input    <span class="ot">&lt;-</span> summer         <span class="op">-&lt;</span> <span class="fl">0.2</span> <span class="op">*</span> err <span class="op">+</span> <span class="fl">0.01</span> <span class="op">*</span> errSums</span>
<span id="cb32-7"><a href="#cb32-7" aria-hidden="true" tabindex="-1"></a>    response <span class="ot">&lt;-</span> blackBoxSystem <span class="op">-&lt;</span> input</span>
<span id="cb32-8"><a href="#cb32-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-9"><a href="#cb32-9" aria-hidden="true" tabindex="-1"></a>    <span class="fu">id</span> <span class="op">-&lt;</span> response</span>
<span id="cb32-10"><a href="#cb32-10" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb32-11"><a href="#cb32-11" aria-hidden="true" tabindex="-1"></a>    blackBoxSystem <span class="ot">=</span> <span class="fu">id</span>     <span class="co">-- to simplify things :)</span></span></code></pre></div>
<p>So this is an <code>Auto</code> that takes in a <code>Double</code> — the control — and outputs a <code>Double</code> — the response. The goal is to get the response to “match” control, by running a value, <code>input</code>, through a “black box system” (To simplify here, we’re only running <code>input</code> through <code>id</code>).</p>
<p>Here is the “logic”, or the relationships between the values:</p>
<ol type="1">
<li>The error value <code>err</code> is the difference between the control and the response.</li>
<li>The sum of errors <code>errSums</code> is the cumulative sum of all of the error values so far.</li>
<li>The input <code>input</code> is the cumulative sum of all of the correction terms: a multiple of <code>err</code> and a multiple of <code>errSums</code>.</li>
<li>The response <code>response</code> is the result of running the input through the black box system (here, just <code>id</code>).</li>
<li>The output is the response!</li>
</ol>
<p>Look at what we wrote. Isn’t it just…beautifully declarative? Elegant? All we stated were <em>relationships between terms</em>…we didn’t worry about state, loops, variables, iterations…there is no concept of “how to update”, everything is just “how things are”. It basically popped up exactly as how we “said” it. I don’t know about you, but this demonstration always leaves me amazed, and was one of the things that sold me on this abstraction in the first place.</p>
<p>But, do you see the problem? To calculate <code>err</code>, we used <code>resp</code>. But to get <code>resp</code>, we need <code>err</code>!</p>
<p>We need to be able to define “recursive bindings”. Have Autos recursively depend on each other.</p>
<p>In another language, this would be hopeless. We’d have to have to resort to keeping explicit state and using a loop. However, with Haskell…and the world of laziness, recursive bindings, and tying knots…I think that we’re going to have a <em>real win</em> if we can make something like what we wrote work.</p>
<h3 id="arrowloop">ArrowLoop</h3>
<p>There is actually a construct in <em>proc</em> notation that lets you do just that. I’m going to cut to the chase and show you how it looks, and how you use it. I’ll explain the drawbacks and caveats. And then I’ll explain how it works in an aside — it’s slightly heavy, but some people like to understand.</p>
<p>Without further ado —</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/machines/Auto3.hs#L266-L276</span></span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a><span class="ot">piTargeter ::</span> <span class="dt">Auto</span> <span class="dt">Double</span> <span class="dt">Double</span></span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true" tabindex="-1"></a>piTargeter <span class="ot">=</span> proc control <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb33-5"><a href="#cb33-5" aria-hidden="true" tabindex="-1"></a>    rec <span class="kw">let</span> err <span class="ot">=</span> control <span class="op">-</span> response</span>
<span id="cb33-6"><a href="#cb33-6" aria-hidden="true" tabindex="-1"></a>        errSums  <span class="ot">&lt;-</span> summer         <span class="op">-&lt;</span> err</span>
<span id="cb33-7"><a href="#cb33-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-8"><a href="#cb33-8" aria-hidden="true" tabindex="-1"></a>        input    <span class="ot">&lt;-</span> laggingSummer  <span class="op">-&lt;</span> <span class="fl">0.2</span> <span class="op">*</span> err <span class="op">+</span> <span class="fl">0.01</span> <span class="op">*</span> errSums</span>
<span id="cb33-9"><a href="#cb33-9" aria-hidden="true" tabindex="-1"></a>        response <span class="ot">&lt;-</span> blackBoxSystem <span class="op">-&lt;</span> input</span>
<span id="cb33-10"><a href="#cb33-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-11"><a href="#cb33-11" aria-hidden="true" tabindex="-1"></a>    <span class="fu">id</span> <span class="op">-&lt;</span> response</span>
<span id="cb33-12"><a href="#cb33-12" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb33-13"><a href="#cb33-13" aria-hidden="true" tabindex="-1"></a>    blackBoxSystem <span class="ot">=</span> <span class="fu">id</span>     <span class="co">-- to simplify things :)</span></span></code></pre></div>
<p>The key here is the <em>rec</em> keyword. Basically, we require that we write an instance of <code>ArrowLoop</code> for our <code>Auto</code>…and now things can refer to each other, and it all works out like magic! Now our solution works…the feedback loop is closed with the usage of <code>rec</code>. Now, our algorithm looks <em>exactly</em> like how we would “declare” the relationship of all the variables. We “declare” that <code>err</code> is the difference between the control and the response. We “declare” that <code>errSums</code> is the cumulative sum of the error values. We “declare” that our <code>input</code> is the cumulative sum of all of the adjustment terms. And we “declare” that our response is just the result of feeding our input through our black box.</p>
<p>No loops. No iteration. No mutable variables. Just…a declaration of relationships.</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> testAuto_ piTargeter [<span class="dv">5</span>,<span class="fl">5.01</span><span class="op">..</span><span class="dv">6</span>]      <span class="co">-- vary our desired target slowly</span></span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a>[ <span class="dv">0</span>, <span class="fl">1.05</span>, <span class="fl">1.93</span>, <span class="fl">2.67</span>, <span class="fl">3.28</span> <span class="op">...</span>         <span class="co">-- &quot;seeking&quot;/tracking to 5</span></span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a>, <span class="fl">5.96</span>, <span class="fl">5.97</span>, <span class="fl">5.98</span>, <span class="fl">5.99</span>, <span class="fl">6.00</span>          <span class="co">-- properly tracking</span></span>
<span id="cb34-4"><a href="#cb34-4" aria-hidden="true" tabindex="-1"></a>]</span></code></pre></div>
<p>Perfect!</p>
<p>Wait wait wait hold on…but how does this even work? Is this magic? Can we just throw <em>anything</em> into a recursive binding, and expect it to magically figure out what we mean?</p>
<p>Kinda, yes, no. This works based on Haskell’s laziness. It’s the reason something like <code>fix</code> works:</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a><span class="ot">fix ::</span> (a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> a</span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a>fix f <span class="ot">=</span> f (fix f)</span></code></pre></div>
<p>Infinite loop, right?</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> <span class="fu">head</span> (fix (<span class="dv">1</span><span class="op">:</span>))</span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a><span class="dv">1</span></span></code></pre></div>
<p>What?</p>
<p><code>fix (1:)</code> is basically an infinite lists of ones. But remember that <code>head</code> only requires the first element to be evaluated:</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a><span class="fu">head</span> (fix (<span class="dv">1</span><span class="op">:</span>))</span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a><span class="fu">head</span> (<span class="dv">1</span> <span class="op">:</span> fix (<span class="dv">1</span><span class="op">:</span>))     <span class="co">-- head (x:_) = x</span></span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true" tabindex="-1"></a><span class="dv">1</span></span></code></pre></div>
<p>So that’s the key. If what we <em>want</em> doesn’t require the entire result of the infinite loop…then we can safely reason about infinite recursion in haskell.</p>
<p>The MVP here really is this function that I sneakily introduced, <code>laggingSummer</code>:</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/machines/Auto3.hs#L258-L262</span></span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-3"><a href="#cb38-3" aria-hidden="true" tabindex="-1"></a><span class="ot">laggingSummer ::</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> <span class="dt">Auto</span> a a</span>
<span id="cb38-4"><a href="#cb38-4" aria-hidden="true" tabindex="-1"></a>laggingSummer <span class="ot">=</span> sumFrom <span class="dv">0</span></span>
<span id="cb38-5"><a href="#cb38-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb38-6"><a href="#cb38-6" aria-hidden="true" tabindex="-1"></a><span class="ot">    sumFrom ::</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Auto</span> a a</span>
<span id="cb38-7"><a href="#cb38-7" aria-hidden="true" tabindex="-1"></a>    sumFrom x0 <span class="ot">=</span> <span class="dt">ACons</span> <span class="op">$</span> \x <span class="ot">-&gt;</span> (x0, sumFrom (x0 <span class="op">+</span> x))</span></code></pre></div>
<p><code>laggingSummer</code> is like <code>summer</code>, except all of the sums are delayed. Every step, it adds the input to the accumulator…but returns the accumulator <em>before</em> the addition. Sort of like <code>x++</code> instead of <code>++x</code> in C. If the accumulator is at 10, and it receives a 2, it <em>outputs 10</em>, and <em>updates the accumulator to 12</em>. The key is that it <em>doesn’t need the input</em> to <em>immediately return that step’s output</em>.</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> testAuto_ laggingSummer [<span class="dv">5</span><span class="op">..</span><span class="dv">10</span>]</span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true" tabindex="-1"></a>[<span class="dv">0</span>, <span class="dv">5</span>, <span class="dv">11</span>, <span class="dv">18</span>, <span class="dv">26</span>, <span class="dv">35</span>]</span></code></pre></div>
<p>The accumulator starts off at 0, and receives a 5…it then outputs 0 and updates the accumulator to 5. The accumulator then has 5 and receives a 6…it outputs 5 and then updates the accumulator to 11. Etc. The next step it would output 45 <em>no matter what input it gets</em>.</p>
<p>Look at the definition of <code>piTargeter</code> again. How would it get its “first value”?</p>
<ol type="1">
<li>The first output is just <code>response</code>.</li>
<li>The first response is just the first <code>input</code></li>
<li>The first <code>input</code> is just the result of <code>laggingSummer</code>.</li>
<li>The first result of <code>laggingSummer</code> is 0.</li>
</ol>
<p>And that’s it! Loop closed! The first result is zero…no infinite recursion here.</p>
<p>Now that we know that the first result of <code>response</code> is 0, we can also find the first values of <code>err</code> and <code>errSums</code>: The first <code>err</code> is the first control (input to the <code>Auto</code>) minus 0 (the first response), and the first <code>errSums</code> is a cumulative sum of <code>errs</code>, so it too starts off as the first control minus zero.</p>
<p>So now, we have all of the first values of <em>all</em> of our Autos. Check! Now the next step is the same thing!</p>
<p>Recursive bindings have a lot of power in that they allow us to directly translate natural language and (cyclic) graph-like “relationships” (here, between the different values of a control system) and model them <em>as relationships</em>. Not as loops and updates and state modifications. But <em>as relationships</em>. Something we can <em>declare</em>, at a high level.</p>
<p>And that’s definitely something I would write home about.</p>
<p>The only caveat is, of course, that we have to make sure our loop can produce a “first value” without worrying about its input. Autos like <code>laggingSummer</code> give this to us.</p>
<p>In the following aside, I detail the exact mechanics of how this works :)</p>
<div class="note">
<p><strong>Aside</strong></p>
<p>Ah, so you’re curious? Or maybe you are just one of those people who really wants to know how things work?</p>
<p>The <code>rec</code> keyword in proc/do blocks desugars to applications of a function called <code>loop</code>:</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Arrow</span> r <span class="ot">=&gt;</span> <span class="dt">ArrowLoop</span> r <span class="kw">where</span></span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a><span class="ot">    loop ::</span> r (a, c) (b, c) <span class="ot">-&gt;</span> r a b</span></code></pre></div>
<p>The type signature seems a bit funny. Loop takes a morphism from <code>(a, c)</code> to <code>(b, c)</code> and turns it into a morphism from <code>a</code> to <code>b</code>. But…how does it do that?</p>
<p>I’ll point you to <a href="https://wiki.haskell.org/Circular_programming">a whole article about the <code>(-&gt;)</code> instance of <code>ArrowLoop</code></a> and how it is useful, if you’re interested. But we’re looking at <code>Auto</code> for now.</p>
<p>We can write an <code>ArrowLoop</code> instance for <code>Auto</code>:</p>
<div class="sourceCode" id="cb41"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/machines/Auto2.hs#L58-L61</span></span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-3"><a href="#cb41-3" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">ArrowLoop</span> <span class="dt">Auto</span> <span class="kw">where</span></span>
<span id="cb41-4"><a href="#cb41-4" aria-hidden="true" tabindex="-1"></a>    loop a <span class="ot">=</span> <span class="dt">ACons</span> <span class="op">$</span> \x <span class="ot">-&gt;</span></span>
<span id="cb41-5"><a href="#cb41-5" aria-hidden="true" tabindex="-1"></a>               <span class="kw">let</span> ((y, d), a&#39;) <span class="ot">=</span> runAuto a (x, d)</span>
<span id="cb41-6"><a href="#cb41-6" aria-hidden="true" tabindex="-1"></a>               <span class="kw">in</span>  (y, loop a&#39;)</span></code></pre></div>
<p>So what does this mean? When will we be able to “get a <code>y</code>”?</p>
<p>We will be able to get a <code>y</code> in the case that the <code>Auto</code> can just “pop out” your <code>y</code> without ever evaluating its arguments…or only using <code>x</code>.</p>
<p>The evaluation of <code>a'</code> is then deferred until later…and through this, everything kinda makes sense. The loop is closed. See the article linked above for more information on how <code>loop</code> really works.</p>
<p>The actual desugaring of a <code>rec</code> block is a little tricky, but we can trust that if we have a properly defined <code>loop</code> (that typechecks and has the circular dependencies that loop demands), then <code>ArrowLoop</code> will do what it is supposed to do.</p>
<p>In any case, we can actually understand <em>how to work with rec blocks</em> pretty well — as long as we can have an <code>Auto</code> in the pipeline that can pop something out immediately ignoring its input, then we can rest assured that our knot will be closed.</p>
<p>By the way, this trick works with <code>ArrowM</code> too — provided that the <code>Monad</code> is an instance of <code>MonadFix</code>, which is basically a generalization of the recursive <code>let</code> bindings we used above:</p>
<div class="sourceCode" id="cb42"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/machines/Auto3.hs#L88-L91</span></span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-3"><a href="#cb42-3" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">MonadFix</span> m <span class="ot">=&gt;</span> <span class="dt">ArrowLoop</span> (<span class="dt">AutoM</span> m) <span class="kw">where</span></span>
<span id="cb42-4"><a href="#cb42-4" aria-hidden="true" tabindex="-1"></a>    loop a <span class="ot">=</span> <span class="dt">AConsM</span> <span class="op">$</span> \x <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb42-5"><a href="#cb42-5" aria-hidden="true" tabindex="-1"></a>               rec ((y, d), a&#39;) <span class="ot">&lt;-</span> runAutoM a (x, d)</span>
<span id="cb42-6"><a href="#cb42-6" aria-hidden="true" tabindex="-1"></a>               <span class="fu">return</span> (y, loop a&#39;)</span></code></pre></div>
</div>
<h2 id="going-kleisli">Going Kleisli</h2>
<p>This is going to be our last “modification” to the <code>Auto</code> type — one more common <code>Auto</code> variation/trick that is used in real life usages of <code>Auto</code>.</p>
<h3 id="inhibition">Inhibition</h3>
<p>It might some times be convenient to imagine the <em>results</em> of the <code>Auto</code>s coming in contexts — for example, <code>Maybe</code>:</p>
<div class="sourceCode" id="cb43"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a><span class="dt">Auto</span> a (<span class="dt">Maybe</span> b)</span></code></pre></div>
<p>How can we interpret/use this? In many domains, this is used to model “on/off” behavior of <code>Auto</code>s. The <code>Auto</code> is “on” if the output is <code>Just</code>, and “off” if the output is <code>Nothing</code>.</p>
<p>We can imagine “baking this in” to our Auto type:</p>
<div class="sourceCode" id="cb44"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/machines/AutoOn.hs#L19-L19</span></span>
<span id="cb44-2"><a href="#cb44-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb44-3"><a href="#cb44-3" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">AutoOn</span> a b <span class="ot">=</span> <span class="dt">AConsOn</span> {<span class="ot"> runAutoOn ::</span> a <span class="ot">-&gt;</span> (<span class="dt">Maybe</span> b, <span class="dt">AutoOn</span> a b) }</span></code></pre></div>
<p>Where the semantics of composition are: if you get a <code>Nothing</code> as an input, just don’t tick anything and pop out a <code>Nothing</code>; if you get a <code>Just x</code> as an input run the auto on the <code>x</code>:</p>
<div class="sourceCode" id="cb45"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/machines/AutoOn.hs#L22-L29</span></span>
<span id="cb45-2"><a href="#cb45-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-3"><a href="#cb45-3" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Category</span> <span class="dt">AutoOn</span> <span class="kw">where</span></span>
<span id="cb45-4"><a href="#cb45-4" aria-hidden="true" tabindex="-1"></a>    <span class="fu">id</span>    <span class="ot">=</span> <span class="dt">AConsOn</span> <span class="op">$</span> \x <span class="ot">-&gt;</span> (<span class="dt">Just</span> x, <span class="fu">id</span>)</span>
<span id="cb45-5"><a href="#cb45-5" aria-hidden="true" tabindex="-1"></a>    g <span class="op">.</span> f <span class="ot">=</span> <span class="dt">AConsOn</span> <span class="op">$</span> \x <span class="ot">-&gt;</span></span>
<span id="cb45-6"><a href="#cb45-6" aria-hidden="true" tabindex="-1"></a>              <span class="kw">let</span> (y, f&#39;) <span class="ot">=</span> runAutoOn f x</span>
<span id="cb45-7"><a href="#cb45-7" aria-hidden="true" tabindex="-1"></a>                  (z, g&#39;) <span class="ot">=</span> <span class="kw">case</span> y <span class="kw">of</span></span>
<span id="cb45-8"><a href="#cb45-8" aria-hidden="true" tabindex="-1"></a>                              <span class="dt">Just</span> _y <span class="ot">-&gt;</span> runAutoOn g _y</span>
<span id="cb45-9"><a href="#cb45-9" aria-hidden="true" tabindex="-1"></a>                              <span class="dt">Nothing</span> <span class="ot">-&gt;</span> (<span class="dt">Nothing</span>, g)</span>
<span id="cb45-10"><a href="#cb45-10" aria-hidden="true" tabindex="-1"></a>              <span class="kw">in</span>  (z, g&#39; <span class="op">.</span> f&#39;)</span></code></pre></div>
<p>The other instances are on the file linked above, but I won’t post them here, so you can write them as an exercise. Have fun on the <code>ArrowLoop</code> instance!<a href="#fn6" class="footnote-ref" id="fnref6" role="doc-noteref"><sup>6</sup></a></p>
<div class="note">
<p><strong>Aside</strong></p>
<p>This aside contains category-theoretic justification for what we just did. You can feel free to skip it if you aren’t really too familiar with the bare basics of Category Theory (What an endofunctor is, for example)… but, if you are, this might be a fun perspective :)</p>
<p>What we’ve really done here is taken a category with objects as Haskell types and morphisms are <code>Auto a b</code>, and turned it into a category with objects as Haskell types and whose morphisms are <code>Auto a (m b)</code>, where <code>m</code> is a Monad.</p>
<p>The act of forming this second category from the first is called forming the <em>Kleisli category</em> on a category. We took <code>Auto</code> and are now looking at the Kleisli category on <code>Auto</code> formed by <code>Maybe</code>.</p>
<p>By the way, a “Monad” here is actually different from the normal <code>Monad</code> typeclass found in standard Haskell. A Monad is an endofunctor on a category with two associated natural transformations — unit and join.</p>
<p>Because we’re not dealing with the typical Haskell category anymore (on <code>(-&gt;)</code>), we have to rethink what we actually “have”.</p>
<p>For any Haskell Monad, we get for free our natural transformations:</p>
<div class="sourceCode" id="cb46"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a><span class="ot">unitA ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">Auto</span> a (m a)</span>
<span id="cb46-2"><a href="#cb46-2" aria-hidden="true" tabindex="-1"></a>unitA <span class="ot">=</span> arr <span class="fu">return</span></span>
<span id="cb46-3"><a href="#cb46-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-4"><a href="#cb46-4" aria-hidden="true" tabindex="-1"></a><span class="ot">joinA ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">Auto</span> (m (m a)) (m a)</span>
<span id="cb46-5"><a href="#cb46-5" aria-hidden="true" tabindex="-1"></a>joinA <span class="ot">=</span> arr join</span></code></pre></div>
<p>But what we <em>don’t get</em>, necessarily, the <em>endofunctor</em>. An endofunctor must map both objects and morphisms. A type constructor like <code>Maybe</code> can map objects fine — we have the same objects in <code>Auto</code> as we do in <code>(-&gt;)</code> (haskell types). But we also need the ability to map <em>morphisms</em>:</p>
<div class="sourceCode" id="cb47"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">FunctorA</span> f <span class="kw">where</span></span>
<span id="cb47-2"><a href="#cb47-2" aria-hidden="true" tabindex="-1"></a><span class="ot">    fmapA ::</span> <span class="dt">Auto</span> a b <span class="ot">-&gt;</span> <span class="dt">Auto</span> (f a) (f b)</span>
<span id="cb47-3"><a href="#cb47-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- fmapA id = id</span></span>
<span id="cb47-4"><a href="#cb47-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- fmapA g . fmapA f = fmapA (g . f)</span></span></code></pre></div>
<p>So, if this function exists for a type constructor, following the usual <code>fmap</code> laws, then that type is an endofunctor in our <code>Auto</code> category. And if it’s also a Monad in <code>(-&gt;)</code>, then it’s also then a Monad in <code>Auto</code>.</p>
<p>We can write such an <code>fmapA</code> for <code>Maybe</code>:</p>
<div class="sourceCode" id="cb48"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">FunctorA</span> <span class="dt">Maybe</span> <span class="kw">where</span></span>
<span id="cb48-2"><a href="#cb48-2" aria-hidden="true" tabindex="-1"></a>    fmapA a <span class="ot">=</span> <span class="dt">ACons</span> <span class="op">$</span> \x <span class="ot">-&gt;</span></span>
<span id="cb48-3"><a href="#cb48-3" aria-hidden="true" tabindex="-1"></a>                <span class="kw">case</span> x <span class="kw">of</span></span>
<span id="cb48-4"><a href="#cb48-4" aria-hidden="true" tabindex="-1"></a>                  <span class="dt">Just</span> _x <span class="ot">-&gt;</span> <span class="kw">let</span> (y, a&#39;) <span class="ot">=</span> runAuto a x</span>
<span id="cb48-5"><a href="#cb48-5" aria-hidden="true" tabindex="-1"></a>                             <span class="kw">in</span>  (<span class="dt">Just</span> y, fmapA a&#39;)</span>
<span id="cb48-6"><a href="#cb48-6" aria-hidden="true" tabindex="-1"></a>                  <span class="dt">Nothing</span> <span class="ot">-&gt;</span> (<span class="dt">Nothing</span>, fmapA a)</span></code></pre></div>
<p>And, it is a fact that if we have a Monad, we can write the composition of its Kleisli category for free:</p>
<div class="sourceCode" id="cb49"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true" tabindex="-1"></a><span class="ot">(&lt;~=&lt;) ::</span> (<span class="dt">FunctorA</span> f, <span class="dt">Monad</span> f) <span class="ot">=&gt;</span> <span class="dt">Auto</span> a (f c) <span class="ot">-&gt;</span> <span class="dt">Auto</span> a (f b) <span class="ot">-&gt;</span> <span class="dt">Auto</span> a (f c)</span>
<span id="cb49-2"><a href="#cb49-2" aria-hidden="true" tabindex="-1"></a>g <span class="op">&lt;~=&lt;</span> f <span class="ot">=</span> joinA <span class="op">.</span> fmapA g <span class="op">.</span> f</span></code></pre></div>
<p>In fact, for <code>f ~ Maybe</code>, this definition is identical to the one for the <code>Category</code> instance we wrote above for <code>AutoOn</code>.</p>
<p>And, if the <code>FunctorA</code> is a real functor and the <code>Monad</code> is a real monad, then we have for free the associativity of this super-fish operator:</p>
<div class="sourceCode" id="cb50"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb50-1"><a href="#cb50-1" aria-hidden="true" tabindex="-1"></a>(h <span class="op">&lt;~=&lt;</span> g) <span class="op">&lt;~=&lt;</span> f <span class="op">==</span> h <span class="op">&lt;~=&lt;</span> (g <span class="op">&lt;~=&lt;</span> f)</span>
<span id="cb50-2"><a href="#cb50-2" aria-hidden="true" tabindex="-1"></a>f <span class="op">&lt;~=&lt;</span> unitA      <span class="op">==</span> unitA <span class="op">&lt;~=&lt;</span> f      <span class="op">==</span> f</span></code></pre></div>
<p>Category theory is neat!</p>
<p>By the way, definitely not all endofunctors on <code>(-&gt;)</code> are endofunctors on <code>Auto</code>. We see that <code>Maybe</code> is one. Can you think of any others? Any others where we could write an instance of <code>FunctorA</code> that follows the laws? Think about it, and post some in the comments!</p>
<p>One immediate example is <code>Either e</code>, which is used for great effect in many FRP libraries! It’s “inhibit, with a <em>value</em>”. As an exercise, see if you can write its <code>FunctorA</code> instance, or re-write the <code>AutoOn</code> in this section to work with <code>Either e</code> (you might need to impose a typeclass constraint on the <code>e</code>) instead of <code>Maybe</code>!</p>
</div>
<p>I’m not going to spend too much time on this, other than saying that it is useful to imagine how it might be useful to have an “off” Auto “shut down” every next Auto in the chain.</p>
<p>One neat thing is that <code>AutoOn</code> admits a handy <code>Alternative</code> instance; <code>a1 &lt;|&gt; a2</code> will create a new <code>AutoOn</code> that feeds in its input to <em>both</em> <code>a1</code> and <code>a2</code>, and the result is the first <code>Just</code>.</p>
<div class="sourceCode" id="cb51"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb51-1"><a href="#cb51-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/machines/AutoOn.hs#L80-L86</span></span>
<span id="cb51-2"><a href="#cb51-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-3"><a href="#cb51-3" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Alternative</span> (<span class="dt">AutoOn</span> a) <span class="kw">where</span></span>
<span id="cb51-4"><a href="#cb51-4" aria-hidden="true" tabindex="-1"></a>    empty     <span class="ot">=</span> <span class="dt">AConsOn</span> <span class="op">$</span> \_ <span class="ot">-&gt;</span> (<span class="dt">Nothing</span>, empty)</span>
<span id="cb51-5"><a href="#cb51-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- (&lt;|&gt;) :: AutoOn a b -&gt; AutoOn a b -&gt; AutoOn a b</span></span>
<span id="cb51-6"><a href="#cb51-6" aria-hidden="true" tabindex="-1"></a>    a1 <span class="op">&lt;|&gt;</span> a2 <span class="ot">=</span> <span class="dt">AConsOn</span> <span class="op">$</span> \x <span class="ot">-&gt;</span></span>
<span id="cb51-7"><a href="#cb51-7" aria-hidden="true" tabindex="-1"></a>                  <span class="kw">let</span> (y1, a1&#39;) <span class="ot">=</span> runAutoOn a1 x</span>
<span id="cb51-8"><a href="#cb51-8" aria-hidden="true" tabindex="-1"></a>                      (y2, a2&#39;) <span class="ot">=</span> runAutoOn a2 x</span>
<span id="cb51-9"><a href="#cb51-9" aria-hidden="true" tabindex="-1"></a>                  <span class="kw">in</span>  (y1 <span class="op">&lt;|&gt;</span> y2, a1&#39; <span class="op">&lt;|&gt;</span> a2&#39;)</span></code></pre></div>
<p>Unexpectedly, we also get the handy <code>empty</code>, which is a “always off” <code>AutoOn</code>. Feed anything through <code>empty</code> and it’ll produce a <code>Nothing</code> no matter what. You can use this to provide an “always fail”, “short-circuit here” kind of composition, like <code>Nothing</code> in the <code>Maybe</code> monad.</p>
<p>You also get this an interesting and useful concept called “switching” that comes from this; the ability to switch from running one Auto or the other by looking if the result is on or off — here is a common switch that behaves like the first <code>AutoOn</code> until it is off, and then behaves like the second forever after:</p>
<div class="sourceCode" id="cb52"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb52-1"><a href="#cb52-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/machines/AutoOn.hs#L115-L121</span></span>
<span id="cb52-2"><a href="#cb52-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb52-3"><a href="#cb52-3" aria-hidden="true" tabindex="-1"></a><span class="ot">(--&gt;) ::</span> <span class="dt">AutoOn</span> a b <span class="ot">-&gt;</span> <span class="dt">AutoOn</span> a b <span class="ot">-&gt;</span> <span class="dt">AutoOn</span> a b</span>
<span id="cb52-4"><a href="#cb52-4" aria-hidden="true" tabindex="-1"></a>a1 <span class="op">--&gt;</span> a2 <span class="ot">=</span> <span class="dt">AConsOn</span> <span class="op">$</span> \x <span class="ot">-&gt;</span></span>
<span id="cb52-5"><a href="#cb52-5" aria-hidden="true" tabindex="-1"></a>              <span class="kw">let</span> (y1, a1&#39;) <span class="ot">=</span> runAutoOn a1 x</span>
<span id="cb52-6"><a href="#cb52-6" aria-hidden="true" tabindex="-1"></a>              <span class="kw">in</span>   <span class="kw">case</span> y1 <span class="kw">of</span></span>
<span id="cb52-7"><a href="#cb52-7" aria-hidden="true" tabindex="-1"></a>                     <span class="dt">Just</span> _  <span class="ot">-&gt;</span> (y1, a1&#39; <span class="op">--&gt;</span> a2)</span>
<span id="cb52-8"><a href="#cb52-8" aria-hidden="true" tabindex="-1"></a>                     <span class="dt">Nothing</span> <span class="ot">-&gt;</span> runAutoOn a2 x</span>
<span id="cb52-9"><a href="#cb52-9" aria-hidden="true" tabindex="-1"></a><span class="kw">infixr</span> <span class="dv">1</span> <span class="op">--&gt;</span></span></code></pre></div>
<h3 id="usages">Usages</h3>
<p>Let’s test this out; first, some helper functions (the same ones we wrote for <code>AutoM</code>)</p>
<div class="sourceCode" id="cb53"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb53-1"><a href="#cb53-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/machines/AutoOn.hs#L91-L107</span></span>
<span id="cb53-2"><a href="#cb53-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb53-3"><a href="#cb53-3" aria-hidden="true" tabindex="-1"></a><span class="ot">autoOn ::</span> <span class="dt">Auto</span> a b <span class="ot">-&gt;</span> <span class="dt">AutoOn</span> a b</span>
<span id="cb53-4"><a href="#cb53-4" aria-hidden="true" tabindex="-1"></a>autoOn a <span class="ot">=</span> <span class="dt">AConsOn</span> <span class="op">$</span> \x <span class="ot">-&gt;</span></span>
<span id="cb53-5"><a href="#cb53-5" aria-hidden="true" tabindex="-1"></a>             <span class="kw">let</span> (y, a&#39;) <span class="ot">=</span> runAuto a x</span>
<span id="cb53-6"><a href="#cb53-6" aria-hidden="true" tabindex="-1"></a>             <span class="kw">in</span>  (<span class="dt">Just</span> y, autoOn a&#39;)</span>
<span id="cb53-7"><a href="#cb53-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb53-8"><a href="#cb53-8" aria-hidden="true" tabindex="-1"></a><span class="ot">arrOn ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> b) <span class="ot">-&gt;</span> <span class="dt">AutoOn</span> a b</span>
<span id="cb53-9"><a href="#cb53-9" aria-hidden="true" tabindex="-1"></a>arrOn f <span class="ot">=</span> <span class="dt">AConsOn</span> <span class="op">$</span> \x <span class="ot">-&gt;</span> (f x, arrOn f)</span>
<span id="cb53-10"><a href="#cb53-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb53-11"><a href="#cb53-11" aria-hidden="true" tabindex="-1"></a><span class="ot">fromAutoOn ::</span> <span class="dt">AutoOn</span> a b <span class="ot">-&gt;</span> <span class="dt">Auto</span> a (<span class="dt">Maybe</span> b)</span>
<span id="cb53-12"><a href="#cb53-12" aria-hidden="true" tabindex="-1"></a>fromAutoOn a <span class="ot">=</span> <span class="dt">ACons</span> <span class="op">$</span> \x <span class="ot">-&gt;</span></span>
<span id="cb53-13"><a href="#cb53-13" aria-hidden="true" tabindex="-1"></a>                 <span class="kw">let</span> (y, a&#39;) <span class="ot">=</span> runAutoOn a x</span>
<span id="cb53-14"><a href="#cb53-14" aria-hidden="true" tabindex="-1"></a>                 <span class="kw">in</span>  (y, fromAutoOn a&#39;)</span></code></pre></div>
<p><code>autoOn</code> turns an <code>Auto a b</code> into an <code>AutoOn a b</code>, where the result is always <code>Just</code>. <code>arrOn</code> is like <code>arr</code> and <code>arrM</code>…it takes an <code>a -&gt; Maybe b</code> and turns it into an <code>AutoOn a b</code>. <code>fromAutoOn</code> turns an <code>AutoOn a b</code> into a normal <code>Auto a (Maybe b)</code>, just so that we can leverage our existing test functions on normal <code>Auto</code>s.</p>
<p>Let’s play around with some test <code>AutoOn</code>s!</p>
<div class="sourceCode" id="cb54"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb54-1"><a href="#cb54-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/machines/AutoOn.hs#L131-L152</span></span>
<span id="cb54-2"><a href="#cb54-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-3"><a href="#cb54-3" aria-hidden="true" tabindex="-1"></a><span class="ot">onFor ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">AutoOn</span> a a</span>
<span id="cb54-4"><a href="#cb54-4" aria-hidden="true" tabindex="-1"></a>onFor n <span class="ot">=</span> proc x <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb54-5"><a href="#cb54-5" aria-hidden="true" tabindex="-1"></a>    i <span class="ot">&lt;-</span> autoOn summer <span class="op">-&lt;</span> <span class="dv">1</span></span>
<span id="cb54-6"><a href="#cb54-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span> i <span class="op">&lt;=</span> n</span>
<span id="cb54-7"><a href="#cb54-7" aria-hidden="true" tabindex="-1"></a>      <span class="kw">then</span> <span class="fu">id</span>    <span class="op">-&lt;</span> x       <span class="co">-- succeed</span></span>
<span id="cb54-8"><a href="#cb54-8" aria-hidden="true" tabindex="-1"></a>      <span class="kw">else</span> empty <span class="op">-&lt;</span> x       <span class="co">-- fail</span></span>
<span id="cb54-9"><a href="#cb54-9" aria-hidden="true" tabindex="-1"></a><span class="co">-- alternatively, using explit recursion:</span></span>
<span id="cb54-10"><a href="#cb54-10" aria-hidden="true" tabindex="-1"></a><span class="co">-- onFor 0 = empty</span></span>
<span id="cb54-11"><a href="#cb54-11" aria-hidden="true" tabindex="-1"></a><span class="co">-- onFor n = AConsOn $ \x -&gt; (Just x, onFor&#39; (n-1))</span></span>
<span id="cb54-12"><a href="#cb54-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-13"><a href="#cb54-13" aria-hidden="true" tabindex="-1"></a><span class="ot">filterA ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> <span class="dt">AutoOn</span> a a</span>
<span id="cb54-14"><a href="#cb54-14" aria-hidden="true" tabindex="-1"></a>filterA p <span class="ot">=</span> arrOn (\x <span class="ot">-&gt;</span> x <span class="op">&lt;$</span> guard (p x))</span>
<span id="cb54-15"><a href="#cb54-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-16"><a href="#cb54-16" aria-hidden="true" tabindex="-1"></a><span class="ot">untilA ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> <span class="dt">AutoOn</span> a a</span>
<span id="cb54-17"><a href="#cb54-17" aria-hidden="true" tabindex="-1"></a>untilA p <span class="ot">=</span> proc x <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb54-18"><a href="#cb54-18" aria-hidden="true" tabindex="-1"></a>    stopped <span class="ot">&lt;-</span> autoOn (autoFold (<span class="op">||</span>) <span class="dt">False</span>) <span class="op">-&lt;</span> p x</span>
<span id="cb54-19"><a href="#cb54-19" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span> stopped</span>
<span id="cb54-20"><a href="#cb54-20" aria-hidden="true" tabindex="-1"></a>      <span class="kw">then</span> empty <span class="op">-&lt;</span> x       <span class="co">-- fail</span></span>
<span id="cb54-21"><a href="#cb54-21" aria-hidden="true" tabindex="-1"></a>      <span class="kw">else</span> <span class="fu">id</span>    <span class="op">-&lt;</span> x       <span class="co">-- succeed</span></span>
<span id="cb54-22"><a href="#cb54-22" aria-hidden="true" tabindex="-1"></a><span class="co">-- alternatively, using explicit recursion:</span></span>
<span id="cb54-23"><a href="#cb54-23" aria-hidden="true" tabindex="-1"></a><span class="co">-- untilA p = AConsOn $ \x -&gt;</span></span>
<span id="cb54-24"><a href="#cb54-24" aria-hidden="true" tabindex="-1"></a><span class="co">--              if p x</span></span>
<span id="cb54-25"><a href="#cb54-25" aria-hidden="true" tabindex="-1"></a><span class="co">--                then (Just x , untilA p)</span></span>
<span id="cb54-26"><a href="#cb54-26" aria-hidden="true" tabindex="-1"></a><span class="co">--                else (Nothing, empty   )</span></span></code></pre></div>
<p>One immediate usage is that we can use these to “short circuit” our proc blocks, just like with monadic <code>Maybe</code> and do blocks:</p>
<div class="sourceCode" id="cb55"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb55-1"><a href="#cb55-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/machines/AutoOn.hs#L163-L173</span></span>
<span id="cb55-2"><a href="#cb55-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-3"><a href="#cb55-3" aria-hidden="true" tabindex="-1"></a><span class="ot">shortCircuit1 ::</span> <span class="dt">AutoOn</span> <span class="dt">Int</span> <span class="dt">Int</span></span>
<span id="cb55-4"><a href="#cb55-4" aria-hidden="true" tabindex="-1"></a>shortCircuit1 <span class="ot">=</span> proc x <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb55-5"><a href="#cb55-5" aria-hidden="true" tabindex="-1"></a>    filterA <span class="fu">even</span> <span class="op">-&lt;</span> x</span>
<span id="cb55-6"><a href="#cb55-6" aria-hidden="true" tabindex="-1"></a>    onFor <span class="dv">3</span>      <span class="op">-&lt;</span> ()</span>
<span id="cb55-7"><a href="#cb55-7" aria-hidden="true" tabindex="-1"></a>    <span class="fu">id</span>           <span class="op">-&lt;</span> x <span class="op">*</span> <span class="dv">10</span></span>
<span id="cb55-8"><a href="#cb55-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-9"><a href="#cb55-9" aria-hidden="true" tabindex="-1"></a><span class="ot">shortCircuit2 ::</span> <span class="dt">AutoOn</span> <span class="dt">Int</span> <span class="dt">Int</span></span>
<span id="cb55-10"><a href="#cb55-10" aria-hidden="true" tabindex="-1"></a>shortCircuit2 <span class="ot">=</span> proc x <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb55-11"><a href="#cb55-11" aria-hidden="true" tabindex="-1"></a>    onFor <span class="dv">3</span>      <span class="op">-&lt;</span> ()</span>
<span id="cb55-12"><a href="#cb55-12" aria-hidden="true" tabindex="-1"></a>    filterA <span class="fu">even</span> <span class="op">-&lt;</span> x</span>
<span id="cb55-13"><a href="#cb55-13" aria-hidden="true" tabindex="-1"></a>    <span class="fu">id</span>           <span class="op">-&lt;</span> x <span class="op">*</span> <span class="dv">10</span></span></code></pre></div>
<p>If either the <code>filterA</code> or the <code>onFor</code> are off, then the whole thing is off. How do you think the two differ?</p>
<div class="sourceCode" id="cb56"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb56-1"><a href="#cb56-1" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> testAuto (fromAutoOn shortCircuit1) [<span class="dv">1</span><span class="op">..</span><span class="dv">12</span>]</span>
<span id="cb56-2"><a href="#cb56-2" aria-hidden="true" tabindex="-1"></a>[ <span class="dt">Nothing</span>, <span class="dt">Just</span> <span class="dv">20</span>, <span class="dt">Nothing</span>, <span class="dt">Just</span> <span class="dv">40</span>, <span class="dt">Nothing</span>, <span class="dt">Just</span> <span class="dv">60</span></span>
<span id="cb56-3"><a href="#cb56-3" aria-hidden="true" tabindex="-1"></a>, <span class="dt">Nothing</span>, <span class="dt">Nothing</span>, <span class="dt">Nothing</span>, <span class="dt">Nothing</span>, <span class="dt">Nothing</span>, <span class="dt">Nothing</span>]</span>
<span id="cb56-4"><a href="#cb56-4" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> testAuto (fromAutoOn shortCircuit2) [<span class="dv">1</span><span class="op">..</span><span class="dv">12</span>]</span>
<span id="cb56-5"><a href="#cb56-5" aria-hidden="true" tabindex="-1"></a>[ <span class="dt">Nothing</span>, <span class="dt">Just</span> <span class="dv">20</span>, <span class="dt">Nothing</span>, <span class="dt">Nothing</span>, <span class="dt">Nothing</span>, <span class="dt">Nothing</span></span>
<span id="cb56-6"><a href="#cb56-6" aria-hidden="true" tabindex="-1"></a>, <span class="dt">Nothing</span>, <span class="dt">Nothing</span>, <span class="dt">Nothing</span>, <span class="dt">Nothing</span>, <span class="dt">Nothing</span>, <span class="dt">Nothing</span>]</span></code></pre></div>
<p>Ah. For <code>shortCircuit1</code>, as soon as the <code>filterA</code> fails, it jumps <em>straight to the end</em>, short-circuiting; it doesn’t bother “ticking along” the <code>onFor</code> and updating its state!</p>
<p>The arguably more interesting usage, and the one that is more used in real life<a href="#fn7" class="footnote-ref" id="fnref7" role="doc-noteref"><sup>7</sup></a>, is the powerful usage of the switching combinator <code>(--&gt;)</code> in order to be able to combine multiple <code>Auto</code>’s that simulate “stages”…an <code>Auto</code> can “do what it wants”, and then choose to “hand it off” when it is ready.</p>
<div class="sourceCode" id="cb57"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb57-1"><a href="#cb57-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/machines/AutoOn.hs#L178-L183</span></span>
<span id="cb57-2"><a href="#cb57-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-3"><a href="#cb57-3" aria-hidden="true" tabindex="-1"></a><span class="ot">stages ::</span> <span class="dt">AutoOn</span> <span class="dt">Int</span> <span class="dt">Int</span></span>
<span id="cb57-4"><a href="#cb57-4" aria-hidden="true" tabindex="-1"></a>stages <span class="ot">=</span> stage1 <span class="op">--&gt;</span> stage2 <span class="op">--&gt;</span> stage3 <span class="op">--&gt;</span> stages</span>
<span id="cb57-5"><a href="#cb57-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb57-6"><a href="#cb57-6" aria-hidden="true" tabindex="-1"></a>    stage1 <span class="ot">=</span> onFor <span class="dv">2</span> <span class="op">.</span> arr <span class="fu">negate</span></span>
<span id="cb57-7"><a href="#cb57-7" aria-hidden="true" tabindex="-1"></a>    stage2 <span class="ot">=</span> untilA (<span class="op">&gt;</span> <span class="dv">15</span>) <span class="op">.</span> autoOn summer</span>
<span id="cb57-8"><a href="#cb57-8" aria-hidden="true" tabindex="-1"></a>    stage3 <span class="ot">=</span> onFor <span class="dv">3</span> <span class="op">.</span> (<span class="fu">pure</span> <span class="dv">100</span> <span class="op">.</span> filterA <span class="fu">even</span> <span class="op">&lt;|&gt;</span> <span class="fu">pure</span> <span class="dv">200</span>)</span></code></pre></div>
<div class="sourceCode" id="cb58"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb58-1"><a href="#cb58-1" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> testAuto_ (fromAutoOn stages) [<span class="dv">1</span><span class="op">..</span><span class="dv">15</span>]</span>
<span id="cb58-2"><a href="#cb58-2" aria-hidden="true" tabindex="-1"></a>[ <span class="dt">Just</span> (<span class="op">-</span><span class="dv">1</span>), <span class="dt">Just</span> (<span class="op">-</span><span class="dv">2</span>)              <span class="co">-- stage 1</span></span>
<span id="cb58-3"><a href="#cb58-3" aria-hidden="true" tabindex="-1"></a>, <span class="dt">Just</span> <span class="dv">3</span>, <span class="dt">Just</span> <span class="dv">7</span>, <span class="dt">Just</span> <span class="dv">12</span>           <span class="co">-- stage 2</span></span>
<span id="cb58-4"><a href="#cb58-4" aria-hidden="true" tabindex="-1"></a>, <span class="dt">Just</span> <span class="dv">100</span>, <span class="dt">Just</span> <span class="dv">200</span>, <span class="dt">Just</span> <span class="dv">100</span>      <span class="co">-- stage 3</span></span>
<span id="cb58-5"><a href="#cb58-5" aria-hidden="true" tabindex="-1"></a>, <span class="dt">Just</span> (<span class="op">-</span><span class="dv">9</span>), <span class="dt">Just</span> (<span class="op">-</span><span class="dv">10</span>)             <span class="co">-- stage 1</span></span>
<span id="cb58-6"><a href="#cb58-6" aria-hidden="true" tabindex="-1"></a>, <span class="dt">Just</span> <span class="dv">11</span>                           <span class="co">-- stage 2</span></span>
<span id="cb58-7"><a href="#cb58-7" aria-hidden="true" tabindex="-1"></a>, <span class="dt">Just</span> <span class="dv">100</span>, <span class="dt">Just</span> <span class="dv">200</span>, <span class="dt">Just</span> <span class="dv">100</span>      <span class="co">-- stage 3</span></span>
<span id="cb58-8"><a href="#cb58-8" aria-hidden="true" tabindex="-1"></a>, <span class="dt">Just</span> (<span class="op">-</span><span class="dv">15</span>), <span class="dt">Just</span> (<span class="op">-</span><span class="dv">16</span>)            <span class="co">-- stage 1</span></span>
<span id="cb58-9"><a href="#cb58-9" aria-hidden="true" tabindex="-1"></a>]</span></code></pre></div>
<p>Note that the stages continually “loop around”, as our recursive definition seems to imply. Neat!</p>
<div class="note">
<p><strong>Aside</strong></p>
<p>You might note that sometimes, to model on/off behavior, it might be nice to really be able to “keep on counting” even when receiving a <code>Nothing</code> in a composition. For example, you might want both versions of <code>shortCircuit</code> to be the same — let <code>onFor</code> still “keep on counting” even when it has been inhibited upstream.</p>
<p>If this is the behavior you want to model (and this is actually the behavior modeled in some FRP libraries), then the type above isn’t powerful enough; you’ll have to go deeper:</p>
<div class="sourceCode" id="cb59"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb59-1"><a href="#cb59-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/machines/AutoOn2.hs#L10-L10</span></span>
<span id="cb59-2"><a href="#cb59-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb59-3"><a href="#cb59-3" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">AutoOn2</span> a b <span class="ot">=</span> <span class="dt">ACons2</span> {<span class="ot"> runAutoOn2 ::</span> <span class="dt">Maybe</span> a <span class="ot">-&gt;</span> (<span class="dt">Maybe</span> b, <span class="dt">AutoOn2</span> a b) }</span></code></pre></div>
<p>So now, you can write something like <code>onFor</code>, which keeps on “ticking on” even if it receives a <code>Nothing</code> from upstream:</p>
<div class="sourceCode" id="cb60"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb60-1"><a href="#cb60-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/machines/AutoOn2.hs#L16-L18</span></span>
<span id="cb60-2"><a href="#cb60-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb60-3"><a href="#cb60-3" aria-hidden="true" tabindex="-1"></a><span class="ot">onFor ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">AutoOn2</span> a a</span>
<span id="cb60-4"><a href="#cb60-4" aria-hidden="true" tabindex="-1"></a>onFor <span class="dv">0</span> <span class="ot">=</span> <span class="dt">ACons2</span> <span class="op">$</span> \_ <span class="ot">-&gt;</span> (<span class="dt">Nothing</span>, onFor <span class="dv">0</span>)</span>
<span id="cb60-5"><a href="#cb60-5" aria-hidden="true" tabindex="-1"></a>onFor n <span class="ot">=</span> <span class="dt">ACons2</span> <span class="op">$</span> \x <span class="ot">-&gt;</span> (x, onFor (n <span class="op">-</span> <span class="dv">1</span>))</span></code></pre></div>
<p>You can of course translate all of your <code>AutoOn</code>s into this new type:</p>
<div class="sourceCode" id="cb61"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb61-1"><a href="#cb61-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/machines/AutoOn2.hs#L24-L31</span></span>
<span id="cb61-2"><a href="#cb61-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-3"><a href="#cb61-3" aria-hidden="true" tabindex="-1"></a><span class="ot">autoOn ::</span> <span class="dt">AutoOn</span> a b <span class="ot">-&gt;</span> <span class="dt">AutoOn2</span> a b</span>
<span id="cb61-4"><a href="#cb61-4" aria-hidden="true" tabindex="-1"></a>autoOn a <span class="ot">=</span> <span class="dt">ACons2</span> <span class="op">$</span> \x <span class="ot">-&gt;</span></span>
<span id="cb61-5"><a href="#cb61-5" aria-hidden="true" tabindex="-1"></a>             <span class="kw">case</span> x <span class="kw">of</span></span>
<span id="cb61-6"><a href="#cb61-6" aria-hidden="true" tabindex="-1"></a>               <span class="dt">Just</span> _x <span class="ot">-&gt;</span></span>
<span id="cb61-7"><a href="#cb61-7" aria-hidden="true" tabindex="-1"></a>                 <span class="kw">let</span> (y, a&#39;) <span class="ot">=</span> runAutoOn a _x</span>
<span id="cb61-8"><a href="#cb61-8" aria-hidden="true" tabindex="-1"></a>                 <span class="kw">in</span>  (y, autoOn a&#39;)</span>
<span id="cb61-9"><a href="#cb61-9" aria-hidden="true" tabindex="-1"></a>               <span class="dt">Nothing</span> <span class="ot">-&gt;</span></span>
<span id="cb61-10"><a href="#cb61-10" aria-hidden="true" tabindex="-1"></a>                 (<span class="dt">Nothing</span>, autoOn a)</span></code></pre></div>
<p>Or you can use the smart constructor method detailed immediately following.</p>
</div>
<h2 id="working-all-together">Working all together</h2>
<p>Of course, we can always literally throw everything we can add together into our <code>Auto</code> type:</p>
<div class="sourceCode" id="cb62"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb62-1"><a href="#cb62-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/machines/AutoX.hs#L18-L18</span></span>
<span id="cb62-2"><a href="#cb62-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb62-3"><a href="#cb62-3" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">AutoX</span> m a b <span class="ot">=</span> <span class="dt">AConsX</span> {<span class="ot"> runAutoX ::</span> a <span class="ot">-&gt;</span> m (<span class="dt">Maybe</span> b, <span class="dt">AutoX</span> m a b) }</span></code></pre></div>
<p>(Again, instances are in the source file, but not here in the post directly)</p>
<p>Here is a same of a big conglomerate type where we throw in a bunch of things.</p>
<p>The benefit? Well, we could work and compose “normal” <code>Auto</code>s, selecting for features that we only need to work with. And then, when we need to, we can just “convert it up” to our “lowest common denominator” type.</p>
<p>This is the common theme, the “functor design pattern”. Pick your common unifying type, and just pop everything into it. You can compose, etc. with the semantics of the other type when convenient, and then have all the parts work together in the end.</p>
<p>This pattern is awesome, if only we didn’t have so many types to convert in between manually.</p>
<p>Well, we’re in luck. There’s actually a great trick, that makes <em>all of this</em> even more streamlined: we can replace the “normal constructors” like <code>ACons</code>, <code>AConsM</code>, and <code>AConsOn</code>, with <em>smart constructors</em> <code>aCons</code>, <code>aConsM</code>, <code>aConsOn</code>, that work <em>exactly the same way</em>:</p>
<div class="sourceCode" id="cb63"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb63-1"><a href="#cb63-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/machines/AutoX.hs#L85-L100</span></span>
<span id="cb63-2"><a href="#cb63-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb63-3"><a href="#cb63-3" aria-hidden="true" tabindex="-1"></a><span class="ot">aCons ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> (b, <span class="dt">AutoX</span> m a b)) <span class="ot">-&gt;</span> <span class="dt">AutoX</span> m a b</span>
<span id="cb63-4"><a href="#cb63-4" aria-hidden="true" tabindex="-1"></a>aCons a <span class="ot">=</span> <span class="dt">AConsX</span> <span class="op">$</span> \x <span class="ot">-&gt;</span></span>
<span id="cb63-5"><a href="#cb63-5" aria-hidden="true" tabindex="-1"></a>            <span class="kw">let</span> (y, aX) <span class="ot">=</span> a x</span>
<span id="cb63-6"><a href="#cb63-6" aria-hidden="true" tabindex="-1"></a>            <span class="kw">in</span>  <span class="fu">return</span> (<span class="dt">Just</span> y, aX)</span>
<span id="cb63-7"><a href="#cb63-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb63-8"><a href="#cb63-8" aria-hidden="true" tabindex="-1"></a><span class="ot">aConsM ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> m (b, <span class="dt">AutoX</span> m a b)) <span class="ot">-&gt;</span> <span class="dt">AutoX</span> m a b</span>
<span id="cb63-9"><a href="#cb63-9" aria-hidden="true" tabindex="-1"></a>aConsM a <span class="ot">=</span> <span class="dt">AConsX</span> <span class="op">$</span> \x <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb63-10"><a href="#cb63-10" aria-hidden="true" tabindex="-1"></a>             (y, aX) <span class="ot">&lt;-</span> a x</span>
<span id="cb63-11"><a href="#cb63-11" aria-hidden="true" tabindex="-1"></a>             <span class="fu">return</span> (<span class="dt">Just</span> y, aX)</span>
<span id="cb63-12"><a href="#cb63-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb63-13"><a href="#cb63-13" aria-hidden="true" tabindex="-1"></a><span class="ot">aConsOn ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> (<span class="dt">Maybe</span> b, <span class="dt">AutoX</span> m a b)) <span class="ot">-&gt;</span> <span class="dt">AutoX</span> m a b</span>
<span id="cb63-14"><a href="#cb63-14" aria-hidden="true" tabindex="-1"></a>aConsOn a <span class="ot">=</span> <span class="dt">AConsX</span> <span class="op">$</span> \x <span class="ot">-&gt;</span></span>
<span id="cb63-15"><a href="#cb63-15" aria-hidden="true" tabindex="-1"></a>              <span class="kw">let</span> (y, aX) <span class="ot">=</span> a x</span>
<span id="cb63-16"><a href="#cb63-16" aria-hidden="true" tabindex="-1"></a>              <span class="kw">in</span>  <span class="fu">return</span> (y, aX)</span></code></pre></div>
<p>Compare these definitions of <code>summer</code>, <code>arrM</code>, and <code>untilA</code> from their “specific type” “real constructor” versions to their <code>AutoX</code>-generic “smart constructor” versions:</p>
<div class="sourceCode" id="cb64"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb64-1"><a href="#cb64-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/machines/Auto.hs#L67-L73</span></span>
<span id="cb64-2"><a href="#cb64-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb64-3"><a href="#cb64-3" aria-hidden="true" tabindex="-1"></a><span class="ot">summer ::</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> <span class="dt">Auto</span> a a</span>
<span id="cb64-4"><a href="#cb64-4" aria-hidden="true" tabindex="-1"></a>summer <span class="ot">=</span> sumFrom <span class="dv">0</span></span>
<span id="cb64-5"><a href="#cb64-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb64-6"><a href="#cb64-6" aria-hidden="true" tabindex="-1"></a><span class="ot">    sumFrom ::</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Auto</span> a a</span>
<span id="cb64-7"><a href="#cb64-7" aria-hidden="true" tabindex="-1"></a>    sumFrom n <span class="ot">=</span> <span class="dt">ACons</span> <span class="op">$</span> \input <span class="ot">-&gt;</span></span>
<span id="cb64-8"><a href="#cb64-8" aria-hidden="true" tabindex="-1"></a>      <span class="kw">let</span> s <span class="ot">=</span> n <span class="op">+</span> input</span>
<span id="cb64-9"><a href="#cb64-9" aria-hidden="true" tabindex="-1"></a>      <span class="kw">in</span>  ( s , sumFrom s )</span>
<span id="cb64-10"><a href="#cb64-10" aria-hidden="true" tabindex="-1"></a><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/machines/Auto3.hs#L104-L107</span></span>
<span id="cb64-11"><a href="#cb64-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb64-12"><a href="#cb64-12" aria-hidden="true" tabindex="-1"></a><span class="ot">arrM ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> m b) <span class="ot">-&gt;</span> <span class="dt">AutoM</span> m a b</span>
<span id="cb64-13"><a href="#cb64-13" aria-hidden="true" tabindex="-1"></a>arrM f <span class="ot">=</span> <span class="dt">AConsM</span> <span class="op">$</span> \x <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb64-14"><a href="#cb64-14" aria-hidden="true" tabindex="-1"></a>                    y <span class="ot">&lt;-</span> f x</span>
<span id="cb64-15"><a href="#cb64-15" aria-hidden="true" tabindex="-1"></a>                    <span class="fu">return</span> (y, arrM f)</span>
<span id="cb64-16"><a href="#cb64-16" aria-hidden="true" tabindex="-1"></a><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/machines/AutoOn.hs#L154-L158</span></span>
<span id="cb64-17"><a href="#cb64-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb64-18"><a href="#cb64-18" aria-hidden="true" tabindex="-1"></a><span class="ot">untilA&#39; ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> <span class="dt">AutoOn</span> a a</span>
<span id="cb64-19"><a href="#cb64-19" aria-hidden="true" tabindex="-1"></a>untilA&#39; p <span class="ot">=</span> <span class="dt">AConsOn</span> <span class="op">$</span> \x <span class="ot">-&gt;</span></span>
<span id="cb64-20"><a href="#cb64-20" aria-hidden="true" tabindex="-1"></a>              <span class="kw">if</span> p x</span>
<span id="cb64-21"><a href="#cb64-21" aria-hidden="true" tabindex="-1"></a>                <span class="kw">then</span> (<span class="dt">Just</span> x , untilA p)</span>
<span id="cb64-22"><a href="#cb64-22" aria-hidden="true" tabindex="-1"></a>                <span class="kw">else</span> (<span class="dt">Nothing</span>, empty   )</span></code></pre></div>
<div class="sourceCode" id="cb65"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb65-1"><a href="#cb65-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/machines/AutoX.hs#L106-L128</span></span>
<span id="cb65-2"><a href="#cb65-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-3"><a href="#cb65-3" aria-hidden="true" tabindex="-1"></a><span class="ot">summer ::</span> (<span class="dt">Monad</span> m, <span class="dt">Num</span> a) <span class="ot">=&gt;</span> <span class="dt">AutoX</span> m a a</span>
<span id="cb65-4"><a href="#cb65-4" aria-hidden="true" tabindex="-1"></a>summer <span class="ot">=</span> sumFrom <span class="dv">0</span></span>
<span id="cb65-5"><a href="#cb65-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb65-6"><a href="#cb65-6" aria-hidden="true" tabindex="-1"></a>    sumFrom n <span class="ot">=</span> aCons <span class="op">$</span> \input <span class="ot">-&gt;</span></span>
<span id="cb65-7"><a href="#cb65-7" aria-hidden="true" tabindex="-1"></a>      <span class="kw">let</span> s <span class="ot">=</span> n <span class="op">+</span> input</span>
<span id="cb65-8"><a href="#cb65-8" aria-hidden="true" tabindex="-1"></a>      <span class="kw">in</span>  ( s , sumFrom s )</span>
<span id="cb65-9"><a href="#cb65-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-10"><a href="#cb65-10" aria-hidden="true" tabindex="-1"></a><span class="ot">arrM ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> m b) <span class="ot">-&gt;</span> <span class="dt">AutoX</span> m a b</span>
<span id="cb65-11"><a href="#cb65-11" aria-hidden="true" tabindex="-1"></a>arrM f <span class="ot">=</span> aConsM <span class="op">$</span> \x <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb65-12"><a href="#cb65-12" aria-hidden="true" tabindex="-1"></a>                    y <span class="ot">&lt;-</span> f x</span>
<span id="cb65-13"><a href="#cb65-13" aria-hidden="true" tabindex="-1"></a>                    <span class="fu">return</span> (y, arrM f)</span>
<span id="cb65-14"><a href="#cb65-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-15"><a href="#cb65-15" aria-hidden="true" tabindex="-1"></a><span class="ot">untilA ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> <span class="dt">AutoX</span> m a a</span>
<span id="cb65-16"><a href="#cb65-16" aria-hidden="true" tabindex="-1"></a>untilA p <span class="ot">=</span> aConsOn <span class="op">$</span> \x <span class="ot">-&gt;</span></span>
<span id="cb65-17"><a href="#cb65-17" aria-hidden="true" tabindex="-1"></a>             <span class="kw">if</span> p x</span>
<span id="cb65-18"><a href="#cb65-18" aria-hidden="true" tabindex="-1"></a>               <span class="kw">then</span> (<span class="dt">Just</span> x , untilA p)</span>
<span id="cb65-19"><a href="#cb65-19" aria-hidden="true" tabindex="-1"></a>               <span class="kw">else</span> (<span class="dt">Nothing</span>, empty   )</span></code></pre></div>
<p>They are literally exactly the same…we just change the constructor to the smart constructor!</p>
<p>You might also note that we can express a “pure, non-Monadic” <code>Auto</code> in <code>AutoM</code> and <code>AutoX</code> by making the type polymorphic over all monads:</p>
<div class="sourceCode" id="cb66"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb66-1"><a href="#cb66-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/machines/AutoX.hs#L106-L106</span></span>
<span id="cb66-2"><a href="#cb66-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb66-3"><a href="#cb66-3" aria-hidden="true" tabindex="-1"></a><span class="ot">summer ::</span> (<span class="dt">Monad</span> m, <span class="dt">Num</span> a) <span class="ot">=&gt;</span> <span class="dt">AutoX</span> m a a</span></code></pre></div>
<p>An <code>Auto</code> with a type like this says, “I cannot perform any effects during stepping” — and we know that <code>summer</code> definitely does not. <code>summer</code> is statically guaranteed not to affect any state or IO, and it’s reflected in its type.</p>
<p>The takeaway? You don’t even have to mungle around multiple types to make this strategy work — just make all your <code>Auto</code>s from the start using these smart constructors, and they all compose together! One type from the start — we just expose different constructors to expose the different “subtypes of power” we want to offer.</p>
<p>Now it’s all just to chose your “greatest common denominator”. If you don’t want inhibition-based semantics, just only use <code>AutoM</code>, for example!</p>
<p>By the way, here’s a “smart constructor” for <code>AutoM</code>.</p>
<div class="sourceCode" id="cb67"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb67-1"><a href="#cb67-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/machines/Auto3.hs#L112-L113</span></span>
<span id="cb67-2"><a href="#cb67-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb67-3"><a href="#cb67-3" aria-hidden="true" tabindex="-1"></a><span class="ot">aCons ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> (b, <span class="dt">AutoM</span> m a b)) <span class="ot">-&gt;</span> <span class="dt">AutoM</span> m a b</span>
<span id="cb67-4"><a href="#cb67-4" aria-hidden="true" tabindex="-1"></a>aCons f <span class="ot">=</span> <span class="dt">AConsM</span> <span class="op">$</span> \x <span class="ot">-&gt;</span> <span class="fu">return</span> (f x)</span></code></pre></div>
<h2 id="closing-remarks">Closing Remarks</h2>
<p>That was a doozy, wasn’t it? For those of you who have been waiting, thank you for being patient. I hope most if not all of you are still with me.</p>
<p>Hopefully after going through all of these examples, you can take away some things:</p>
<ul>
<li><p>From the previous parts, you’ve recognized the power of local statefulness and the declarative style offered by proc notation.</p></li>
<li><p>From here, you’ve seen that the Auto type can be equipped in many ways to give it many features which have practical applications in the real world.</p></li>
<li><p>You’ve learned how to handle those features and use and manage them together in sane ways, and their limitations.</p></li>
<li><p>You also know that you can really “program”, “compose”, or “think” in any sort of Auto or composition semantics that you want, for any small part of the problem. And then at the end, just push them all into your greatest common denominator type. So, you aren’t afraid to play with different effect types even in the same program!</p></li>
<li><p>You’ve seen the power of recursive bindings to make complete the promise of declarative programming — being able to extend the realm of what we can express “declaratively”, and what we can <em>denote</em>.</p></li>
<li><p>You are ready to really understand anything you encounter involving <code>Auto</code> and <code>Auto</code>-like entities.</p></li>
</ul>
<p>So, what’s next?</p>
<ul>
<li><p><a href="http://blog.jle.im/source/code-samples/machines">Download the files of this post</a>, play along with the examples in this post, CTRL+F this page for “exercise” to find exercises, and try writing your own examples!</p></li>
<li><p>Feel ready to be able to have a grasp of the situation you see <code>Auto</code> in the real world, such as in the popular FRP library <a href="http://hackage.haskell.org/package/netwire">netwire</a>!</p></li>
<li><p>Apply it to the real world and your real world problems!</p></li>
<li><p>Well, a bit of self-promotion, my upcoming library <a href="https://github.com/mstksg/auto.">auto</a> is basically supposed to be almost all of these concepts (except for implicit on/off behavior) implemented as a finely tuned and optimized performant library, attached with semantic tools for working with real-world problems with these concepts of local statefulness, composition, and declarative style. You can really apply what you learned here to start building projects right away!</p>
<p>Well, sorta. Unfortunately, as of Feburary 2015, it is not yet ready for real usage, and the API is still being finalized. But now that this post is finished, I will be posting more examples and hype posts in the upcoming weeks and months leading up to its official release.</p>
<p>I am open to pull requests and help on the final stages of documentation :)</p>
<p>If you’re interested, or are curious, stop by <em>#haskell-auto</em> on freenode or send me a message!</p></li>
<li><p>Look forward to an actual series on Arrowized FRP, coming up soon! We’ll be using the concepts in this series to <em>implement FRP</em>.</p></li>
</ul>
<p>Happy Haskelling!</p>
<section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes">
<hr />
<ol>
<li id="fn1"><p>Some of you might recall an earlier plan for this post that would include FRP. Unfortunately, I’ve refactored FRP into a completely new topic, because I’ve realized that the two aren’t exactly as related as I had led you all to believe. Still, most if not all of these techniques here are used in actual arrowized FRP libraries today. So, look out for that one soon!<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p>I’m going to go out on a limb here and say that, where Haskell lets you abstract over functions and function composition with <code>Category</code>, Haskell lets you abstract over values and function application with <code>Monad</code>, <code>Applicative</code>, and <code>Functor</code>.<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3"><p>This function really could be avoided if we had written all of our <code>Auto</code>s is <code>AutoM</code>’s parameterized over all <code>m</code> in the first place — that is, written our <code>Auto a b</code>’s as the equally powerful <code>Monad m =&gt; AutoM m a b</code>. But we’re just going to run with <code>Auto</code> for the rest of this series to make things a bit less confusing.<a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn4"><p>By the way, you might notice this pattern as something that seems more fit for <code>Reader</code> than <code>IO</code>. We’ll look at that later!<a href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn5"><p>Which really isn’t the point of these posts, anyway!<a href="#fnref5" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn6"><p>Another exercise you can do if you wanted is to write the exact same instances, but for <code>newtype AutoOn a b = AutoOn (Auto a (Maybe b))</code> :)<a href="#fnref6" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn7"><p>Admittedly, implicit short-circuiting with <code>Auto</code>s is actually often times a lot more of a headache than it’s worth; note that “switching” still works if you have a normal <code>Auto a (Maybe b)</code>; this is the approach that many libraries like <a href="https://github.com/mstksg/auto."><em>auto</em></a> take — write switching combinators on normal <code>Auto a (Maybe b)</code>’s instead.<a href="#fnref7" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section></div><footer><hr><div class="copy-content"><p>Hi, thanks for reading! You can reach me via email at <a href="mailto:justin@jle.im" class="email">justin@jle.im</a>, or at twitter at <a href="https://twitter.com/mstk">@mstk</a>! This post and all others are published under the <a href="https://creativecommons.org/licenses/by-nc-nd/3.0/">CC-BY-NC-ND 3.0</a> license. Corrections and edits via pull request are welcome and encouraged at <a href="https://github.com/mstksg/inCode">the source repository</a>.</p>
<p>If you feel inclined, or this post was particularly helpful for you, why not consider <a href="https://www.patreon.com/justinle/overview">supporting me on Patreon</a>, or a <a href="bitcoin:3D7rmAYgbDnp4gp4rf22THsGt74fNucPDU">BTC donation</a>? :)</p></div><div class="clear"></div><ul class="entry-series"><li><div>This entry is a part of a series called <b>&quot;Intro to Machines and Arrows&quot;</b>.  Find the rest of the entries in this series at its <a href="https://blog.jle.im/entries/series/+intro-to-machines-and-arrows.html" class="tag-a-series" title="+Intro to Machines and Arrows"> series history</a>.</div></li></ul><ul class="tag-list"><li><a href="https://blog.jle.im/entries/tagged/arrows.html" class="tag-a-tag">#arrows</a></li><li><a href="https://blog.jle.im/entries/tagged/auto-machines.html" class="tag-a-tag">#auto-machines</a></li><li><a href="https://blog.jle.im/entries/tagged/haskell.html" class="tag-a-tag">#haskell</a></li><li><a href="https://blog.jle.im/entries/tagged/machines.html" class="tag-a-tag">#machines</a></li><li><a href="https://blog.jle.im/entries/category/@haskell.html" class="tag-a-category">@HASKELL</a></li><li><a href="https://blog.jle.im/entries/category/@ramblings.html" class="tag-a-category">@RAMBLINGS</a></li><li><a href="https://blog.jle.im/entries/series/+intro-to-machines-and-arrows.html" class="tag-a-series">+Intro to Machines and Arrows</a></li></ul><aside class="social-buttons"><div class="addthis_toolbox addthis_default_style addthis-buttons"><a class="addthis_button_facebook_like" fb:like:layout="button_count"></a><a class="addthis_button_tweet"></a><a class="addthis_button_google_plusone" g:plusone:size="medium"></a><a class="addthis_counter addthis_pill_style"></a></div><div class="custom-social-buttons"><div class="custom-social-button"><a href="https://www.reddit.com/submit" onclick="window.location = &#39;https://www.reddit.com/submit?url=&#39;+ encodeURIComponent(window.location); return false"><img src="https://www.reddit.com/static/spreddit7.gif" alt="submit to reddit"></a></div></div></aside><nav class="next-prev-links"><ul><li class="prev-entry-link">&larr; <a href="https://blog.jle.im/entry/a-non-unique-monad-instance.html">A Non-Unique Monad Instance</a> (Previous)</li><li class="next-entry-link">(Next) <a href="https://blog.jle.im/entry/introducing-the-auto-library.html">Introducing: the Auto library!</a> &rarr;</li></ul></nav></footer></article><div class="post-entry"><div class="tile"><div id="disqus_thread"></div><script type="text/javascript">var disqus_config = function () {
    this.page.url = 'https://blog.jle.im/entry/effectful-recursive-real-world-autos-intro-to-machine.html';
    this.page.identifier = 'machines-3';
};
(function() {
    var d = document, s = d.createElement('script');
    s.src = '//incode.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
})();
</script><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a><br></noscript><a href="http://disqus.com" class="dsq-brlink">Comments powered by <span class="logo-disqus">Disqus</span></a></div></div></div></div></div><div id="footer-container"><div id="footer-content"><div class="tile"><div class="footer-copyright">&copy; 2020 Justin Le <span class="license-link">(<a href="https://creativecommons.org/licenses/by-nc-nd/3.0/" class="license">CC-BY-NC-ND 3.0</a>)</span></div><div class="footer-follow social-follows"><ul class="social-follows-list"><li><ul class="social-follows-list-social"><li><a class="social-follow-twitter" title="Follow me on Twitter!" href="https://twitter.com/intent/user?user_id=mstk" onclick="window.open(
  &#39;http://twitter.com/intent/user?user_id=907281&#39;,
  &#39;facebook-share-dialog&#39;,
  &#39;width=550,height=520&#39;);
return false;
">Twitter</a></li><li><a class="social-follow-github" title="Fork me on Github!" href="https://github.com/mstksg">Github</a></li><li><a class="social-follow-twitch" title="Watch me on Twitch!" href="https://www.twitch.tv/justin_l">Twitch</a></li><li><a class="social-follow-patreon" title="Support me on Patreon!" href="https://www.patreon.com/justinle/overview">Patreon</a></li><li><a class="social-follow-gplus" title="Add me on Google+!" href="https://plus.google.com/+JustinLe">Google+</a></li><li><a class="social-follow-keybase" title="Track me on Keybase!" href="https://keybase.io/mstksg">Keybase</a></li><li><a class="social-follow-linkedin" title="Connect with me on LinkedIn!" href="https://linkedin.com/in/lejustin">LinkedIn</a></li><li><a class="social-follow-bitcoin" title="Donate via bitcoin!" href="bitcoin:3D7rmAYgbDnp4gp4rf22THsGt74fNucPDU">Bitcoin</a></li></ul></li><li><ul class="social-follows-list-site"><li><a class="social-follow-rss" title="Subscribe to my RSS Feed!" href="http://feeds.feedburner.com/incodeblog">RSS</a></li><li><a class="social-follow-email" title="Subscribe to the mailing list!" href="https://feedburner.google.com/fb/a/mailverify?loc=en_US&amp;uri=incodeblog">Mailing list</a></li></ul></li></ul></div></div></div></div></body></html>