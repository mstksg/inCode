\documentclass[]{article}
\usepackage{lmodern}
\usepackage{amssymb,amsmath}
\usepackage{ifxetex,ifluatex}
\usepackage{fixltx2e} % provides \textsubscript
\ifnum 0\ifxetex 1\fi\ifluatex 1\fi=0 % if pdftex
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
\else % if luatex or xelatex
  \ifxetex
    \usepackage{mathspec}
    \usepackage{xltxtra,xunicode}
  \else
    \usepackage{fontspec}
  \fi
  \defaultfontfeatures{Mapping=tex-text,Scale=MatchLowercase}
  \newcommand{\euro}{€}
\fi
% use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
% use microtype if available
\IfFileExists{microtype.sty}{\usepackage{microtype}}{}
\usepackage[margin=1in]{geometry}
\usepackage{color}
\usepackage{fancyvrb}
\newcommand{\VerbBar}{|}
\newcommand{\VERB}{\Verb[commandchars=\\\{\}]}
\DefineVerbatimEnvironment{Highlighting}{Verbatim}{commandchars=\\\{\}}
% Add ',fontsize=\small' for more characters per line
\newenvironment{Shaded}{}{}
\newcommand{\AlertTok}[1]{\textcolor[rgb]{1.00,0.00,0.00}{\textbf{#1}}}
\newcommand{\AnnotationTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{#1}}}}
\newcommand{\AttributeTok}[1]{\textcolor[rgb]{0.49,0.56,0.16}{#1}}
\newcommand{\BaseNTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{#1}}
\newcommand{\BuiltInTok}[1]{\textcolor[rgb]{0.00,0.50,0.00}{#1}}
\newcommand{\CharTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand{\CommentTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textit{#1}}}
\newcommand{\CommentVarTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{#1}}}}
\newcommand{\ConstantTok}[1]{\textcolor[rgb]{0.53,0.00,0.00}{#1}}
\newcommand{\ControlFlowTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{#1}}}
\newcommand{\DataTypeTok}[1]{\textcolor[rgb]{0.56,0.13,0.00}{#1}}
\newcommand{\DecValTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{#1}}
\newcommand{\DocumentationTok}[1]{\textcolor[rgb]{0.73,0.13,0.13}{\textit{#1}}}
\newcommand{\ErrorTok}[1]{\textcolor[rgb]{1.00,0.00,0.00}{\textbf{#1}}}
\newcommand{\ExtensionTok}[1]{#1}
\newcommand{\FloatTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{#1}}
\newcommand{\FunctionTok}[1]{\textcolor[rgb]{0.02,0.16,0.49}{#1}}
\newcommand{\ImportTok}[1]{\textcolor[rgb]{0.00,0.50,0.00}{\textbf{#1}}}
\newcommand{\InformationTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{#1}}}}
\newcommand{\KeywordTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{#1}}}
\newcommand{\NormalTok}[1]{#1}
\newcommand{\OperatorTok}[1]{\textcolor[rgb]{0.40,0.40,0.40}{#1}}
\newcommand{\OtherTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{#1}}
\newcommand{\PreprocessorTok}[1]{\textcolor[rgb]{0.74,0.48,0.00}{#1}}
\newcommand{\RegionMarkerTok}[1]{#1}
\newcommand{\SpecialCharTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand{\SpecialStringTok}[1]{\textcolor[rgb]{0.73,0.40,0.53}{#1}}
\newcommand{\StringTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand{\VariableTok}[1]{\textcolor[rgb]{0.10,0.09,0.49}{#1}}
\newcommand{\VerbatimStringTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand{\WarningTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{#1}}}}
\ifxetex
  \usepackage[setpagesize=false, % page size defined by xetex
              unicode=false, % unicode breaks when used with xetex
              xetex]{hyperref}
\else
  \usepackage[unicode=true]{hyperref}
\fi
\hypersetup{breaklinks=true,
            bookmarks=true,
            pdfauthor={Justin Le},
            pdftitle={``Interpreters a la Carte'' in Advent of Code 2017 Duet},
            colorlinks=true,
            citecolor=blue,
            urlcolor=blue,
            linkcolor=magenta,
            pdfborder={0 0 0}}
\urlstyle{same}  % don't use monospace font for urls
% Make links footnotes instead of hotlinks:
\renewcommand{\href}[2]{#2\footnote{\url{#1}}}
\setlength{\parindent}{0pt}
\setlength{\parskip}{6pt plus 2pt minus 1pt}
\setlength{\emergencystretch}{3em}  % prevent overfull lines
\setcounter{secnumdepth}{0}

\title{``Interpreters a la Carte'' in Advent of Code 2017 Duet}
\author{Justin Le}
\date{January 22, 2018}

\begin{document}
\maketitle

\emph{Originally posted on
\textbf{\href{https://blog.jle.im/entry/interpreters-a-la-carte-duet.html}{in
Code}}.}

\documentclass[]{}
\usepackage{lmodern}
\usepackage{amssymb,amsmath}
\usepackage{ifxetex,ifluatex}
\usepackage{fixltx2e} % provides \textsubscript
\ifnum 0\ifxetex 1\fi\ifluatex 1\fi=0 % if pdftex
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
\else % if luatex or xelatex
  \ifxetex
    \usepackage{mathspec}
    \usepackage{xltxtra,xunicode}
  \else
    \usepackage{fontspec}
  \fi
  \defaultfontfeatures{Mapping=tex-text,Scale=MatchLowercase}
  \newcommand{\euro}{€}
\fi
% use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
% use microtype if available
\IfFileExists{microtype.sty}{\usepackage{microtype}}{}
\usepackage[margin=1in]{geometry}
\ifxetex
  \usepackage[setpagesize=false, % page size defined by xetex
              unicode=false, % unicode breaks when used with xetex
              xetex]{hyperref}
\else
  \usepackage[unicode=true]{hyperref}
\fi
\hypersetup{breaklinks=true,
            bookmarks=true,
            pdfauthor={},
            pdftitle={},
            colorlinks=true,
            citecolor=blue,
            urlcolor=blue,
            linkcolor=magenta,
            pdfborder={0 0 0}}
\urlstyle{same}  % don't use monospace font for urls
% Make links footnotes instead of hotlinks:
\renewcommand{\href}[2]{#2\footnote{\url{#1}}}
\setlength{\parindent}{0pt}
\setlength{\parskip}{6pt plus 2pt minus 1pt}
\setlength{\emergencystretch}{3em}  % prevent overfull lines
\setcounter{secnumdepth}{0}

\textbackslash begin\{document\}

This post is just a fun one exploring a wide range of techniques that I applied
to solve the Day 18 puzzles of this past year's great
\href{https://adventofcode.com/2017}{Advent of Code}. The puzzles involved
interpreting an assembly language on an abstract machine. The twist is that Part
A gave you a description of \emph{one abstract machine}, and Part B gave you a
\emph{different} abstract machine to interpret the \emph{same language} in.

This twist (one language, but different interpreters/abstract machines) is
basically one of the textbook applications of the \emph{interpreter pattern} in
Haskell and functional programming, so it was fun to implement my solution in
that pattern --- the assembly language source was ``compiled'' to an abstract
monad once, and the difference between Part A and Part B was just a different
choice of interpreter.

Even \emph{more} interesting is that the two machines are only ``half
different'' -- there's one aspect of the virtual machines that are the same
between the two parts, and aspect that is different. This means that we can
apply the ``data types a la carte'' technique in order to mix and match isolated
components of virtual machine interpreters, and re-use code whenever possible in
assembling our interpreters for our different machines! This can be considered
an extension of the traditional interpreter pattern: the \emph{modular}
interpreter pattern.

This blog post will not necessarily be a focused tutorial on this trick/pattern,
but rather an explanation on my solution centered around this pattern, where I
will also add in insight on how I approach and solve non-trivial Haskell
problems. We'll be using the
\emph{\href{https://hackage.haskell.org/package/operational}{operational}}
package to implement our interpreter pattern program and the
\emph{\href{https://hackage.haskell.org/package/type-combinators}{type-combinators}}
package to implement the modularity aspect, and along the way we'll also use mtl
typeclasses and classy lenses.

The source code is
\href{https://github.com/mstksg/inCode/tree/master/code-samples/duet/Duet.hs}{available
online} and is executable as a stack script. This post is written to be
accessible for early-intermediate Haskell programmers.

\section{The Puzzle}\label{the-puzzle}

The puzzle is \href{https://adventofcode.com/2017/day/18}{Advent of Code 2017
Day 18}, and Part A is:

\begin{quote}
You discover a tablet containing some strange assembly code labeled simply
``Duet''. Rather than bother the sound card with it, you decide to run the code
yourself. Unfortunately, you don't see any documentation, so you're left to
figure out what the instructions mean on your own.

It seems like the assembly is meant to operate on a set of \emph{registers} that
are each named with a single letter and that can each hold a single integer. You
suppose each register should start with a value of \texttt{0}.

There aren't that many instructions, so it shouldn't be hard to figure out what
they do. Here's what you determine:

\begin{itemize}
\tightlist
\item
  \texttt{snd\ X} \emph{plays a sound} with a frequency equal to the value of
  \texttt{X}.
\item
  \texttt{set\ X\ Y} \emph{sets} register \texttt{X} to the value of \texttt{Y}.
\item
  \texttt{add\ X\ Y} \emph{increases} register \texttt{X} by the value of
  \texttt{Y}.
\item
  \texttt{mul\ X\ Y} sets register \texttt{X} to the result of
  \emph{multiplying} the value contained in register \texttt{X} by the value of
  \texttt{Y}.
\item
  \texttt{mod\ X\ Y} sets register \texttt{X} to the \emph{remainder} of
  dividing the value contained in register \texttt{X} by the value of \texttt{Y}
  (that is, it sets \texttt{X} to the result of \texttt{X} modulo \texttt{Y}).
\item
  \texttt{rcv\ X} \emph{recovers} the frequency of the last sound played, but
  only when the value of \texttt{X} is not zero. (If it is zero, the command
  does nothing.)
\item
  \texttt{jgz\ X\ Y} \emph{jumps} with an offset of the value of \texttt{Y}, but
  only if the value of \texttt{X} is \emph{greater than zero}. (An offset of
  \texttt{2} skips the next instruction, an offset of \texttt{-1} jumps to the
  previous instruction, and so on.)
\end{itemize}

Many of the instructions can take either a register (a single letter) or a
number. The value of a register is the integer it contains; the value of a
number is that number.

After each \emph{jump} instruction, the program continues with the instruction
to which the \emph{jump} jumped. After any other instruction, the program
continues with the next instruction. Continuing (or jumping) off either end of
the program terminates it.

\emph{What is the value of the recovered frequency} (the value of the most
recently played sound) the \emph{first} time a \texttt{rcv} instruction is
executed with a non-zero value?
\end{quote}

Part B, however, says:

\begin{quote}
As you congratulate yourself for a job well done, you notice that the
documentation has been on the back of the tablet this entire time. While you
actually got most of the instructions correct, there are a few key differences.
This assembly code isn't about sound at all - it's meant to be run \emph{twice
at the same time}.

Each running copy of the program has its own set of registers and follows the
code independently - in fact, the programs don\textquotesingle t even
necessarily run at the same speed. To coordinate, they use the \emph{send}
(\texttt{snd}) and \emph{receive} (\texttt{rcv}) instructions:

\begin{itemize}
\tightlist
\item
  \texttt{snd\ X} \emph{sends} the value of \texttt{X} to the other program.
  These values wait in a queue until that program is ready to receive them. Each
  program has its own message queue, so a program can never receive a message it
  sent.
\item
  \texttt{rcv\ X} \emph{receives} the next value and stores it in register
  \texttt{X}. If no values are in the queue, the program \emph{waits for a value
  to be sent to it}. Programs do not continue to the next instruction until they
  have received a value. Values are received in the order they are sent.
\end{itemize}

Each program also has its own \emph{program ID} (one \texttt{0} and the other
\texttt{1}); the register \texttt{p} should begin with this value.

Once both of your programs have terminated (regardless of what caused them to do
so), \emph{how many times did program \texttt{1} send a value}?
\end{quote}

(In each of these, ``the program'' is a program (written in the Duet assembly
language), which is different for each user and given to us by the site. If you
sign up and view the page, you will see a link to your own unique program to
run.)

What's going on here is that both parts execute the same program in two
different virtual machines --- one has ``sound'' and ``recover'', and the other
has ``send'' and ``receive''. We are supposed to run the same program in
\emph{both} of these machines.

However, note that these two machines aren't \emph{completely} different ---
they both have the ability to manipulate memory and read/shift program data. So
really, we want to be able to create a ``modular'' spec and implementation of
these machines, so that we may re-use this memory manipulation aspect when
constructing our machine, without duplicating any code.

\section{Parsing Duet}\label{parsing-duet}

First, let's get the parsing of the actual input program out of the way. We'll
be parsing a program into a list of ``ops'' that we will read as our program.

Our program will be interpreted as a list of \texttt{Op} values, a data type
representing opcodes. There are four categories: ``snd'', ``rcv'', ``jgz'', and
the binary mathematical operations:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{{-}{-} source: https://github.com/mstksg/inCode/tree/master/code{-}samples/duet/Duet.hs\#L32{-}L37}

\KeywordTok{type} \DataTypeTok{Addr} \OtherTok{=} \DataTypeTok{Either} \DataTypeTok{Char} \DataTypeTok{Int}

\KeywordTok{data} \DataTypeTok{Op} \OtherTok{=} \DataTypeTok{OSnd} \DataTypeTok{Addr}
        \OperatorTok{|} \DataTypeTok{ORcv} \DataTypeTok{Char}
        \OperatorTok{|} \DataTypeTok{OJgz} \DataTypeTok{Addr} \DataTypeTok{Addr}
        \OperatorTok{|} \DataTypeTok{OBin}\NormalTok{ (}\DataTypeTok{Int} \OtherTok{{-}\textgreater{}} \DataTypeTok{Int} \OtherTok{{-}\textgreater{}} \DataTypeTok{Int}\NormalTok{) }\DataTypeTok{Char} \DataTypeTok{Addr}
\end{Highlighting}
\end{Shaded}

It's important to remember that ``snd'', ``jgz'', and the binary operations can
all take either numbers or other registers.

Now, parsing a single \texttt{Op} is just a matter of pattern matching on
\texttt{words}:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{{-}{-} source: https://github.com/mstksg/inCode/tree/master/code{-}samples/duet/Duet.hs\#L39{-}L52}

\OtherTok{parseOp ::} \DataTypeTok{String} \OtherTok{{-}\textgreater{}} \DataTypeTok{Op}
\NormalTok{parseOp inp }\OtherTok{=} \KeywordTok{case} \FunctionTok{words}\NormalTok{ inp }\KeywordTok{of}
    \StringTok{"snd"}\OperatorTok{:}\NormalTok{c    }\OperatorTok{:}\NormalTok{\_   }\OtherTok{{-}\textgreater{}} \DataTypeTok{OSnd}\NormalTok{ (addr c)}
    \StringTok{"set"}\OperatorTok{:}\NormalTok{(x}\OperatorTok{:}\NormalTok{\_)}\OperatorTok{:}\NormalTok{y}\OperatorTok{:}\NormalTok{\_ }\OtherTok{{-}\textgreater{}} \DataTypeTok{OBin}\NormalTok{ (}\FunctionTok{const} \FunctionTok{id}\NormalTok{) x (addr y)}
    \StringTok{"add"}\OperatorTok{:}\NormalTok{(x}\OperatorTok{:}\NormalTok{\_)}\OperatorTok{:}\NormalTok{y}\OperatorTok{:}\NormalTok{\_ }\OtherTok{{-}\textgreater{}} \DataTypeTok{OBin}\NormalTok{ (}\OperatorTok{+}\NormalTok{)        x (addr y)}
    \StringTok{"mul"}\OperatorTok{:}\NormalTok{(x}\OperatorTok{:}\NormalTok{\_)}\OperatorTok{:}\NormalTok{y}\OperatorTok{:}\NormalTok{\_ }\OtherTok{{-}\textgreater{}} \DataTypeTok{OBin}\NormalTok{ (}\OperatorTok{*}\NormalTok{)        x (addr y)}
    \StringTok{"mod"}\OperatorTok{:}\NormalTok{(x}\OperatorTok{:}\NormalTok{\_)}\OperatorTok{:}\NormalTok{y}\OperatorTok{:}\NormalTok{\_ }\OtherTok{{-}\textgreater{}} \DataTypeTok{OBin} \FunctionTok{mod}\NormalTok{        x (addr y)}
    \StringTok{"rcv"}\OperatorTok{:}\NormalTok{(x}\OperatorTok{:}\NormalTok{\_)}\OperatorTok{:}\NormalTok{\_   }\OtherTok{{-}\textgreater{}} \DataTypeTok{ORcv}\NormalTok{ x}
    \StringTok{"jgz"}\OperatorTok{:}\NormalTok{x    }\OperatorTok{:}\NormalTok{y}\OperatorTok{:}\NormalTok{\_ }\OtherTok{{-}\textgreater{}} \DataTypeTok{OJgz}\NormalTok{ (addr x) (addr y)}
\NormalTok{    \_               }\OtherTok{{-}\textgreater{}} \FunctionTok{error} \StringTok{"Bad parse"}
  \KeywordTok{where}
\OtherTok{    addr ::} \DataTypeTok{String} \OtherTok{{-}\textgreater{}} \DataTypeTok{Addr}
\NormalTok{    addr [c] }\OperatorTok{|} \FunctionTok{isAlpha}\NormalTok{ c }\OtherTok{=} \DataTypeTok{Left}\NormalTok{ c}
\NormalTok{    addr str }\OtherTok{=} \DataTypeTok{Right}\NormalTok{ (}\FunctionTok{read}\NormalTok{ str)}
\end{Highlighting}
\end{Shaded}

We're going to store our program in a \texttt{PointedList} from the
\emph{\href{https://hackage.haskell.org/package/pointedlist}{pointedlist}}
package, which is a non-empty list with a ``focus'' at a given index, which we
use to represent the program counter/program head/current instruction. Parsing
our program is then just parsing each line in the program string, and collecting
them into a \texttt{PointedList}. We're ready to go!

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{{-}{-} source: https://github.com/mstksg/inCode/tree/master/code{-}samples/duet/Duet.hs\#L54{-}L55}

\OtherTok{parseProgram ::} \DataTypeTok{String} \OtherTok{{-}\textgreater{}} \DataTypeTok{P.PointedList} \DataTypeTok{Op}
\NormalTok{parseProgram }\OtherTok{=}\NormalTok{ fromJust }\OperatorTok{.}\NormalTok{ P.fromList }\OperatorTok{.} \FunctionTok{map}\NormalTok{ parseOp }\OperatorTok{.} \FunctionTok{lines}
\end{Highlighting}
\end{Shaded}

Note that it is possible to skip this parsing step and instead operate directly
on the original strings for the rest of the program, but this pre-processing
step lets us isolate our partial code and acts as a verification step as well,
to get rid of impossible states and commands right off the bat. Definitely more
in line with the Haskell Way™.

\section{Our Virtual Machine}\label{our-virtual-machine}

\subsection{Operational}\label{operational}

We're going to be using the great
\emph{\href{https://hackage.haskell.org/package/operational}{operational}}
library\footnote{You could also use the more-or-less identical
  \href{https://hackage.haskell.org/package/operational}{MonadPrompt} library.
  However, this is not to be confused with the
  \href{https://hackage.haskell.org/package/prompt}{prompt} library, which is
  unrelated! The library is actually my own that I wrote a few years back before
  I knew about MonadPrompt, and this unfortunate naming collision is one of my
  greatest Haskell regrets.} to build our representation of our interpreted
language. Another common choice is to use
\emph{\href{https://hackage.haskell.org/package/free}{free}}, and a lot of other
tutorials go down this route. I always felt like the implementation of
interpreter pattern programs in \emph{free} was a bit awkward, since it relies
on manually (and carefully) constructing continuations.

\emph{operational} lets us construct a language (and a monad) using GADTs to
represent command primitives; it essentially is \texttt{Free}, but abstracting
over the continuations we would otherwise need to write using the coyoneda
lemma. For example, to implement something like \texttt{State\ Int} (which we'll
call \texttt{IntState}), you might use this GADT:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{data} \DataTypeTok{StateCommand}\OtherTok{ ::} \DataTypeTok{Type} \OtherTok{{-}\textgreater{}} \DataTypeTok{Type} \KeywordTok{where}
    \DataTypeTok{Put}\OtherTok{ ::} \DataTypeTok{Int} \OtherTok{{-}\textgreater{}} \DataTypeTok{StateCommand}\NormalTok{ ()}
    \DataTypeTok{Get}\OtherTok{ ::} \DataTypeTok{StateCommand} \DataTypeTok{Int}
\end{Highlighting}
\end{Shaded}

For those unfamiliar with GADT syntax, this is declaring a data type
\texttt{StateCommand\ a} with two constructors --- \texttt{Put}, which takes an
\texttt{Int} and creates a \texttt{StateCommand\ ()}, and \texttt{Get}, which
takes no parameters and creates a \texttt{StateCommand\ Int}. We give
\texttt{StateCommand} a \emph{kind signature},
\texttt{Type\ -\textgreater{}\ Type}, meaning that it is a single-argument type
constructor (\texttt{Type} is just a synonym for \texttt{*}).

Our GADT here says that the two ``primitive'' commands of \texttt{IntState} are
``putting'' (which requires an \texttt{Int} and produces a \texttt{()} result)
and ``getting'' (which requires no inputs, and produces an \texttt{Int} result).

You can then write \texttt{IntState} as:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{type} \DataTypeTok{IntState} \OtherTok{=} \DataTypeTok{Program} \DataTypeTok{StateCommand}
\end{Highlighting}
\end{Shaded}

which automatically has the appropriate Functor, Applicative, and Monad
instances.

Our primitives can be constructed using \texttt{singleton}:

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{singleton ::} \DataTypeTok{StateCommand}\NormalTok{ a }\OtherTok{{-}\textgreater{}} \DataTypeTok{IntState}\NormalTok{ a}

\NormalTok{singleton (}\DataTypeTok{Put} \DecValTok{10}\NormalTok{)}\OtherTok{ ::} \DataTypeTok{IntState}\NormalTok{ ()}
\NormalTok{singleton }\DataTypeTok{Get}\OtherTok{      ::} \DataTypeTok{IntState} \DataTypeTok{Int}

\OtherTok{putInt ::} \DataTypeTok{Int} \OtherTok{{-}\textgreater{}} \DataTypeTok{IntState}\NormalTok{ ()}
\NormalTok{putInt }\OtherTok{=}\NormalTok{ singleton }\OperatorTok{.} \DataTypeTok{Put}

\OtherTok{getInt ::} \DataTypeTok{IntState} \DataTypeTok{Int}
\NormalTok{getInt }\OtherTok{=}\NormalTok{ singleton }\DataTypeTok{Get}
\end{Highlighting}
\end{Shaded}

With this, we can write an \texttt{IntState} action like we would write an
action in any other monad.

Now, we \emph{interpret} an \texttt{IntState} in a monadic context using the
appropriately named \texttt{interpretWithMonad}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{interpretWithMonad}
\OtherTok{    ::} \DataTypeTok{Monad}\NormalTok{ m                              }\CommentTok{{-}{-} m is the monad to interpret in}
    \OtherTok{=\textgreater{}}\NormalTok{ (}\KeywordTok{forall}\NormalTok{ x}\OperatorTok{.} \DataTypeTok{StateCommand}\NormalTok{ x }\OtherTok{{-}\textgreater{}}\NormalTok{ m x)    }\CommentTok{{-}{-} a way to interpret each primitive in \textquotesingle{}m\textquotesingle{}}
    \OtherTok{{-}\textgreater{}} \DataTypeTok{IntState}\NormalTok{ a                           }\CommentTok{{-}{-} IntState to interpret}
    \OtherTok{{-}\textgreater{}}\NormalTok{ m a                                  }\CommentTok{{-}{-} resulting action in \textquotesingle{}m\textquotesingle{}}
\end{Highlighting}
\end{Shaded}

If you're unfamiliar with \emph{-XRankNTypes},
\texttt{forall\ x.\ StateCommand\ x\ -\textgreater{}\ m\ x} is the type of a
handler that can handle a \texttt{StateCommand} of \emph{any} type, and return a
value of \texttt{m\ x} (an action returning the \emph{same type} as the
\texttt{StateCommand}). So, you can't give it something like
\texttt{StateCommand\ Int\ -\textgreater{}\ m\ Bool}, or
\texttt{StateCommand\ x\ -\textgreater{}\ m\ ()}\ldots it has to be able to
handle a \texttt{StateCommand\ a} of \emph{any} type \texttt{a} and return an
action in the interpreting context producing a result of the same type. If given
a \texttt{StateCommand\ Int}, it has to return an \texttt{m\ Int}, and if given
a \texttt{StateCommand\ ()}, it has to return an \texttt{m\ ()}, etc. etc.

Now, if we wanted to use \texttt{IO} and \texttt{IORefs} as the mechanism for
interpreting our \texttt{IntState}:

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{interpretIO ::} \DataTypeTok{IORef} \DataTypeTok{Int} \OtherTok{{-}\textgreater{}}\NormalTok{ (}\DataTypeTok{StateCommand}\NormalTok{ a }\OtherTok{{-}\textgreater{}} \DataTypeTok{IO}\NormalTok{ a)}
\NormalTok{interpretIO r }\OtherTok{=}\NormalTok{ \textbackslash{}}\KeywordTok{case}           \CommentTok{{-}{-} using {-}XLambdaCase}
    \DataTypeTok{Put}\NormalTok{ x }\OtherTok{{-}\textgreater{}}\NormalTok{ writeIORef r x}
    \DataTypeTok{Get}   \OtherTok{{-}\textgreater{}}\NormalTok{ readIORef r}

\OtherTok{runAsIO ::} \DataTypeTok{IntState}\NormalTok{ a }\OtherTok{{-}\textgreater{}} \DataTypeTok{Int} \OtherTok{{-}\textgreater{}} \DataTypeTok{IO}\NormalTok{ (a, }\DataTypeTok{Int}\NormalTok{)}
\NormalTok{runAsIO m s0 }\OtherTok{=} \KeywordTok{do}
\NormalTok{    r }\OtherTok{\textless{}{-}}\NormalTok{ newIORef s0}
\NormalTok{    interpretWithMonad (interpretIO r) m}
\end{Highlighting}
\end{Shaded}

\texttt{interpretIO\ r} is our interpreter, in \texttt{IO}.
\texttt{interpretWithMonad} will interpret each primitive (\texttt{Put} and
\texttt{Get}) using \texttt{interpretIO} and generate the result for us.

The GADT property of \texttt{StateCommand} ensures us that the \emph{result} of
our \texttt{IO} action matches with the result that the GADT constructor
implies, due to the magic of dependent pattern matching. For the
\texttt{Put\ x\ ::\ StateCommand\ ()} branch, the result has to be
\texttt{IO\ ()}; for the \texttt{Get\ ::\ StateCommand\ Int} branch, the result
has to be \texttt{IO\ Int}.

We can also be boring and interpret it using \texttt{State\ Int}:

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{interpretState ::} \DataTypeTok{StateCommand}\NormalTok{ a }\OtherTok{{-}\textgreater{}} \DataTypeTok{State} \DataTypeTok{Int}\NormalTok{ a}
\NormalTok{interpretState }\OtherTok{=}\NormalTok{ \textbackslash{}}\KeywordTok{case}
    \DataTypeTok{Put}\NormalTok{ x }\OtherTok{{-}\textgreater{}}\NormalTok{ put x}
    \DataTypeTok{Get}   \OtherTok{{-}\textgreater{}}\NormalTok{ get}

\OtherTok{runAsState ::} \DataTypeTok{IntState}\NormalTok{ a }\OtherTok{{-}\textgreater{}} \DataTypeTok{State} \DataTypeTok{Int}\NormalTok{ a}
\NormalTok{runAsState }\OtherTok{=}\NormalTok{ runPromptM interpretState}
\end{Highlighting}
\end{Shaded}

Basically, an \texttt{IntState\ a} is an abstract representation of a program
(as a Monad), and \texttt{interpretIO} and \texttt{interpretState} are different
ways of \emph{interpreting} that program, in different monadic contexts. To
``run'' or interpret our program in a context, we provide a function
\texttt{forall\ x.\ StateCommand\ x\ -\textgreater{}\ m\ x}, which interprets
each individual primitive command.

\subsection{Duet Commands}\label{duet-commands}

Now let's specify the ``primitives'' of our program. It'll be useful to separate
out the ``memory-based'' primitive commands from the ``communication-based''
primitive commands. This is so that we can write interpreters that operate on
each one individually, and re-use our memory-based primitives and interpreters
for both parts of the puzzle.

For memory, we can access and modify register values, as well as jump around in
the program tape and read the \texttt{Op} at the current program head:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{{-}{-} source: https://github.com/mstksg/inCode/tree/master/code{-}samples/duet/Duet.hs\#L57{-}L61}

\KeywordTok{data} \DataTypeTok{Mem}\OtherTok{ ::} \DataTypeTok{Type} \OtherTok{{-}\textgreater{}} \DataTypeTok{Type} \KeywordTok{where}
    \DataTypeTok{MGet}\OtherTok{  ::} \DataTypeTok{Char} \OtherTok{{-}\textgreater{}} \DataTypeTok{Mem} \DataTypeTok{Int}
    \DataTypeTok{MSet}\OtherTok{  ::} \DataTypeTok{Char} \OtherTok{{-}\textgreater{}} \DataTypeTok{Int} \OtherTok{{-}\textgreater{}} \DataTypeTok{Mem}\NormalTok{ ()}
    \DataTypeTok{MJump}\OtherTok{ ::} \DataTypeTok{Int}  \OtherTok{{-}\textgreater{}} \DataTypeTok{Mem}\NormalTok{ ()}
    \DataTypeTok{MPeek}\OtherTok{ ::} \DataTypeTok{Mem} \DataTypeTok{Op}
\end{Highlighting}
\end{Shaded}

For communication, we must be able to ``snd'' and ``rcv''.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{{-}{-} source: https://github.com/mstksg/inCode/tree/master/code{-}samples/duet/Duet.hs\#L63{-}L65}

\KeywordTok{data} \DataTypeTok{Com}\OtherTok{ ::} \DataTypeTok{Type} \OtherTok{{-}\textgreater{}} \DataTypeTok{Type} \KeywordTok{where}
    \DataTypeTok{CSnd}\OtherTok{ ::} \DataTypeTok{Int} \OtherTok{{-}\textgreater{}} \DataTypeTok{Com}\NormalTok{ ()}
    \DataTypeTok{CRcv}\OtherTok{ ::} \DataTypeTok{Int} \OtherTok{{-}\textgreater{}} \DataTypeTok{Com} \DataTypeTok{Int}
\end{Highlighting}
\end{Shaded}

Part A requires \texttt{CRcv} to take, as an argument, a number, since whether
or not \texttt{CRcv} is a no-op depends on the value of a certain register for
Part A's virtual machine.

Now, we can leverage the \texttt{:\textbar{}:} type from
\emph{\href{https://hackage.haskell.org/package/type-combinators}{type-combinators}}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{data}\NormalTok{ (f }\OperatorTok{:|:}\NormalTok{ g) a }\OtherTok{=} \DataTypeTok{L}\NormalTok{ (f a)}
                 \OperatorTok{|} \DataTypeTok{R}\NormalTok{ (g a)}
\end{Highlighting}
\end{Shaded}

\texttt{:\textbar{}:} is a ``functor disjunction'' --- a value of type
\texttt{(f\ :\textbar{}:\ g)\ a} is either \texttt{f\ a} or \texttt{g\ a}.
\texttt{:\textbar{}:} is in \emph{base} twice, as \texttt{:+:} in
\emph{GHC.Generics} and as \texttt{Sum} in \emph{Data.Functor.Sum}. However, the
version in \emph{type-combinators} has some nice utility combinators we will be
using and is more fully-featured.

We can use \texttt{:\textbar{}:} to create the type
\texttt{Mem\ :\textbar{}:\ Com}. If \texttt{Mem} and \texttt{Com} represent
``primitives'' in our Duet language, then \texttt{Mem\ :\textbar{}:\ Com}
represents \emph{primitives from either \texttt{Mem} or \texttt{Com}}. It's a
type that contains all of the primitives of \texttt{Mem} and the primitives of
\texttt{Com}. It contains:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{L}\NormalTok{ (}\DataTypeTok{MGet} \CharTok{\textquotesingle{}c\textquotesingle{}}\NormalTok{)}\OtherTok{ ::}\NormalTok{ (}\DataTypeTok{Mem} \OperatorTok{:|:} \DataTypeTok{Com}\NormalTok{) }\DataTypeTok{Int}
\DataTypeTok{L} \DataTypeTok{MPeek}\OtherTok{      ::}\NormalTok{ (}\DataTypeTok{Mem} \OperatorTok{:|:} \DataTypeTok{Com}\NormalTok{) }\DataTypeTok{Op}
\DataTypeTok{R}\NormalTok{ (}\DataTypeTok{CSnd} \DecValTok{5}\NormalTok{)}\OtherTok{   ::}\NormalTok{ (}\DataTypeTok{Mem} \OperatorTok{:|:} \DataTypeTok{Com}\NormalTok{) ()}
\end{Highlighting}
\end{Shaded}

etc.

Our final data monad, then --- a monad that encompasses \emph{all} possible Duet
primitive commands --- is:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{{-}{-} source: https://github.com/mstksg/inCode/tree/master/code{-}samples/duet/Duet.hs\#L67{-}L67}

\KeywordTok{type} \DataTypeTok{Duet} \OtherTok{=} \DataTypeTok{Program}\NormalTok{ (}\DataTypeTok{Mem} \OperatorTok{:|:} \DataTypeTok{Com}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

We can write some convenient utility primitives to make things easier for us in
the long run:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{{-}{-} source: https://github.com/mstksg/inCode/tree/master/code{-}samples/duet/Duet.hs\#L69{-}L85}

\OtherTok{dGet ::} \DataTypeTok{Char} \OtherTok{{-}\textgreater{}} \DataTypeTok{Duet} \DataTypeTok{Int}
\NormalTok{dGet }\OtherTok{=}\NormalTok{ singleton }\OperatorTok{.} \DataTypeTok{L} \OperatorTok{.} \DataTypeTok{MGet}

\OtherTok{dSet ::} \DataTypeTok{Char} \OtherTok{{-}\textgreater{}} \DataTypeTok{Int} \OtherTok{{-}\textgreater{}} \DataTypeTok{Duet}\NormalTok{ ()}
\NormalTok{dSet r }\OtherTok{=}\NormalTok{ singleton }\OperatorTok{.} \DataTypeTok{L} \OperatorTok{.} \DataTypeTok{MSet}\NormalTok{ r}

\OtherTok{dJump ::} \DataTypeTok{Int} \OtherTok{{-}\textgreater{}} \DataTypeTok{Duet}\NormalTok{ ()}
\NormalTok{dJump }\OtherTok{=}\NormalTok{ singleton }\OperatorTok{.} \DataTypeTok{L} \OperatorTok{.} \DataTypeTok{MJump}

\OtherTok{dPeek ::} \DataTypeTok{Duet} \DataTypeTok{Op}
\NormalTok{dPeek }\OtherTok{=}\NormalTok{ singleton (}\DataTypeTok{L} \DataTypeTok{MPeek}\NormalTok{)}

\OtherTok{dSnd ::} \DataTypeTok{Int} \OtherTok{{-}\textgreater{}} \DataTypeTok{Duet}\NormalTok{ ()}
\NormalTok{dSnd }\OtherTok{=}\NormalTok{ singleton }\OperatorTok{.} \DataTypeTok{R} \OperatorTok{.} \DataTypeTok{CSnd}

\OtherTok{dRcv ::} \DataTypeTok{Int} \OtherTok{{-}\textgreater{}} \DataTypeTok{Duet} \DataTypeTok{Int}
\NormalTok{dRcv }\OtherTok{=}\NormalTok{ singleton }\OperatorTok{.} \DataTypeTok{R} \OperatorTok{.} \DataTypeTok{CRcv}
\end{Highlighting}
\end{Shaded}

\subsection{Constructing Duet Programs}\label{constructing-duet-programs}

Armed with our \texttt{Duet} monad, we can now write a real-life \texttt{Duet}
action to represent \emph{one step} of our duet programs:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{{-}{-} source: https://github.com/mstksg/inCode/tree/master/code{-}samples/duet/Duet.hs\#L87{-}L110}

\OtherTok{stepProg ::} \DataTypeTok{Duet}\NormalTok{ ()}
\NormalTok{stepProg }\OtherTok{=}\NormalTok{ dPeek }\OperatorTok{\textgreater{}\textgreater{}=}\NormalTok{ \textbackslash{}}\KeywordTok{case}
    \DataTypeTok{OSnd}\NormalTok{ x }\OtherTok{{-}\textgreater{}} \KeywordTok{do}
\NormalTok{      dSnd }\OperatorTok{=\textless{}\textless{}}\NormalTok{ addrVal x}
\NormalTok{      dJump }\DecValTok{1}
    \DataTypeTok{OBin}\NormalTok{ f x y }\OtherTok{{-}\textgreater{}} \KeywordTok{do}
\NormalTok{      yVal }\OtherTok{\textless{}{-}}\NormalTok{ addrVal y}
\NormalTok{      xVal }\OtherTok{\textless{}{-}}\NormalTok{ dGet    x}
\NormalTok{      dSet x }\OperatorTok{$}\NormalTok{ f xVal yVal}
\NormalTok{      dJump }\DecValTok{1}
    \DataTypeTok{ORcv}\NormalTok{ x }\OtherTok{{-}\textgreater{}} \KeywordTok{do}
\NormalTok{      y }\OtherTok{\textless{}{-}}\NormalTok{ dRcv }\OperatorTok{=\textless{}\textless{}}\NormalTok{ dGet x}
\NormalTok{      dSet x y}
\NormalTok{      dJump }\DecValTok{1}
    \DataTypeTok{OJgz}\NormalTok{ x y }\OtherTok{{-}\textgreater{}} \KeywordTok{do}
\NormalTok{      xVal }\OtherTok{\textless{}{-}}\NormalTok{ addrVal x}
\NormalTok{      dJump }\OperatorTok{=\textless{}\textless{}} \KeywordTok{if}\NormalTok{ xVal }\OperatorTok{\textgreater{}} \DecValTok{0}
        \KeywordTok{then}\NormalTok{ addrVal y}
        \KeywordTok{else} \FunctionTok{return} \DecValTok{1}
  \KeywordTok{where}
    \CommentTok{{-}{-} | Addr is \textasciigrave{}Either Char Int\textasciigrave{} {-}{-} \textasciigrave{}Left\textasciigrave{} means a register (so we use}
    \CommentTok{{-}{-} \textasciigrave{}dGet\textasciigrave{}) and \textasciigrave{}Right\textasciigrave{} means a direct integer value.}
\NormalTok{    addrVal (}\DataTypeTok{Left}\NormalTok{ r ) }\OtherTok{=}\NormalTok{ dGet r}
\NormalTok{    addrVal (}\DataTypeTok{Right}\NormalTok{ x) }\OtherTok{=} \FunctionTok{return}\NormalTok{ x}
\end{Highlighting}
\end{Shaded}

This is basically a straightforward interpretation of the ``rules'' of our
language, and what to do when encountering each op code.

The only non-trivial thing is the \texttt{ORcv} branch, where we include the
contents of the register in question, so that our interpreter will know whether
or not to treat it as a no-op.

\section{The Interpreters}\label{the-interpreters}

Now for the fun part!

\subsection{Interpreting Memory
Primitives}\label{interpreting-memory-primitives}

To interpret our \texttt{Mem} primitives, we need to be in some sort of stateful
monad that contains the program state. First, let's make a type describing our
relevant program state, along with classy lenses for operating on it
polymorphically:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{{-}{-} source: https://github.com/mstksg/inCode/tree/master/code{-}samples/duet/Duet.hs\#L112{-}L116}

\KeywordTok{data} \DataTypeTok{ProgState} \OtherTok{=} \DataTypeTok{PS}
\NormalTok{    \{}\OtherTok{ \_psOps  ::} \DataTypeTok{P.PointedList} \DataTypeTok{Op}
\NormalTok{    ,}\OtherTok{ \_psRegs ::} \DataTypeTok{M.Map} \DataTypeTok{Char} \DataTypeTok{Int}
\NormalTok{    \}}
\NormalTok{makeClassy \textquotesingle{}}\DataTypeTok{\textquotesingle{}ProgState}
\end{Highlighting}
\end{Shaded}

We store the current program and program head with the \texttt{PointedList}, and
also represent the register contents with a \texttt{Map\ Char\ Int}.

\subsubsection{Brief Aside on Lenses with
State}\label{brief-aside-on-lenses-with-state}

We're going to be implementing our interpreters using
\emph{\href{https://hackage.haskell.org/package/lens}{lens}} machinery. Keep in
mind that this isn't necessary --- to me, this just makes things a lot simpler.
Using \emph{lens} with classy lenses is one of the things that make programming
against \texttt{State} and \texttt{MonadState} with non-trivial state bearable
for me, personally! However, keep in mind that the lens aspect is more or less
unrelated to the interpreter pattern and is not necessary for it. We're just
using it here to make \texttt{State} and \texttt{MonadState} a little nicer to
work with!

\texttt{makeClassy} gives us a typeclass \texttt{HasProgState}, which is for
things that ``have'' a \texttt{ProgState}, as well as lenses into the
\texttt{psOps} and \texttt{psRegs} field for that type:

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{psOps  ::} \DataTypeTok{HasProgState}\NormalTok{ s }\OtherTok{=\textgreater{}} \DataTypeTok{Lens\textquotesingle{}}\NormalTok{ s (}\DataTypeTok{P.PointedList} \DataTypeTok{Op}\NormalTok{)}
\OtherTok{psRegs ::} \DataTypeTok{HasProgState}\NormalTok{ s }\OtherTok{=\textgreater{}} \DataTypeTok{Lens\textquotesingle{}}\NormalTok{ s (}\DataTypeTok{M.Map} \DataTypeTok{Char} \DataTypeTok{Int}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

We can use these lenses with \emph{lens} library functions for working with
State:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{{-}{-} | "get" based on a lens}
\OtherTok{use   ::} \DataTypeTok{MonadState}\NormalTok{ s m }\OtherTok{=\textgreater{}} \DataTypeTok{Lens\textquotesingle{}}\NormalTok{ s a }\OtherTok{{-}\textgreater{}}\NormalTok{ m a}

\CommentTok{{-}{-} | "set" through on a lens}
\OtherTok{(.=)  ::} \DataTypeTok{MonadState}\NormalTok{ s m }\OtherTok{=\textgreater{}} \DataTypeTok{Lens\textquotesingle{}}\NormalTok{ s a }\OtherTok{{-}\textgreater{}}\NormalTok{ a }\OtherTok{{-}\textgreater{}}\NormalTok{ m ()}

\CommentTok{{-}{-} | "lift" a State action through a lens}
\OtherTok{zoom  ::} \DataTypeTok{Lens\textquotesingle{}}\NormalTok{ s t }\OtherTok{{-}\textgreater{}} \DataTypeTok{State}\NormalTok{ t a }\OtherTok{{-}\textgreater{}} \DataTypeTok{State}\NormalTok{ s a}
\end{Highlighting}
\end{Shaded}

So, for example, we have:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{{-}{-} | "get" the registers}
\NormalTok{use}\OtherTok{ psRegs ::}\NormalTok{ (}\DataTypeTok{HasProgState}\NormalTok{ s, }\DataTypeTok{MonadState}\NormalTok{ s m) }\OtherTok{=\textgreater{}}\NormalTok{ m (}\DataTypeTok{M.Map} \DataTypeTok{Char} \DataTypeTok{Int}\NormalTok{)}

\CommentTok{{-}{-} | "set" the PointedList}
\NormalTok{(psOps }\OperatorTok{.=}\NormalTok{)}\OtherTok{ ::}\NormalTok{ (}\DataTypeTok{HasProgState}\NormalTok{ s, }\DataTypeTok{MonadState}\NormalTok{ s m) }\OtherTok{=\textgreater{}} \DataTypeTok{P.PointedList} \DataTypeTok{Op} \OtherTok{{-}\textgreater{}}\NormalTok{ m ()}
\end{Highlighting}
\end{Shaded}

The nice thing about lenses is that they compose. For example, we have:

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{at ::}\NormalTok{ k }\OtherTok{{-}\textgreater{}} \DataTypeTok{Lens\textquotesingle{}}\NormalTok{ (}\DataTypeTok{Map}\NormalTok{ k    v  ) (}\DataTypeTok{Maybe}\NormalTok{ v  )}

\NormalTok{at }\CharTok{\textquotesingle{}h\textquotesingle{}}\OtherTok{  ::} \DataTypeTok{Lens\textquotesingle{}}\NormalTok{ (}\DataTypeTok{Map} \DataTypeTok{Char} \DataTypeTok{Int}\NormalTok{) (}\DataTypeTok{Maybe} \DataTypeTok{Int}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

We can use \texttt{at\ \textquotesingle{}c\textquotesingle{}} to give us a lens
from our registers (\texttt{Map\ Char\ Int}) into the specific register
\texttt{\textquotesingle{}c\textquotesingle{}} as a \texttt{Maybe\ Int} --- it's
\texttt{Nothing} if the item is not in the \texttt{Map}, and \texttt{Just} if it
is (with the value).

However, we want to treat all registers as \texttt{0} by default, not as
\texttt{Nothing}, so we can use \texttt{non\ 0}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{non }\DecValTok{0}\OtherTok{ ::} \DataTypeTok{Lens\textquotesingle{}}\NormalTok{ (}\DataTypeTok{Maybe} \DataTypeTok{Int}\NormalTok{) }\DataTypeTok{Int}
\end{Highlighting}
\end{Shaded}

\texttt{non\ 0} is a \texttt{Lens} (actually an \texttt{Iso}, but who's
counting?) into a \texttt{Maybe\ Int} to treat \texttt{Nothing} as if it was
\texttt{0}, and to treat \texttt{Just\ x} as if it was \texttt{x}.

We can chain \texttt{at\ r} with \texttt{non\ 0} to get a lens into a
\texttt{Map\ Char\ Int}, which we can use to edit a specific item, treating
non-present-items as 0.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{         at }\CharTok{\textquotesingle{}h\textquotesingle{}} \OperatorTok{.}\NormalTok{ non }\DecValTok{0}\OtherTok{ ::} \DataTypeTok{Lens\textquotesingle{}}\NormalTok{ (}\DataTypeTok{Map} \DataTypeTok{Char} \DataTypeTok{Int}\NormalTok{) }\DataTypeTok{Int}

\NormalTok{psRegs }\OperatorTok{.}\NormalTok{ at }\CharTok{\textquotesingle{}h\textquotesingle{}} \OperatorTok{.}\NormalTok{ non }\DecValTok{0}\OtherTok{ ::} \DataTypeTok{HasProgState}\NormalTok{ s }\OtherTok{=\textgreater{}} \DataTypeTok{Lens\textquotesingle{}}\NormalTok{ s }\DataTypeTok{Int}
\end{Highlighting}
\end{Shaded}

\subsubsection{Interpreting Mem}\label{interpreting-mem}

With these tools to make life easier, we can write an interpreter for our
\texttt{Mem} commands:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{{-}{-} source: https://github.com/mstksg/inCode/tree/master/code{-}samples/duet/Duet.hs\#L118{-}L128}

\NormalTok{interpMem}
\OtherTok{    ::}\NormalTok{ (}\DataTypeTok{MonadState}\NormalTok{ s m, }\DataTypeTok{MonadFail}\NormalTok{ m, }\DataTypeTok{HasProgState}\NormalTok{ s)}
    \OtherTok{=\textgreater{}} \DataTypeTok{Mem}\NormalTok{ a}
    \OtherTok{{-}\textgreater{}}\NormalTok{ m a}
\NormalTok{interpMem }\OtherTok{=}\NormalTok{ \textbackslash{}}\KeywordTok{case}
    \DataTypeTok{MGet}\NormalTok{ c   }\OtherTok{{-}\textgreater{}}\NormalTok{ use (psRegs }\OperatorTok{.}\NormalTok{ at c }\OperatorTok{.}\NormalTok{ non }\DecValTok{0}\NormalTok{)}
    \DataTypeTok{MSet}\NormalTok{ c x }\OtherTok{{-}\textgreater{}}\NormalTok{ psRegs }\OperatorTok{.}\NormalTok{ at c }\OperatorTok{.}\NormalTok{ non }\DecValTok{0} \OperatorTok{.=}\NormalTok{ x}
    \DataTypeTok{MJump}\NormalTok{ n  }\OtherTok{{-}\textgreater{}} \KeywordTok{do}
      \DataTypeTok{Just}\NormalTok{ t\textquotesingle{} }\OtherTok{\textless{}{-}}\NormalTok{ P.moveN n }\OperatorTok{\textless{}$\textgreater{}}\NormalTok{ use psOps}
\NormalTok{      psOps }\OperatorTok{.=}\NormalTok{ t\textquotesingle{}}
    \DataTypeTok{MPeek}    \OtherTok{{-}\textgreater{}}\NormalTok{ use (psOps }\OperatorTok{.}\NormalTok{ P.focus)}
\end{Highlighting}
\end{Shaded}

Nothing too surprising here --- we just interpret every primitive in our monadic
context.

We use \texttt{MonadFail} to explicitly state that we rely on a failed pattern
match for control flow.\footnote{Using \texttt{MonadFail} in situations were we
  would normally use \texttt{Alternative}/\texttt{MonadPlus}, to take advantage
  of pattern match syntax in do block and have it work with \texttt{Alternative}
  combinators like \texttt{many}, is
  \href{https://wiki.haskell.org/MonadFail_Proposal}{coming}! For good hygiene,
  remember to turn on the \emph{-XMonadFailDesugaring} extension so that pattern
  match failures explicitly use \texttt{fail} from \texttt{MonadFail}, thus
  requiring the typeclass constraint.}
\texttt{P.moveN\ ::\ Int\ -\textgreater{}\ P.PointedList\ a\ -\textgreater{}\ Maybe\ (P.PointedList\ a)}
will ``shift'' a \texttt{PointedList} by a given amount, but will return
\texttt{Nothing} if it goes out of bounds. Our program is meant to terminate if
we ever go out of bounds, so we can implement this by using a do block pattern
match with \texttt{MonadFail}. For instances like
\texttt{MaybeT}/\texttt{Maybe}, this means
\texttt{empty}/\texttt{Nothing}/short-circuit. So when we \texttt{P.move}, we
do-block pattern match on \texttt{Just\ t\textquotesingle{}}.

We also use \texttt{P.focus\ ::\ Lens\textquotesingle{}\ (P.PointedList\ a)\ a},
a lens that the \emph{pointedlist} library provides to the current ``focus'' of
the \texttt{PointedList}.

Again, this usage of lens with State is not exactly necessary (we can manually
use \texttt{modify}, \texttt{gets}, etc. instead of lenses and their
combinators, which gets ugly pretty quickly), but it does make things a bit more
convenient to write.

We're programming against \emph{abstract interfaces} (like \texttt{MonadState},
\texttt{MonadFail}) instead of actual instances (like \texttt{StateT}, etc.)
because, as we will see later, this lets us combine interpreters together much
more smoothly.

\subsubsection{GADT Property}\label{gadt-property}

Again, the GADT-ness of \texttt{Mem} (and \texttt{Com}) works to enforce that
the ``results'' that each primitive expects is the result that we give.

For example, \texttt{MGet\ \textquotesingle{}c\textquotesingle{}\ ::\ Mem\ Int}
requires us to return \texttt{m\ Int}. This is what \texttt{use} gives us.
\texttt{MSet\ \textquotesingle{}c\textquotesingle{}\ 3\ ::\ Mem\ ()} requires us
to return \texttt{m\ ()}, which is what \texttt{(.=)} returns.

We have \texttt{MPeek\ ::\ Mem\ Op}, which requires us to return \texttt{m\ Op}.
That's exactly what
\texttt{use\ (psOps\ .\ P.focus)\ ::\ (MonadState\ s\ m,\ HasProgState\ s)\ =\textgreater{}\ m\ Op}
gives.

The fact that we can use GADTs to specify the ``result type'' of each of our
primitives is a key part about how \texttt{Program} from \emph{operational}
works, and how it implements the interpreter pattern.

This is enforced in Haskell's type system (through the ``dependent pattern
match''), so GHC will complain to us if we ever return something of the wrong
type while handling a given constructor/primitive.

\subsection{Interpreting Com for Part A}\label{interpreting-com-for-part-a}

Now, Part A requires an environment where:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \texttt{CSnd} ``emits'' items (as sounds), keeping track only of the
  \emph{last} emitted item
\item
  \texttt{CRcv} ``catches'' the last thing seen by \texttt{CSnd}, keeping track
  of only the \emph{first} caught item
\end{enumerate}

We can keep track of this using \texttt{MonadWriter\ (First\ Int)} to interpret
\texttt{CRcv} (if there are two \emph{rcv}'s, we only care about the first
\emph{rcv}'d thing), and \texttt{MonadAccum\ (Last\ Int)} to interpret
\texttt{CSnd}. A \texttt{MonadAccum} is just like \texttt{MonadWriter} (where
you can ``tell'' things and accumulate things), but you also have the ability to
read the accumulated log at any time. We use \texttt{Last\ Int} because, if
there are two \emph{snd}'s, we only care about the last \emph{snd}'d thing.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{{-}{-} source: https://github.com/mstksg/inCode/tree/master/code{-}samples/duet/Duet.hs\#L134{-}L145}

\NormalTok{interpComA}
\OtherTok{    ::}\NormalTok{ (}\DataTypeTok{MonadAccum}\NormalTok{ (}\DataTypeTok{Last} \DataTypeTok{Int}\NormalTok{) m, }\DataTypeTok{MonadWriter}\NormalTok{ (}\DataTypeTok{First} \DataTypeTok{Int}\NormalTok{) m)}
    \OtherTok{=\textgreater{}} \DataTypeTok{Com}\NormalTok{ a}
    \OtherTok{{-}\textgreater{}}\NormalTok{ m a}
\NormalTok{interpComA }\OtherTok{=}\NormalTok{ \textbackslash{}}\KeywordTok{case}
    \DataTypeTok{CSnd}\NormalTok{ x }\OtherTok{{-}\textgreater{}}
\NormalTok{      add (}\DataTypeTok{Last}\NormalTok{ (}\DataTypeTok{Just}\NormalTok{ x))}
    \DataTypeTok{CRcv}\NormalTok{ x }\OtherTok{{-}\textgreater{}} \KeywordTok{do}
\NormalTok{      unless (x }\OperatorTok{==} \DecValTok{0}\NormalTok{) }\OperatorTok{$} \KeywordTok{do}      \CommentTok{{-}{-} don\textquotesingle{}t rcv if the register parameter is 0}
        \DataTypeTok{Last}\NormalTok{ lastSent }\OtherTok{\textless{}{-}}\NormalTok{ look}
\NormalTok{        tell (}\DataTypeTok{First}\NormalTok{ lastSent)}
      \FunctionTok{return}\NormalTok{ x}
\end{Highlighting}
\end{Shaded}

Note
\texttt{add\ ::\ MonadAccum\ w\ m\ =\textgreater{}\ w\ -\textgreater{}\ m\ ()}
and \texttt{look\ ::\ MonadAccum\ w\ w}, the functions to ``tell'' to a
\texttt{MonadAccum} and the function to ``get''/``ask'' from a
\texttt{MonadAccum}.

\subsubsection{MonadAccum}\label{monadaccum}

Small relevant note --- \texttt{MonadAccum} does not yet exist in \emph{mtl},
though it probably will in the next version. It's the classy version of
\texttt{AccumT}, which is already in
\emph{\href{https://hackage.haskell.org/package/transformers-0.5.5.0}{transformers-0.5.5.0}}.

For now,
\href{https://github.com/mstksg/inCode/tree/master/code-samples/duet/Duet.hs\#L130-L132}{I've
added \texttt{MonadAccum}} and
\href{https://github.com/mstksg/inCode/tree/master/code-samples/duet/Duet.hs\#L249-L251}{appropriate
instances} in the sample source code, but when the new version of \emph{mtl}
comes out, I'll be sure to update this post to take this into account!

\subsection{Interpreting Com for Part B}\label{interpreting-com-for-part-b}

Part B requires an environment where:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \texttt{CSnd} ``emits'' items into into some accumulating log of items, and we
  need to keep track of all of them.
\item
  \texttt{CRcv} ``consumes'' items from some external environment, and fails
  when there are no more items to consume.
\end{enumerate}

We can interpret \texttt{CSnd}'s effects using \texttt{MonadWriter\ {[}Int{]}},
to collect all emitted \texttt{Int}s. We can interpret \texttt{CRcv}'s effects
using \texttt{MonadState\ s}, where \texttt{s} contains an \texttt{{[}Int{]}}
acting as a source of \texttt{Int}s to consume.

We're going to use a \texttt{Thread} type to keep track of all thread state. We
do this so we can merge the contexts of \texttt{interpMem} and
\texttt{interpComB}, and really treat them (using type inference) as both
working in the same interpretation context.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{{-}{-} source: https://github.com/mstksg/inCode/tree/master/code{-}samples/duet/Duet.hs\#L158{-}L165}

\KeywordTok{data} \DataTypeTok{Thread} \OtherTok{=} \DataTypeTok{T}
\NormalTok{    \{}\OtherTok{ \_tState   ::} \DataTypeTok{ProgState}
\NormalTok{    ,}\OtherTok{ \_tBuffer  ::}\NormalTok{ [}\DataTypeTok{Int}\NormalTok{]}
\NormalTok{    \}}
\NormalTok{makeClassy \textquotesingle{}}\DataTypeTok{\textquotesingle{}Thread}

\KeywordTok{instance} \DataTypeTok{HasProgState} \DataTypeTok{Thread} \KeywordTok{where}
\NormalTok{    progState }\OtherTok{=}\NormalTok{ tState}
\end{Highlighting}
\end{Shaded}

(We write an instance for \texttt{HasProgState\ Thread}, so we can use
\texttt{interpMem} in a \texttt{MonadState\ Thread\ m}, since
\texttt{psRegs\ ::\ Lens\textquotesingle{}\ Thread\ (M.Map\ Char\ Int)}, for
example, will refer to the \texttt{psRegs} inside the \texttt{ProgState} in the
\texttt{Thread})

And now, to interpret:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{{-}{-} source: https://github.com/mstksg/inCode/tree/master/code{-}samples/duet/Duet.hs\#L167{-}L176}

\NormalTok{interpComB}
\OtherTok{    ::}\NormalTok{ (}\DataTypeTok{MonadWriter}\NormalTok{ [}\DataTypeTok{Int}\NormalTok{] m, }\DataTypeTok{MonadFail}\NormalTok{ m, }\DataTypeTok{MonadState} \DataTypeTok{Thread}\NormalTok{ m)}
    \OtherTok{=\textgreater{}} \DataTypeTok{Com}\NormalTok{ a}
    \OtherTok{{-}\textgreater{}}\NormalTok{ m a}
\NormalTok{interpComB }\OtherTok{=}\NormalTok{ \textbackslash{}}\KeywordTok{case}
    \DataTypeTok{CSnd}\NormalTok{ x }\OtherTok{{-}\textgreater{}}\NormalTok{ tell [x]}
    \DataTypeTok{CRcv}\NormalTok{ \_ }\OtherTok{{-}\textgreater{}} \KeywordTok{do}
\NormalTok{      x}\OperatorTok{:}\NormalTok{xs }\OtherTok{\textless{}{-}}\NormalTok{ use tBuffer}
\NormalTok{      tBuffer }\OperatorTok{.=}\NormalTok{ xs}
      \FunctionTok{return}\NormalTok{ x}
\end{Highlighting}
\end{Shaded}

Note again the usage of do block pattern matches and \texttt{MonadFail}.

\subsection{Combining Interpreters}\label{combining-interpreters}

To combine interpreters, we're going to be using, from \emph{type-combinators}:

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{(\textgreater{}|\textless{}) ::}\NormalTok{ (f a }\OtherTok{{-}\textgreater{}}\NormalTok{ r)}
      \OtherTok{{-}\textgreater{}}\NormalTok{ (g a }\OtherTok{{-}\textgreater{}}\NormalTok{ r)}
      \OtherTok{{-}\textgreater{}}\NormalTok{ ((f }\OperatorTok{:|:}\NormalTok{ g) a }\OtherTok{{-}\textgreater{}}\NormalTok{ r)}
\end{Highlighting}
\end{Shaded}

Basically, \texttt{\textgreater{}\textbar{}\textless{}} lets us write a
``handler'' for a \texttt{:\textbar{}:} by providing a handler for each side.
For example, with more concrete types:

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{(\textgreater{}|\textless{}) ::}\NormalTok{ (}\DataTypeTok{Mem}\NormalTok{ a           }\OtherTok{{-}\textgreater{}}\NormalTok{ r)}
      \OtherTok{{-}\textgreater{}}\NormalTok{ (}\DataTypeTok{Com}\NormalTok{ a           }\OtherTok{{-}\textgreater{}}\NormalTok{ r)}
      \OtherTok{{-}\textgreater{}}\NormalTok{ ((}\DataTypeTok{Mem} \OperatorTok{:|:} \DataTypeTok{Com}\NormalTok{) a }\OtherTok{{-}\textgreater{}}\NormalTok{ r)}
\end{Highlighting}
\end{Shaded}

We can use this to build an interpreter for \texttt{Duet}, which goes into
\texttt{interpretWithMonad}, by using
\texttt{\textgreater{}\textbar{}\textless{}} to generate our compound
interpreters.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{interpretWithMonad}
\OtherTok{    ::} \DataTypeTok{Monad}\NormalTok{ m}
    \OtherTok{=\textgreater{}}\NormalTok{ (}\KeywordTok{forall}\NormalTok{ x}\OperatorTok{.}\NormalTok{ (}\DataTypeTok{Mem}\NormalTok{ x }\OperatorTok{:|:} \DataTypeTok{Com}\NormalTok{ x) }\OtherTok{{-}\textgreater{}}\NormalTok{ m x)}
    \OtherTok{{-}\textgreater{}} \DataTypeTok{Duet}\NormalTok{ a}
    \OtherTok{{-}\textgreater{}}\NormalTok{ m a}
\end{Highlighting}
\end{Shaded}

This is how we can create interpreters on \texttt{Duet} by ``combining'', in a
modular way, interpreters for \texttt{Mem} and \texttt{Com}. This is the essence
of the ``data types a la carte'' technique and the modular interpreter pattern.

\section{Getting the Results}\label{getting-the-results}

We now just have to pick concrete monads now for us to interpret into.

\subsection{Part A}\label{part-a}

Our interpreter for Part A is
\texttt{interpMem\ \textgreater{}\textbar{}\textless{}\ interpComA} --- we
interpret the \texttt{Mem} primitives the usual way, and interpret the
\texttt{Com} primitives the Part A way.

Let's check what capabilities our interpreter must have:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ghci}\OperatorTok{\textgreater{}} \OperatorTok{:}\NormalTok{t interpMem }\OperatorTok{\textgreater{}|\textless{}}\NormalTok{ interpComA}
\NormalTok{interpMem }\OperatorTok{\textgreater{}|\textless{}}\NormalTok{ interpComA}
\OtherTok{    ::}\NormalTok{ ( }\DataTypeTok{MonadWriter}\NormalTok{ (}\DataTypeTok{First} \DataTypeTok{Int}\NormalTok{) m}
\NormalTok{       , }\DataTypeTok{MonadAccum}\NormalTok{ (}\DataTypeTok{Last} \DataTypeTok{Int}\NormalTok{) m}
\NormalTok{       , }\DataTypeTok{MonadFail}\NormalTok{ m}
\NormalTok{       , }\DataTypeTok{MonadState}\NormalTok{ s m}
\NormalTok{       , }\DataTypeTok{HasProgState}\NormalTok{ s}
\NormalTok{       )}
    \OtherTok{=\textgreater{}}\NormalTok{ (}\DataTypeTok{Mem} \OperatorTok{:|:} \DataTypeTok{Com}\NormalTok{) a}
    \OtherTok{{-}\textgreater{}}\NormalTok{ m a}
\end{Highlighting}
\end{Shaded}

So it looks like we need to be \texttt{MonadWriter\ (First\ Int)},
\texttt{MonadAccum\ (Last\ Int)}, \texttt{MonadFail\ m}, and
\texttt{MonadState\ s\ m}, where \texttt{HasProgState\ s}.

Now, we can write such a Monad from scratch, or we can use the
\emph{transformers} library to generate a transformer with all of those
instances for us. For the sake of brevity and reducing duplicated code, let's
take the latter route. We can use:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{MaybeT}\NormalTok{ (}\DataTypeTok{StateT} \DataTypeTok{ProgState}\NormalTok{ (}\DataTypeTok{WriterT}\NormalTok{ (}\DataTypeTok{First} \DataTypeTok{Int}\NormalTok{) (}\DataTypeTok{Accum}\NormalTok{ (}\DataTypeTok{Last} \DataTypeTok{Int}\NormalTok{))))}
\end{Highlighting}
\end{Shaded}

And so we can write our final ``step'' function in that context:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{{-}{-} source: https://github.com/mstksg/inCode/tree/master/code{-}samples/duet/Duet.hs\#L147{-}L148}

\OtherTok{stepA ::} \DataTypeTok{MaybeT}\NormalTok{ (}\DataTypeTok{StateT} \DataTypeTok{ProgState}\NormalTok{ (}\DataTypeTok{WriterT}\NormalTok{ (}\DataTypeTok{First} \DataTypeTok{Int}\NormalTok{) (}\DataTypeTok{A.Accum}\NormalTok{ (}\DataTypeTok{Last} \DataTypeTok{Int}\NormalTok{)))) ()}
\NormalTok{stepA }\OtherTok{=}\NormalTok{ interpretWithMonad (interpMem }\OperatorTok{\textgreater{}|\textless{}}\NormalTok{ interpComA) stepProg}
\end{Highlighting}
\end{Shaded}

\texttt{stepA} will make a single step of the tape, according to the
interpreters \texttt{interpMem} and \texttt{interpComA}.

Our final answer is then just the result of \emph{repeating} this over and over
again until there's a failure (we jump out-of-bounds). We take advantage of the
fact that \texttt{MaybeT}'s \texttt{Alternative} instance uses \texttt{empty}
for \texttt{fail}, so we can use
\texttt{many\ ::\ MaybeT\ m\ a\ -\textgreater{}\ MaybeT\ m\ {[}a{]}}, which
repeats a \texttt{MaybeT} action several times until a failure is encountered.
In our case, this means we repeat until we jump out of bounds.

As a nice benefit of laziness, note that if we only want the value of the
\texttt{First\ Int} in the \texttt{WriterT}, this will actually only repeat
\texttt{stepA} until the \emph{first} valid \texttt{CRcv} uses \texttt{tell}. If
we only ask for the \texttt{First\ Int}, it'll stop running the rest of the
computation, bypassing \texttt{many}!

Here is the entirety of running Part A --- as you can see, it consists mostly of
unwrapping \emph{transformers} newtype wrappers.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{{-}{-} source: https://github.com/mstksg/inCode/tree/master/code{-}samples/duet/Duet.hs\#L150{-}L156}

\OtherTok{partA ::} \DataTypeTok{P.PointedList} \DataTypeTok{Op} \OtherTok{{-}\textgreater{}} \DataTypeTok{Maybe} \DataTypeTok{Int}
\NormalTok{partA ops }\OtherTok{=}\NormalTok{ getFirst}
          \OperatorTok{.} \FunctionTok{flip}\NormalTok{ A.evalAccum }\FunctionTok{mempty}
          \OperatorTok{.}\NormalTok{ execWriterT}
          \OperatorTok{.} \FunctionTok{flip}\NormalTok{ runStateT (}\DataTypeTok{PS}\NormalTok{ ops M.empty)}
          \OperatorTok{.}\NormalTok{ runMaybeT}
          \OperatorTok{$}\NormalTok{ many stepA}
\end{Highlighting}
\end{Shaded}

A \texttt{Nothing} result means that the \texttt{Writer} log never received any
outputs before \texttt{many} ends looping, which means that the tape goes out of
bounds before a successful \emph{rcv}.

\subsection{Part B}\label{part-b}

Our interpreter's type for Part B is a little simpler:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ghci}\OperatorTok{\textgreater{}} \OperatorTok{:}\NormalTok{t interpMem }\OperatorTok{\textgreater{}|\textless{}}\NormalTok{ interpComB}
\NormalTok{interpMem }\OperatorTok{\textgreater{}|\textless{}}\NormalTok{ interpComB}
\OtherTok{    ::}\NormalTok{ ( }\DataTypeTok{MonadWriter}\NormalTok{ [}\DataTypeTok{Int}\NormalTok{] m}
\NormalTok{       , }\DataTypeTok{MonadFail}\NormalTok{ m}
\NormalTok{       , }\DataTypeTok{MonadState} \DataTypeTok{Thread}\NormalTok{ m}
\NormalTok{       )}
    \OtherTok{=\textgreater{}}\NormalTok{ (}\DataTypeTok{Mem} \OperatorTok{:|:} \DataTypeTok{Com}\NormalTok{) a}
    \OtherTok{{-}\textgreater{}}\NormalTok{ m a}
\end{Highlighting}
\end{Shaded}

We can really just use:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{WriterT}\NormalTok{ [}\DataTypeTok{Int}\NormalTok{] (}\DataTypeTok{MaybeT}\NormalTok{ (}\DataTypeTok{State} \DataTypeTok{Thread}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

Writing our concrete \texttt{stepB} is a little more involved, since we have to
juggle the state of each thread separately. We can do this using:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{zoom}\OtherTok{ \_1 ::} \DataTypeTok{MaybeT}\NormalTok{ (}\DataTypeTok{State}\NormalTok{ s) a }\OtherTok{{-}\textgreater{}} \DataTypeTok{MaybeT}\NormalTok{ (}\DataTypeTok{State}\NormalTok{ (s, t)) a}
\NormalTok{zoom}\OtherTok{ \_2 ::} \DataTypeTok{MaybeT}\NormalTok{ (}\DataTypeTok{State}\NormalTok{ t) a }\OtherTok{{-}\textgreater{}} \DataTypeTok{MaybeT}\NormalTok{ (}\DataTypeTok{State}\NormalTok{ (s, t)) a}
\end{Highlighting}
\end{Shaded}

To ``lift'' our actions on one thread to be actions on a ``tuple'' of threads.
We have, in the end:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{{-}{-} source: https://github.com/mstksg/inCode/tree/master/code{-}samples/duet/Duet.hs\#L178{-}L187}

\OtherTok{stepB ::} \DataTypeTok{MaybeT}\NormalTok{ (}\DataTypeTok{State}\NormalTok{ (}\DataTypeTok{Thread}\NormalTok{, }\DataTypeTok{Thread}\NormalTok{)) }\DataTypeTok{Int}
\NormalTok{stepB }\OtherTok{=} \KeywordTok{do}
\NormalTok{    outA }\OtherTok{\textless{}{-}}\NormalTok{ execWriterT }\OperatorTok{.}\NormalTok{ zoom \_1 }\OperatorTok{$}
\NormalTok{      many }\OperatorTok{$}\NormalTok{ interpretWithMonad (interpMem }\OperatorTok{\textgreater{}|\textless{}}\NormalTok{ interpComB) stepProg}
\NormalTok{    outB }\OtherTok{\textless{}{-}}\NormalTok{ execWriterT }\OperatorTok{.}\NormalTok{ zoom \_2 }\OperatorTok{$}
\NormalTok{      many }\OperatorTok{$}\NormalTok{ interpretWithMonad (interpMem }\OperatorTok{\textgreater{}|\textless{}}\NormalTok{ interpComB) stepProg}
\NormalTok{    \_1 }\OperatorTok{.}\NormalTok{ tBuffer }\OperatorTok{.=}\NormalTok{ outB}
\NormalTok{    \_2 }\OperatorTok{.}\NormalTok{ tBuffer }\OperatorTok{.=}\NormalTok{ outA}
\NormalTok{    guard }\OperatorTok{.} \FunctionTok{not} \OperatorTok{$} \FunctionTok{null}\NormalTok{ outA }\OperatorTok{\&\&} \FunctionTok{null}\NormalTok{ outB}
    \FunctionTok{return} \OperatorTok{$} \FunctionTok{length}\NormalTok{ outB}
\end{Highlighting}
\end{Shaded}

Our final \texttt{stepB} really doesn't need the \texttt{WriterT\ {[}Int{]}} ---
we just need that internally to collect \emph{snd} outputs. So we use
\texttt{execWriter} after ``interpreting'' our actions (along with
\texttt{many}, to repeat our thread steps until they block) to just get the
resulting logs immediately.

We then reset the input buffers appropriately (by putting in the collected
outputs of the previous threads).

If both threads are blocking (they both have to external outputs to pass on),
then we're done (using \texttt{guard}, which acts as a ``immediately fail here''
action for \texttt{MaybeT}).

We return the number of items that ``Program 1'' (the second thread) outputs,
because that's what we need for our answer.

This is one ``single pass'' of both of our threads. As you probably guessed,
we'll use \texttt{many} again to run these multiple times until both threads
block.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{{-}{-} source: https://github.com/mstksg/inCode/tree/master/code{-}samples/duet/Duet.hs\#L189{-}L197}

\OtherTok{partB ::} \DataTypeTok{P.PointedList} \DataTypeTok{Op} \OtherTok{{-}\textgreater{}} \DataTypeTok{Int}
\NormalTok{partB ops }\OtherTok{=} \FunctionTok{maybe}\NormalTok{ (}\FunctionTok{error} \StringTok{"\textasciigrave{}many\textasciigrave{} cannot fail"}\NormalTok{) }\FunctionTok{sum}
          \OperatorTok{.} \FunctionTok{flip}\NormalTok{ evalState s0}
          \OperatorTok{.}\NormalTok{ runMaybeT}
          \OperatorTok{$}\NormalTok{ many stepB}
  \KeywordTok{where}
\NormalTok{    s0 }\OtherTok{=}\NormalTok{ ( }\DataTypeTok{T}\NormalTok{ (}\DataTypeTok{PS}\NormalTok{ ops (M.singleton }\CharTok{\textquotesingle{}p\textquotesingle{}} \DecValTok{0}\NormalTok{)) []}
\NormalTok{         , }\DataTypeTok{T}\NormalTok{ (}\DataTypeTok{PS}\NormalTok{ ops (M.singleton }\CharTok{\textquotesingle{}p\textquotesingle{}} \DecValTok{1}\NormalTok{)) []}
\NormalTok{         )}
\end{Highlighting}
\end{Shaded}

\texttt{many\ ::\ MaybeT\ s\ Int\ -\textgreater{}\ MaybeT\ s\ {[}Int{]}}, so
\texttt{runMaybeT} gives us a \texttt{Maybe\ {[}Int{]}}, where each item in the
resulting list is the number of items emitted by Program 1 at every iteration of
\texttt{stepB}. Note that \texttt{many} produces an action that is guaranteed to
succeed, so its result \emph{must be \texttt{Just}}. To get our final answer, we
only need to sum.

\subsection{Examples}\label{examples}

In the
\href{https://github.com/mstksg/inCode/tree/master/code-samples/duet/Duet.hs}{sample
source code}, I've included
\href{https://github.com/mstksg/inCode/tree/master/code-samples/duet/Duet.hs\#L204-L247}{my
own puzzle input} provided to me from the advent of code website. We can now get
actual answers given some sample puzzle input:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{{-}{-} source: https://github.com/mstksg/inCode/tree/master/code{-}samples/duet/Duet.hs\#L199{-}L202}

\OtherTok{main ::} \DataTypeTok{IO}\NormalTok{ ()}
\NormalTok{main }\OtherTok{=} \KeywordTok{do}
    \FunctionTok{print} \OperatorTok{$}\NormalTok{ partA (parseProgram testProg)}
    \FunctionTok{print} \OperatorTok{$}\NormalTok{ partB (parseProgram testProg)}
\end{Highlighting}
\end{Shaded}

And, as a stack script, we can run this and see my own puzzle input's answers:

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{$}\NormalTok{ ./Duet.hs}
\ExtensionTok{Just}\NormalTok{ 7071}
\ExtensionTok{8001}
\end{Highlighting}
\end{Shaded}

\section{Wrap Up}\label{wrap-up}

\section{That's it! Hope you enjoyed some of the techniques used in this post,
including}\label{thats-it-hope-you-enjoyed-some-of-the-techniques-used-in-this-post-including}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Leveraging the interpreter pattern (with \emph{operational}) to create a monad
  that can be interpreted in multiple contexts with multiple different
  interpreters
\item
  Using functor disjunctions like \texttt{:\textbar{}:} (or \texttt{:+:},
  \texttt{Sum}, etc.) to combine interpretable primitives
\item
  Writing modular interpreters for each set of primitives, then using
  deconstructors like \texttt{\textgreater{}\textbar{}\textless{}} to easily
  combine and swap out interpreters.
\item
  Lenses with State and classy lenses.
\item
  Programming against polymorphic monadic contexts like \texttt{MonadState},
  \texttt{MonadWriter}, \texttt{MonadAccum}, etc., which helps us combine
  interpreters in a very smooth way.
\end{enumerate}

\section{Pushing the Boundaries}\label{pushing-the-boundaries}

That's the main part of the post! However, just for fun, we can take things a
little further and expand on this technique. The \emph{type-combinators} library
opens up a lot of doors to combining modular interpreters in more complex ways!

\subsection{Functor conjunctions}\label{functor-conjunctions}

We see that \texttt{:\textbar{}:} (functor disjunction) can be used to merge
sets of primitives. We can also use \texttt{:\&:} (functor conjunction), also
known as \texttt{:*:} from \emph{Generics.GHC} and \texttt{Product} from
\emph{Data.Functor.Product}!

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{newtype}\NormalTok{ (f }\OperatorTok{:\&:}\NormalTok{ g) a }\OtherTok{=}\NormalTok{ f a }\OperatorTok{:\&:}\NormalTok{ g a}
\end{Highlighting}
\end{Shaded}

Used with GADTs representing primitives, \texttt{:\&:} lets us ``tag'' our
primitives with extra things.

For example, we were pretty sneaky earlier by using \texttt{zoom} to manually
lift our \texttt{Mem} interpreter to work on specific threads. Instead, we can
actually use \texttt{Const\ Int} to attach a thread ID to \texttt{Mem}s:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{{-}{-} | type{-}combinators exports its own version of \textquotesingle{}Const\textquotesingle{}}
\KeywordTok{newtype} \DataTypeTok{C}\NormalTok{ r a }\OtherTok{=} \DataTypeTok{C}\NormalTok{ \{}\OtherTok{ getC ::}\NormalTok{ r \}}

\CommentTok{{-}{-} | Peek into Thread 0}
\DataTypeTok{C} \DecValTok{0} \OperatorTok{:\&:} \DataTypeTok{MPeek}\OtherTok{       ::}\NormalTok{ (}\DataTypeTok{C} \DataTypeTok{Int} \OperatorTok{:\&:} \DataTypeTok{Mem}\NormalTok{) }\DataTypeTok{Op}

\CommentTok{{-}{-} | Get contents of register \textquotesingle{}c\textquotesingle{} of Thread 1}
\DataTypeTok{C} \DecValTok{1} \OperatorTok{:\&:} \DataTypeTok{MGet} \CharTok{\textquotesingle{}c\textquotesingle{}}\OtherTok{    ::}\NormalTok{ (}\DataTypeTok{C} \DataTypeTok{Int} \OperatorTok{:\&:} \DataTypeTok{Mem}\NormalTok{) }\DataTypeTok{Int}
\end{Highlighting}
\end{Shaded}

The advantage we gain by using these tags is that we now have an approach that
can be generalized to multiple threads, as well.

If we had a version of \texttt{interpMem} that takes a thread:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{interpMemThread}
\OtherTok{    ::}\NormalTok{ (}\DataTypeTok{MonadState}\NormalTok{ s m, }\DataTypeTok{MonadFail}\NormalTok{ m, }\DataTypeTok{HasProgState}\NormalTok{ s)}
    \OtherTok{=\textgreater{}} \DataTypeTok{C} \DataTypeTok{Int}\NormalTok{ a}
    \OtherTok{{-}\textgreater{}} \DataTypeTok{Mem}\NormalTok{ a}
    \OtherTok{{-}\textgreater{}}\NormalTok{ m a}
\end{Highlighting}
\end{Shaded}

we can use the analogy of \texttt{\textgreater{}\textbar{}\textless{}},
\texttt{uncurryFan}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{uncurryFan}
\OtherTok{    ::}\NormalTok{ (}\KeywordTok{forall}\NormalTok{ x}\OperatorTok{.}\NormalTok{ f x }\OtherTok{{-}\textgreater{}}\NormalTok{ g x }\OtherTok{{-}\textgreater{}}\NormalTok{ r)}
    \OtherTok{{-}\textgreater{}}\NormalTok{ (f }\OperatorTok{:\&:}\NormalTok{ g) a}
    \OtherTok{{-}\textgreater{}}\NormalTok{ r}

\NormalTok{uncurryFan interpMemThread}
\OtherTok{    ::}\NormalTok{ (}\DataTypeTok{MonadState}\NormalTok{ s m, }\DataTypeTok{MonadFail}\NormalTok{ m)}
    \OtherTok{=\textgreater{}}\NormalTok{ (}\DataTypeTok{C} \DataTypeTok{Int} \OperatorTok{:\&:} \DataTypeTok{Mem}\NormalTok{) a}
    \OtherTok{{-}\textgreater{}}\NormalTok{ m a}
\end{Highlighting}
\end{Shaded}

We can build interpreters of combinations of \texttt{:\textbar{}:} and
\texttt{:\&:} by using combinations of
\texttt{\textgreater{}\textbar{}\textless{}} and \texttt{uncurryFan}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{interpMem }\OperatorTok{\textgreater{}|\textless{}}\NormalTok{ interpComB}
\OtherTok{    ::}\NormalTok{ ( }\DataTypeTok{MonadWriter}\NormalTok{ [}\DataTypeTok{Int}\NormalTok{] m}
\NormalTok{       , }\DataTypeTok{MonadFail}\NormalTok{ m}
\NormalTok{       , }\DataTypeTok{MonadState} \DataTypeTok{Thread}\NormalTok{ m}
\NormalTok{       )}
    \OtherTok{=\textgreater{}}\NormalTok{ (}\DataTypeTok{Mem} \OperatorTok{:|:} \DataTypeTok{Com}\NormalTok{) a}
    \OtherTok{{-}\textgreater{}}\NormalTok{ m a}

\NormalTok{uncurryFan interpMemThread }\OperatorTok{\textgreater{}|\textless{}}\NormalTok{ interpComB}
\OtherTok{    ::}\NormalTok{ ( }\DataTypeTok{MonadWriter}\NormalTok{ [}\DataTypeTok{Int}\NormalTok{] m}
\NormalTok{       , }\DataTypeTok{MonadFail}\NormalTok{ m}
\NormalTok{       , }\DataTypeTok{MonadState} \DataTypeTok{Thread}\NormalTok{ m}
\NormalTok{       )}
    \OtherTok{=\textgreater{}}\NormalTok{ ((}\DataTypeTok{C} \DataTypeTok{Int} \OperatorTok{:\&:} \DataTypeTok{Mem}\NormalTok{) }\OperatorTok{:|:} \DataTypeTok{Com}\NormalTok{) a}
    \OtherTok{{-}\textgreater{}}\NormalTok{ m a}
\end{Highlighting}
\end{Shaded}

\subsection{Manipulating Disjunctions and
Conjunctions}\label{manipulating-disjunctions-and-conjunctions}

So, we have a \texttt{Mem\ :\textbar{}:\ Com}. How could we ``tag'' our
\texttt{Mem} after-the-fact, to add \texttt{C\ Int}? Well, we can manipulate the
structure of conjunctions and disjunctions using the \texttt{Bifunctor1} from
\emph{Type.Class.Higher}, in \emph{type-combinators}.

\texttt{bimap1} can be used to modify either half of a \texttt{:\textbar{}:} or
\texttt{:\&:}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{bimap1}
\OtherTok{    ::}\NormalTok{ (}\KeywordTok{forall}\NormalTok{ x}\OperatorTok{.}\NormalTok{ f x }\OtherTok{{-}\textgreater{}}\NormalTok{ h x)}
    \OtherTok{{-}\textgreater{}}\NormalTok{ (}\KeywordTok{forall}\NormalTok{ x}\OperatorTok{.}\NormalTok{ g x }\OtherTok{{-}\textgreater{}}\NormalTok{ j x)}
    \OtherTok{{-}\textgreater{}}\NormalTok{ (f }\OperatorTok{:|:}\NormalTok{ g) a}
    \OtherTok{{-}\textgreater{}}\NormalTok{ (h }\OperatorTok{:|:}\NormalTok{ j) a}

\NormalTok{bimap1}
\OtherTok{    ::}\NormalTok{ (}\KeywordTok{forall}\NormalTok{ x}\OperatorTok{.}\NormalTok{ f x }\OtherTok{{-}\textgreater{}}\NormalTok{ h x)}
    \OtherTok{{-}\textgreater{}}\NormalTok{ (}\KeywordTok{forall}\NormalTok{ x}\OperatorTok{.}\NormalTok{ g x }\OtherTok{{-}\textgreater{}}\NormalTok{ j x)}
    \OtherTok{{-}\textgreater{}}\NormalTok{ (f }\OperatorTok{:\&:}\NormalTok{ g) a}
    \OtherTok{{-}\textgreater{}}\NormalTok{ (h }\OperatorTok{:\&:}\NormalTok{ j) a}
\end{Highlighting}
\end{Shaded}

So we can ``tag'' the \texttt{Mem} in \texttt{Mem\ :\textbar{}:\ Cmd} using:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{bimap1 (}\DataTypeTok{C} \DecValTok{0} \OperatorTok{:\&:}\NormalTok{) }\FunctionTok{id}
\OtherTok{    ::}\NormalTok{ (      }\DataTypeTok{Mem}       \OperatorTok{:|:} \DataTypeTok{Com}\NormalTok{) a}
    \OtherTok{{-}\textgreater{}}\NormalTok{ ((}\DataTypeTok{C} \DataTypeTok{Int} \OperatorTok{:\&:} \DataTypeTok{Mem}\NormalTok{) }\OperatorTok{:|:} \DataTypeTok{Com}\NormalTok{) a}
\end{Highlighting}
\end{Shaded}

Which we can use to re-tag a \texttt{Program\ (Mem\ :\textbar{}:\ Com)}, with
the help of \texttt{interpretWithMonad}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{\textbackslash{}f }\OtherTok{{-}\textgreater{}}\NormalTok{ interpretWithMonad (singleotn }\OperatorTok{.}\NormalTok{ f)}
\OtherTok{    ::}\NormalTok{ (}\KeywordTok{forall}\NormalTok{ x}\OperatorTok{.}\NormalTok{ f x }\OtherTok{{-}\textgreater{}}\NormalTok{ g x)}
    \OtherTok{{-}\textgreater{}} \DataTypeTok{Program}\NormalTok{ f a}
    \OtherTok{{-}\textgreater{}} \DataTypeTok{Program}\NormalTok{ g a}

\NormalTok{interpretWithMonad (singleton }\OperatorTok{.}\NormalTok{ bimap1 (}\DataTypeTok{C} \DecValTok{0} \OperatorTok{:\&:}\NormalTok{) }\FunctionTok{id}\NormalTok{)}
\OtherTok{    ::} \DataTypeTok{Program}\NormalTok{ (      }\DataTypeTok{Mem}       \OperatorTok{:|:} \DataTypeTok{Com}\NormalTok{) a}
    \OtherTok{{-}\textgreater{}} \DataTypeTok{Program}\NormalTok{ ((}\DataTypeTok{C} \DataTypeTok{Int} \OperatorTok{:\&:} \DataTypeTok{Mem}\NormalTok{) }\OperatorTok{:|:} \DataTypeTok{Com}\NormalTok{) a}
\end{Highlighting}
\end{Shaded}

\subsection{Combining many different sets of
primitives}\label{combining-many-different-sets-of-primitives}

If we had three sets of primitives we wanted to combine, we might be tempted to
use \texttt{f\ :\textbar{}:\ g\ :\textbar{}:\ h} and
\texttt{handleF\ \textgreater{}\textbar{}\textless{}\ handleG\ \textgreater{}\textbar{}\textless{}\ handleH}.
However, there's a better way! Instead of
\texttt{f\ :\textbar{}:\ g\ :\textbar{}:\ h}, you can use
\texttt{FSum\ \textquotesingle{}{[}f,\ g,\ h{]}} to combine multiple sets of
primitives in a clean way, using a type-level list.

If there are no duplicates in your type-level list, you can even use
\texttt{finj} to create your \texttt{FSum}s automatically:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{{-}{-} (∈) is a typeclass that has instances whenever f in the type{-}level list fs}
\OtherTok{finj ::}\NormalTok{ f ∈ fs }\OtherTok{=\textgreater{}}\NormalTok{ f a }\OtherTok{{-}\textgreater{}} \DataTypeTok{FSum}\NormalTok{ fs a}

\OtherTok{finj ::} \DataTypeTok{Mem}\NormalTok{ a }\OtherTok{{-}\textgreater{}} \DataTypeTok{FSum}\NormalTok{ \textquotesingle{}[}\DataTypeTok{Mem}\NormalTok{, }\DataTypeTok{Com}\NormalTok{, }\DataTypeTok{Foo}\NormalTok{] a}
\OtherTok{finj ::} \DataTypeTok{Com}\NormalTok{ a }\OtherTok{{-}\textgreater{}} \DataTypeTok{FSum}\NormalTok{ \textquotesingle{}[}\DataTypeTok{Mem}\NormalTok{, }\DataTypeTok{Com}\NormalTok{, }\DataTypeTok{Foo}\NormalTok{] a}
\OtherTok{finj ::} \DataTypeTok{Foo}\NormalTok{ a }\OtherTok{{-}\textgreater{}} \DataTypeTok{FSum}\NormalTok{ \textquotesingle{}[}\DataTypeTok{Mem}\NormalTok{, }\DataTypeTok{Com}\NormalTok{, }\DataTypeTok{Foo}\NormalTok{] a}

\NormalTok{singleton (finj (}\DataTypeTok{MGet} \CharTok{\textquotesingle{}c\textquotesingle{}}\NormalTok{))}\OtherTok{ ::} \DataTypeTok{Program}\NormalTok{ (}\DataTypeTok{FSum}\NormalTok{ \textquotesingle{}[}\DataTypeTok{Mem}\NormalTok{, }\DataTypeTok{Com}\NormalTok{, }\DataTypeTok{Foo}\NormalTok{]) }\DataTypeTok{Int}
\NormalTok{singleton (finj (}\DataTypeTok{CSnd} \DecValTok{3}\NormalTok{  ))}\OtherTok{ ::} \DataTypeTok{Program}\NormalTok{ (}\DataTypeTok{FSum}\NormalTok{ \textquotesingle{}[}\DataTypeTok{Mem}\NormalTok{, }\DataTypeTok{Com}\NormalTok{, }\DataTypeTok{Foo}\NormalTok{]) }\DataTypeTok{Int}
\end{Highlighting}
\end{Shaded}

There isn't really a nice built-in way to build handlers for these (like we did
earlier using \texttt{\textgreater{}\textbar{}\textless{}}), but you can whip up
a utility function with \texttt{Prod} (from \emph{type-combinators}) and
\texttt{ifoldMapFSum}.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{newtype} \DataTypeTok{Handle}\NormalTok{ a r f }\OtherTok{=} \DataTypeTok{Handle}\NormalTok{ \{}\OtherTok{ runHandle ::}\NormalTok{ f a }\OtherTok{{-}\textgreater{}}\NormalTok{ r \}}

\OtherTok{handleFSum ::} \DataTypeTok{Prod}\NormalTok{ (}\DataTypeTok{Handle}\NormalTok{ a r) fs }\OtherTok{{-}\textgreater{}} \DataTypeTok{FSum}\NormalTok{ fs a }\OtherTok{{-}\textgreater{}}\NormalTok{ r}
\NormalTok{handleFSum hs }\OtherTok{=}\NormalTok{ ifoldMapFSum }\OperatorTok{$}\NormalTok{ \textbackslash{}i }\OtherTok{{-}\textgreater{}}\NormalTok{ runHandle (}\FunctionTok{index}\NormalTok{ i hs)}
\end{Highlighting}
\end{Shaded}

\texttt{Prod} lets you bunch up a bunch of handlers together, so you can build
handlers like:

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{handleMem ::} \DataTypeTok{Mem}\NormalTok{ a }\OtherTok{{-}\textgreater{}}\NormalTok{ m a}
\OtherTok{handleCom ::} \DataTypeTok{Com}\NormalTok{ a }\OtherTok{{-}\textgreater{}}\NormalTok{ m a}
\OtherTok{handleFoo ::} \DataTypeTok{Foo}\NormalTok{ a }\OtherTok{{-}\textgreater{}}\NormalTok{ m a}

\NormalTok{handleFSum (}\DataTypeTok{Handle}\NormalTok{ handleMem }\OperatorTok{:\textless{}} \DataTypeTok{Handle}\NormalTok{ handleCom }\OperatorTok{:\textless{}} \DataTypeTok{Handle}\NormalTok{ handleFoo }\OperatorTok{:\textless{}}\NormalTok{ Ø)}
\OtherTok{    ::} \DataTypeTok{FSum}\NormalTok{ \textquotesingle{}[}\DataTypeTok{Mem}\NormalTok{, }\DataTypeTok{Com}\NormalTok{, }\DataTypeTok{Foo}\NormalTok{] a }\OtherTok{{-}\textgreater{}}\NormalTok{ m a}

\NormalTok{interpretWithMonad}
\NormalTok{        (handleFSum ( }\DataTypeTok{Handle}\NormalTok{ handleMem}
                   \OperatorTok{:\textless{}} \DataTypeTok{Handle}\NormalTok{ handleCom}
                   \OperatorTok{:\textless{}} \DataTypeTok{Handle}\NormalTok{ handleFoo}
                   \OperatorTok{:\textless{}}\NormalTok{ Ø)}
\NormalTok{        )}
\OtherTok{    ::} \DataTypeTok{Program}\NormalTok{ (}\DataTypeTok{FSum}\NormalTok{ \textquotesingle{}[}\DataTypeTok{Mem}\NormalTok{, }\DataTypeTok{Com}\NormalTok{, }\DataTypeTok{Foo}\NormalTok{]) a }\OtherTok{{-}\textgreater{}}\NormalTok{ m a}
\end{Highlighting}
\end{Shaded}

\subsection{Endless Possibilities}\label{endless-possibilities}

Hopefully this post inspires you a bit about this fun design pattern! And, if
anything, I hope after reading this, you learn to recognize situations where
this \emph{modular} interpreter pattern might be useful in your everyday
programming.

\section{Signoff}\label{signoff}

Hi, thanks for reading! You can reach me via email at
\href{mailto:justin@jle.im}{\nolinkurl{justin@jle.im}}, or at twitter at
\href{https://twitter.com/mstk}{@mstk}! This post and all others are published
under the \href{https://creativecommons.org/licenses/by-nc-nd/3.0/}{CC-BY-NC-ND
3.0} license. Corrections and edits via pull request are welcome and encouraged
at \href{https://github.com/mstksg/inCode}{the source repository}.

If you feel inclined, or this post was particularly helpful for you, why not
consider \href{https://www.patreon.com/justinle/overview}{supporting me on
Patreon}, or a \href{bitcoin:3D7rmAYgbDnp4gp4rf22THsGt74fNucPDU}{BTC donation}?
:)

\textbackslash end\{document\}

\end{document}
