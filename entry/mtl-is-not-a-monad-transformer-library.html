<!DOCTYPE HTML>
<html><head><title>mtl is Not a Monad Transformer Library · in Code</title><meta name="description" content="Weblog of Justin Le, covering various adventures in programming and explorations in the worlds of computation physics, and knowledge.
"><meta http-equiv="Content-Type" content="text/html;charset=utf-8"><meta name="viewport" content="width=device-width,initial-scale=1.0"><meta name="flattr:id" content="3p9jqr"><meta property="og:site_name" content="in Code"><meta property="og:description" content="mtl is not a monad transformer library — contrary to popular conception. I believe that this commonly spread myth is due in part to some rather peculiar branding choices (the name of the library) and in part to some historical accidents (mtl was, in the distant and pre-historic past, indeed a monad transformer library). What is mtl? It is a library of interfaces you can provide to your own types, in the form of typeclasses. It abstracts over different design patterns for different types, in the form of typeclasses. Just like Functor abstracts over “things that can be fmapped”. mtl provides typeclasses abstracting over many useful patterns that many types satisfy — patterns involving different sorts of “effects”."><meta property="og:type" content="article"><meta property="og:title" content="mtl is Not a Monad Transformer Library"><meta property="og:image" content="https://blog.jle.im/img/site_logo.jpg"><meta property="og:locale" content="en_US"><meta property="og:url" content="https://blog.jle.im/entry/mtl-is-not-a-monad-transformer-library.html"><meta name="twitter:card" content="summary"><meta name="twitter:creator:id" content="mstk"><link rel="author" href="https://plus.google.com/107705320197444500140"><link rel="alternate" type="application/rss+xml" title="in Code (RSS Feed)" href="http://feeds.feedburner.com/incodeblog"><link rel="canonical" href="https://blog.jle.im/entry/mtl-is-not-a-monad-transformer-library.html"><link href="https://blog.jle.im/favicon.ico" rel="shortcut icon"><link href="https://blog.jle.im/css/toast.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/font.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/main.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/page/entry.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/pygments.css" rel="stylesheet" type="text/css"><script type="text/javascript">var page_data = {};
var disqus_shortname='incode';
</script><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-443711-8', 'jle.im');
ga('send', 'pageview');
</script><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script id="MathJax-script" async="" src="https://cdn.jsdelivr.net/npm/mathjax@3.0.1/es5/tex-mml-chtml.js"></script><script type="text/javascript" src="//ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script><script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5234d67a6b68dcd4"></script><script type="text/javascript" src="https://blog.jle.im/js/page/entry_toc.js"></script><script type="text/javascript" src="https://blog.jle.im/js/disqus_count.js"></script><script type="text/javascript" src="https://blog.jle.im/js/social.js"></script><script type="text/javascript" src="https://blog.jle.im/js/jquery/jquery.toc.js"></script><script type="text/javascript" src="https://blog.jle.im/purescript/entry.js"></script></head><body><div id="fb-root"><script>(function(d, s, id) {
 var js, fjs = d.getElementsByTagName(s)[0];
 if (d.getElementById(id)) return;
 js = d.createElement(s); js.id = id;
 js.src = "//connect.facebook.net/en_US/all.js#xfbml=1&appId=641852699171929";
 fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));
</script></div><div id="header-container"><div id="navbar-container" class="tile"><nav id="navbar-content"><div class="nav-info"><h1 class="site-title"><a href="https://blog.jle.im/" class="nav-title">in Code</a></h1><span class="nav-author">Justin Le</span></div><ul class="nav-links"><li><a href="https://blog.jle.im/">home</a></li><li><a href="https://blog.jle.im/entries.html">archives</a></li><li><a href="https://cv.jle.im">cv</a></li><div class="clear"></div></ul></nav></div><div id="header-content"></div></div><div id="body-container" class="container"><div id="main-container" class="grid"><div class="entry-section unit span-grid" role="main"><article class="tile article"><header><h1 id="title">mtl is Not a Monad Transformer Library</h1><p class="entry-info">by <a class="author" href="https://blog.jle.im/">Justin Le</a><span class="info-separator"> &diams; </span><time datetime="2015-05-18T10:07:36Z" pubdate="" class="pubdate">Monday May 18, 2015</time></p><p><span class="source-info"><a class="source-link" href="https://github.com/mstksg/inCode/tree/master/copy/entries/mtl.md">Source</a><span class="info-separator"> &diams; </span><a class="source-link" href="https://github.com/mstksg/inCode/tree/gh-pages/entry/mtl-is-not-a-monad-transformer-library.md">Markdown</a><span class="info-separator"> &diams; </span><a class="source-link" href="https://blog.jle.im/entry/mtl-is-not-a-monad-transformer-library.tex">LaTeX</a><span class="info-separator"> &diams; </span></span>Posted in <a href="https://blog.jle.im/entries/category/@haskell.html" class="tag-a-category" title="Functional, pure, non-strict, statically and strongly typed, natively
compiled...really just the king of great languages.
">Haskell</a>, <a href="https://blog.jle.im/entries/category/@ramblings.html" class="tag-a-category" title="My slight ramblings on subjects of interest (to me and hopefully to you too!).
Lots of surveys and introducts to new subjects.
">Ramblings</a><span class="info-separator"> &diams; </span><a class="comment-link" href="#disqus_thread">Comments</a></p></header><hr><aside class="contents-container"><h5 id="contents-header">Contents</h5><div id="toc"></div></aside><div class="main-content copy-content"><p><em>mtl</em> is not a monad transformer library — contrary to popular conception. I believe that this commonly spread myth is due in part to some rather peculiar branding choices (the name of the library) and in part to some historical accidents (<em>mtl</em> was, in the distant and pre-historic past, indeed a monad transformer library).</p>
<p>What is <em>mtl</em>? It is a library of <em>interfaces</em> you can provide to your own types, in the form of typeclasses. It abstracts over <em>different design patterns</em> for different types, in the form of typeclasses. Just like Functor abstracts over “things that can be fmapped”. <em>mtl</em> provides typeclasses abstracting over many useful patterns that many types satisfy — patterns involving different sorts of “effects”.</p>
<h2 id="the-patterns">The Patterns</h2>
<h3 id="monaderror">MonadError</h3>
<p><code>MonadError</code> is a generic interface over things where you can throw “errors” of a specific type <code>e</code>, and “catch” them. It offers two methods: <code>throwError :: e -&gt; m a</code>, and <code>catchError :: m a -&gt; (e -&gt; m a) -&gt; m a</code>, which does what you’d expect from an error monad.</p>
<p>Now, we have a generic interface to work on <em>all specific type error-throwing Monads</em>. The <code>Either</code> type comes to mind as an obvious candidate:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">MonadError</span> e (<span class="dt">Either</span> e) <span class="kw">where</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    throwError <span class="ot">=</span> <span class="dt">Left</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    catchError s f <span class="ot">=</span> <span class="kw">case</span> s <span class="kw">of</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>                       <span class="dt">Right</span> _ <span class="ot">-&gt;</span> s</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>                       <span class="dt">Left</span> e  <span class="ot">-&gt;</span> f e</span></code></pre></div>
<p>But there are definitely other instances possible. How about for <code>IO</code> and <code>IOException</code>s, in specific?</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">MonadError</span> <span class="dt">IOException</span> <span class="dt">IO</span> <span class="kw">where</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>    throwError  <span class="ot">=</span> <span class="fu">ioError</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>    catchErrror <span class="ot">=</span> <span class="fu">catch</span>     <span class="co">-- will not catch non-IOExceptions</span></span></code></pre></div>
<p>This is great, because we can now write code <em>generic</em> over <em>all</em> specific-type error things!</p>
<h4 id="error-behaviorfor-free">Error behavior…for free!</h4>
<p>If we’re clever enough, we can actually imbue any arbitrary Monad <code>m</code> with rudimentary, basic, “dumb” error handling by using the <code>ExceptT</code> type. An <code>ExceptT e m</code> behaves <em>just</em> like our original Monad <code>m</code> in every way…except now, we have access to rudimentary implementations of side-channels of <code>throwError</code> and <code>catchError</code>.</p>
<p>This is pretty useful…to be able to add short-circuiting error behavior to any Monad we wanted. But remember, <code>ExceptT</code> is not the “point” of <code>MonadError</code>. It’s just one way to generate instances for free given a Monad. The real power of <code>MonadError</code> is in the ability to write generically over many Monads with some sort of “error” behavior, like <code>Either</code> or <code>IO</code>.</p>
<h3 id="monadstate">MonadState</h3>
<p>A <code>MonadState s m</code> is a Monad <code>m</code> where, during in the context of <code>m</code>, you have access to a global state of type <code>s</code> that you can modify.</p>
<p>You can “get” it with <code>get :: m s</code>. You can modify it with <code>modify :: (s -&gt; s) -&gt; m ()</code>. You can replace it with <code>put :: s -&gt; m ()</code>.</p>
<p>There are a lot of types that can offer this type of interface. You might have, for example, a type where “getting” the state comes from reading an <code>IORef</code>, and “putting” it comes from writing to the <code>IORef</code>. Or maybe the state can come from a a query to a database…where <code>get</code> queries a database in IO, and <code>put</code> writes to the database.</p>
<p><code>MonadState</code>, as a typeclass, gives you the ability to <em>write generically over all Monads with state</em>. You can now write generically over those database state things…or those IORef state things…or those web query things…or anything that cares to implement the interface!</p>
<p><code>MonadState</code> says, “the functions and actions I write can work for <em>all</em> Monads offering state I can modify!” An action of type <code>MonadState String m =&gt; m Double</code> can create a <code>Double</code> from <em>any</em> monad offering some sort of <code>String</code> state.</p>
<h4 id="statefor-free">State…for free!</h4>
<p>Again, we can actually imbue any Monad <code>m</code> with some very rudimentary, “dumb” stateful interface, using a type called <code>StateT</code>. A <code>StateT s m</code> behaves just like our monad <code>m</code> (be it <code>IO</code>, <code>Reader</code>, <code>ST</code>, <code>STM</code>…), except now we have access to a rudimentary state getting-and-putting mechanism on a state of type <code>s</code>, using a form of function composition. The implementation of the <code>StateT</code> handles it under the hood.</p>
<p>Obviously, being able to add a rudimentary stateful interface on top of any Monad is pretty useful. Very useful, in fact!</p>
<p>But remember, this isn’t the <em>point</em> of <code>MonadState</code>. <code>MonadState</code> doesn’t exist for <code>StateT</code>. <code>StateT</code> is just a way to generate a free instance of <code>MonadState</code> if you just want to add rudimentary statefulness to an existing Monad. But there are many instances of <code>MonadState</code>…really, <code>MonadState</code> has nothing to do with <code>StateT</code> fundamentally, any more than <code>Monad</code> has to do with <code>Maybe</code> fundamentally. And <code>MonadState</code> and <code>StateT</code> don’t even come from the same library!</p>
<p><em>mtl</em> offers a generic interface for working with all monads offering a statey API.</p>
<h3 id="monadreader">MonadReader</h3>
<p><code>MonadReader</code> is more or less the same thing…it offers a generic interface to work on monads that have access to some sort of global, unchanging “environment”. An example might be a Monad where you could work with command line arguments, or environment variables, assuming they are read once and fixed when things start up. You could access the command line arguments with <code>ask</code>, and use them in your program.</p>
<h3 id="monadio">MonadIO</h3>
<p>This one is actually from <em>transformers</em>, but it gives a nice picture. Any <code>MonadIO m</code> is a <code>Monad</code> that allows you to embed and sequence in any arbitrary IO action. This is pretty useful! In the <em><a href="http://hackage.haskell.org/package/persistent">persistent</a></em> database library, for example — the main “database access type monad” can sequence actions that access databases <em>and</em> arbitrary IO actions, as well. A lot of resource managers and DSL’s offer the ability to sequence IO in the middle of all the other actions.</p>
<p>That’s what <code>MonadIO</code> is for — it allows you to write functions and say, “hey, my function is generic over <em>all</em> things that can embed IO…anything that can embed IO can sequence my function/type”. The generic “embedding” action is <code>liftIO :: MonadIO m =&gt; IO a -&gt; m a</code>.</p>
<div class="note">
<p><strong>Aside</strong></p>
<p>You know…ideally, all of these typeclasses would have laws, so we could make conclusions and apply equational reasoning to generically written functions.</p>
<p>Some of the laws are simple…<code>liftIO</code> from <code>MonadIO</code> should be a <a href="http://hackage.haskell.org/package/mmorph-1.0.4/docs/Control-Monad-Morph.html">monad morphism</a>. But the rest of them don’t really have any well-established laws. This is a bit of a shame, because we’d really like to be able to apply reasoning to generic functions.</p>
<p>People have suggested <code>MonadState</code> have laws similar to how view/set/over interact in the <em>lens</em> laws. But as of now, most of we have in terms of our capability of analyzing generic programs is rough heuristins/feelings about what “should” be right.</p>
<p>A bit un-ideal, but…in practice, this ends up working not-so-badly :)</p>
</div>
<h2 id="not-a-monad-transformer-library">Not a Monad Transformer Library</h2>
<p>So, let’s work together to dispel the myth that <em>mtl</em> is a monad transformer library. It really has nothing to do with monad transformers at all…any more than <code>Control.Monad</code> is an “IO module”, or <code>Control.Monoid</code> is a “list module”. Transformers don’t even come from the <em>mtl</em> library!</p>
<p>Together, we can overcome this myth. We can show people that we can live in a world where we can combine effects, work generically in Monads with <em>multiple types of effects</em> by writing functions generic over many different <em>mtl</em> typeclasses at once! (<code>MonadState</code> + <code>MonadIO</code>, maybe?)</p>
<p>We don’t <em>have to</em> reach for Monad transformers to work with combined effects. We can write our own combined effects monads and just write the instances…or we can write generically and not even care about what Monad we actually use in the end. We don’t have to teach people to be afraid of monad transformers as if they were the only way to get things done, and <em>mtl</em> is tied to them like a ball and chain.</p>
<p><em>mtl</em> is not a Monad transformer library. How liberating!</p></div><footer><hr><div class="copy-content"><p>Hi, thanks for reading! You can reach me via email at <a href="mailto:justin@jle.im" class="email">justin@jle.im</a>, or at twitter at <a href="https://twitter.com/mstk">@mstk</a>! This post and all others are published under the <a href="https://creativecommons.org/licenses/by-nc-nd/3.0/">CC-BY-NC-ND 3.0</a> license. Corrections and edits via pull request are welcome and encouraged at <a href="https://github.com/mstksg/inCode">the source repository</a>.</p>
<p>If you feel inclined, or this post was particularly helpful for you, why not consider <a href="https://www.patreon.com/justinle/overview">supporting me on Patreon</a>, or a <a href="bitcoin:3D7rmAYgbDnp4gp4rf22THsGt74fNucPDU">BTC donation</a>? :)</p></div><div class="clear"></div><ul class="entry-series"><li><div>This entry is a part of a series called <b>&quot;Haskell Mythbusters&quot;</b>.  Find the rest of the entries in this series at its <a href="https://blog.jle.im/entries/series/+haskell-mythbusters.html" class="tag-a-series" title="+Haskell Mythbusters"> series history</a>.</div></li></ul><ul class="tag-list"><li><a href="https://blog.jle.im/entries/tagged/functional-programming.html" class="tag-a-tag">#functional programming</a></li><li><a href="https://blog.jle.im/entries/tagged/haskell.html" class="tag-a-tag">#haskell</a></li><li><a href="https://blog.jle.im/entries/category/@haskell.html" class="tag-a-category">@HASKELL</a></li><li><a href="https://blog.jle.im/entries/category/@ramblings.html" class="tag-a-category">@RAMBLINGS</a></li><li><a href="https://blog.jle.im/entries/series/+haskell-mythbusters.html" class="tag-a-series">+Haskell Mythbusters</a></li></ul><aside class="social-buttons"><div class="addthis_toolbox addthis_default_style addthis-buttons"><a class="addthis_button_facebook_like" fb:like:layout="button_count"></a><a class="addthis_button_tweet"></a><a class="addthis_button_google_plusone" g:plusone:size="medium"></a><a class="addthis_counter addthis_pill_style"></a></div><div class="custom-social-buttons"><div class="custom-social-button"><a href="https://www.reddit.com/submit" onclick="window.location = &#39;https://www.reddit.com/submit?url=&#39;+ encodeURIComponent(window.location); return false"><img src="https://www.reddit.com/static/spreddit7.gif" alt="submit to reddit"></a></div></div></aside><nav class="next-prev-links"><ul><li class="prev-entry-link">&larr; <a href="https://blog.jle.im/entry/fixed-length-vector-types-in-haskell-2015.html">Fixed-Length Vector Types in Haskell, 2015</a> (Previous)</li><li class="next-entry-link">(Next) <a href="https://blog.jle.im/entry/introducing-the-prompt-library.html">Introducing the &quot;Prompt&quot; library</a> &rarr;</li></ul></nav></footer></article><div class="post-entry"><div class="tile"><div id="disqus_thread"></div><script type="text/javascript">var disqus_config = function () {
    this.page.url = 'https://blog.jle.im/entry/mtl-is-not-a-monad-transformer-library.html';
    this.page.identifier = 'mtl';
};
(function() {
    var d = document, s = d.createElement('script');
    s.src = '//incode.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
})();
</script><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a><br></noscript><a href="http://disqus.com" class="dsq-brlink">Comments powered by <span class="logo-disqus">Disqus</span></a></div></div></div></div></div><div id="footer-container"><div id="footer-content"><div class="tile"><div class="footer-copyright">&copy; 2020 Justin Le <span class="license-link">(<a href="https://creativecommons.org/licenses/by-nc-nd/3.0/" class="license">CC-BY-NC-ND 3.0</a>)</span></div><div class="footer-follow social-follows"><ul class="social-follows-list"><li><ul class="social-follows-list-social"><li><a class="social-follow-twitter" title="Follow me on Twitter!" href="https://twitter.com/intent/user?user_id=mstk" onclick="window.open(
  &#39;http://twitter.com/intent/user?user_id=907281&#39;,
  &#39;facebook-share-dialog&#39;,
  &#39;width=550,height=520&#39;);
return false;
">Twitter</a></li><li><a class="social-follow-github" title="Fork me on Github!" href="https://github.com/mstksg">Github</a></li><li><a class="social-follow-twitch" title="Watch me on Twitch!" href="https://www.twitch.tv/justin_l">Twitch</a></li><li><a class="social-follow-patreon" title="Support me on Patreon!" href="https://www.patreon.com/justinle/overview">Patreon</a></li><li><a class="social-follow-gplus" title="Add me on Google+!" href="https://plus.google.com/+JustinLe">Google+</a></li><li><a class="social-follow-keybase" title="Track me on Keybase!" href="https://keybase.io/mstksg">Keybase</a></li><li><a class="social-follow-linkedin" title="Connect with me on LinkedIn!" href="https://linkedin.com/in/lejustin">LinkedIn</a></li><li><a class="social-follow-bitcoin" title="Donate via bitcoin!" href="bitcoin:3D7rmAYgbDnp4gp4rf22THsGt74fNucPDU">Bitcoin</a></li></ul></li><li><ul class="social-follows-list-site"><li><a class="social-follow-rss" title="Subscribe to my RSS Feed!" href="http://feeds.feedburner.com/incodeblog">RSS</a></li><li><a class="social-follow-email" title="Subscribe to the mailing list!" href="https://feedburner.google.com/fb/a/mailverify?loc=en_US&amp;uri=incodeblog">Mailing list</a></li></ul></li></ul></div></div></div></div></body></html>