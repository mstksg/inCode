<!DOCTYPE HTML>
<html><head><title>&quot;Five-Point Haskell&quot;: Unconditional Election (via Parametricity) · in Code</title><meta name="description" content="Weblog of Justin Le, covering various adventures in programming and explorations in the worlds of computation physics, and knowledge.
"><meta http-equiv="Content-Type" content="text/html;charset=utf-8"><meta name="viewport" content="width=device-width,initial-scale=1.0"><meta name="flattr:id" content="3p9jqr"><meta property="og:site_name" content="in Code"><meta property="og:description" content="Welcome back to Five-Point Haskell! This is my attempt to codify principles of writing robust, maintainable, correct, clear, and effective code in Haskell and to dispel common bad practices (or, heresies) I have run into in my time. In the last post, we talked about Total Depravity, which is about treating any mentally tracked constraint or condition as inevitably leading to a catastrophe and denouncing the reliance on our flawed mental context windows. However, stopping here gives us an incomplete picture. Firstly, types aren’t just about preventing bad behaviors. They’re about designing good code. Secondly, there is only so much you can do by picking careful structures and making invalid states unrepresentable. These are still human tools with human flaws. The next point, to me, is about an aspect of the type system that I see little coverage of, but is a doctrine of design that I reach for in almost everything I write. It’s about leveraging the unyielding properties of math itself to take care of our fate, even when we are unable to structure our types well. So, when writing Haskell, remember Unconditional Election. Unconditional Election: The power of the forall to elect or reprobate instantiations and implementations through parametric polymorphism. These properties aren’t based on any conditional ad-hoc aspect of types, but are truly unconditional, predestined by universal quantification.Surrender your control to parametric polymorphism in all things. Embrace the “free”-dom of “Free Theorems” from one of Haskell’s greatest unexpected strengths: the type parameter."><meta property="og:type" content="article"><meta property="og:title" content="&quot;Five-Point Haskell&quot;: Unconditional Election (via Parametricity)"><meta property="og:image" content="https://blog.jle.im/img/site_logo.jpg"><meta property="og:locale" content="en_US"><meta property="og:url" content="https://blog.jle.im/entry/five-point-haskell-part-2-unconditional-election.html"><meta name="twitter:card" content="summary"><meta name="twitter:creator:id" content="mstk"><link rel="author" href="https://plus.google.com/107705320197444500140"><link rel="alternate" type="application/rss+xml" title="in Code (RSS Feed)" href="http://feeds.feedburner.com/incodeblog"><link rel="canonical" href="https://blog.jle.im/entry/five-point-haskell-part-2-unconditional-election.html"><link href="https://blog.jle.im/favicon.ico" rel="shortcut icon"><link href="https://blog.jle.im/css/toast.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/font.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/main.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/page/entry.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/pygments.css" rel="stylesheet" type="text/css"><script type="text/javascript">var page_data = {};
var disqus_shortname='incode';
</script><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-443711-8', 'jle.im');
ga('send', 'pageview');
</script><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script id="MathJax-script" async="" src="https://cdn.jsdelivr.net/npm/mathjax@3.0.1/es5/tex-mml-chtml.js"></script><script type="text/javascript" src="//ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script><script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5234d67a6b68dcd4"></script><script type="text/javascript" src="https://blog.jle.im/js/page/entry_toc.js"></script><script type="text/javascript" src="https://blog.jle.im/js/disqus_count.js"></script><script type="text/javascript" src="https://blog.jle.im/js/social.js"></script><script type="text/javascript" src="https://blog.jle.im/js/jquery/jquery.toc.js"></script><script type="text/javascript" src="https://blog.jle.im/purescript/entry.js"></script></head><body><div id="fb-root"><script>(function(d, s, id) {
 var js, fjs = d.getElementsByTagName(s)[0];
 if (d.getElementById(id)) return;
 js = d.createElement(s); js.id = id;
 js.src = "//connect.facebook.net/en_US/all.js#xfbml=1&appId=641852699171929";
 fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));
</script></div><div id="header-container"><div id="navbar-container" class="tile"><nav id="navbar-content"><div class="nav-info"><h1 class="site-title"><a href="https://blog.jle.im/" class="nav-title">in Code</a></h1><span class="nav-author">Justin Le</span></div><ul class="nav-links"><li><a href="https://blog.jle.im/">home</a></li><li><a href="https://blog.jle.im/entries.html">archives</a></li><li><a href="https://cv.jle.im">cv</a></li><div class="clear"></div></ul></nav></div><div id="header-content"></div></div><div id="body-container" class="container"><div id="main-container" class="grid"><div class="entry-section unit span-grid" role="main"><article class="tile article"><header><div class="unposted-banner">Unposted entry</div><h1 id="title">&quot;Five-Point Haskell&quot;: Unconditional Election (via Parametricity)</h1><p class="entry-info">by <a class="author" href="https://blog.jle.im/">Justin Le</a></p><p><span class="source-info"><a class="source-link" href="https://github.com/mstksg/inCode/tree/master/copy/entries/five-point-haskell-2.md">Source</a><span class="info-separator"> &diams; </span><a class="source-link" href="https://github.com/mstksg/inCode/tree/gh-pages/entry/five-point-haskell-part-2-unconditional-election.md">Markdown</a><span class="info-separator"> &diams; </span><a class="source-link" href="https://blog.jle.im/entry/five-point-haskell-part-2-unconditional-election.tex">LaTeX</a><span class="info-separator"> &diams; </span></span>Posted in <a href="https://blog.jle.im/entries/category/@haskell.html" class="tag-a-category" title="Functional, pure, non-strict, statically and strongly typed, natively
compiled...really just the king of great languages.
">Haskell</a><span class="info-separator"> &diams; </span><a class="comment-link" href="#disqus_thread">Comments</a></p></header><hr><aside class="contents-container"><h5 id="contents-header">Contents</h5><div id="toc"></div></aside><div class="main-content copy-content"><p>Welcome back to <em><a href="https://blog.jle.im/entries/series/+five-point-haskell.html">Five-Point Haskell</a></em>! This is my attempt to codify principles of writing robust, maintainable, correct, clear, and effective code in Haskell and to dispel common bad practices (or, heresies) I have run into in my time.</p>
<p>In the last post, we talked about <a href="https://blog.jle.im/entry/five-point-haskell-part-1-total-depravity.html">Total Depravity</a>, which is about treating any mentally tracked constraint or condition as inevitably leading to a catastrophe and denouncing the reliance on our flawed mental context windows.</p>
<p>However, stopping here gives us an incomplete picture. Firstly, types aren’t just about preventing bad behaviors. They’re about designing good code. Secondly, there is only so much you can do by picking careful structures and making invalid states unrepresentable. These are still human tools with human flaws.</p>
<p>The next point, to me, is about an aspect of the type system that I see little coverage of, but is a doctrine of design that I reach for in almost everything I write. It’s about leveraging the unyielding properties of math <em>itself</em> to take care of our fate, even when we are unable to structure our types well.</p>
<p>So, when writing Haskell, remember <strong>Unconditional Election</strong>.</p>
<blockquote>
<p>Unconditional Election: The power of the <code>forall</code> to elect or reprobate instantiations and implementations through parametric polymorphism. These properties aren’t based on any conditional ad-hoc aspect of types, but are truly unconditional, predestined by universal quantification.</p>
<p>Surrender your control to parametric polymorphism in all things. Embrace the “free”-dom of “Free Theorems” from one of Haskell’s greatest unexpected strengths: the type parameter.</p>
</blockquote>
<h2 id="choice-is-a-prison">Choice is a Prison</h2>
<h3 id="conditional-election">Conditional Election</h3>
<p>Learning Haskell can be a journey full of surprises, but this was one of the ones that blew my mind the most.</p>
<p>Let’s think of a polymorphic function in Java that takes a value of any type and returns something of that same type:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode java"><code class="sourceCode java"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="dt">static</span> <span class="op">&lt;</span>T<span class="op">&gt;</span> T <span class="fu">foo</span><span class="op">(</span>T x<span class="op">)</span></span></code></pre></div>
<p>What could that function do?</p>
<p>Well, it could do IO or throw an exception, mutate the input, or possibly be non-terminating, but let’s assume all it (and every other example here) does is purely return a value without mutation. What could it do?</p>
<p>The answer: pretty much anything. It could return the same value it was given, except if it is an <code>Integer</code>, in which case it negates it:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode java"><code class="sourceCode java"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="dt">static</span> <span class="op">&lt;</span>T<span class="op">&gt;</span> T <span class="fu">foo</span><span class="op">(</span>T x<span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>x <span class="kw">instanceof</span> <span class="bu">Integer</span> i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">(</span>T<span class="op">)</span> <span class="bu">Integer</span><span class="op">.</span><span class="fu">valueOf</span><span class="op">(-</span>i<span class="op">);</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> x<span class="op">;</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Same deal in TypeScript or pretty much any other typed language without parametricity:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode typescript"><code class="sourceCode typescript"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">foo</span><span class="op">&lt;</span>T<span class="op">&gt;</span>(x<span class="op">:</span> T)<span class="op">:</span> T</span></code></pre></div>
<p>Yet again, we have conditional election:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode typescript"><code class="sourceCode typescript"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">foo</span><span class="op">&lt;</span>T<span class="op">&gt;</span>(x<span class="op">:</span> T)<span class="op">:</span> T {</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> (<span class="kw">typeof</span> x <span class="op">===</span> <span class="st">&quot;number&quot;</span>) {</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> (<span class="op">-</span>x) <span class="im">as</span> <span class="dt">any</span> <span class="im">as</span> T<span class="op">;</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> x<span class="op">;</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>But how about Haskell?</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="ot">foo ::</span> a <span class="ot">-&gt;</span> a</span></code></pre></div>
<p>(For the rest of this post, let’s ignore [non-termination][fastandloose] and other [escape hatches]<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>)</p>
<p>Because Haskell has type erasure and no runtime reflection, the <em>only</em> possible implementation is simply:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="ot">foo ::</span> a <span class="ot">-&gt;</span> a</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>foo x <span class="ot">=</span> x</span></code></pre></div>
<p>So there is an invariant that appeared somehow in our code: a function of type <code>forall a. a -&gt; a</code> <em>must</em> leave its value unchanged!</p>
<p>But wait…says who? Did we insert some sort of <code>const</code> compiler annotation? Did we add some sort of annotation or pre- and post-condition that the value cannot change? Are we relying on any sort of foreseeable property of the value given?</p>
<p>No. This behavior is intrinsically fixed! We got this theorem <em>for free</em>. No need for any sort of work, no need for any foreseen faithfulness. We didn’t even have to <em>write</em> the function before knowing all it possibly could be.</p>
<p>This is the power of the <code>forall</code>. Note that the above <code>foo :: a -&gt; a</code> is “sugar” for:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="ot">foo ::</span> <span class="kw">forall</span> a<span class="op">.</span> a <span class="ot">-&gt;</span> a</span></code></pre></div>
<p>If you don’t add a <code>forall a</code>, it is implicitly added. Some languages, like PureScript and Dhall, require the <code>forall</code> in every case to be explicit. This is basically Haskell’s equivalent of <code>&lt;T&gt;</code> in Java, <code>template &lt;typename T&gt;</code> in C++, etc.</p>
<p>Anyway, let’s consider another type signature:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode java"><code class="sourceCode java"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="dt">static</span> <span class="op">&lt;</span>T<span class="op">&gt;</span> <span class="bu">String</span> <span class="fu">foo</span><span class="op">(</span>T x<span class="op">)</span></span></code></pre></div>
<p>Even if we disallow IO (like getting the time, or system state), in Java (and most other languages), this again could literally be anything. You can serialize the object with <code>toString</code>, or you can get its class using <code>getClass</code>…</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode java"><code class="sourceCode java"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="dt">static</span> <span class="op">&lt;</span>T<span class="op">&gt;</span> <span class="bu">String</span> <span class="fu">foo</span><span class="op">(</span>T x<span class="op">)</span> <span class="op">{</span> <span class="cf">return</span> <span class="st">&quot;hello&quot;</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="dt">static</span> <span class="op">&lt;</span>T<span class="op">&gt;</span> <span class="bu">String</span> <span class="fu">foo</span><span class="op">(</span>T x<span class="op">)</span> <span class="op">{</span> <span class="cf">return</span> x<span class="op">.</span><span class="fu">toString</span><span class="op">();</span> <span class="op">}</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a><span class="dt">static</span> <span class="op">&lt;</span>T<span class="op">&gt;</span> <span class="bu">String</span> <span class="fu">foo</span><span class="op">(</span>T x<span class="op">)</span> <span class="op">{</span> <span class="cf">return</span> x<span class="op">.</span><span class="fu">getClass</span><span class="op">().</span><span class="fu">getSimpleName</span><span class="op">();</span> <span class="op">}</span></span></code></pre></div>
<p>In Haskell? A <code>forall a. a -&gt; String</code> cannot use its input! It <em>must</em> be a constant string!</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="ot">foo ::</span> a <span class="ot">-&gt;</span> <span class="dt">String</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>foo _ <span class="ot">=</span> <span class="st">&quot;hello&quot;</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a><span class="co">-- or</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>foo _ <span class="ot">=</span> <span class="st">&quot;goodbye&quot;</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a><span class="co">-- or</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>foo _ <span class="ot">=</span> <span class="st">&quot;i always ignore my input&quot;</span></span></code></pre></div>
<p>In fact, there is an isomorphism between <code>String</code> and <code>forall a. a -&gt; String</code> (fun exercise: write it!)</p>
<p>You can “selectively” bring in capabilities using typeclasses:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="ot">foo ::</span> <span class="dt">Show</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">String</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>foo _ <span class="ot">=</span> <span class="st">&quot;hello&quot;</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a><span class="co">-- or</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>foo x <span class="ot">=</span> <span class="fu">show</span> x</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a><span class="co">-- or</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>foo x <span class="ot">=</span> <span class="st">&quot;reversed: &quot;</span> <span class="op">&lt;&gt;</span> <span class="fu">reverse</span> (<span class="fu">show</span> x)</span></code></pre></div>
<p>But there are still properties you can enforce: the resulting string can <em>only</em> depend on the input as far as what is revealed in its <code>Show</code> instance. Any property not in its <code>Show</code> instance is off-limits.</p>
<p>Alternatively, you can rephrase it as:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="ot">foo ::</span> (a <span class="ot">-&gt;</span> <span class="dt">String</span>) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">String</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>foo showVal x <span class="ot">=</span> <span class="co">-- ...</span></span></code></pre></div>
<p>and you can see that the only way you can ever inspect <code>a</code> is through the singular inspection-lens <code>a -&gt; String</code> that you are given. No <code>getClass()</code>, no back doors, etc.</p>
<h3 id="the-guessing-game">The Guessing Game</h3>
<p>One game Haskellers get used to playing is “guess the properties that the <code>forall</code> ensures” on different type signatures. Let’s try it out!</p>
<p>For example:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="ot">mystery ::</span> a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> a</span></code></pre></div>
<p><code>mystery</code> <em>has</em> to be <code>\x _ -&gt; x</code> — there is no other option.</p>
<p>How about:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="ot">turmeric ::</span> ((a, b) <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c</span></code></pre></div>
<p>If you think about it, the only option is:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="ot">turmeric ::</span> ((a, b) <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>turmeric f x y <span class="ot">=</span> f (x, y)</span></code></pre></div>
<p>You can go pretty far down this lane using Haskell as a <a href="https://blog.jle.im/entry/the-baby-paradox-in-haskell.html#haskell-as-a-theorem-prover">theorem prover</a>, in that the type signature represents a proposition and the implementation represents a proof of that claim. But we’re not going to go down that route for now, since most practical code is not theorem-proving.</p>
<p>But let’s look at something a bit more structural. How about:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="ot">theThing ::</span> [a] <span class="ot">-&gt;</span> [a]</span></code></pre></div>
<p>What could this do?</p>
<p>Well, we know that all items from the result list <em>must</em> be from the input list. It must be a “subset” — but the ordering or multiplicity can change. And more importantly, it <em>can’t</em> depend on anything about the properties of any <code>a</code>. We also know that if the input is empty, so must be the output.</p>
<p>From this, we can derive what are called <a href="https://people.mpi-sws.org/~dreyer/tor/papers/wadler.pdf">free theorems</a> to look at properties that <em>any implementation</em> must have. Namely, <em>mapping</em> a function over the list and calling <code>theThing</code> must be equivalent to calling <code>theThing</code> and then mapping:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>theThing <span class="op">.</span> <span class="fu">map</span> f</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>  <span class="op">==</span> <span class="fu">map</span> f <span class="op">.</span> theThing</span></code></pre></div>
<p>Can you see why? Think of any possible implementation — <code>reverse</code>, <code>take 3</code>, etc. — and see how this must be the case. However, this is <em>not</em> true for i.e. <code>sort :: [Int] -&gt; [Int]</code>. Because <code>sort</code> depends on the actual properties of the items, <code>map f</code> could change the properties that <code>sort</code> depends on!</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> <span class="fu">sort</span> <span class="op">.</span> <span class="fu">map</span> <span class="fu">abs</span> <span class="op">$</span> [<span class="dv">5</span>,<span class="op">-</span><span class="dv">1</span>,<span class="dv">3</span>,<span class="op">-</span><span class="dv">7</span>]</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>[<span class="dv">1</span>,<span class="dv">3</span>,<span class="dv">5</span>,<span class="dv">7</span>]</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> <span class="fu">map</span> <span class="fu">abs</span> <span class="op">.</span> <span class="fu">sort</span> <span class="op">$</span> [<span class="dv">5</span>,<span class="op">-</span><span class="dv">1</span>,<span class="dv">3</span>,<span class="op">-</span><span class="dv">7</span>]</span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>[<span class="dv">7</span>,<span class="dv">1</span>,<span class="dv">3</span>,<span class="dv">5</span>]</span></code></pre></div>
<p>Compared to an actual function with the polymorphic type, like <code>take 3</code>:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> <span class="fu">take</span> <span class="dv">3</span> <span class="op">.</span> <span class="fu">map</span> <span class="fu">abs</span> <span class="op">$</span> [<span class="dv">5</span>,<span class="op">-</span><span class="dv">1</span>,<span class="dv">3</span>,<span class="op">-</span><span class="dv">7</span>]</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>[<span class="dv">5</span>,<span class="dv">1</span>,<span class="dv">3</span>]</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> <span class="fu">map</span> <span class="fu">abs</span> <span class="op">.</span> <span class="fu">take</span> <span class="dv">3</span> <span class="op">$</span> [<span class="dv">5</span>,<span class="op">-</span><span class="dv">1</span>,<span class="dv">3</span>,<span class="op">-</span><span class="dv">7</span>]</span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>[<span class="dv">5</span>,<span class="dv">1</span>,<span class="dv">3</span>]</span></code></pre></div>
<p>How about:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="ot">doIt ::</span> [a] <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a</span></code></pre></div>
<p>Think about what this <em>can’t</em> do. It clearly selects a single item, but:</p>
<ol type="1">
<li>The single item cannot be determined based on any quality or merit of that item — it can’t be the smallest, the largest, etc.; it has to depend purely on the position in the list and the length of the list</li>
<li>If given an empty list, it <em>must</em> return <code>Nothing</code></li>
</ol>
<p>And again we have the same free theorem, <code>doIt . map f == fmap f . doIt</code>. No matter how you implement <code>doIt</code>, it is guaranteed to commute with <code>map</code> and <code>fmap</code>!</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- no free theorem: `minimumMay :: [Int] -&gt; Maybe Int`</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> minimumMay <span class="op">.</span> <span class="fu">map</span> <span class="fu">abs</span> <span class="op">$</span> [<span class="dv">5</span>,<span class="op">-</span><span class="dv">1</span>,<span class="dv">3</span>,<span class="op">-</span><span class="dv">7</span>]</span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a><span class="dt">Just</span> <span class="dv">1</span></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> <span class="fu">fmap</span> <span class="fu">abs</span> <span class="op">.</span> minimumMay <span class="op">$</span> [<span class="dv">5</span>,<span class="op">-</span><span class="dv">1</span>,<span class="dv">3</span>,<span class="op">-</span><span class="dv">7</span>]</span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a><span class="dt">Just</span> <span class="dv">7</span></span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true" tabindex="-1"></a><span class="co">-- free theorem: `listToMaybe :: [a] -&gt; Maybe a`</span></span>
<span id="cb21-8"><a href="#cb21-8" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> listToMaybe <span class="op">.</span> <span class="fu">map</span> <span class="fu">abs</span> <span class="op">$</span> [<span class="dv">5</span>,<span class="op">-</span><span class="dv">1</span>,<span class="dv">3</span>,<span class="op">-</span><span class="dv">7</span>]</span>
<span id="cb21-9"><a href="#cb21-9" aria-hidden="true" tabindex="-1"></a><span class="dt">Just</span> <span class="dv">5</span></span>
<span id="cb21-10"><a href="#cb21-10" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> <span class="fu">fmap</span> <span class="fu">abs</span> <span class="op">.</span> listToMaybe <span class="op">$</span> [<span class="dv">5</span>,<span class="op">-</span><span class="dv">1</span>,<span class="dv">3</span>,<span class="op">-</span><span class="dv">7</span>]</span>
<span id="cb21-11"><a href="#cb21-11" aria-hidden="true" tabindex="-1"></a><span class="dt">Just</span> <span class="dv">5</span></span></code></pre></div>
<p>Let’s try another one:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="ot">collapse ::</span> [a] <span class="ot">-&gt;</span> <span class="dt">Int</span></span></code></pre></div>
<p>What could this possibly do? Well, we can rule out things like <code>sum</code> because we can’t use any property of the values themselves. The only things that this could return are constant functions and functions that depend on the <em>length</em> but not the <em>contents</em> of the list. We also have another free theorem, <code>collapse . map f == collapse</code>: mapping a function shouldn’t change the output, because none of the actual values matter.</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- no free theorem: `sum :: [Int] -&gt; Int`</span></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> <span class="fu">sum</span> <span class="op">.</span> <span class="fu">map</span> <span class="fu">abs</span> <span class="op">$</span> [<span class="dv">5</span>,<span class="op">-</span><span class="dv">1</span>,<span class="dv">3</span>,<span class="op">-</span><span class="dv">7</span>]</span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a><span class="dv">16</span></span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> <span class="fu">sum</span> [<span class="dv">5</span>,<span class="op">-</span><span class="dv">1</span>,<span class="dv">3</span>,<span class="op">-</span><span class="dv">7</span>]</span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a><span class="dv">0</span></span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-7"><a href="#cb23-7" aria-hidden="true" tabindex="-1"></a><span class="co">-- free theorem: `length :: [a] -&gt; Int`</span></span>
<span id="cb23-8"><a href="#cb23-8" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> <span class="fu">length</span> <span class="op">.</span> <span class="fu">map</span> <span class="fu">abs</span> <span class="op">$</span> [<span class="dv">5</span>,<span class="op">-</span><span class="dv">1</span>,<span class="dv">3</span>,<span class="op">-</span><span class="dv">7</span>]</span>
<span id="cb23-9"><a href="#cb23-9" aria-hidden="true" tabindex="-1"></a><span class="dv">4</span></span>
<span id="cb23-10"><a href="#cb23-10" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> <span class="fu">length</span> [<span class="dv">5</span>,<span class="op">-</span><span class="dv">1</span>,<span class="dv">3</span>,<span class="op">-</span><span class="dv">7</span>]</span>
<span id="cb23-11"><a href="#cb23-11" aria-hidden="true" tabindex="-1"></a><span class="dv">4</span></span></code></pre></div>
<p>How about something in the opposite direction:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="ot">dupper ::</span> a <span class="ot">-&gt;</span> [a]</span></code></pre></div>
<p>From this type signature, we can conclude that the final list must contain the <em>same item</em>! The only possible inhabitants are <code>replicate n</code> for some <code>n</code>, or <code>repeat</code>.<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a></p>
<p>Again, we have a free theorem: <code>map f . dupper == dupper . f</code></p>
<div class="sourceCode" id="cb25"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- no free theorem: `take 3 . iterate (+1) :: Int -&gt; [Int]`</span></span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> <span class="fu">take</span> <span class="dv">3</span> <span class="op">.</span> <span class="fu">iterate</span> (<span class="op">+</span><span class="dv">1</span>) <span class="op">.</span> <span class="fu">negate</span> <span class="op">$</span> <span class="dv">4</span></span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a>[<span class="op">-</span><span class="dv">4</span>,<span class="op">-</span><span class="dv">3</span>,<span class="op">-</span><span class="dv">2</span>]</span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> <span class="fu">map</span> <span class="fu">negate</span> <span class="op">.</span> <span class="fu">take</span> <span class="dv">3</span> <span class="op">.</span> <span class="fu">iterate</span> (<span class="op">+</span><span class="dv">1</span>) <span class="op">$</span> <span class="dv">4</span></span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a>[<span class="op">-</span><span class="dv">4</span>,<span class="op">-</span><span class="dv">5</span>,<span class="op">-</span><span class="dv">6</span>]</span>
<span id="cb25-6"><a href="#cb25-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-7"><a href="#cb25-7" aria-hidden="true" tabindex="-1"></a><span class="co">-- free theorem: `replicate 3 :: Int -&gt; [Int]`</span></span>
<span id="cb25-8"><a href="#cb25-8" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> <span class="fu">replicate</span> <span class="dv">3</span> <span class="op">.</span> <span class="fu">negate</span> <span class="op">$</span> <span class="dv">4</span></span>
<span id="cb25-9"><a href="#cb25-9" aria-hidden="true" tabindex="-1"></a>[<span class="op">-</span><span class="dv">4</span>,<span class="op">-</span><span class="dv">4</span>,<span class="op">-</span><span class="dv">4</span>]</span>
<span id="cb25-10"><a href="#cb25-10" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> <span class="fu">map</span> <span class="fu">negate</span> <span class="op">.</span> <span class="fu">replicate</span> <span class="dv">3</span> <span class="op">$</span> <span class="dv">4</span></span>
<span id="cb25-11"><a href="#cb25-11" aria-hidden="true" tabindex="-1"></a>[<span class="op">-</span><span class="dv">4</span>,<span class="op">-</span><span class="dv">4</span>,<span class="op">-</span><span class="dv">4</span>]</span></code></pre></div>
<p>What’s better than one type variable? How about two?</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="ot">mapMaybe ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> b) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [b]</span></code></pre></div>
<p>Because this has to work for <em>all</em> <code>a</code> and <code>b</code>, we know that the <em>only</em> possible <code>b</code>s you can find in your result list are <code>b</code>s that you get from the <code>a -&gt; Maybe b</code> function. So, you can be sure that the implementation doesn’t conjure out any arbitrary <code>b</code> except for the specific ones producible by your <code>a -&gt; Maybe b</code>. For example, if you pass it a function that returns only even integers, the resulting list will <em>only</em> ever contain even integers!</p>
<p>One final one, with a higher-rank variable:</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="ot">traverseIO ::</span> (a <span class="ot">-&gt;</span> <span class="dt">IO</span> b) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">IO</span> [b]</span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a><span class="co">-- vs</span></span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true" tabindex="-1"></a><span class="fu">traverse</span><span class="ot"> ::</span> <span class="dt">Applicative</span> f <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> f b) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> f [b]</span></code></pre></div>
<p>What invariant does the second add over the first? Even <em>if</em> you only ever plan on calling things with <code>IO</code>, the second gives you a new invariant: there won’t be any “stray” <code>IO</code> actions other than what is given in the <code>a -&gt; f b</code>. In the first one, you never know if the resulting <code>IO</code> action might include a <code>putStrLn "hello"</code> or a <code>launchMissiles</code>. You definitely don’t want any functions doing sneaky IO behind your back!</p>
<h3 id="the-more-you-surrender">The More you Surrender</h3>
<p>Practically, this becomes similar to the principle of least power, the idea that you should use the tools with the least power necessary to do your job. Say you <em>are</em> writing a function that shuffles a list of items, important for your business logic. You can encode exactly <em>what</em> business logic is being done by adding more and more parametricity.</p>
<ul>
<li>If your type is <code>[Int] -&gt; [Int]</code>, you know your function has pretty much no restriction on what it can do. It can even look at the machine representation of your values.</li>
<li>If your type is <code>Num a =&gt; [a] -&gt; [a]</code>, you know that it can possibly numerically transform the items in your list, or even conjure up new items.</li>
<li>If your type is <code>Ord a =&gt; [a] -&gt; [a]</code>, you know that your business logic is allowed to look at the ordering between items in the list, but cannot return any items that weren’t in the original list.</li>
<li>If your type is <code>[a] -&gt; [a]</code>, you know that your logic can only affect the permutation and multiplicity of items in your list.</li>
<li>If your type is <code>Functor f =&gt; f Int -&gt; f Int</code>, if you call with <code>[]</code>, you know that the length of the result will be preserved, and also any mappings of <code>Int</code>s will be done purely.</li>
<li>If your type is <code>Monad m =&gt; m a -&gt; m a</code>, if you call with <code>[]</code>, you know that the lengths of your results will always be integer powers of the length of the input.</li>
</ul>
<p>By switching from concrete types slowly to parametric types, you surrender control of what your functions can do, and create stronger and stronger guarantees. In other languages, or with refinement types, you might have to explicitly declare a post-condition like “the final values must all come from the original list”. With parametric polymorphism, this is already guaranteed and elected, no matter what the implementation is.</p>
<h3 id="its-only-natural">It’s Only Natural</h3>
<p>As an aside, did you wonder where I got those free theorems from? In the examples above, they come from <em>naturality</em>. Basically, any <code>forall a. (Functor f, Functor g) =&gt; f a -&gt; g a</code> corresponds to a <em><a href="https://en.wikipedia.org/wiki/Natural_transformation">natural transformation</a></em> in category theory, and so must commute with any <code>fmap</code>.</p>
<p>Basically, if you have a natural transformation <code>h :: forall a. F a -&gt; G a</code>, with <code>Functor F</code> and <code>Functor G</code>, then we have:</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a>h <span class="op">.</span> <span class="fu">fmap</span> f</span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a>    <span class="op">==</span> <span class="fu">fmap</span> f <span class="op">.</span> h</span></code></pre></div>
<p>The above examples, <code>forall a. [a] -&gt; [a]</code>, <code>forall a. [a] -&gt; Maybe a</code>, etc. all arise from this. But you might have to think carefully to see that <code>forall a. a -&gt; [a]</code> is really <code>forall a. Identity a -&gt; [a]</code>. And can you think of the Functor that gives us naturality for <code>forall a. [a] -&gt; Int</code>?<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a></p>
<p>Maybe more surprising than the fact that these free theorems exist is the fact that their root is intrinsically tied to a branch of math as obscure and esoteric as “category theory”!</p>
<h2 id="add-a-type-variable">Add a Type Variable</h2>
<p>Let’s say I had a data type like:</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">User</span> <span class="ot">=</span> <span class="dt">User</span></span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a>    {<span class="ot"> userId ::</span> <span class="dt">Int</span></span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a>    ,<span class="ot"> userName ::</span> <span class="dt">String</span></span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a>    ,<span class="ot"> userAge ::</span> <span class="dt">Int</span></span>
<span id="cb29-5"><a href="#cb29-5" aria-hidden="true" tabindex="-1"></a>    }</span></code></pre></div>
<p>And we have a function to process the user, like:</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="ot">processUser ::</span> <span class="dt">User</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">User</span></span></code></pre></div>
<p>How can we enforce that the <code>userId</code> is not changed?</p>
<p>Maybe if we were in C, we could have a <code>const</code> field:</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> User <span class="op">{</span></span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">const</span> <span class="dt">int</span> userId<span class="op">;</span></span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">char</span> userName<span class="op">[</span><span class="dv">20</span><span class="op">];</span></span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> userAge<span class="op">;</span></span>
<span id="cb31-5"><a href="#cb31-5" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>But, this applies to <em>all</em> usage of the <code>User</code> struct…what if we only wanted to preserve this property on a single function? You can’t declare struct-level <code>const</code> on a single argument!</p>
<p>Instead, we can enforce this by making <code>userId</code>’s type parameterized:</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">User</span> uid <span class="ot">=</span> <span class="dt">User</span></span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a>    {<span class="ot"> userId ::</span> uid</span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a>    ,<span class="ot"> userName ::</span> <span class="dt">String</span></span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true" tabindex="-1"></a>    ,<span class="ot"> userAge ::</span> <span class="dt">Int</span></span>
<span id="cb32-5"><a href="#cb32-5" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb32-6"><a href="#cb32-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-7"><a href="#cb32-7" aria-hidden="true" tabindex="-1"></a><span class="co">-- | Guaranteed not to change the ID</span></span>
<span id="cb32-8"><a href="#cb32-8" aria-hidden="true" tabindex="-1"></a><span class="ot">processUser ::</span> <span class="dt">User</span> uid <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">User</span> uid)</span></code></pre></div>
<p>Is this constraint enforced because we carefully designed the structure of our type? Is it constrained because we added compiler annotations or refinement types or static analysis? Not quite! It truly did come for free.</p>
<p>Or, consider a checklist item:</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Checklist</span> <span class="ot">=</span> <span class="dt">Checklist</span></span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a>  {<span class="ot"> updated ::</span> <span class="dt">UTCTime</span></span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> items ::</span> [(<span class="dt">Status</span>, <span class="dt">String</span>)]</span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true" tabindex="-1"></a>  }</span></code></pre></div>
<p>What if I wanted to write a function that processed items without adding or removing any? Just each item in-place?</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- | Invariant: Preserves the ordering of items, and their number.</span></span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a><span class="ot">updateItems ::</span> <span class="dt">Checklist</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">Checklist</span></span></code></pre></div>
<p>How can we make sure all our implementations are <em>elected</em> to only be implementations that don’t modify the length of <code>items</code>?</p>
<p>Again the answer can be: add quantification!</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Checklist</span> t <span class="ot">=</span> <span class="dt">Checklist</span></span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a>  {<span class="ot"> updated ::</span> <span class="dt">UTCTime</span></span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> items ::</span> t (<span class="dt">Status</span>, <span class="dt">String</span>)</span>
<span id="cb35-4"><a href="#cb35-4" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb35-5"><a href="#cb35-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-6"><a href="#cb35-6" aria-hidden="true" tabindex="-1"></a><span class="co">-- | Guaranteed not to add or remove or rearrange items, but can still perform</span></span>
<span id="cb35-7"><a href="#cb35-7" aria-hidden="true" tabindex="-1"></a><span class="co">-- IO to get the new Status and String</span></span>
<span id="cb35-8"><a href="#cb35-8" aria-hidden="true" tabindex="-1"></a><span class="ot">updateItems ::</span> <span class="dt">Traversable</span> t <span class="ot">=&gt;</span> <span class="dt">Checklist</span> t <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">Checklist</span> t)</span></code></pre></div>
<p>For an example of a possible implementation:</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a><span class="ot">updateSingleItem ::</span> (<span class="dt">Status</span>, <span class="dt">String</span>) <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">Status</span>, <span class="dt">String</span>)</span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true" tabindex="-1"></a><span class="ot">updateItems ::</span> <span class="dt">Traversable</span> t <span class="ot">=&gt;</span> <span class="dt">Checklist</span> t <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">Checklist</span> t)</span>
<span id="cb36-4"><a href="#cb36-4" aria-hidden="true" tabindex="-1"></a>updateItems c0 <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb36-5"><a href="#cb36-5" aria-hidden="true" tabindex="-1"></a>  newItems <span class="ot">&lt;-</span> <span class="fu">traverse</span> updateSingleItem (items c0)</span>
<span id="cb36-6"><a href="#cb36-6" aria-hidden="true" tabindex="-1"></a>  newUpdated <span class="ot">&lt;-</span> getCurrentTime</span>
<span id="cb36-7"><a href="#cb36-7" aria-hidden="true" tabindex="-1"></a>  <span class="fu">pure</span> (<span class="dt">Checklist</span> newUpdated newItems)</span></code></pre></div>
<p>Try as you might, you can’t make an implementation that rearranges the items.</p>
<p>Note that we are <em>not</em> adding type parameters for abstraction or to be able to use “exotic checklists” (<code>Checklist Maybe</code>). Instead, we are intentionally using them universally quantified in functions that process them, in order to take advantage of these automatically enforced properties.</p>
<p>This intersects a lot with the <a href="https://reasonablypolymorphic.com/blog/higher-kinded-data/">Higher-Kinded Data</a> pattern. Maybe we <em>do</em> have data we want to have multiple structural versions of:</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">UserF</span> f <span class="ot">=</span> <span class="dt">User</span></span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a>    {<span class="ot"> userName ::</span> f <span class="dt">String</span></span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true" tabindex="-1"></a>    ,<span class="ot"> userAge ::</span> f <span class="dt">Int</span></span>
<span id="cb37-4"><a href="#cb37-4" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb37-5"><a href="#cb37-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-6"><a href="#cb37-6" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">User</span> <span class="ot">=</span> <span class="dt">UserF</span> <span class="dt">Identity</span></span>
<span id="cb37-7"><a href="#cb37-7" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">NullableUser</span> <span class="ot">=</span> <span class="dt">UserF</span> <span class="dt">Maybe</span></span>
<span id="cb37-8"><a href="#cb37-8" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">UserParser</span> <span class="ot">=</span> <span class="dt">UserF</span> <span class="dt">Parser</span></span>
<span id="cb37-9"><a href="#cb37-9" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">UserDocs</span> <span class="ot">=</span> <span class="dt">UserF</span> (<span class="dt">Const</span> <span class="dt">Doc</span>)</span>
<span id="cb37-10"><a href="#cb37-10" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">UserPrinter</span> <span class="ot">=</span> <span class="dt">UserF</span> (<span class="dt">Op</span> <span class="dt">String</span>)</span></code></pre></div>
<p>In this case, a function like</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a><span class="ot">processUser ::</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> <span class="dt">UserF</span> f <span class="ot">-&gt;</span> <span class="dt">UserF</span> f</span></code></pre></div>
<p>will give you a different, unique guarantee for every “shape” your user has:</p>
<ul>
<li>For <code>UserF Maybe</code>, the quantification ensures that the null-or-present property of each field is preserved</li>
<li>For <code>UserF Parser</code>, it ensures that all of the “parsing” logic, and the set of strings that are validly parsed, is preserved</li>
<li>For <code>UserF (Const Doc)</code>, it ensures that the per-field <code>Doc</code>/documentation is never changed or updated.</li>
</ul>
<p>For an example, we can write:</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a><span class="ot">processUser ::</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> <span class="dt">UserF</span> f <span class="ot">-&gt;</span> <span class="dt">UserF</span> f</span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true" tabindex="-1"></a>processUser user <span class="ot">=</span> <span class="dt">User</span></span>
<span id="cb39-3"><a href="#cb39-3" aria-hidden="true" tabindex="-1"></a>    { userName <span class="ot">=</span> <span class="fu">fmap</span> (<span class="fu">map</span> <span class="fu">toUpper</span>) (userName user)</span>
<span id="cb39-4"><a href="#cb39-4" aria-hidden="true" tabindex="-1"></a>    , userAge <span class="ot">=</span> <span class="fu">fmap</span> (<span class="op">+</span> <span class="dv">1</span>) (userAge user)</span>
<span id="cb39-5"><a href="#cb39-5" aria-hidden="true" tabindex="-1"></a>    }</span></code></pre></div>
<p>This is guaranteed to keep nullable fields null if <code>UserF Maybe</code>, preserve all successful parses if <code>UserF Parser</code>, and leave any field-level documentation unchanged if <code>UserF (Const Doc)</code>.</p>
<p>All of these properties are <em>mathematically</em> enforced, <em>unconditionally</em>. It doesn’t depend on any foreseen property of the types or values we use. These guarantees free us to be able to confidently use these functions without fear of invariants breaking.</p>
<p>This game becomes even stronger when you consider dependent typing, where we can express more complex relationships between type variables. For example, in the case where you have a phantom type (like in <a href="https://blog.jle.im/entry/introduction-to-singletons-1.html">this singletons tutorial</a>):</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">DoorState</span> <span class="ot">=</span> <span class="dt">Opened</span> <span class="op">|</span> <span class="dt">Closed</span> <span class="op">|</span> <span class="dt">Locked</span></span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-3"><a href="#cb40-3" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Door</span> (<span class="ot">s ::</span> <span class="dt">DoorState</span>)</span>
<span id="cb40-4"><a href="#cb40-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-5"><a href="#cb40-5" aria-hidden="true" tabindex="-1"></a><span class="ot">processDoor ::</span> <span class="dt">Door</span> s <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">Door</span> s)</span></code></pre></div>
<p><code>processDoor</code>, by virtue of taking <code>forall s</code>, <em>must leave</em> the door state unchanged! It can never open a closed door, unlock a locked door, etc.</p>
<p>For things like <a href="https://blog.jle.im/entry/fixed-length-vector-types-in-haskell.html">fixed length vectors</a>, where the length <code>n</code> parameter is the size, what invariant do you think is preserved in:</p>
<div class="sourceCode" id="cb41"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a><span class="ot">something ::</span> <span class="dt">Vector</span> n a <span class="ot">-&gt;</span> <span class="dt">Vector</span> n a</span></code></pre></div>
<p>We know that the length of the result must be the same as the length of the input. Furthermore, with the <code>forall a</code>, we know that every item in the result must come from the input, but we might rearrange or change the multiplicity of the occurrences as long as they add to the same original total number. This might be a good candidate for a function like <code>reverse</code>.</p>
<p>Or, consider:</p>
<div class="sourceCode" id="cb42"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a><span class="ot">somethingElse ::</span> <span class="dt">Vector</span> n a <span class="ot">-&gt;</span> <span class="dt">Vector</span> (n <span class="op">-</span> <span class="dv">1</span>) a</span></code></pre></div>
<p>From this, we know that the original vector <em>must</em> be non-empty! Because of how the types must flow for whatever <code>n</code> you give it, this requires <code>n &gt;= 1</code>.</p>
<h2 id="ranking-up">Ranking Up</h2>
<p>Now that you see how useful it is to use type parameters and <code>forall</code>, can we <em>use</em> this fact at the meta-level even within our code itself?</p>
<h3 id="ensuring-structural-preservation">Ensuring structural preservation</h3>
<p>Let’s say we want to map an IO function over every item in our <code>UserF</code>, and return a new one. We know that whatever IO function we use <em>must</em> leave the actual “result” type unchanged. So that means we must take a <code>forall a. f a -&gt; IO (f a)</code>.</p>
<div class="sourceCode" id="cb43"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a>traverseUser</span>
<span id="cb43-2"><a href="#cb43-2" aria-hidden="true" tabindex="-1"></a><span class="ot">    ::</span> <span class="dt">Applicative</span> h</span>
<span id="cb43-3"><a href="#cb43-3" aria-hidden="true" tabindex="-1"></a>    <span class="ot">=&gt;</span> (<span class="kw">forall</span> a<span class="op">.</span> f a <span class="ot">-&gt;</span> h (g a))</span>
<span id="cb43-4"><a href="#cb43-4" aria-hidden="true" tabindex="-1"></a>    <span class="ot">-&gt;</span> <span class="dt">UserF</span> f</span>
<span id="cb43-5"><a href="#cb43-5" aria-hidden="true" tabindex="-1"></a>    <span class="ot">-&gt;</span> h (<span class="dt">UserF</span> g)</span>
<span id="cb43-6"><a href="#cb43-6" aria-hidden="true" tabindex="-1"></a>traverseUser f u <span class="ot">=</span> <span class="dt">User</span> <span class="op">&lt;$&gt;</span> f (userName u) <span class="op">&lt;*&gt;</span> f (userAge u)</span></code></pre></div>
<p>Here again we use the trick above to generalize for all <code>Applicative h</code> instead of concretely <code>IO</code>, so we can know that the final action can’t sneak in stray IO.</p>
<h3 id="ensuring-memory-safety">Ensuring memory safety</h3>
<p>We can also use this property in phantom types to enforce memory regions. Let’s say we are simulating memory in an <code>IntMap</code>:</p>
<div class="sourceCode" id="cb44"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">Var</span> <span class="ot">=</span> <span class="dt">Var</span> <span class="dt">Int</span></span>
<span id="cb44-2"><a href="#cb44-2" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">Memory</span> v <span class="ot">=</span> <span class="dt">Memory</span> {<span class="ot"> getMemory ::</span> <span class="dt">IntMap</span> v }</span>
<span id="cb44-3"><a href="#cb44-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb44-4"><a href="#cb44-4" aria-hidden="true" tabindex="-1"></a><span class="ot">initVar ::</span> v <span class="ot">-&gt;</span> <span class="dt">State</span> (<span class="dt">Memory</span> v) <span class="dt">Var</span></span>
<span id="cb44-5"><a href="#cb44-5" aria-hidden="true" tabindex="-1"></a>initVar x <span class="ot">=</span> state <span class="op">$</span> \(<span class="dt">Memory</span> mp) <span class="ot">-&gt;</span></span>
<span id="cb44-6"><a href="#cb44-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">case</span> IM.lookupMax mp <span class="kw">of</span></span>
<span id="cb44-7"><a href="#cb44-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Nothing</span> <span class="ot">-&gt;</span> (<span class="dt">Var</span> <span class="dv">0</span>, <span class="dt">Memory</span> <span class="op">$</span> IM.insert <span class="dv">0</span> x mp)</span>
<span id="cb44-8"><a href="#cb44-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Just</span> (i, _) <span class="ot">-&gt;</span> (<span class="dt">Var</span> (i <span class="op">+</span> <span class="dv">1</span>), <span class="dt">Memory</span> <span class="op">$</span> IM.insert (i <span class="op">+</span> <span class="dv">1</span>) x mp)</span>
<span id="cb44-9"><a href="#cb44-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb44-10"><a href="#cb44-10" aria-hidden="true" tabindex="-1"></a><span class="ot">readVar ::</span> <span class="dt">Var</span> <span class="ot">-&gt;</span> <span class="dt">State</span> (<span class="dt">Memory</span> v) v</span>
<span id="cb44-11"><a href="#cb44-11" aria-hidden="true" tabindex="-1"></a>readVar (<span class="dt">Var</span> i) <span class="ot">=</span> gets ((<span class="op">IM.!</span> i) <span class="op">.</span> getMemory)</span>
<span id="cb44-12"><a href="#cb44-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb44-13"><a href="#cb44-13" aria-hidden="true" tabindex="-1"></a><span class="ot">writeVar ::</span> <span class="dt">Var</span> <span class="ot">-&gt;</span> v <span class="ot">-&gt;</span> <span class="dt">State</span> (<span class="dt">Memory</span> v) ()</span>
<span id="cb44-14"><a href="#cb44-14" aria-hidden="true" tabindex="-1"></a>writeVar (<span class="dt">Var</span> i) x <span class="ot">=</span> modify (<span class="dt">Memory</span> <span class="op">.</span> IM.insert i x <span class="op">.</span> getMemory)</span>
<span id="cb44-15"><a href="#cb44-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb44-16"><a href="#cb44-16" aria-hidden="true" tabindex="-1"></a><span class="ot">runWithMemory ::</span> <span class="dt">State</span> (<span class="dt">Memory</span> v) a <span class="ot">-&gt;</span> a</span>
<span id="cb44-17"><a href="#cb44-17" aria-hidden="true" tabindex="-1"></a>runWithMemory <span class="ot">=</span> (<span class="ot">`evalState`</span> <span class="dt">Memory</span> IM.empty)</span></code></pre></div>
<p>(By the way, what do we gain from having the state be <code>IntMap v</code> parametric on <code>v</code>? What guarantees/invariants do we get, what sort of actions do we forbid the library itself from doing? Is it possible to have a default-initialized variable?)</p>
<p>We can run operations like:</p>
<div class="sourceCode" id="cb45"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a><span class="ot">getFib ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">State</span> (<span class="dt">Memory</span> <span class="dt">Int</span>) <span class="dt">Int</span></span>
<span id="cb45-2"><a href="#cb45-2" aria-hidden="true" tabindex="-1"></a>getFib n <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb45-3"><a href="#cb45-3" aria-hidden="true" tabindex="-1"></a>    a <span class="ot">&lt;-</span> initVar <span class="dv">0</span></span>
<span id="cb45-4"><a href="#cb45-4" aria-hidden="true" tabindex="-1"></a>    b <span class="ot">&lt;-</span> initVar <span class="dv">1</span></span>
<span id="cb45-5"><a href="#cb45-5" aria-hidden="true" tabindex="-1"></a>    replicateM_ n <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb45-6"><a href="#cb45-6" aria-hidden="true" tabindex="-1"></a>        newSum <span class="ot">&lt;-</span> (<span class="op">+</span>) <span class="op">&lt;$&gt;</span> readVar a <span class="op">&lt;*&gt;</span> readVar b</span>
<span id="cb45-7"><a href="#cb45-7" aria-hidden="true" tabindex="-1"></a>        writeVar a <span class="op">=&lt;&lt;</span> readVar b</span>
<span id="cb45-8"><a href="#cb45-8" aria-hidden="true" tabindex="-1"></a>        writeVar b newSum</span>
<span id="cb45-9"><a href="#cb45-9" aria-hidden="true" tabindex="-1"></a>    readVar b</span></code></pre></div>
<div class="sourceCode" id="cb46"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> runWithMemory (getFib <span class="dv">10</span>)</span>
<span id="cb46-2"><a href="#cb46-2" aria-hidden="true" tabindex="-1"></a><span class="dv">55</span></span></code></pre></div>
<p>But now our memory regions are pretty unsafe. We could, for instance, run <code>runWithMemory</code> <em>inside</em> itself:</p>
<div class="sourceCode" id="cb47"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a><span class="ot">myAction ::</span> <span class="dt">State</span> (<span class="dt">Memory</span> <span class="dt">String</span>) a</span>
<span id="cb47-2"><a href="#cb47-2" aria-hidden="true" tabindex="-1"></a>myAction <span class="ot">=</span> <span class="kw">do</span>                 <span class="co">-- new memory starts out empty</span></span>
<span id="cb47-3"><a href="#cb47-3" aria-hidden="true" tabindex="-1"></a>  v <span class="ot">&lt;-</span> initVar <span class="st">&quot;hello&quot;</span>        <span class="co">-- memory is now (0, &quot;hello&quot;)</span></span>
<span id="cb47-4"><a href="#cb47-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> x <span class="ot">=</span> runWithMemory <span class="op">$</span> <span class="kw">do</span>  <span class="co">-- new memory starts out empty</span></span>
<span id="cb47-5"><a href="#cb47-5" aria-hidden="true" tabindex="-1"></a>        readVar v             <span class="co">-- runtime error, looking up &#39;0&#39; in empty map!</span></span>
<span id="cb47-6"><a href="#cb47-6" aria-hidden="true" tabindex="-1"></a>        <span class="co">-- ..</span></span>
<span id="cb47-7"><a href="#cb47-7" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- ..</span></span></code></pre></div>
<p>Now <code>readVar v</code> will fail! Remember that <code>v</code> is <code>Var 0</code>, but that <code>0</code> key refers to the state map in the outer <code>IntMap</code>, and is undefined in the internal one.</p>
<p>We can also do something silly like returning a <code>Var</code>:</p>
<div class="sourceCode" id="cb48"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> runWithMemory (initVar <span class="st">&quot;hello&quot;</span>)</span>
<span id="cb48-2"><a href="#cb48-2" aria-hidden="true" tabindex="-1"></a><span class="dt">Var</span> <span class="dv">0</span></span></code></pre></div>
<p>And now that var exists without a context…its memory is gone, it refers to something that no longer has any meaning.</p>
<p>We can prevent this by associating a variable and its associated memory region with a phantom. Then we can ensure that <code>runWithMemory</code> requires the phantom to never be a part of the final output:</p>
<div class="sourceCode" id="cb49"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">Var</span> s <span class="ot">=</span> <span class="dt">Var</span> <span class="dt">Int</span></span>
<span id="cb49-2"><a href="#cb49-2" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">Memory</span> s v <span class="ot">=</span> <span class="dt">Memory</span> {<span class="ot"> getMemory ::</span> <span class="dt">IntMap</span> v }</span>
<span id="cb49-3"><a href="#cb49-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-4"><a href="#cb49-4" aria-hidden="true" tabindex="-1"></a><span class="ot">initVar ::</span> v <span class="ot">-&gt;</span> <span class="dt">State</span> (<span class="dt">Memory</span> s v) (<span class="dt">Var</span> s)</span>
<span id="cb49-5"><a href="#cb49-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-6"><a href="#cb49-6" aria-hidden="true" tabindex="-1"></a><span class="ot">readVar ::</span> <span class="dt">Var</span> s <span class="ot">-&gt;</span> <span class="dt">State</span> (<span class="dt">Memory</span> s v) v</span>
<span id="cb49-7"><a href="#cb49-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-8"><a href="#cb49-8" aria-hidden="true" tabindex="-1"></a><span class="ot">writeVar ::</span> <span class="dt">Var</span> s <span class="ot">-&gt;</span> v <span class="ot">-&gt;</span> <span class="dt">State</span> (<span class="dt">Memory</span> s v) ()</span>
<span id="cb49-9"><a href="#cb49-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-10"><a href="#cb49-10" aria-hidden="true" tabindex="-1"></a><span class="ot">runWithMemory ::</span> (<span class="kw">forall</span> s<span class="op">.</span> <span class="dt">State</span> (<span class="dt">Memory</span> s v) a) <span class="ot">-&gt;</span> a</span>
<span id="cb49-11"><a href="#cb49-11" aria-hidden="true" tabindex="-1"></a>runWithMemory <span class="ot">=</span> (<span class="ot">`evalState`</span> <span class="dt">Memory</span> IM.empty)</span></code></pre></div>
<p>Here, a <code>Var s</code> must come from a memory bank <code>Memory s v</code> with the <em>same</em> <code>s</code>. It is associated with that region, and no others. The <code>forall</code> here ensures that the action being given cannot unify with any external <code>s</code>: it <em>must</em> be treated as fresh from <code>runWithMemory</code>.</p>
<p>Right off the bat, this prevents passing variables into nested calls (the first var’s <code>s</code> is different than the inner memory bank’s <code>s</code>), but this also prevents variables from leaking. That’s because the result type <code>a</code> must be fully <em>independent</em> of the <code>s</code>, so returning a <code>Var s</code> is illegal, since that would require the <code>a</code> to depend on <code>s</code>, which escapes the scope of the <code>forall</code>. (This is exactly how the <code>ST</code> monad works in GHC standard libraries, actually.)</p>
<p>By requiring the <em>caller</em> to give up control of the <code>s</code>, we ensure safety both of the library and of the user-given continuation. Now our memory-safety doesn’t come from carefully tracking variables and their source memory blocks. Instead, it is assured through the universality of the <code>forall</code> and the unconditional properties it enforces.</p>
<h2 id="habits-to-build">Habits to Build</h2>
<p>Let’s look at what it looks like to recognize this principle in practice, and use it in your code. Let’s imagine we have a function that you can use to deploy a new <code>Config</code> in your environment:</p>
<div class="sourceCode" id="cb50"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb50-1"><a href="#cb50-1" aria-hidden="true" tabindex="-1"></a><span class="ot">deployConfig ::</span> <span class="dt">Config</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span></code></pre></div>
<p>But, deployment is a bit expensive. So we want to deduplicate our deploys: deploying the same <code>Config</code> twice would be a no-op. We can do this by keeping a <code>Config</code> in an <code>IORef</code>:</p>
<div class="sourceCode" id="cb51"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb51-1"><a href="#cb51-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- | returns True if changed, otherwise False if already deployed</span></span>
<span id="cb51-2"><a href="#cb51-2" aria-hidden="true" tabindex="-1"></a><span class="ot">updateConfig ::</span> <span class="dt">IORef</span> <span class="dt">Config</span> <span class="ot">-&gt;</span> <span class="dt">Config</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">Bool</span></span>
<span id="cb51-3"><a href="#cb51-3" aria-hidden="true" tabindex="-1"></a>updateConfig cache newConfig <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb51-4"><a href="#cb51-4" aria-hidden="true" tabindex="-1"></a>    oldConfig <span class="ot">&lt;-</span> readIORef cache</span>
<span id="cb51-5"><a href="#cb51-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span> oldConfig <span class="op">==</span> newConfig</span>
<span id="cb51-6"><a href="#cb51-6" aria-hidden="true" tabindex="-1"></a>        <span class="kw">then</span> <span class="fu">pure</span> <span class="dt">False</span></span>
<span id="cb51-7"><a href="#cb51-7" aria-hidden="true" tabindex="-1"></a>        <span class="kw">else</span> <span class="kw">do</span></span>
<span id="cb51-8"><a href="#cb51-8" aria-hidden="true" tabindex="-1"></a>            deployConfig newConfig</span>
<span id="cb51-9"><a href="#cb51-9" aria-hidden="true" tabindex="-1"></a>            writeIORef cache newConfig</span>
<span id="cb51-10"><a href="#cb51-10" aria-hidden="true" tabindex="-1"></a>            <span class="fu">pure</span> <span class="dt">True</span></span></code></pre></div>
<p>This <em>works</em>, but after learning about the principles in this post, that type signature should feel a little bit suspicious to you. Note that our function never actually <em>inspects</em> the <code>Config</code> at all. The logic is independent. Would there be any value in pulling out the caching logic generically?</p>
<div class="sourceCode" id="cb52"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb52-1"><a href="#cb52-1" aria-hidden="true" tabindex="-1"></a><span class="ot">cachedUpdate ::</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">IO</span> ()) <span class="ot">-&gt;</span> <span class="dt">IORef</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">Bool</span></span>
<span id="cb52-2"><a href="#cb52-2" aria-hidden="true" tabindex="-1"></a>cachedUpdate action cache newVal <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb52-3"><a href="#cb52-3" aria-hidden="true" tabindex="-1"></a>    oldVal <span class="ot">&lt;-</span> readIORef cache</span>
<span id="cb52-4"><a href="#cb52-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span> oldVal <span class="op">==</span> newVal</span>
<span id="cb52-5"><a href="#cb52-5" aria-hidden="true" tabindex="-1"></a>        <span class="kw">then</span> <span class="fu">pure</span> <span class="dt">False</span></span>
<span id="cb52-6"><a href="#cb52-6" aria-hidden="true" tabindex="-1"></a>        <span class="kw">else</span> <span class="kw">do</span></span>
<span id="cb52-7"><a href="#cb52-7" aria-hidden="true" tabindex="-1"></a>            action newVal</span>
<span id="cb52-8"><a href="#cb52-8" aria-hidden="true" tabindex="-1"></a>            writeIORef cache newVal</span>
<span id="cb52-9"><a href="#cb52-9" aria-hidden="true" tabindex="-1"></a>            <span class="fu">pure</span> <span class="dt">True</span></span>
<span id="cb52-10"><a href="#cb52-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb52-11"><a href="#cb52-11" aria-hidden="true" tabindex="-1"></a><span class="ot">updateConfig ::</span> <span class="dt">IORef</span> <span class="dt">Config</span> <span class="ot">-&gt;</span> <span class="dt">Config</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">Bool</span></span>
<span id="cb52-12"><a href="#cb52-12" aria-hidden="true" tabindex="-1"></a>updateConfig <span class="ot">=</span> cachedUpdate deployConfig</span></code></pre></div>
<p>Let’s presume that we never intend to reuse <code>cachedUpdate</code>. So, we just increased our total lines of code…and for what? What does <code>cachedUpdate</code> get us?</p>
<p>Firstly, in the original monomorphic <code>updateConfig</code>, written directly against <code>Config</code>, there is so much that could go wrong. Maybe you could mis-handle the configuration or accidentally modify it. You could set certain fields to fixed values. You might end up deploying a configuration that was never passed in directly.</p>
<p>In our <code>cachedUpdate</code> implementation, we are <em>sure</em> that any <code>Config</code> deployed will <em>only</em> come <em>directly</em> from calls to <code>updateConfig</code>. No other operations are possible.</p>
<p>Secondly, the type signature of <code>cachedUpdate</code> tells us a lot more about what <code>cachedUpdate</code>’s intended logic is and what exactly it can support. Let’s say in the future, a new requirement comes: Deploy a “default” configuration if <code>deployConfig</code> ever fails.</p>
<p>You <em>want</em> something as drastic as this to require you to change your types and your contracts. In fact, if a new requirement comes along and you are able to implement it without changing your types, that should be extremely scary to you, because you previously allowed way too many potentially invalid programs to compile.</p>
<p>If we were to add such a change (“deploy a default <code>Config</code>”), it <em>should</em> have us go back to the type signature of <code>cachedUpdate</code> and see how it must change in order for us to support it. That process of interrogation makes us think about what we actually want to do and how it would fundamentally change our data flow.</p>
<p>If you subscribe to <a href="https://en.wikipedia.org/wiki/SOLID">“SOLID” programming</a>, this should all remind you of “Dependency Inversion”.</p>
<p>Basically: treat all monomorphic code with suspicion. It may be a symptom of you trying to hold on to more control, when you should be letting go.</p>
<h2 id="embracing-unconditional-election">Embracing Unconditional Election</h2>
<p>What sort of control are you trying to hang on to in life, in a way that puts you in your own prison?</p>
<p>To me, the fact that making code more polymorphic and giving up information is valuable not just for abstraction, but for taking advantage of universal properties, was a surprising one. But ever since I started writing Haskell, it’s a fact that I take advantage of every day. So, next time you see the opportunity, try thinking about what that parametric <code>forall</code> can do for you. Take advantage of the doctrine of Haskell predestination that arrives from properties of logic determined before our universe ever existed.</p>
<h3 id="the-next-step">The Next Step</h3>
<p>Embracing Total Depravity and Unconditional Election should redefine your relationship with your code. But not all code lives in the nice pure world where we can cordon off effects. <code>forall a. [a] -&gt; [a]</code> is very different than <code>forall a. [a] -&gt; IO [a]</code>, after all.</p>
<p>To extend these boundaries to useful code, we have to deal with that boundary between the world of the pure and the world where <a href="https://xkcd.com/1312/">things actually happen for real</a>. We’ll explore the nuances of that boundary in the next chapter of <a href="https://blog.jle.im/entries/series/+five-point-haskell.html">Five-Point Haskell</a>, <strong>Limited Atonement</strong>.</p>
<h2 id="special-thanks">Special Thanks</h2>
<p>I am very humbled to be supported by an amazing community, who make it possible for me to devote time to researching and writing these posts. Very special thanks to my supporter at the “Amazing” level on <a href="https://www.patreon.com/justinle/overview">patreon</a>, Josh Vera! :)</p>
<section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes">
<hr />
<ol>
<li id="fn1"><p>Excluding <code>unsafePerformIO</code>, <code>unsafeCoerce</code>, etc.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p>If you disallow <code>repeat</code>, <code>forall a. a -&gt; [a]</code> is actually isomorphic to the natural numbers!<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3"><p>It’s <code>forall a. [a] -&gt; Const Int a</code>!<a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section></div><footer><hr><div class="copy-content"><p>Hi, thanks for reading! You can reach me via email at <a href="mailto:justin@jle.im" class="email">justin@jle.im</a>, or at twitter at <a href="https://twitter.com/mstk">@mstk</a>! This post and all others are published under the <a href="https://creativecommons.org/licenses/by-nc-nd/3.0/">CC-BY-NC-ND 3.0</a> license. Corrections and edits via pull request are welcome and encouraged at <a href="https://github.com/mstksg/inCode">the source repository</a>.</p>
<p>If you feel inclined, or this post was particularly helpful for you, why not consider <a href="https://www.patreon.com/justinle/overview">supporting me on Patreon</a>, or a <a href="bitcoin:3D7rmAYgbDnp4gp4rf22THsGt74fNucPDU">BTC donation</a>? :)</p></div><div class="clear"></div><ul class="entry-series"><li><div>This entry is a part of a series called <b>&quot;Five-Point Haskell&quot;</b>.  Find the rest of the entries in this series at its <a href="https://blog.jle.im/entries/series/+five-point-haskell.html" class="tag-a-series" title="+Five-Point Haskell"> series history</a>.</div></li></ul><ul class="tag-list"><li><a href="https://blog.jle.im/entries/tagged/functional-programming.html" class="tag-a-tag">#functional programming</a></li><li><a href="https://blog.jle.im/entries/category/@haskell.html" class="tag-a-category">@HASKELL</a></li><li><a href="https://blog.jle.im/entries/series/+five-point-haskell.html" class="tag-a-series">+Five-Point Haskell</a></li></ul><aside class="social-buttons"><div class="addthis_toolbox addthis_default_style addthis-buttons"><a class="addthis_button_facebook_like" fb:like:layout="button_count"></a><a class="addthis_button_tweet"></a><a class="addthis_button_google_plusone" g:plusone:size="medium"></a><a class="addthis_counter addthis_pill_style"></a></div><div class="custom-social-buttons"><div class="custom-social-button"><a href="https://www.reddit.com/submit" onclick="window.location = &#39;https://www.reddit.com/submit?url=&#39;+ encodeURIComponent(window.location); return false"><img src="https://www.reddit.com/static/spreddit7.gif" alt="submit to reddit"></a></div></div></aside><nav class="next-prev-links"><ul><li class="next-entry-link">(Next) <a href="https://blog.jle.im/entry/introducing-in-code.html">Introducing &quot;in Code&quot;!</a> &rarr;</li></ul></nav></footer></article><div class="post-entry"><div class="tile"><div id="disqus_thread"></div><script type="text/javascript">var disqus_config = function () {
    this.page.url = 'https://blog.jle.im/entry/five-point-haskell-part-2-unconditional-election.html';
    this.page.identifier = 'five-point-haskell-2';
};
(function() {
    var d = document, s = d.createElement('script');
    s.src = '//incode.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
})();
</script><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a><br></noscript><a href="http://disqus.com" class="dsq-brlink">Comments powered by <span class="logo-disqus">Disqus</span></a></div></div></div></div></div><div id="footer-container"><div id="footer-content"><div class="tile"><div class="footer-copyright">&copy; 2020 Justin Le <span class="license-link">(<a href="https://creativecommons.org/licenses/by-nc-nd/3.0/" class="license">CC-BY-NC-ND 3.0</a>)</span></div><div class="footer-follow social-follows"><ul class="social-follows-list"><li><ul class="social-follows-list-social"><li><a class="social-follow-twitter" title="Follow me on Twitter!" href="https://twitter.com/intent/user?user_id=mstk" onclick="window.open(
  &#39;http://twitter.com/intent/user?user_id=907281&#39;,
  &#39;facebook-share-dialog&#39;,
  &#39;width=550,height=520&#39;);
return false;
">Twitter</a></li><li><a class="social-follow-github" title="Fork me on Github!" href="https://github.com/mstksg">Github</a></li><li><a class="social-follow-twitch" title="Watch me on Twitch!" href="https://www.twitch.tv/justin_l">Twitch</a></li><li><a class="social-follow-patreon" title="Support me on Patreon!" href="https://www.patreon.com/justinle/overview">Patreon</a></li><li><a class="social-follow-gplus" title="Add me on Google+!" href="https://plus.google.com/+JustinLe">Google+</a></li><li><a class="social-follow-keybase" title="Track me on Keybase!" href="https://keybase.io/mstksg">Keybase</a></li><li><a class="social-follow-linkedin" title="Connect with me on LinkedIn!" href="https://linkedin.com/in/lejustin">LinkedIn</a></li><li><a class="social-follow-bitcoin" title="Donate via bitcoin!" href="bitcoin:3D7rmAYgbDnp4gp4rf22THsGt74fNucPDU">Bitcoin</a></li></ul></li><li><ul class="social-follows-list-site"><li><a class="social-follow-rss" title="Subscribe to my RSS Feed!" href="http://feeds.feedburner.com/incodeblog">RSS</a></li><li><a class="social-follow-email" title="Subscribe to the mailing list!" href="https://feedburner.google.com/fb/a/mailverify?loc=en_US&amp;uri=incodeblog">Mailing list</a></li></ul></li></ul></div></div></div></div></body></html>