<!DOCTYPE HTML>
<html><head><title>Practical Dependent Types: A Deeper Look at Proofs · in Code</title><meta name="description" content="Weblog of Justin Le, covering various adventures in programming and explorations in the worlds of computation physics, and knowledge.
"><meta http-equiv="Content-Type" content="text/html;charset=utf-8"><meta name="viewport" content="width=device-width,initial-scale=1.0"><meta name="flattr:id" content="3p9jqr"><meta property="og:site_name" content="in Code"><meta property="og:description" content="Hi! This will be the final post of the dependently typed neural network series. This post has been long put-off because there really wasn’t too much more we can learn about dependent types and programming with dependent types from this example. Still, this example still has a bit more to offer us, so let’s take one last look :) Think of this post as an epilogue. In Part 1, we tried solving our problem in an “untyped” way, recognized all of those Haskell red flags, and then added types to make things safer and reap benefits in API clarity, compiler support, and a smoother code writing experience. In Part 2, we looked at how integrating our typed programs with the real world, where types might vary at runtime, by levering existential types in two different forms."><meta property="og:type" content="article"><meta property="og:title" content="Practical Dependent Types: A Deeper Look at Proofs"><meta property="og:image" content="https://blog.jle.im/img/site_logo.jpg"><meta property="og:locale" content="en_US"><meta property="og:url" content="https://blog.jle.im/entry/practical-dependent-types-in-haskell-3.html"><meta name="twitter:card" content="summary"><meta name="twitter:creator:id" content="mstk"><link rel="author" href="https://plus.google.com/107705320197444500140"><link rel="alternate" type="application/rss+xml" title="in Code (RSS Feed)" href="http://feeds.feedburner.com/incodeblog"><link rel="canonical" href="https://blog.jle.im/entry/practical-dependent-types-in-haskell-3.html"><link href="https://blog.jle.im/favicon.ico" rel="shortcut icon"><link href="https://blog.jle.im/css/toast.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/font.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/main.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/page/entry.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/pygments.css" rel="stylesheet" type="text/css"><script type="text/javascript">var page_data = {};
var disqus_shortname='incode';
</script><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-443711-8', 'jle.im');
ga('send', 'pageview');
</script><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script id="MathJax-script" async="" src="https://cdn.jsdelivr.net/npm/mathjax@3.0.1/es5/tex-mml-chtml.js"></script><script type="text/javascript" src="//ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script><script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5234d67a6b68dcd4"></script><script type="text/javascript" src="https://blog.jle.im/js/page/entry_toc.js"></script><script type="text/javascript" src="https://blog.jle.im/js/disqus_count.js"></script><script type="text/javascript" src="https://blog.jle.im/js/social.js"></script><script type="text/javascript" src="https://blog.jle.im/js/jquery/jquery.toc.js"></script><script type="text/javascript" src="https://blog.jle.im/purescript/entry.js"></script></head><body><div id="fb-root"><script>(function(d, s, id) {
 var js, fjs = d.getElementsByTagName(s)[0];
 if (d.getElementById(id)) return;
 js = d.createElement(s); js.id = id;
 js.src = "//connect.facebook.net/en_US/all.js#xfbml=1&appId=641852699171929";
 fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));
</script></div><div id="header-container"><div id="navbar-container" class="tile"><nav id="navbar-content"><div class="nav-info"><h1 class="site-title"><a href="https://blog.jle.im/" class="nav-title">in Code</a></h1><span class="nav-author">Justin Le</span></div><ul class="nav-links"><li><a href="https://blog.jle.im/">home</a></li><li><a href="https://blog.jle.im/entries.html">archives</a></li><li><a href="https://cv.jle.im">cv</a></li><div class="clear"></div></ul></nav></div><div id="header-content"></div></div><div id="body-container" class="container"><div id="main-container" class="grid"><div class="entry-section unit span-grid" role="main"><article class="tile article"><header><div class="unposted-banner">Unposted entry</div><h1 id="title">Practical Dependent Types: A Deeper Look at Proofs</h1><p class="entry-info">by <a class="author" href="https://blog.jle.im/">Justin Le</a></p><p><span class="source-info"><a class="source-link" href="https://github.com/mstksg/inCode/tree/master/copy/entries/dependent-haskell-3.md">Source</a><span class="info-separator"> &diams; </span><a class="source-link" href="https://github.com/mstksg/inCode/tree/gh-pages/entry/practical-dependent-types-in-haskell-3.md">Markdown</a><span class="info-separator"> &diams; </span><a class="source-link" href="https://blog.jle.im/entry/practical-dependent-types-in-haskell-3.tex">LaTeX</a><span class="info-separator"> &diams; </span></span>Posted in <a href="https://blog.jle.im/entries/category/@haskell.html" class="tag-a-category" title="Functional, pure, non-strict, statically and strongly typed, natively
compiled...really just the king of great languages.
">Haskell</a>, <a href="https://blog.jle.im/entries/category/@ramblings.html" class="tag-a-category" title="My slight ramblings on subjects of interest (to me and hopefully to you too!).
Lots of surveys and introducts to new subjects.
">Ramblings</a><span class="info-separator"> &diams; </span><a class="comment-link" href="#disqus_thread">Comments</a></p></header><hr><aside class="contents-container"><h5 id="contents-header">Contents</h5><div id="toc"></div></aside><div class="main-content copy-content"><p>Hi! This will be the final post of the <a href="https://blog.jle.im/entries/series/+practical-dependent-types-in-haskell.html">dependently typed neural network series</a>. This post has been long put-off because there really wasn’t <em>too</em> much more we can learn about dependent types and programming with dependent types from this example. Still, this example still has a bit more to offer us, so let’s take one last look :) Think of this post as an epilogue.</p>
<p>In <a href="https://blog.jle.im/entry/practical-dependent-types-in-haskell-1.html">Part 1</a>, we tried solving our problem in an “untyped” way, recognized all of those Haskell red flags, and then added types to make things safer and reap benefits in API clarity, compiler support, and a smoother code writing experience. In <a href="https://blog.jle.im/entry/practical-dependent-types-in-haskell-2.html">Part 2</a>, we looked at how integrating our typed programs with the real world, where types might vary at runtime, by levering existential types in two different forms.</p>
<h2 id="the-secret-life-of-proofs">The Secret Life of Proofs</h2>
<p>So far in this journey, we’ve hand-waved the idea of “proofs”, and their role in this dependently typed programming. In fact, I’ve sort of intentionally left the idea vague, because I feel like a lot of other dependent type introductions/tutorials over-emphasize proofs, to the point there is a public impression that <a href="https://www.reddit.com/r/haskell/comments/62uv6g/verify_your_typeclass_instances_in_haskell_today/dfpt2g7/">dependently typed programming is all about proofs</a>:</p>
<blockquote>
<p>I think dependent types are pretty cool, but honestly the sheer difficulty jump from quickcheck tests to actual proofs to me seems a bit too massive to justify having to deal with them much.</p>
<p>I think if we just had testable functions (basically just predicates that should always return true) alongside classes that could be quickchecked against. And actually took it very seriously when an instance isn’t lawful (basically just disallow it almost always), then I think we would be in a pretty darn good spot.</p>
</blockquote>
<p>There’s a popular (mis?)conception that dependent types are basically a replacement for QuickCheck, or refinement types (like Liquid Haskell). But really, as we have seen, they are much more — they let you leverage the compiler to help you write your code, help you enforce properties at the structural level for your types, create more expressive API’s, and much more. They aren’t “just” to prove properties about your program.</p>
<p>In reality, the idea of dependent types and the idea of proofs sort of are separate but complementing ideas. Dependent types enable this “proofy” style discussed in the comment, but, also, the ability to dynamically construct and manipulate proofs opens up many doors for the capabilities of dependently typed programs.</p>
<h3 id="what-are-they">What are they?</h3>
<p>In the context of dependent types (in Haskell), a “proof” is general (non-rigorous, informal) term for a <em>runtime value</em> that GHC/Haskell can use for <em>type-level</em> shenanigans. In other words, it’s a <em>term-level</em> witness for a <em>type-level</em> truth.</p>
<p>It’s the critical <em>run-time</em> values that we use to power our <em>type-level</em> fun, and are also commonly known as “witnesses”.</p>
<p>I don’t believe there is any rigorous definition, but the term comes up whenever we talk about generating or using run-time values that give us type-level power.</p>
<p>In this article, the simplest example of something that can be called a proof or a witness is the singleton for <code>Nat</code>s: A value of type <code>Sing n</code> (for <code>Nat n</code>) “witnesses” a <code>KnownNat n</code> constraint.</p>
<p>We saw it earlier when we wanted to pass along evidence that our <code>n</code> has an instance of <code>KnownNat</code>:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="ot">nIsKnownNatWePromise ::</span> <span class="kw">forall</span> n<span class="op">.</span> <span class="dt">Sing</span> n <span class="ot">-&gt;</span> <span class="dt">Integer</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>nIsKnonwNatWePromise <span class="ot">=</span> \<span class="kw">case</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">SNat</span> <span class="ot">-&gt;</span> natVal (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> n)</span></code></pre></div>
<p>In the case statement above, in the <code>SNat -&gt;</code> branch, GHC knows that <code>n</code> has a <code>KnownNat</code> instance. This runtime value, <code>SNat</code>, carries the fact that we have an instance of <code>KnownNat n</code>. Remember that <code>natVal :: KnownNat n =&gt; p n -&gt; Integer</code> – it only works of <code>n</code> is an instance of <code>KnownNat</code>. <code>SNat :: Sing n</code> is a runtime value that “gives us” that instance. It’s a “proof” that <code>n</code> is an instance of <code>KnownNat</code>.</p>
<h3 id="first-class-values">First-Class Values</h3>
<p>The <em>key</em> to their usefulness is that, as runtime values, they are <em>first-class values</em> in Haskell. We can manipulate them, pass them, construct them, etc., just as if they were normal values. You can construct complex proofs from simple ones, compose them, etc.</p>
<p>For example, check out the function <code>%:+</code> from the <em>singletons</em> package:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="ot">(%:+) ::</span> <span class="kw">forall</span> (<span class="ot">n ::</span> <span class="dt">Nat</span>) (<span class="ot">m ::</span> <span class="dt">Nat</span>)<span class="op">.</span> <span class="dt">Sing</span> n <span class="ot">-&gt;</span> <span class="dt">Sing</span> m <span class="ot">-&gt;</span> <span class="dt">Sing</span> (n <span class="op">+</span> m)</span></code></pre></div>
<p>Given, at runtime, a witness for <code>KnownNat n</code> (our <code>Sing n</code>) and a witness for <code>KnownNat m</code>, we can construct, at runtime a witness for <code>KnownNat (n + m)</code>:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="ot">add ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>add x y <span class="ot">=</span> withSomeSing x <span class="op">$</span> \(<span class="ot">sx ::</span> <span class="dt">Sing</span> x) <span class="ot">-&gt;</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>          withSomeSing y <span class="op">$</span> \(<span class="ot">sy ::</span> <span class="dt">Sing</span> y) <span class="ot">-&gt;</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>            <span class="kw">case</span> sx <span class="op">%:+</span> sy <span class="kw">of</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>              <span class="co">-- z is x + y</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>              (<span class="dt">SNat</span><span class="ot"> ::</span> <span class="dt">Sing</span> z) <span class="ot">-&gt;</span> natVal (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> z)</span></code></pre></div>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> add <span class="dv">5</span> <span class="dv">7</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="dv">12</span></span></code></pre></div></div><footer><hr><div class="copy-content"><p>Hi, thanks for reading! You can reach me via email at <a href="mailto:justin@jle.im" class="email">justin@jle.im</a>, or at twitter at <a href="https://twitter.com/mstk">@mstk</a>! This post and all others are published under the <a href="https://creativecommons.org/licenses/by-nc-nd/3.0/">CC-BY-NC-ND 3.0</a> license. Corrections and edits via pull request are welcome and encouraged at <a href="https://github.com/mstksg/inCode">the source repository</a>.</p>
<p>If you feel inclined, or this post was particularly helpful for you, why not consider <a href="https://www.patreon.com/justinle/overview">supporting me on Patreon</a>, or a <a href="bitcoin:3D7rmAYgbDnp4gp4rf22THsGt74fNucPDU">BTC donation</a>? :)</p></div><div class="clear"></div><ul class="entry-series"><li><div>This entry is a part of a series called <b>&quot;Practical Dependent Types in Haskell&quot;</b>.  Find the rest of the entries in this series at its <a href="https://blog.jle.im/entries/series/+practical-dependent-types-in-haskell.html" class="tag-a-series" title="+Practical Dependent Types in Haskell"> series history</a>.</div></li></ul><ul class="tag-list"><li><a href="https://blog.jle.im/entries/tagged/artificial-neural-networks.html" class="tag-a-tag">#artificial neural networks</a></li><li><a href="https://blog.jle.im/entries/tagged/dependent-types.html" class="tag-a-tag">#dependent types</a></li><li><a href="https://blog.jle.im/entries/tagged/existential-types.html" class="tag-a-tag">#existential types</a></li><li><a href="https://blog.jle.im/entries/tagged/functional-programming.html" class="tag-a-tag">#functional programming</a></li><li><a href="https://blog.jle.im/entries/tagged/haskell.html" class="tag-a-tag">#haskell</a></li><li><a href="https://blog.jle.im/entries/tagged/linear-algebra.html" class="tag-a-tag">#linear algebra</a></li><li><a href="https://blog.jle.im/entries/tagged/machine-learning.html" class="tag-a-tag">#machine learning</a></li><li><a href="https://blog.jle.im/entries/tagged/numerical.html" class="tag-a-tag">#numerical</a></li><li><a href="https://blog.jle.im/entries/tagged/singletons.html" class="tag-a-tag">#singletons</a></li><li><a href="https://blog.jle.im/entries/tagged/types.html" class="tag-a-tag">#types</a></li><li><a href="https://blog.jle.im/entries/category/@haskell.html" class="tag-a-category">@HASKELL</a></li><li><a href="https://blog.jle.im/entries/category/@ramblings.html" class="tag-a-category">@RAMBLINGS</a></li><li><a href="https://blog.jle.im/entries/series/+practical-dependent-types-in-haskell.html" class="tag-a-series">+Practical Dependent Types in Haskell</a></li></ul><aside class="social-buttons"><div class="addthis_toolbox addthis_default_style addthis-buttons"><a class="addthis_button_facebook_like" fb:like:layout="button_count"></a><a class="addthis_button_tweet"></a><a class="addthis_button_google_plusone" g:plusone:size="medium"></a><a class="addthis_counter addthis_pill_style"></a></div><div class="custom-social-buttons"><div class="custom-social-button"><a href="https://www.reddit.com/submit" onclick="window.location = &#39;https://www.reddit.com/submit?url=&#39;+ encodeURIComponent(window.location); return false"><img src="https://www.reddit.com/static/spreddit7.gif" alt="submit to reddit"></a></div></div></aside><nav class="next-prev-links"><ul><li class="next-entry-link">(Next) <a href="https://blog.jle.im/entry/introducing-in-code.html">Introducing &quot;in Code&quot;!</a> &rarr;</li></ul></nav></footer></article><div class="post-entry"><div class="tile"><div id="disqus_thread"></div><script type="text/javascript">var disqus_config = function () {
    this.page.url = 'https://blog.jle.im/entry/practical-dependent-types-in-haskell-3.html';
    this.page.identifier = 'dependent-haskell-3';
};
(function() {
    var d = document, s = d.createElement('script');
    s.src = '//incode.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
})();
</script><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a><br></noscript><a href="http://disqus.com" class="dsq-brlink">Comments powered by <span class="logo-disqus">Disqus</span></a></div></div></div></div></div><div id="footer-container"><div id="footer-content"><div class="tile"><div class="footer-copyright">&copy; 2020 Justin Le <span class="license-link">(<a href="https://creativecommons.org/licenses/by-nc-nd/3.0/" class="license">CC-BY-NC-ND 3.0</a>)</span></div><div class="footer-follow social-follows"><ul class="social-follows-list"><li><ul class="social-follows-list-social"><li><a class="social-follow-twitter" title="Follow me on Twitter!" href="https://twitter.com/intent/user?user_id=mstk" onclick="window.open(
  &#39;http://twitter.com/intent/user?user_id=907281&#39;,
  &#39;facebook-share-dialog&#39;,
  &#39;width=550,height=520&#39;);
return false;
">Twitter</a></li><li><a class="social-follow-github" title="Fork me on Github!" href="https://github.com/mstksg">Github</a></li><li><a class="social-follow-twitch" title="Watch me on Twitch!" href="https://www.twitch.tv/justin_l">Twitch</a></li><li><a class="social-follow-patreon" title="Support me on Patreon!" href="https://www.patreon.com/justinle/overview">Patreon</a></li><li><a class="social-follow-gplus" title="Add me on Google+!" href="https://plus.google.com/+JustinLe">Google+</a></li><li><a class="social-follow-keybase" title="Track me on Keybase!" href="https://keybase.io/mstksg">Keybase</a></li><li><a class="social-follow-linkedin" title="Connect with me on LinkedIn!" href="https://linkedin.com/in/lejustin">LinkedIn</a></li><li><a class="social-follow-bitcoin" title="Donate via bitcoin!" href="bitcoin:3D7rmAYgbDnp4gp4rf22THsGt74fNucPDU">Bitcoin</a></li></ul></li><li><ul class="social-follows-list-site"><li><a class="social-follow-rss" title="Subscribe to my RSS Feed!" href="http://feeds.feedburner.com/incodeblog">RSS</a></li><li><a class="social-follow-email" title="Subscribe to the mailing list!" href="https://feedburner.google.com/fb/a/mailverify?loc=en_US&amp;uri=incodeblog">Mailing list</a></li></ul></li></ul></div></div></div></div></body></html>