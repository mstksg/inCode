\documentclass[]{article}
\usepackage{lmodern}
\usepackage{amssymb,amsmath}
\usepackage{ifxetex,ifluatex}
\usepackage{fixltx2e} % provides \textsubscript
\ifnum 0\ifxetex 1\fi\ifluatex 1\fi=0 % if pdftex
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
\else % if luatex or xelatex
  \ifxetex
    \usepackage{mathspec}
    \usepackage{xltxtra,xunicode}
  \else
    \usepackage{fontspec}
  \fi
  \defaultfontfeatures{Mapping=tex-text,Scale=MatchLowercase}
  \newcommand{\euro}{€}
\fi
% use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
% use microtype if available
\IfFileExists{microtype.sty}{\usepackage{microtype}}{}
\usepackage[margin=1in]{geometry}
\usepackage{color}
\usepackage{fancyvrb}
\newcommand{\VerbBar}{|}
\newcommand{\VERB}{\Verb[commandchars=\\\{\}]}
\DefineVerbatimEnvironment{Highlighting}{Verbatim}{commandchars=\\\{\}}
% Add ',fontsize=\small' for more characters per line
\newenvironment{Shaded}{}{}
\newcommand{\AlertTok}[1]{\textcolor[rgb]{1.00,0.00,0.00}{\textbf{#1}}}
\newcommand{\AnnotationTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{#1}}}}
\newcommand{\AttributeTok}[1]{\textcolor[rgb]{0.49,0.56,0.16}{#1}}
\newcommand{\BaseNTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{#1}}
\newcommand{\BuiltInTok}[1]{\textcolor[rgb]{0.00,0.50,0.00}{#1}}
\newcommand{\CharTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand{\CommentTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textit{#1}}}
\newcommand{\CommentVarTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{#1}}}}
\newcommand{\ConstantTok}[1]{\textcolor[rgb]{0.53,0.00,0.00}{#1}}
\newcommand{\ControlFlowTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{#1}}}
\newcommand{\DataTypeTok}[1]{\textcolor[rgb]{0.56,0.13,0.00}{#1}}
\newcommand{\DecValTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{#1}}
\newcommand{\DocumentationTok}[1]{\textcolor[rgb]{0.73,0.13,0.13}{\textit{#1}}}
\newcommand{\ErrorTok}[1]{\textcolor[rgb]{1.00,0.00,0.00}{\textbf{#1}}}
\newcommand{\ExtensionTok}[1]{#1}
\newcommand{\FloatTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{#1}}
\newcommand{\FunctionTok}[1]{\textcolor[rgb]{0.02,0.16,0.49}{#1}}
\newcommand{\ImportTok}[1]{\textcolor[rgb]{0.00,0.50,0.00}{\textbf{#1}}}
\newcommand{\InformationTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{#1}}}}
\newcommand{\KeywordTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{#1}}}
\newcommand{\NormalTok}[1]{#1}
\newcommand{\OperatorTok}[1]{\textcolor[rgb]{0.40,0.40,0.40}{#1}}
\newcommand{\OtherTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{#1}}
\newcommand{\PreprocessorTok}[1]{\textcolor[rgb]{0.74,0.48,0.00}{#1}}
\newcommand{\RegionMarkerTok}[1]{#1}
\newcommand{\SpecialCharTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand{\SpecialStringTok}[1]{\textcolor[rgb]{0.73,0.40,0.53}{#1}}
\newcommand{\StringTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand{\VariableTok}[1]{\textcolor[rgb]{0.10,0.09,0.49}{#1}}
\newcommand{\VerbatimStringTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand{\WarningTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{#1}}}}
\ifxetex
  \usepackage[setpagesize=false, % page size defined by xetex
              unicode=false, % unicode breaks when used with xetex
              xetex]{hyperref}
\else
  \usepackage[unicode=true]{hyperref}
\fi
\hypersetup{breaklinks=true,
            bookmarks=true,
            pdfauthor={Justin Le},
            pdftitle={Seven Levels of Type Safety in Haskell: Lists},
            colorlinks=true,
            citecolor=blue,
            urlcolor=blue,
            linkcolor=magenta,
            pdfborder={0 0 0}}
\urlstyle{same}  % don't use monospace font for urls
% Make links footnotes instead of hotlinks:
\renewcommand{\href}[2]{#2\footnote{\url{#1}}}
\setlength{\parindent}{0pt}
\setlength{\parskip}{6pt plus 2pt minus 1pt}
\setlength{\emergencystretch}{3em}  % prevent overfull lines
\setcounter{secnumdepth}{0}

\title{Seven Levels of Type Safety in Haskell: Lists}
\author{Justin Le}
\date{September 4, 2024}

\begin{document}
\maketitle

\emph{Originally posted on
\textbf{\href{https://blog.jle.im/entry/levels-of-type-safety-haskell-lists.html}{in
Code}}.}

\documentclass[]{}
\usepackage{lmodern}
\usepackage{amssymb,amsmath}
\usepackage{ifxetex,ifluatex}
\usepackage{fixltx2e} % provides \textsubscript
\ifnum 0\ifxetex 1\fi\ifluatex 1\fi=0 % if pdftex
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
\else % if luatex or xelatex
  \ifxetex
    \usepackage{mathspec}
    \usepackage{xltxtra,xunicode}
  \else
    \usepackage{fontspec}
  \fi
  \defaultfontfeatures{Mapping=tex-text,Scale=MatchLowercase}
  \newcommand{\euro}{€}
\fi
% use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
% use microtype if available
\IfFileExists{microtype.sty}{\usepackage{microtype}}{}
\usepackage[margin=1in]{geometry}
\ifxetex
  \usepackage[setpagesize=false, % page size defined by xetex
              unicode=false, % unicode breaks when used with xetex
              xetex]{hyperref}
\else
  \usepackage[unicode=true]{hyperref}
\fi
\hypersetup{breaklinks=true,
            bookmarks=true,
            pdfauthor={},
            pdftitle={},
            colorlinks=true,
            citecolor=blue,
            urlcolor=blue,
            linkcolor=magenta,
            pdfborder={0 0 0}}
\urlstyle{same}  % don't use monospace font for urls
% Make links footnotes instead of hotlinks:
\renewcommand{\href}[2]{#2\footnote{\url{#1}}}
\setlength{\parindent}{0pt}
\setlength{\parskip}{6pt plus 2pt minus 1pt}
\setlength{\emergencystretch}{3em}  % prevent overfull lines
\setcounter{secnumdepth}{0}

\textbackslash begin\{document\}

One thing I always appreciate about Haskell is that you can often choose the
level of type-safety you want to work at. Haskell offers tools to be able to
work at \emph{both} extremes, whereas most languages only offer some limited
part of the spectrum. Picking the right level often comes down to being
consciously aware of the benefits/drawbacks/unique advantages to each.

So, here is a rundown of seven ``levels'' of type safety that you can operate at
when working with the ubiquitous linked list data type, and how to use them! I
genuinely believe all of these are useful (or useless) in their own different
circumstances, even though the ``extremes'' at both ends are definitely pushing
the limits of the language.

This post is written for an intermediate Haskeller, who is already familiar with
ADTs and defining their own custom list type like
\texttt{data\ List\ a\ =\ Nil\ \textbar{}\ Cons\ a\ (List\ a)}. But, be advised
that \emph{most} of the techniques discussed in this post (especially at both
extremes) are considered esoteric at best and harmful at worst for most actual
real-world applications. The point of this post is more to inspire the
imagination and demonstrate principles that could be useful to apply in actual
code, and \emph{not} to present actual useful data structures.

All of the code here is
\href{https://github.com/mstksg/inCode/tree/master/code-samples/type-levels/flake.nix}{available
online} here, and if you check out the repo and run \texttt{nix\ develop} you
should be able to load them all in ghci as well:

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{$}\NormalTok{ cd code{-}samples/type{-}levels}
\ExtensionTok{$}\NormalTok{ nix develop}
\ExtensionTok{$}\NormalTok{ ghci}
\ExtensionTok{ghci}\OperatorTok{\textgreater{}}\NormalTok{ :load Level1.hs}
\end{Highlighting}
\end{Shaded}

\section{Level 1: Could be anything}\label{level-1-could-be-anything}

\emph{\href{https://github.com/mstksg/inCode/tree/master/code-samples/type-levels/Level1.hs}{Code
available here}}

What's the moooost type-unsafe you can be in Haskell? Well, we can make a
``black hole'' data type that could be anything:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{{-}{-} source: https://github.com/mstksg/inCode/tree/master/code{-}samples/type{-}levels/Level1.hs\#L12{-}L13}

\KeywordTok{data} \DataTypeTok{Any}\OtherTok{ ::} \DataTypeTok{Type} \KeywordTok{where}
  \DataTypeTok{MkAny}\OtherTok{ ::}\NormalTok{ a }\OtherTok{{-}\textgreater{}} \DataTypeTok{Any}
\end{Highlighting}
\end{Shaded}

(This data type declaration written using
\href{https://typeclasses.com/ghc/gadt-syntax}{GADT Syntax}, and the name was
chosen because it resembles
\href{https://hackage.haskell.org/package/bas/docs/GHC-Exts.html\#t:Any}{the Any
type in base})

So you can have values:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{{-}{-} source: https://github.com/mstksg/inCode/tree/master/code{-}samples/type{-}levels/Level1.hs\#L15{-}L22}

\OtherTok{anyInt ::} \DataTypeTok{Any}
\NormalTok{anyInt }\OtherTok{=} \DataTypeTok{MkAny}\NormalTok{ (}\DecValTok{8}\OtherTok{ ::} \DataTypeTok{Int}\NormalTok{)}

\OtherTok{anyBool ::} \DataTypeTok{Any}
\NormalTok{anyBool }\OtherTok{=} \DataTypeTok{MkAny} \DataTypeTok{True}

\OtherTok{anyList ::} \DataTypeTok{Any}
\NormalTok{anyList }\OtherTok{=} \DataTypeTok{MkAny}\NormalTok{ ([}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{]}\OtherTok{ ::}\NormalTok{ [}\DataTypeTok{Int}\NormalTok{])}
\end{Highlighting}
\end{Shaded}

A value of any type can be given to \texttt{MkAny}, and the resulting type will
have type \texttt{Any}.

However, this type is \emph{truly} a black hole; you can't really do anything
with the values inside it because of parametric polymorphism: you must treat any
value inside it in a way that is compatible with a value of \emph{any} type. But
there aren't \emph{too} many useful things you can do with something in a way
that is compatible with a value of any type (things like,
\texttt{id\ ::\ a\ -\textgreater{}\ a},
\texttt{const\ 3\ ::\ a\ -\textgreater{}\ Int}). In the end, it's essentially
isomorphic to unit \texttt{()}.

However, this isn't really how dynamic types work. In other languages, we are at
least able to query and interrogate a type for things we can do with it using
runtime reflection. To get there, we can instead allow some sort of witness on
the type of the value. Here's \texttt{Sigma}, where \texttt{Sigma\ p} is a value
\texttt{a} paired with some witness \texttt{p\ a}:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{{-}{-} source: https://github.com/mstksg/inCode/tree/master/code{-}samples/type{-}levels/Level1.hs\#L24{-}L25}

\KeywordTok{data} \DataTypeTok{Sigma}\OtherTok{ ::}\NormalTok{ (}\DataTypeTok{Type} \OtherTok{{-}\textgreater{}} \DataTypeTok{Type}\NormalTok{) }\OtherTok{{-}\textgreater{}} \DataTypeTok{Type} \KeywordTok{where}
  \DataTypeTok{MkSigma}\OtherTok{ ::}\NormalTok{ p a }\OtherTok{{-}\textgreater{}}\NormalTok{ a }\OtherTok{{-}\textgreater{}} \DataTypeTok{Sigma}\NormalTok{ p}
\end{Highlighting}
\end{Shaded}

And the most classic witness is
\href{https://hackage.haskell.org/package/base/docs/Type-Reflection.html\#t:TypeRep}{\texttt{TypeRep}}
from \emph{base}, which is a witness that lets you ``match'' on the type.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{{-}{-} source: https://github.com/mstksg/inCode/tree/master/code{-}samples/type{-}levels/Level1.hs\#L27{-}L32}

\OtherTok{showIfBool ::} \DataTypeTok{Sigma} \DataTypeTok{TypeRep} \OtherTok{{-}\textgreater{}} \DataTypeTok{String}
\NormalTok{showIfBool (}\DataTypeTok{MkSigma}\NormalTok{ tr x) }\OtherTok{=} \KeywordTok{case}\NormalTok{ testEquality tr (typeRep }\OperatorTok{@}\DataTypeTok{Bool}\NormalTok{) }\KeywordTok{of}
  \DataTypeTok{Just} \DataTypeTok{Refl} \OtherTok{{-}\textgreater{}} \KeywordTok{case}\NormalTok{ x }\KeywordTok{of} \CommentTok{{-}{-} in this branch, we know x is a Bool}
    \DataTypeTok{False} \OtherTok{{-}\textgreater{}} \StringTok{"False"}
    \DataTypeTok{True} \OtherTok{{-}\textgreater{}} \StringTok{"True"}
  \DataTypeTok{Nothing} \OtherTok{{-}\textgreater{}} \StringTok{"Not a Bool"}
\end{Highlighting}
\end{Shaded}

This uses \emph{type application syntax}, \texttt{@Bool}, that lets us pass in
the \emph{type} \texttt{Bool} to the function
\texttt{typeRep\ ::\ Typeable\ a\ =\textgreater{}\ TypeRep\ a}.

Now we can use \texttt{TypeRep}'s interface to ``match'' (using
\texttt{testEquality}) on if the value inside is a \texttt{Bool}. If the match
works (and we get \texttt{Just\ Refl}) then we can treat \texttt{x} as a
\texttt{Bool} in that case. If it doesn't (and we get \texttt{Nothing}), then we
do what we would want to do otherwise.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ghci}\OperatorTok{\textgreater{}} \KeywordTok{let}\NormalTok{ x }\OtherTok{=} \DataTypeTok{MkSigma}\NormalTok{ typeRep }\DataTypeTok{True}
\NormalTok{ghci}\OperatorTok{\textgreater{}} \KeywordTok{let}\NormalTok{ y }\OtherTok{=} \DataTypeTok{MkSigma}\NormalTok{ typeRep (}\DecValTok{4}\OtherTok{ ::} \DataTypeTok{Int}\NormalTok{)}
\NormalTok{ghci}\OperatorTok{\textgreater{}}\NormalTok{ showIfBool x}
\StringTok{"True"}
\NormalTok{ghci}\OperatorTok{\textgreater{}}\NormalTok{ showIfBool y}
\StringTok{"Not a Bool"}
\end{Highlighting}
\end{Shaded}

This pattern is common enough that there's the
\emph{\href{https://hackage.haskell.org/package/base/docs/Data-Dynamic.html}{Data.Dynamic}}
module in base that is \texttt{Sigma\ TypeRep}, and \texttt{testEquality} is
replaced with that module's \texttt{fromDynamic}:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{{-}{-} source: https://github.com/mstksg/inCode/tree/master/code{-}samples/type{-}levels/Level1.hs\#L40{-}L45}

\OtherTok{showIfBoolDynamic ::} \DataTypeTok{Dynamic} \OtherTok{{-}\textgreater{}} \DataTypeTok{String}
\NormalTok{showIfBoolDynamic dyn }\OtherTok{=} \KeywordTok{case}\NormalTok{ fromDynamic dyn }\KeywordTok{of}
  \DataTypeTok{Just}\NormalTok{ x }\OtherTok{{-}\textgreater{}} \KeywordTok{case}\NormalTok{ x }\KeywordTok{of} \CommentTok{{-}{-} in this branch, we know x is a Bool}
    \DataTypeTok{False} \OtherTok{{-}\textgreater{}} \StringTok{"False"}
    \DataTypeTok{True} \OtherTok{{-}\textgreater{}} \StringTok{"True"}
  \DataTypeTok{Nothing} \OtherTok{{-}\textgreater{}} \StringTok{"Not a Bool"}
\end{Highlighting}
\end{Shaded}

For make our life easier in the future, let's write a version of
\texttt{fromDynamic} for our \texttt{Sigma\ TypeRep}:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{{-}{-} source: https://github.com/mstksg/inCode/tree/master/code{-}samples/type{-}levels/Level1.hs\#L47{-}L53}

\OtherTok{castSigma ::} \DataTypeTok{TypeRep}\NormalTok{ a }\OtherTok{{-}\textgreater{}} \DataTypeTok{Sigma} \DataTypeTok{TypeRep} \OtherTok{{-}\textgreater{}} \DataTypeTok{Maybe}\NormalTok{ a}
\NormalTok{castSigma tr (}\DataTypeTok{MkSigma}\NormalTok{ tr\textquotesingle{} x) }\OtherTok{=} \KeywordTok{case}\NormalTok{ testEquality tr tr\textquotesingle{} }\KeywordTok{of}
  \DataTypeTok{Just} \DataTypeTok{Refl} \OtherTok{{-}\textgreater{}} \DataTypeTok{Just}\NormalTok{ x}
  \DataTypeTok{Nothing} \OtherTok{{-}\textgreater{}} \DataTypeTok{Nothing}

\OtherTok{castSigma\textquotesingle{} ::} \DataTypeTok{Typeable}\NormalTok{ a }\OtherTok{=\textgreater{}} \DataTypeTok{Sigma} \DataTypeTok{TypeRep} \OtherTok{{-}\textgreater{}} \DataTypeTok{Maybe}\NormalTok{ a}
\NormalTok{castSigma\textquotesingle{} }\OtherTok{=}\NormalTok{ castSigma typeRep}
\end{Highlighting}
\end{Shaded}

But the reason why I'm presenting the more generic \texttt{Sigma} instead of the
specific \texttt{type\ Dynamic\ =\ Sigma\ TypeRep} is that you can swap out
\texttt{TypeRep} to get other interesting types. For example, if you had a
witness of showability:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{{-}{-} source: https://github.com/mstksg/inCode/tree/master/code{-}samples/type{-}levels/Level1.hs\#L55{-}L62}

\KeywordTok{data} \DataTypeTok{Showable}\OtherTok{ ::} \DataTypeTok{Type} \OtherTok{{-}\textgreater{}} \DataTypeTok{Type} \KeywordTok{where}
  \DataTypeTok{WitShowable}\OtherTok{ ::} \DataTypeTok{Show}\NormalTok{ a }\OtherTok{=\textgreater{}} \DataTypeTok{Showable}\NormalTok{ a}

\OtherTok{showableInt ::} \DataTypeTok{Sigma} \DataTypeTok{Showable}
\NormalTok{showableInt }\OtherTok{=} \DataTypeTok{MkSigma} \DataTypeTok{WitShowable}\NormalTok{ (}\DecValTok{3}\OtherTok{ ::} \DataTypeTok{Int}\NormalTok{)}

\OtherTok{showableBool ::} \DataTypeTok{Sigma} \DataTypeTok{Showable}
\NormalTok{showableBool }\OtherTok{=} \DataTypeTok{MkSigma} \DataTypeTok{WitShowable} \DataTypeTok{True}
\end{Highlighting}
\end{Shaded}

(This type is related to \texttt{Dict\ Show} from the
\href{https://hackage.haskell.org/package/constraints-0.13/docs/Data-Constraint.html\#t:Dict}{constraints}
library; it's technically \texttt{Compose\ Dict\ Show})

And now we have a type \texttt{Sigma\ Showable} that's kind of of
``not-so-black'': we can at least use \texttt{show} on it:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{{-}{-} source: https://github.com/mstksg/inCode/tree/master/code{-}samples/type{-}levels/Level1.hs\#L64{-}L65}

\OtherTok{showSigma ::} \DataTypeTok{Sigma} \DataTypeTok{Showable} \OtherTok{{-}\textgreater{}} \DataTypeTok{String}
\NormalTok{showSigma (}\DataTypeTok{MkSigma} \DataTypeTok{WitShowable}\NormalTok{ x) }\OtherTok{=} \FunctionTok{show}\NormalTok{ x }\CommentTok{{-}{-} here, we know x is Show}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ghci}\OperatorTok{\textgreater{}} \KeywordTok{let}\NormalTok{ x }\OtherTok{=} \DataTypeTok{MkSigma} \DataTypeTok{WitShowable} \DataTypeTok{True}
\NormalTok{ghci}\OperatorTok{\textgreater{}} \KeywordTok{let}\NormalTok{ y }\OtherTok{=} \DataTypeTok{MkSigma} \DataTypeTok{WitShowable} \DecValTok{4}
\NormalTok{ghci}\OperatorTok{\textgreater{}}\NormalTok{ showSigma x}
\StringTok{"True"}
\NormalTok{ghci}\OperatorTok{\textgreater{}}\NormalTok{ showSigma y}
\StringTok{"4"}
\end{Highlighting}
\end{Shaded}

This is the
``\href{https://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/}{existential
typeclass antipattern}''\footnote{Luke's blog has been known to switch back and
  forth from private to non-private, so I will link to the official post and
  respect the decision of the author on whether or not it should be visible.
  However, the term itself is quite commonly used and if you search for it
  online you will find much discussion about it.}, but since we are talking
about different ways we can push the type system, it's probably worth
mentioning. In particular, \texttt{Show} is a silly typeclass to use in this
context because a \texttt{Sigma\ Showable} is equivalent to just a
\texttt{String}: once you match on the constructor to get the value, the only
thing you can do with the value is \texttt{show} it anyway.

One fun thing we can do is provide a ``useless witness'', like \texttt{Proxy}:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{{-}{-} source: https://github.com/mstksg/inCode/tree/master/code{-}samples/type{-}levels/Level1.hs\#L67{-}L70}

\KeywordTok{data} \DataTypeTok{Proxy}\NormalTok{ a }\OtherTok{=} \DataTypeTok{Proxy}

\OtherTok{uselessBool ::} \DataTypeTok{Sigma} \DataTypeTok{Proxy}
\NormalTok{uselessBool }\OtherTok{=} \DataTypeTok{MkSigma} \DataTypeTok{Proxy} \DataTypeTok{True}
\end{Highlighting}
\end{Shaded}

So a value like \texttt{MkSigma\ Proxy\ True\ ::\ Sigma\ Proxy} is truly a
useless data type (basically our \texttt{Any} from before), since we know that
\texttt{MkSigma} constrains \emph{some} value of \emph{some} type, but there's
no witness to give us any clue on how we can use it. A \texttt{Sigma\ Proxy} is
isomorphic to \texttt{()}.

On the other extreme, we can use a witness to constrain the value to only be a
specific type, like \texttt{IsBool}:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{{-}{-} source: https://github.com/mstksg/inCode/tree/master/code{-}samples/type{-}levels/Level1.hs\#L72{-}L76}

\KeywordTok{data} \DataTypeTok{IsBool}\OtherTok{ ::} \DataTypeTok{Type} \OtherTok{{-}\textgreater{}} \DataTypeTok{Type} \KeywordTok{where}
  \DataTypeTok{ItsABool}\OtherTok{ ::} \DataTypeTok{IsBool} \DataTypeTok{Bool}

\OtherTok{justABool ::} \DataTypeTok{Sigma} \DataTypeTok{IsBool}
\NormalTok{justABool }\OtherTok{=} \DataTypeTok{MkSigma} \DataTypeTok{ItsABool} \DataTypeTok{False}
\end{Highlighting}
\end{Shaded}

So you can have a value of type
\texttt{MkSigma\ ItsABool\ True\ ::\ Sigma\ IsBool}, or
\texttt{MkSigma\ ItsABool\ False}, but \texttt{MkSigma\ ItsABool\ 2} will not
typecheck --- remember, to make a \texttt{Sigma}, you need a \texttt{p\ a} and
an \texttt{a}. \texttt{ItsABool\ ::\ IsBool\ Bool}, so the \texttt{a} you put in
must be \texttt{Bool} to match. \texttt{Sigma\ IsBool} is essentially isomorphic
to \texttt{Bool}.

There's a general version of this too, \texttt{(:\textasciitilde{}:)\ a} (from
\emph{\href{https://hackage.haskell.org/package/base/docs/Data-Type-Equality.html\#t::-126-:}{Data.Type.Equality}}
in base). \texttt{(:\textasciitilde{}:)\ Bool} is our \texttt{IsBool} earlier.
\texttt{Sigma\ ((:\textasciitilde{}:)\ a)} is essentially exactly
\texttt{a}\ldots basically bringing us incidentally back to complete type
safety? Weird. Anyway.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{{-}{-} source: https://github.com/mstksg/inCode/tree/master/code{-}samples/type{-}levels/Level1.hs\#L78{-}L79}

\OtherTok{justAnInt ::} \DataTypeTok{Sigma}\NormalTok{ ((}\OperatorTok{:\textasciitilde{}:}\NormalTok{) }\DataTypeTok{Int}\NormalTok{)}
\NormalTok{justAnInt }\OtherTok{=} \DataTypeTok{MkSigma} \DataTypeTok{Refl} \DecValTok{10} \CommentTok{{-}{-} Refl :: Int :\textasciitilde{}: Int}
\end{Highlighting}
\end{Shaded}

I think one interesting thing to see here is that being ``type-unsafe'' in
Haskell can be much less convenient than doing something similar in a
dynamically typed language like python. The python ecosystem is designed around
runtime reflection and inspection for properties and interfaces, whereas the
dominant implementation of interfaces in Haskell (typeclasses) doesn't gel with
this. There's no runtime typeclass instantiation: we can't pattern match on a
\texttt{TypeRep} and check if it's an instance of \texttt{Ord} or not.

That's why I don't fancy those memes/jokes about how dynamically typed languages
are just ``static types with a single type''. The actual way you use those types
(and the ecosystem built around them) lend themselves to different ergonomics,
and the reductionist take doesn't quite capture that nuance.

\section{Level 2: Heterogeneous List}\label{level-2-heterogeneous-list}

\emph{\href{https://github.com/mstksg/inCode/tree/master/code-samples/type-levels/Level2.hs}{Code
available here}}

The lowest level of safety in which a list might be useful is the dynamically
heterogeneous list. This is the level where lists (or ``arrays'') live in most
dynamic languages.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{{-}{-} source: https://github.com/mstksg/inCode/tree/master/code{-}samples/type{-}levels/Level2.hs\#L12{-}L12}

\KeywordTok{type} \DataTypeTok{HList}\NormalTok{ p }\OtherTok{=}\NormalTok{ [}\DataTypeTok{Sigma}\NormalTok{ p]}
\end{Highlighting}
\end{Shaded}

We tag values with a witness \texttt{p} for the same reason as before: if we
don't provide \emph{some} type of witness, our type is useless.

The ``dynamically heterogeneous list of values of any type'' is
\texttt{HList\ TypeRep}. This is somewhat similar to how functions with
positional arguments work in a dynamic language like javascript. For example,
here's a function that connects to a host (\texttt{String}), optionally taking a
port (\texttt{Int}) and a method (\texttt{Method}).

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{{-}{-} source: https://github.com/mstksg/inCode/tree/master/code{-}samples/type{-}levels/Level2.hs\#L14{-}L33}

\KeywordTok{data} \DataTypeTok{Method} \OtherTok{=} \DataTypeTok{HTTP} \OperatorTok{|} \DataTypeTok{HTTPS}

\OtherTok{indexHList ::} \DataTypeTok{Int} \OtherTok{{-}\textgreater{}} \DataTypeTok{HList}\NormalTok{ p }\OtherTok{{-}\textgreater{}} \DataTypeTok{Maybe}\NormalTok{ (}\DataTypeTok{Sigma}\NormalTok{ p)}
\NormalTok{indexHList }\DecValTok{0}\NormalTok{ [] }\OtherTok{=} \DataTypeTok{Nothing}
\NormalTok{indexHList }\DecValTok{0}\NormalTok{ (x }\OperatorTok{:}\NormalTok{ \_) }\OtherTok{=} \DataTypeTok{Just}\NormalTok{ x}
\NormalTok{indexHList n (\_ }\OperatorTok{:}\NormalTok{ xs) }\OtherTok{=}\NormalTok{ indexHList (n }\OperatorTok{{-}} \DecValTok{1}\NormalTok{) xs}

\OtherTok{mkConnection ::} \DataTypeTok{HList} \DataTypeTok{TypeRep} \OtherTok{{-}\textgreater{}} \DataTypeTok{IO}\NormalTok{ ()}
\NormalTok{mkConnection args }\OtherTok{=}\NormalTok{ doTheThing host port method}
  \KeywordTok{where}
\OtherTok{    host ::} \DataTypeTok{Maybe} \DataTypeTok{String}
\NormalTok{    host }\OtherTok{=}\NormalTok{ castSigma\textquotesingle{} }\OperatorTok{=\textless{}\textless{}}\NormalTok{ indexHList }\DecValTok{0}\NormalTok{ args}
\OtherTok{    port ::} \DataTypeTok{Maybe} \DataTypeTok{Int}
\NormalTok{    port }\OtherTok{=}\NormalTok{ castSigma\textquotesingle{} }\OperatorTok{=\textless{}\textless{}}\NormalTok{ indexHList }\DecValTok{1}\NormalTok{ args}
\OtherTok{    method ::} \DataTypeTok{Maybe} \DataTypeTok{Method}
\NormalTok{    method }\OtherTok{=}\NormalTok{ castSigma\textquotesingle{} }\OperatorTok{=\textless{}\textless{}}\NormalTok{ indexHList }\DecValTok{2}\NormalTok{ args}
\end{Highlighting}
\end{Shaded}

Of course, this would \emph{probably} be better expressed in Haskell as a
function of type
\texttt{Maybe\ String\ -\textgreater{}\ Maybe\ Int\ -\textgreater{}\ Maybe\ Method\ -\textgreater{}\ IO\ ()}.
But maybe this could be useful in a situation where you would want to offer the
ability to take arguments in any order? We could ``find'' the first value of a
given type:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{{-}{-} source: https://github.com/mstksg/inCode/tree/master/code{-}samples/type{-}levels/Level2.hs\#L35{-}L36}

\OtherTok{findValueOfType ::} \DataTypeTok{Typeable}\NormalTok{ a }\OtherTok{=\textgreater{}} \DataTypeTok{HList} \DataTypeTok{TypeRep} \OtherTok{{-}\textgreater{}} \DataTypeTok{Maybe}\NormalTok{ a}
\NormalTok{findValueOfType }\OtherTok{=}\NormalTok{ listToMaybe }\OperatorTok{.}\NormalTok{ mapMaybe castSigma\textquotesingle{}}
\end{Highlighting}
\end{Shaded}

Then we could write:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{{-}{-} source: https://github.com/mstksg/inCode/tree/master/code{-}samples/type{-}levels/Level2.hs\#L39{-}L47}

\OtherTok{mkConnectionAnyOrder ::} \DataTypeTok{HList} \DataTypeTok{TypeRep} \OtherTok{{-}\textgreater{}} \DataTypeTok{IO}\NormalTok{ ()}
\NormalTok{mkConnectionAnyOrder args }\OtherTok{=}\NormalTok{ doTheThing host port method}
  \KeywordTok{where}
\OtherTok{    host ::} \DataTypeTok{Maybe} \DataTypeTok{String}
\NormalTok{    host }\OtherTok{=}\NormalTok{ findValueOfType args}
\OtherTok{    port ::} \DataTypeTok{Maybe} \DataTypeTok{Int}
\NormalTok{    port }\OtherTok{=}\NormalTok{ findValueOfType args}
\OtherTok{    method ::} \DataTypeTok{Maybe} \DataTypeTok{Method}
\NormalTok{    method }\OtherTok{=}\NormalTok{ findValueOfType args}
\end{Highlighting}
\end{Shaded}

But is this a good idea? Probably not.

Anyway, one very common usage of this type is for ``extensible'' systems that
let you store components of different types in a container, as long as they all
support some common interface (ie, the widgets system from the
\href{https://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/}{Luke
Palmer} post).

For example, we could have a list of any item as long as the item is an instance
of \texttt{Show}: that's \texttt{HList\ Showable}!

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{{-}{-} source: https://github.com/mstksg/inCode/tree/master/code{-}samples/type{-}levels/Level2.hs\#L52{-}L55}

\OtherTok{showAll ::} \DataTypeTok{HList} \DataTypeTok{Showable} \OtherTok{{-}\textgreater{}}\NormalTok{ [}\DataTypeTok{String}\NormalTok{]}
\NormalTok{showAll }\OtherTok{=} \FunctionTok{map}\NormalTok{ showSigma}
  \KeywordTok{where}
\NormalTok{    showSigma (}\DataTypeTok{MkSigma} \DataTypeTok{WitShowable}\NormalTok{ x) }\OtherTok{=} \FunctionTok{show}\NormalTok{ x}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ghci}\OperatorTok{\textgreater{}} \KeywordTok{let}\NormalTok{ xs }\OtherTok{=}\NormalTok{ [}\DataTypeTok{MkSigma} \DataTypeTok{WitShowable} \DecValTok{1}\NormalTok{, }\DataTypeTok{MkSigma} \DataTypeTok{WitShowable} \DataTypeTok{True}\NormalTok{]}
\NormalTok{ghci}\OperatorTok{\textgreater{}}\NormalTok{ showAll xs}
\NormalTok{[}\StringTok{"1"}\NormalTok{, }\StringTok{"True"}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

Again, \texttt{Show} is a bad typeclass to use for this because we might as well
be storing \texttt{{[}String{]}}. But for fun, let's imagine some other things
we could fill in for \texttt{p}. If we use \texttt{HList\ Proxy}, then we
basically don't have any witness at all. We can't use the values in the list in
any meaningful way; \texttt{HList\ Proxy} is essentially the same as
\texttt{Natural}, since the only information is the length.

If we use \texttt{HList\ IsBool}, we basically have \texttt{{[}Bool{]}}, since
every item must be a \texttt{Bool}! In general,
\texttt{HList\ ((:\textasciitilde{}:)\ a)} is the same as \texttt{{[}a{]}}.

\section{Level 3: Homogeneous Dynamic
List}\label{level-3-homogeneous-dynamic-list}

\emph{\href{https://github.com/mstksg/inCode/tree/master/code-samples/type-levels/Level3.hs}{Code
available here}}

A next level of type safety we can add is to ensure that all elements in the
list are of the same type. This adds a layer of usefulness because there are a
lot of things we might want to do with the elements of a list that are only
possible if they are all of the same type.

First of all, let's clarify a subtle point here. It's very easy in Haskell to
\emph{consume} lists where all elements are of the same (but not necessarily
known) type. Functions like
\texttt{sum\ ::\ Num\ a\ =\textgreater{}\ {[}a{]}\ -\textgreater{}\ a} and
\texttt{sort\ ::\ Ord\ a\ =\textgreater{}\ {[}a{]}\ -\textgreater{}\ {[}a{]}} do
that. This is ``polymorphism'', where the function is written to not worry about
the type, and the ultimate \emph{caller} of the function must pick the type they
want to use with it. For the sake of this discussion, we aren't talking about
\emph{consuming} values --- we're talking about \emph{producing} and
\emph{storing} values where the \emph{producer} (and not the consumer) controls
the type variable.

To do this, we can flip the witness to \emph{outside} the list:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{{-}{-} source: https://github.com/mstksg/inCode/tree/master/code{-}samples/type{-}levels/Level3.hs\#L17{-}L18}

\KeywordTok{data} \DataTypeTok{SomeList}\OtherTok{ ::}\NormalTok{ (}\DataTypeTok{Type} \OtherTok{{-}\textgreater{}} \DataTypeTok{Type}\NormalTok{) }\OtherTok{{-}\textgreater{}} \DataTypeTok{Type} \KeywordTok{where}
  \DataTypeTok{MkSomeList}\OtherTok{ ::}\NormalTok{ p a }\OtherTok{{-}\textgreater{}}\NormalTok{ [a] }\OtherTok{{-}\textgreater{}} \DataTypeTok{SomeList}\NormalTok{ p}
\end{Highlighting}
\end{Shaded}

We can write some meaningful predicates on this list --- for example, we can
check if it is monotonic (the items increase in order)

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{{-}{-} source: https://github.com/mstksg/inCode/tree/master/code{-}samples/type{-}levels/Level3.hs\#L21{-}L32}

\KeywordTok{data} \DataTypeTok{Comparable}\OtherTok{ ::} \DataTypeTok{Type} \OtherTok{{-}\textgreater{}} \DataTypeTok{Type} \KeywordTok{where}
  \DataTypeTok{WitOrd}\OtherTok{ ::} \DataTypeTok{Ord}\NormalTok{ a }\OtherTok{=\textgreater{}} \DataTypeTok{Comparable}\NormalTok{ a}

\OtherTok{monotonic ::} \DataTypeTok{Ord}\NormalTok{ a }\OtherTok{=\textgreater{}}\NormalTok{ [a] }\OtherTok{{-}\textgreater{}} \DataTypeTok{Bool}
\NormalTok{monotonic [] }\OtherTok{=} \DataTypeTok{True}
\NormalTok{monotonic (x }\OperatorTok{:}\NormalTok{ xs) }\OtherTok{=}\NormalTok{ go x xs}
  \KeywordTok{where}
\NormalTok{    go y [] }\OtherTok{=} \DataTypeTok{True}
\NormalTok{    go y (z }\OperatorTok{:}\NormalTok{ zs) }\OtherTok{=}\NormalTok{ (y }\OperatorTok{\textless{}=}\NormalTok{ z) }\OperatorTok{\&\&}\NormalTok{ go z zs}

\OtherTok{monotonicSomeList ::} \DataTypeTok{SomeList} \DataTypeTok{Comparable} \OtherTok{{-}\textgreater{}} \DataTypeTok{Bool}
\NormalTok{monotonicSomeList (}\DataTypeTok{MkSomeList} \DataTypeTok{WitOrd}\NormalTok{ xs) }\OtherTok{=}\NormalTok{ monotonic xs}
\end{Highlighting}
\end{Shaded}

This is fun, but, as mentioned before, \texttt{monotonicSomeList} doesn't have
any advantage over \texttt{monotonic}, because the caller determines the type.
What would be more motivating here is a function that produces ``any sortable
type'', and the caller has to use it in a way generic over all sortable types.
For example, a database API might let you query a database for a column of
values, but you don't know ahead of time what the exact \emph{type} of that
column is. You only know that it is ``some sortable type''. In \emph{that case},
a \texttt{SomeList} could be useful.

For a contrived one, let's think about pulling such a list from IO:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{{-}{-} source: https://github.com/mstksg/inCode/tree/master/code{-}samples/type{-}levels/Level3.hs\#L34{-}L54}

\OtherTok{getItems ::} \DataTypeTok{IO}\NormalTok{ (}\DataTypeTok{SomeList} \DataTypeTok{Comparable}\NormalTok{)}
\NormalTok{getItems }\OtherTok{=} \KeywordTok{do}
  \FunctionTok{putStrLn} \StringTok{"would you like to provide int or bool or string?"}
\NormalTok{  ans }\OtherTok{\textless{}{-}} \FunctionTok{getLine}
  \KeywordTok{case} \FunctionTok{map} \FunctionTok{toLower}\NormalTok{ ans }\KeywordTok{of}
    \StringTok{"int"} \OtherTok{{-}\textgreater{}} \DataTypeTok{MkSomeList} \DataTypeTok{WitOrd} \OperatorTok{\textless{}$\textgreater{}}\NormalTok{ replicateM }\DecValTok{3}\NormalTok{ (}\FunctionTok{readLn} \OperatorTok{@}\DataTypeTok{Int}\NormalTok{)}
    \StringTok{"bool"} \OtherTok{{-}\textgreater{}} \DataTypeTok{MkSomeList} \DataTypeTok{WitOrd} \OperatorTok{\textless{}$\textgreater{}}\NormalTok{ replicateM }\DecValTok{3}\NormalTok{ (}\FunctionTok{readLn} \OperatorTok{@}\DataTypeTok{Bool}\NormalTok{)}
    \StringTok{"string"} \OtherTok{{-}\textgreater{}} \DataTypeTok{MkSomeList} \DataTypeTok{WitOrd} \OperatorTok{\textless{}$\textgreater{}}\NormalTok{ replicateM }\DecValTok{3} \FunctionTok{getLine}
\NormalTok{    \_ }\OtherTok{{-}\textgreater{}}\NormalTok{ throwIO }\OperatorTok{$} \FunctionTok{userError} \StringTok{"no"}

\OtherTok{getAndAnalyze ::} \DataTypeTok{IO}\NormalTok{ ()}
\NormalTok{getAndAnalyze }\OtherTok{=} \KeywordTok{do}
  \DataTypeTok{MkSomeList} \DataTypeTok{WitOrd}\NormalTok{ xs }\OtherTok{\textless{}{-}}\NormalTok{ getItems}
  \FunctionTok{putStrLn} \OperatorTok{$} \StringTok{"Got "} \OperatorTok{++} \FunctionTok{show}\NormalTok{ (}\FunctionTok{length}\NormalTok{ xs) }\OperatorTok{++} \StringTok{" items."}
  \KeywordTok{let}\NormalTok{ isMono }\OtherTok{=}\NormalTok{ monotonic xs}
\NormalTok{      isRevMono }\OtherTok{=}\NormalTok{ monotonic (}\FunctionTok{reverse}\NormalTok{ xs)}
\NormalTok{  when isMono }\OperatorTok{$}
    \FunctionTok{putStrLn} \StringTok{"The items are monotonic."}
\NormalTok{  when (isMono }\OperatorTok{\&\&}\NormalTok{ isRevMono) }\OperatorTok{$} \KeywordTok{do}
    \FunctionTok{putStrLn} \StringTok{"The items are monotonic both directions."}
    \FunctionTok{putStrLn} \StringTok{"This means the items are all identical."}
\end{Highlighting}
\end{Shaded}

Consider also an example where process items different based on what type they
have:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{{-}{-} source: https://github.com/mstksg/inCode/tree/master/code{-}samples/type{-}levels/Level3.hs\#L62{-}L68}

\OtherTok{processList ::} \DataTypeTok{SomeList} \DataTypeTok{TypeRep} \OtherTok{{-}\textgreater{}} \DataTypeTok{Bool}
\NormalTok{processList (}\DataTypeTok{MkSomeList}\NormalTok{ tr xs)}
  \OperatorTok{|} \DataTypeTok{Just} \DataTypeTok{Refl} \OtherTok{\textless{}{-}}\NormalTok{ testEquality tr (typeRep }\OperatorTok{@}\DataTypeTok{Bool}\NormalTok{) }\OtherTok{=} \FunctionTok{and}\NormalTok{ xs}
  \OperatorTok{|} \DataTypeTok{Just} \DataTypeTok{Refl} \OtherTok{\textless{}{-}}\NormalTok{ testEquality tr (}\DataTypeTok{TypeRep} \OperatorTok{@}\DataTypeTok{Int}\NormalTok{) }\OtherTok{=} \FunctionTok{sum}\NormalTok{ xs }\OperatorTok{\textgreater{}} \DecValTok{50}
  \OperatorTok{|} \DataTypeTok{Just} \DataTypeTok{Refl} \OtherTok{\textless{}{-}}\NormalTok{ testEquality tr (}\DataTypeTok{TypeRep} \OperatorTok{@}\DataTypeTok{Double}\NormalTok{) }\OtherTok{=} \FunctionTok{sum}\NormalTok{ xs }\OperatorTok{\textgreater{}} \FloatTok{5.0}
  \OperatorTok{|} \DataTypeTok{Just} \DataTypeTok{Refl} \OtherTok{\textless{}{-}}\NormalTok{ testEquality tr (}\DataTypeTok{TypeRep} \OperatorTok{@}\DataTypeTok{String}\NormalTok{) }\OtherTok{=} \StringTok{"hello"} \OtherTok{\textasciigrave{}elem\textasciigrave{}}\NormalTok{ xs}
  \OperatorTok{|} \FunctionTok{otherwise} \OtherTok{=} \DataTypeTok{False}
\end{Highlighting}
\end{Shaded}

(That's \href{https://wiki.haskell.org/Pattern_guard}{pattern guard} syntax, if
you were wondering)

In this specific situation, using a closed ADT of all the types you'd actually
want is probably preferred (like
\texttt{data\ Value\ =\ VBool\ Bool\ \textbar{}\ VInt\ Int\ \textbar{}\ VDouble\ Double\ \textbar{}\ VString\ String}),
since we only ever get one of four different types. Using \texttt{Comparable}
like this gives you a \emph{completely open} type that can take \emph{any}
instance of \texttt{Ord}, and using \texttt{TypeRep} gives you a
\emph{completely open type} that can take literally \emph{anything}.

This pattern is overall similar to how lists are often used in practice for
dynamic languages: often when we use lists in dynamically typed situations, we
expect them all to have items of the same type or interface. However, using
lists this way (in a language without type safety) makes it really tempting to
hop down into Level 2, where you start throwing ``alternatively typed'' things
into your list, as well, for convenience. And then the temptation comes to also
hop down to Level 1 and throw a \texttt{null} in every once in a while. All of a
sudden, any consumers must now check the type of \emph{every} item, and a lot of
things are going to start needing unit tests.

Now, let's talk a bit about ascending and descending between each levels. In the
general case we don't have much to work with, but let's assume our constraint is
\texttt{TypeRep} here, so we can match for type equality.

We can move from Level 3 to Level 2 by moving the \texttt{TypeRep} into the
values of the list, and we can move from Level 3 to Level 1 by converting our
\texttt{TypeRep\ a} into a \texttt{TypeRep\ {[}a{]}}:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{{-}{-} source: https://github.com/mstksg/inCode/tree/master/code{-}samples/type{-}levels/Level3.hs\#L75{-}L86}

\OtherTok{someListToHList ::} \DataTypeTok{SomeList} \DataTypeTok{TypeRep} \OtherTok{{-}\textgreater{}} \DataTypeTok{HList} \DataTypeTok{TypeRep}
\NormalTok{someListToHList (}\DataTypeTok{MkSomeList}\NormalTok{ tr xs) }\OtherTok{=} \DataTypeTok{MkSigma}\NormalTok{ tr }\OperatorTok{\textless{}$\textgreater{}}\NormalTok{ xs}

\OtherTok{someListToSigma ::} \DataTypeTok{SomeList} \DataTypeTok{TypeRep} \OtherTok{{-}\textgreater{}} \DataTypeTok{Sigma} \DataTypeTok{TypeRep}
\NormalTok{someListToSigma (}\DataTypeTok{MkSomeList}\NormalTok{ tr xs) }\OtherTok{=} \DataTypeTok{MkSigma}\NormalTok{ (typeRep }\OperatorTok{@}\NormalTok{[] }\OtherTok{\textasciigrave{}App\textasciigrave{}}\NormalTok{ tr) xs}
\end{Highlighting}
\end{Shaded}

\texttt{App} here as a constructor lets us come \texttt{TypeRep}s:
\texttt{App\ ::\ TypeRep\ f\ -\textgreater{}\ TypeRep\ a\ -\textgreater{}\ TypeRep\ (f\ a)}.

Going the other way around is trickier. For \texttt{HList}, we don't even know
if every item has the same type, so we can only successfully move up if every
item has the same type. So, first we get the \texttt{typeRep} for the first
value, and then cast the other values to be the same type if possible:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{{-}{-} source: https://github.com/mstksg/inCode/tree/master/code{-}samples/type{-}levels/Level3.hs\#L70{-}L73}

\OtherTok{hlistToSomeList ::} \DataTypeTok{HList} \DataTypeTok{TypeRep} \OtherTok{{-}\textgreater{}} \DataTypeTok{Maybe}\NormalTok{ (}\DataTypeTok{SomeList} \DataTypeTok{TypeRep}\NormalTok{)}
\NormalTok{hlistToSomeList }\OtherTok{=}\NormalTok{ \textbackslash{}}\KeywordTok{case}
\NormalTok{  [] }\OtherTok{{-}\textgreater{}} \DataTypeTok{Nothing}
  \DataTypeTok{MkSigma}\NormalTok{ tr x }\OperatorTok{:}\NormalTok{ xs }\OtherTok{{-}\textgreater{}} \DataTypeTok{MkSomeList}\NormalTok{ tr }\OperatorTok{.}\NormalTok{ (x }\OperatorTok{:}\NormalTok{) }\OperatorTok{\textless{}$\textgreater{}} \FunctionTok{traverse}\NormalTok{ (castSigma tr) xs}
\end{Highlighting}
\end{Shaded}

To go from \texttt{Sigma\ TypeRep}, we first need to match the \texttt{TypeRep}
as some \texttt{f\ a} application using the \texttt{App} pattern\ldots then we
can check if \texttt{f} is \texttt{{[}{]}} (list), then we can create a
\texttt{SomeList} with the \texttt{TypeRep\ a}. \emph{But},
\texttt{testEquality} can only be called on things of the same kind, so we have
to verify that \texttt{f} has kind \texttt{Type\ -\textgreater{}\ Type} first,
so that we can even call \texttt{testEquality} on \texttt{f} and
\texttt{{[}{]}}! Phew! Dynamic types are hard!

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{{-}{-} source: https://github.com/mstksg/inCode/tree/master/code{-}samples/type{-}levels/Level3.hs\#L78{-}L83}

\OtherTok{sigmaToHList ::} \DataTypeTok{Sigma} \DataTypeTok{TypeRep} \OtherTok{{-}\textgreater{}} \DataTypeTok{Maybe}\NormalTok{ (}\DataTypeTok{SomeList} \DataTypeTok{TypeRep}\NormalTok{)}
\NormalTok{sigmaToHList (}\DataTypeTok{MkSigma}\NormalTok{ tr xs) }\OtherTok{=} \KeywordTok{do}
  \DataTypeTok{App}\NormalTok{ tcon telem }\OtherTok{\textless{}{-}} \DataTypeTok{Just}\NormalTok{ tr}
  \DataTypeTok{Refl} \OtherTok{\textless{}{-}}\NormalTok{ testEquality (typeRepKind telem) (typeRep }\OperatorTok{@}\DataTypeTok{Type}\NormalTok{)}
  \DataTypeTok{Refl} \OtherTok{\textless{}{-}}\NormalTok{ testEquality tcon (typeRep }\OperatorTok{@}\NormalTok{[])}
  \FunctionTok{pure} \OperatorTok{$} \DataTypeTok{MkSomeList}\NormalTok{ telem xs}
\end{Highlighting}
\end{Shaded}

\section{Level 4: Homogeneous Typed List}\label{level-4-homogeneous-typed-list}

Ahh, now right in the middle, we've reached Haskell's ubiquitous list type! It
is essentially:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{data} \DataTypeTok{List}\OtherTok{ ::} \DataTypeTok{Type} \OtherTok{{-}\textgreater{}} \DataTypeTok{Type} \KeywordTok{where}
    \DataTypeTok{Nil}\OtherTok{  ::} \DataTypeTok{List}\NormalTok{ a}
    \DataTypeTok{Cons}\OtherTok{ ::}\NormalTok{ a }\OtherTok{{-}\textgreater{}} \DataTypeTok{List}\NormalTok{ a }\OtherTok{{-}\textgreater{}} \DataTypeTok{List}\NormalTok{ a}
\end{Highlighting}
\end{Shaded}

I don't have too much to say here, other than to acknowledge that this is truly
a ``sweet spot'' in terms of safety vs.~unsafety and usability. This simple
\texttt{List\ a} / \texttt{{[}a{]}} type has so many benefits from type-safety:

\begin{itemize}
\tightlist
\item
  It lets us write functions that can meaningfully say that the input and result
  types are the same, like
  \texttt{take\ ::\ Int\ -\textgreater{}\ {[}a{]}\ -\textgreater{}\ {[}a{]}}
\item
  It lets us write functions that can meaningfully link lists and the items in
  the list, like \texttt{head\ ::\ {[}a{]}\ -\textgreater{}\ a} and
  \texttt{replicate\ ::\ Int\ -\textgreater{}\ a\ -\textgreater{}\ {[}a{]}}.
\item
  It lets us write functions that can meaningfully state relationships between
  input and results, like
  \texttt{map\ ::\ (a\ -\textgreater{}\ b)\ -\textgreater{}\ {[}a{]}\ -\textgreater{}\ {[}b{]}}
\item
  We can require two input lists to have the same type of items, like
  \texttt{(++)\ \ \ \ \ ::\ {[}a{]}\ -\textgreater{}\ {[}a{]}\ -\textgreater{}\ {[}a{]}}
\item
  We can express complex relationships between inputs and outputs, like
  \texttt{zipWith\ ::\ (a\ -\textgreater{}\ b\ -\textgreater{}\ c)\ -\textgreater{}\ {[}a{]}\ -\textgreater{}\ {[}b{]}\ -\textgreater{}\ {[}c{]}}.
\end{itemize}

The property of being able to state and express relationships between the values
of input lists and output lists and the items in those lists is extremely
powerful, and also extremely ergonomic to use in Haskell. It can be argued that
Haskell, as a language, was tuned explicitly to be used with the least friction
at \emph{this} exact level of type safety. Haskell is a ``Level 4 language''.

\section{Level 5: Fixed-size List}\label{level-5-fixed-size-list}

\emph{\href{https://github.com/mstksg/inCode/tree/master/code-samples/type-levels/Level5.hs}{Code
available here}}

From here on, we aren't going to be ``building up'' linearly on safety, but
rather showing three structural type safety mechanism of increasing strength and
complexity.

For Level 5, we're not going to try to enforce anything on the contents of the
list, but we can try to enforce something on the \emph{spline} of the list: the
number of items!

To me, this level still feels very natural in Haskell to write in, although in
terms of usability we are starting to bump into some of the things Haskell is
lacking for higher type safety ergonomics. I've talked about
\href{https://blog.jle.im/entry/fixed-length-vector-types-in-haskell.html}{fixed-length
vector types in depth before}, so this is going to be a high-level view
contrasting this level with the others.\footnote{Note that I don't really like
  calling these ``vectors'' any more, because in a computer science context the
  word vector carries implications of contiguous-memory storage. ``Lists'' of
  fixed length is the more appropriate description here, in my opinion. The term
  ``vector'' for this concept arises from linear algebra, where a vector is
  inherently defined by its vector \emph{space}, which
  \href{https://en.wikipedia.org/wiki/Dimension_theorem_for_vector_spaces}{does
  have an inherent dimensionality}. But we are talking about computer science
  concepts here, not mathematical concepts, so we should pick the name that
  provides the most useful implicit connotations.}

The essential concept is to introduce a \emph{phantom type}, a type parameter
that doesn't do anything other than indicate something that we can use in
user-space. Here we will create a type that structurally encodes the natural
numbers 0, 1, 2\ldots:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{{-}{-} source: https://github.com/mstksg/inCode/tree/master/code{-}samples/type{-}levels/Level5.hs\#L15{-}L15}

\KeywordTok{data} \DataTypeTok{Nat} \OtherTok{=} \DataTypeTok{Z} \OperatorTok{|} \DataTypeTok{S} \DataTypeTok{Nat}
\end{Highlighting}
\end{Shaded}

So, \texttt{Z} will represent zero, \texttt{S\ Z} will represent one,
\texttt{S\ (S\ Z)} will represent two, etc. We want to create a type
\texttt{Vec\ n\ a}, where \texttt{n} will be a type of kind \texttt{Nat}
(promoted using DataKinds, which lets us use \texttt{Z} and \texttt{S} as type
constructors), representing a linked list with \texttt{n} elements of type
\texttt{a}.

We can define \texttt{Vec} in a way that structurally matches how \texttt{Nat}
is constructed, which is the key to making things work nicely:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{{-}{-} source: https://github.com/mstksg/inCode/tree/master/code{-}samples/type{-}levels/Level5.hs\#L17{-}L21}

\KeywordTok{data} \DataTypeTok{Vec}\OtherTok{ ::} \DataTypeTok{Nat} \OtherTok{{-}\textgreater{}} \DataTypeTok{Type} \OtherTok{{-}\textgreater{}} \DataTypeTok{Type} \KeywordTok{where}
  \DataTypeTok{VNil}\OtherTok{ ::} \DataTypeTok{Vec} \DataTypeTok{Z}\NormalTok{ a}
\OtherTok{  (:+) ::}\NormalTok{ a }\OtherTok{{-}\textgreater{}} \DataTypeTok{Vec}\NormalTok{ n a }\OtherTok{{-}\textgreater{}} \DataTypeTok{Vec}\NormalTok{ (}\DataTypeTok{S}\NormalTok{ n) a}

\KeywordTok{infixr} \DecValTok{5} \OperatorTok{:+}
\end{Highlighting}
\end{Shaded}

This is offered in the
\emph{\href{https://hackage.haskell.org/package/vec}{vec}} library. Here are
some example values:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{{-}{-} source: https://github.com/mstksg/inCode/tree/master/code{-}samples/type{-}levels/Level5.hs\#L23{-}L33}

\OtherTok{zeroItems ::} \DataTypeTok{Vec} \DataTypeTok{Z} \DataTypeTok{Int}
\NormalTok{zeroItems }\OtherTok{=} \DataTypeTok{VNil}

\OtherTok{oneItem ::} \DataTypeTok{Vec}\NormalTok{ (}\DataTypeTok{S} \DataTypeTok{Z}\NormalTok{) }\DataTypeTok{Int}
\NormalTok{oneItem }\OtherTok{=} \DecValTok{1} \OperatorTok{:+} \DataTypeTok{VNil}

\OtherTok{twoItems ::} \DataTypeTok{Vec}\NormalTok{ (}\DataTypeTok{S}\NormalTok{ (}\DataTypeTok{S} \DataTypeTok{Z}\NormalTok{)) }\DataTypeTok{Int}
\NormalTok{twoItems }\OtherTok{=} \DecValTok{1} \OperatorTok{:+} \DecValTok{2} \OperatorTok{:+} \DataTypeTok{VNil}

\OtherTok{threeItems ::} \DataTypeTok{Vec}\NormalTok{ (}\DataTypeTok{S}\NormalTok{ (}\DataTypeTok{S}\NormalTok{ (}\DataTypeTok{S} \DataTypeTok{Z}\NormalTok{))) }\DataTypeTok{Int}
\NormalTok{threeItems }\OtherTok{=} \DecValTok{1} \OperatorTok{:+} \DecValTok{2} \OperatorTok{:+} \DecValTok{3} \OperatorTok{:+} \DataTypeTok{VNil}
\end{Highlighting}
\end{Shaded}

Note two things:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \texttt{1\ :+\ 2\ :+\ VNil} gets automatically type-inferred to be a
  \texttt{Vec\ (S\ (S\ Z))\ \ \ \ \ a}, because every application of \texttt{:+}
  adds an \texttt{S} to the phantom type.
\item
  There is \emph{only one way} to construct a \texttt{Vec\ (S\ (S\ Z))\ a}: by
  using \texttt{:+} twice. That means that such a value is a list of exactly two
  items.
\end{enumerate}

However, the main benefit of this system is \emph{not} so you can create a
two-item list\ldots just use tuples or \texttt{data\ V2\ a\ =\ V2\ a\ a} from
\emph{\href{https://hackage.haskell.org/package/linear}{linear}} for that. No,
the main benefit is that you can now encode how arguments in your functions
relate to each other with respect to length.

For example, the \emph{type} alone of
\texttt{map\ ::\ (a\ -\textgreater{}\ b)\ -\textgreater{}\ {[}a{]}\ -\textgreater{}\ {[}b{]}}
does \emph{not} tell you that the length of the result list is the same as the
length of the input list. However, consider
\texttt{vmap\ ::\ (a\ -\textgreater{}\ b)\ -\textgreater{}\ Vec\ n\ a\ -\textgreater{}\ Vec\ n\ b}.
Here we see that the output list must have the same number of items as the input
list, and it's enforced right there in the type signature!

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{{-}{-} source: https://github.com/mstksg/inCode/tree/master/code{-}samples/type{-}levels/Level5.hs\#L35{-}L38}

\OtherTok{vmap ::}\NormalTok{ (a }\OtherTok{{-}\textgreater{}}\NormalTok{ b) }\OtherTok{{-}\textgreater{}} \DataTypeTok{Vec}\NormalTok{ n a }\OtherTok{{-}\textgreater{}} \DataTypeTok{Vec}\NormalTok{ n b}
\NormalTok{vmap f }\OtherTok{=}\NormalTok{ \textbackslash{}}\KeywordTok{case}
  \DataTypeTok{VNil} \OtherTok{{-}\textgreater{}} \DataTypeTok{VNil}
\NormalTok{  x }\OperatorTok{:+}\NormalTok{ xs }\OtherTok{{-}\textgreater{}}\NormalTok{ f x }\OperatorTok{:+}\NormalTok{ vmap f xs}
\end{Highlighting}
\end{Shaded}

And how about
\texttt{zipWith\ ::\ (a\ -\textgreater{}\ b\ -\textgreater{}\ c)\ -\textgreater{}\ {[}a{]}\ -\textgreater{}\ {[}b{]}\ -\textgreater{}\ {[}c{]}}?
It's not clear or obvious at all how the final list's length depends on the
input lists' lengths. However, a \texttt{vzipWith} would ensure the input
lengths are the same size and that the output list is also the same length:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{{-}{-} source: https://github.com/mstksg/inCode/tree/master/code{-}samples/type{-}levels/Level5.hs\#L40{-}L45}

\OtherTok{vzipWith ::}\NormalTok{ (a }\OtherTok{{-}\textgreater{}}\NormalTok{ b }\OtherTok{{-}\textgreater{}}\NormalTok{ c) }\OtherTok{{-}\textgreater{}} \DataTypeTok{Vec}\NormalTok{ n a }\OtherTok{{-}\textgreater{}} \DataTypeTok{Vec}\NormalTok{ n b }\OtherTok{{-}\textgreater{}} \DataTypeTok{Vec}\NormalTok{ n c}
\NormalTok{vzipWith f }\OtherTok{=}\NormalTok{ \textbackslash{}}\KeywordTok{case}
  \DataTypeTok{VNil} \OtherTok{{-}\textgreater{}}\NormalTok{ \textbackslash{}}\KeywordTok{case}
    \DataTypeTok{VNil} \OtherTok{{-}\textgreater{}} \DataTypeTok{VNil}
\NormalTok{  x }\OperatorTok{:+}\NormalTok{ xs }\OtherTok{{-}\textgreater{}}\NormalTok{ \textbackslash{}}\KeywordTok{case}
\NormalTok{    y }\OperatorTok{:+}\NormalTok{ ys }\OtherTok{{-}\textgreater{}}\NormalTok{ f x y }\OperatorTok{:+}\NormalTok{ vzipWith f xs ys}
\end{Highlighting}
\end{Shaded}

Note that both of the inner pattern matches are known by GHC to be exhaustive:
if it knows that the first list is \texttt{VNil}, then it knows that
\texttt{n\ \textasciitilde{}\ Z}, so the second list \emph{has to also} be
\texttt{VNil}. Thanks GHC!

From here on out, we're now always going to assume that GHC's exhaustiveness
checker is on, so we always handle every branch that GHC tells us is necessary,
and skip handling branches that GHC tells us is unnecessary (through compiler
warnings).

We can even express more complicated relationships with type families
(type-level ``functions''):

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{{-}{-} source: https://github.com/mstksg/inCode/tree/master/code{-}samples/type{-}levels/Level5.hs\#L47{-}L63}

\KeywordTok{type} \KeywordTok{family} \DataTypeTok{Plus}\NormalTok{ (}\OtherTok{x ::} \DataTypeTok{Nat}\NormalTok{) (}\OtherTok{y ::} \DataTypeTok{Nat}\NormalTok{) }\KeywordTok{where}
  \DataTypeTok{Plus} \DataTypeTok{Z}\NormalTok{ y }\OtherTok{=}\NormalTok{ y}
  \DataTypeTok{Plus}\NormalTok{ (}\DataTypeTok{S}\NormalTok{ z) y }\OtherTok{=} \DataTypeTok{S}\NormalTok{ (}\DataTypeTok{Plus}\NormalTok{ z y)}

\KeywordTok{type} \KeywordTok{family} \DataTypeTok{Times}\NormalTok{ (}\OtherTok{x ::} \DataTypeTok{Nat}\NormalTok{) (}\OtherTok{y ::} \DataTypeTok{Nat}\NormalTok{) }\KeywordTok{where}
  \DataTypeTok{Times} \DataTypeTok{Z}\NormalTok{ y }\OtherTok{=} \DataTypeTok{Z}
  \DataTypeTok{Times}\NormalTok{ (}\DataTypeTok{S}\NormalTok{ z) y }\OtherTok{=} \DataTypeTok{Plus}\NormalTok{ y (}\DataTypeTok{Times}\NormalTok{ z y)}

\OtherTok{vconcat ::} \DataTypeTok{Vec}\NormalTok{ n a }\OtherTok{{-}\textgreater{}} \DataTypeTok{Vec}\NormalTok{ m a }\OtherTok{{-}\textgreater{}} \DataTypeTok{Vec}\NormalTok{ (}\DataTypeTok{Plus}\NormalTok{ n m) a}
\NormalTok{vconcat }\OtherTok{=}\NormalTok{ \textbackslash{}}\KeywordTok{case}
  \DataTypeTok{VNil} \OtherTok{{-}\textgreater{}} \FunctionTok{id}
\NormalTok{  x }\OperatorTok{:+}\NormalTok{ xs }\OtherTok{{-}\textgreater{}}\NormalTok{ \textbackslash{}ys }\OtherTok{{-}\textgreater{}}\NormalTok{ x }\OperatorTok{:+}\NormalTok{ vconcat xs ys}

\OtherTok{vconcatMap ::}\NormalTok{ (a }\OtherTok{{-}\textgreater{}} \DataTypeTok{Vec}\NormalTok{ m b) }\OtherTok{{-}\textgreater{}} \DataTypeTok{Vec}\NormalTok{ n a }\OtherTok{{-}\textgreater{}} \DataTypeTok{Vec}\NormalTok{ (}\DataTypeTok{Times}\NormalTok{ n m) b}
\NormalTok{vconcatMap f }\OtherTok{=}\NormalTok{ \textbackslash{}}\KeywordTok{case}
  \DataTypeTok{VNil} \OtherTok{{-}\textgreater{}} \DataTypeTok{VNil}
\NormalTok{  x }\OperatorTok{:+}\NormalTok{ xs }\OtherTok{{-}\textgreater{}}\NormalTok{ f x }\OtherTok{\textasciigrave{}vconcat\textasciigrave{}}\NormalTok{ vconcatMap f xs}
\end{Highlighting}
\end{Shaded}

Note that all of these only work in GHC because the structure of the functions
themselves match exactly the structure of the type families. If you follow the
pattern matches in the functions, note that they match exactly with the
different equations of the type family.

Famously, we can totally index into fixed-length lists, in a way that indexing
will not fail. To do that, we have to define a type \texttt{Fin\ n}, which
represents an index into a list of length \texttt{n}. So,
\texttt{Fin\ (S\ (S\ (S\ Z)))} will be either 0, 1, or 2, the three possible
indices of a three-item list.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{{-}{-} source: https://github.com/mstksg/inCode/tree/master/code{-}samples/type{-}levels/Level5.hs\#L65{-}L76}

\KeywordTok{data} \DataTypeTok{Fin}\OtherTok{ ::} \DataTypeTok{Nat} \OtherTok{{-}\textgreater{}} \DataTypeTok{Type} \KeywordTok{where}
  \CommentTok{{-}{-} | if z is non{-}zero, FZ :: Fin z gives you the first item}
  \DataTypeTok{FZ}\OtherTok{ ::} \DataTypeTok{Fin}\NormalTok{ (}\DataTypeTok{\textquotesingle{}S}\NormalTok{ n)}
  \CommentTok{{-}{-} | if i indexes into length z, then (i+1) indixes into length (z+1)}
  \DataTypeTok{FS}\OtherTok{ ::} \DataTypeTok{Fin}\NormalTok{ n }\OtherTok{{-}\textgreater{}} \DataTypeTok{Fin}\NormalTok{ (}\DataTypeTok{\textquotesingle{}S}\NormalTok{ n)}

\OtherTok{vindex ::} \DataTypeTok{Fin}\NormalTok{ n }\OtherTok{{-}\textgreater{}} \DataTypeTok{Vec}\NormalTok{ n a }\OtherTok{{-}\textgreater{}}\NormalTok{ a}
\NormalTok{vindex }\OtherTok{=}\NormalTok{ \textbackslash{}}\KeywordTok{case}
  \DataTypeTok{FZ} \OtherTok{{-}\textgreater{}}\NormalTok{ \textbackslash{}}\KeywordTok{case}
\NormalTok{    x }\OperatorTok{:+}\NormalTok{ \_ }\OtherTok{{-}\textgreater{}}\NormalTok{ x}
  \DataTypeTok{FS}\NormalTok{ i }\OtherTok{{-}\textgreater{}}\NormalTok{ \textbackslash{}}\KeywordTok{case}
\NormalTok{    \_ }\OperatorTok{:+}\NormalTok{ xs }\OtherTok{{-}\textgreater{}}\NormalTok{ vindex i xs}
\end{Highlighting}
\end{Shaded}

\texttt{Fin} takes the place of \texttt{Int} in
\texttt{index\ ::\ Int\ -\textgreater{}\ {[}a{]}\ -\textgreater{}\ a}. You can
use \texttt{FZ} in any non-empty list, because \texttt{FZ\ ::\ Fin\ (S\ n)} will
match any \texttt{Vec\ (S\ n)} (which is necessarily of length greater than 0).
You can use \texttt{FS\ FZ} only on something that matches
\texttt{Vec\ (S\ (S\ n))}. This is the type-safety.

We can also specify non-trivial relationships between lengths of lists, like
making a more type-safe
\texttt{take\ ::\ Int\ -\textgreater{}\ {[}a{]}\ -\textgreater{}\ {[}a{]}}. We
want to make sure that the result list has a length less than or equal to the
input list. We need another ``int'' that can only be constructed in the case
that the result length is less than or equal to the first length. This called
``proofs'' or ``witnesses'', and act in the same role as \texttt{TypeRep},
\texttt{(:\textasciitilde{}:)}, etc. did above for our \texttt{Sigma} examples.

We want a type \texttt{LTE\ n\ m} that is a ``witness'' that \texttt{n} is less
than or equal to \texttt{m}. It can only be constructed for if \texttt{n} is
less than or equal to \texttt{m}. For example, you can create a value of type
\texttt{LTE\ (S\ Z)\ (S\ (S\ Z))}, but not of \texttt{LTE\ (S\ (S\ Z))\ Z}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{{-}{-} source: https://github.com/mstksg/inCode/tree/master/code{-}samples/type{-}levels/Level5.hs\#L78{-}L87}

\KeywordTok{data} \DataTypeTok{LTE}\OtherTok{ ::} \DataTypeTok{Nat} \OtherTok{{-}\textgreater{}} \DataTypeTok{Nat} \OtherTok{{-}\textgreater{}} \DataTypeTok{Type} \KeywordTok{where}
  \CommentTok{{-}{-} | Z is less than or equal to any number}
  \DataTypeTok{LTEZ}\OtherTok{ ::} \DataTypeTok{LTE} \DataTypeTok{Z}\NormalTok{ m}
  \CommentTok{{-}{-} | if n \textless{}= m, then (n + 1) \textless{}= (m + 1)}
  \DataTypeTok{LTES}\OtherTok{ ::} \DataTypeTok{LTE}\NormalTok{ n m }\OtherTok{{-}\textgreater{}} \DataTypeTok{LTE}\NormalTok{ (}\DataTypeTok{\textquotesingle{}S}\NormalTok{ n) (}\DataTypeTok{\textquotesingle{}S}\NormalTok{ m)}

\OtherTok{vtake ::} \DataTypeTok{LTE}\NormalTok{ n m }\OtherTok{{-}\textgreater{}} \DataTypeTok{Vec}\NormalTok{ m a }\OtherTok{{-}\textgreater{}} \DataTypeTok{Vec}\NormalTok{ n a}
\NormalTok{vtake }\OtherTok{=}\NormalTok{ \textbackslash{}}\KeywordTok{case}
  \DataTypeTok{LTEZ} \OtherTok{{-}\textgreater{}}\NormalTok{ \textbackslash{}\_ }\OtherTok{{-}\textgreater{}} \DataTypeTok{VNil}
  \DataTypeTok{LTES}\NormalTok{ l }\OtherTok{{-}\textgreater{}}\NormalTok{ \textbackslash{}}\KeywordTok{case}\NormalTok{ x }\OperatorTok{:+}\NormalTok{ xs }\OtherTok{{-}\textgreater{}}\NormalTok{ x }\OperatorTok{:+}\NormalTok{ vtake l xs}
\end{Highlighting}
\end{Shaded}

Notice the similarity to how we would define
\texttt{take\ ::\ Int\ -\textgreater{}\ {[}a{]}\ -\textgreater{}\ {[}a{]}}. We
just spiced up the \texttt{Int} argument with type safety.

Another thing we would like to do is use be able to \emph{create} lists of
arbitrary length. We can look at
\texttt{replicate\ ::\ Int\ -\textgreater{}\ a\ -\textgreater{}\ {[}a{]}}, and
create a new ``spicy int'' \texttt{SNat\ n}, so
\texttt{vreplicate\ ::\ SNat\ n\ -\textgreater{}\ a\ -\textgreater{}\ Vec\ n\ a}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{{-}{-} source: https://github.com/mstksg/inCode/tree/master/code{-}samples/type{-}levels/Level5.hs\#L89{-}L96}

\KeywordTok{data} \DataTypeTok{SNat}\OtherTok{ ::} \DataTypeTok{Nat} \OtherTok{{-}\textgreater{}} \DataTypeTok{Type} \KeywordTok{where}
  \DataTypeTok{SZ}\OtherTok{ ::} \DataTypeTok{SNat} \DataTypeTok{Z}
  \DataTypeTok{SS}\OtherTok{ ::} \DataTypeTok{SNat}\NormalTok{ n }\OtherTok{{-}\textgreater{}} \DataTypeTok{SNat}\NormalTok{ (}\DataTypeTok{S}\NormalTok{ n)}

\OtherTok{vreplicate ::} \DataTypeTok{SNat}\NormalTok{ n }\OtherTok{{-}\textgreater{}}\NormalTok{ a }\OtherTok{{-}\textgreater{}} \DataTypeTok{Vec}\NormalTok{ n a}
\NormalTok{vreplicate }\OtherTok{=}\NormalTok{ \textbackslash{}}\KeywordTok{case}
  \DataTypeTok{SZ} \OtherTok{{-}\textgreater{}}\NormalTok{ \textbackslash{}\_ }\OtherTok{{-}\textgreater{}} \DataTypeTok{VNil}
  \DataTypeTok{SS}\NormalTok{ n }\OtherTok{{-}\textgreater{}}\NormalTok{ \textbackslash{}x }\OtherTok{{-}\textgreater{}}\NormalTok{ x }\OperatorTok{:+}\NormalTok{ vreplicate n x}
\end{Highlighting}
\end{Shaded}

Notice that this type has a lot more guarantees than \texttt{replicate}. For
\texttt{replicate\ ::\ Int\ -\textgreater{}\ a\ -\textgreater{}\ {[}a{]}}, we
can't guarantee (as the caller) that the return type does have the length we
give it. But for
\texttt{vreplicate\ ::\ SNat\ n\ -\textgreater{}\ a\ -\textgreater{}\ Vec\ n\ a},
it does!

\texttt{SNat\ n} is actually kind of special. We call it a \emph{singleton}, and
it's useful because it perfectly reflects the structure of \texttt{n} the type,
as a value\ldots nothing more and nothing less. By pattern matching on
\texttt{SNat\ n}, we can exactly determine what \texttt{n} is. \texttt{SZ} means
\texttt{n} is \texttt{Z}, \texttt{SS\ SZ} means \texttt{n} is \texttt{S\ Z},
etc. This is useful because we can't directly pattern match on types at runtime
in Haskell (because of type erasure), but we \emph{can} pattern match on
singletons at runtime.

We actually encountered singletons before in this post! \texttt{TypeRep\ a} is a
singleton for the type \texttt{a}: by pattern matching on it (like with
\texttt{App} earlier), we can essentially ``pattern match'' on the type
\texttt{a} itself.

In practice, we often write typeclasses to automatically generate singletons,
similar to \texttt{Typeable} from before:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{{-}{-} source: https://github.com/mstksg/inCode/tree/master/code{-}samples/type{-}levels/Level5.hs\#L98{-}L108}

\KeywordTok{class} \DataTypeTok{KnownNat}\NormalTok{ n }\KeywordTok{where}
\OtherTok{  nat ::} \DataTypeTok{SNat}\NormalTok{ n}

\KeywordTok{instance} \DataTypeTok{KnownNat} \DataTypeTok{Z} \KeywordTok{where}
\NormalTok{  nat }\OtherTok{=} \DataTypeTok{SZ}

\KeywordTok{instance} \DataTypeTok{KnownNat}\NormalTok{ n }\OtherTok{=\textgreater{}} \DataTypeTok{KnownNat}\NormalTok{ (}\DataTypeTok{S}\NormalTok{ n) }\KeywordTok{where}
\NormalTok{  nat }\OtherTok{=} \DataTypeTok{SS}\NormalTok{ nat}

\OtherTok{vreplicate\textquotesingle{} ::} \DataTypeTok{KnownNat}\NormalTok{ n }\OtherTok{=\textgreater{}}\NormalTok{ a }\OtherTok{{-}\textgreater{}} \DataTypeTok{Vec}\NormalTok{ n a}
\NormalTok{vreplicate\textquotesingle{} }\OtherTok{=}\NormalTok{ vreplicate nat}
\end{Highlighting}
\end{Shaded}

One last thing: moving back and forth between the different levels. We can't
really write a \texttt{{[}a{]}\ -\textgreater{}\ Vec\ n\ a}, because in Haskell,
the type variables are determined by the \emph{caller}. We want \texttt{n} to be
determined by the list, and the function itself. And now suddenly we run into
the same issue that we ran into before, when moving between levels 2 and 3.

We can do the same trick before and write an existential wrapper:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{{-}{-} source: https://github.com/mstksg/inCode/tree/master/code{-}samples/type{-}levels/Level5.hs\#L110{-}L116}

\KeywordTok{data} \DataTypeTok{SomeVec}\NormalTok{ a }\OtherTok{=} \KeywordTok{forall}\NormalTok{ n}\OperatorTok{.} \DataTypeTok{MkSomeVec}\NormalTok{ (}\DataTypeTok{SNat}\NormalTok{ n) (}\DataTypeTok{Vec}\NormalTok{ n a)}

\OtherTok{toSomeVec ::}\NormalTok{ [a] }\OtherTok{{-}\textgreater{}} \DataTypeTok{SomeVec}\NormalTok{ a}
\NormalTok{toSomeVec }\OtherTok{=}\NormalTok{ \textbackslash{}}\KeywordTok{case}
\NormalTok{  [] }\OtherTok{{-}\textgreater{}} \DataTypeTok{MkSomeVec} \DataTypeTok{SZ} \DataTypeTok{VNil}
\NormalTok{  x }\OperatorTok{:}\NormalTok{ xs }\OtherTok{{-}\textgreater{}} \KeywordTok{case}\NormalTok{ toSomeVec xs }\KeywordTok{of}
    \DataTypeTok{MkSomeVec}\NormalTok{ n ys }\OtherTok{{-}\textgreater{}} \DataTypeTok{MkSomeVec}\NormalTok{ (}\DataTypeTok{SS}\NormalTok{ n) (x }\OperatorTok{:+}\NormalTok{ ys)}
\end{Highlighting}
\end{Shaded}

It is common practice (and a good habit) to always include a singleton (or a
singleton-like typeclass constraint) to the type you are ``hiding'' when you
create an existential type wrapper, even when it is not always necessary. That's
why we included \texttt{TypeRep} in \texttt{HList} and \texttt{SomeList}
earlier.

\texttt{SomeVec\ a} is essentially isomorphic to \texttt{{[}a{]}}, except you
can pattern match on it and get the length \texttt{n} as a type you can use.

There's a slightly more light-weight method of returning an existential type: by
returning it in a continuation.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{{-}{-} source: https://github.com/mstksg/inCode/tree/master/code{-}samples/type{-}levels/Level5.hs\#L118{-}L121}

\OtherTok{withVec ::}\NormalTok{ [a] }\OtherTok{{-}\textgreater{}}\NormalTok{ (}\KeywordTok{forall}\NormalTok{ n}\OperatorTok{.} \DataTypeTok{SNat}\NormalTok{ n }\OtherTok{{-}\textgreater{}} \DataTypeTok{Vec}\NormalTok{ n a }\OtherTok{{-}\textgreater{}}\NormalTok{ r) }\OtherTok{{-}\textgreater{}}\NormalTok{ r}
\NormalTok{withVec }\OtherTok{=}\NormalTok{ \textbackslash{}}\KeywordTok{case}
\NormalTok{  [] }\OtherTok{{-}\textgreater{}}\NormalTok{ \textbackslash{}f }\OtherTok{{-}\textgreater{}}\NormalTok{ f }\DataTypeTok{SZ} \DataTypeTok{VNil}
\NormalTok{  x }\OperatorTok{:}\NormalTok{ xs }\OtherTok{{-}\textgreater{}}\NormalTok{ \textbackslash{}f }\OtherTok{{-}\textgreater{}}\NormalTok{ withVec xs \textbackslash{}n ys }\OtherTok{{-}\textgreater{}}\NormalTok{ f (}\DataTypeTok{SS}\NormalTok{ n) (x }\OperatorTok{:+}\NormalTok{ ys)}
\end{Highlighting}
\end{Shaded}

That way, you can use the type variable within the continuation. Doing
\texttt{withSomeVec\ xs\ \textbackslash{}n\ v\ -\textgreater{}\ ....} is
identical to
\texttt{case\ toSomeVec\ xs\ of\ SomeVec\ n\ v\ -\textgreater{}\ ...}.

However, since you don't get the \texttt{n} itself until runtime, you might find
yourself struggling to use concepts like \texttt{Fin} and \texttt{LTE}. To do
use them comfortably, you have to write functions to ``check'' if your
\texttt{LTE} is even possible, known as ``decision functions'':

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{{-}{-} source: https://github.com/mstksg/inCode/tree/master/code{-}samples/type{-}levels/Level5.hs\#L123{-}L128}

\OtherTok{isLTE ::} \DataTypeTok{SNat}\NormalTok{ n }\OtherTok{{-}\textgreater{}} \DataTypeTok{SNat}\NormalTok{ m }\OtherTok{{-}\textgreater{}} \DataTypeTok{Maybe}\NormalTok{ (}\DataTypeTok{LTE}\NormalTok{ n m)}
\NormalTok{isLTE }\OtherTok{=}\NormalTok{ \textbackslash{}}\KeywordTok{case}
  \DataTypeTok{SZ} \OtherTok{{-}\textgreater{}}\NormalTok{ \textbackslash{}\_ }\OtherTok{{-}\textgreater{}} \DataTypeTok{Just} \DataTypeTok{LTEZ}
  \DataTypeTok{SS}\NormalTok{ n }\OtherTok{{-}\textgreater{}}\NormalTok{ \textbackslash{}}\KeywordTok{case}
    \DataTypeTok{SZ} \OtherTok{{-}\textgreater{}} \DataTypeTok{Nothing}
    \DataTypeTok{SS}\NormalTok{ m }\OtherTok{{-}\textgreater{}} \DataTypeTok{LTES} \OperatorTok{\textless{}$\textgreater{}}\NormalTok{ isLTE n m}
\end{Highlighting}
\end{Shaded}

This was a very whirlwind introduction, and I definitely recommend reading
\href{https://blog.jle.im/entry/fixed-length-vector-types-in-haskell.html}{this
post on fixed-length lists} for a more in-depth guide and tour of the features.
In practice, fixed-length lists are not that useful because the situations where
you want lazily linked lists and the situations where you want them to be
statically sized has very little overlap. But you will often see
\href{https://hackage.haskell.org/package/vector-sized}{fixed-length vectors} in
real life code --- mostly numerical code.

Overall as you can see, at this level we gain some powerful guarantees and
tools, but we also run into some small inconveniences (like manipulating
witnesses and singletons). This level is fairly comfortable to work with in
modern Haskell tooling. However, if you live here long enough, you're going to
eventually be tempted to wander into\ldots{}

\section{Level 6: Local Structure Enforced
List}\label{level-6-local-structure-enforced-list}

\emph{\href{https://github.com/mstksg/inCode/tree/master/code-samples/type-levels/Level6.hs}{Code
available here}}

For our next level let's jump back back into constraints on the \emph{contents}
of the list. Let's imagine a \emph{priority queue} on top of a list. Each value
in the list will be a \texttt{(priority,\ value)} pair. To make the \texttt{pop}
operation (pop out the value of lowest priority) efficient, we can enforce that
the list is \emph{always sorted by priority}: the lowest priority is always
first, the second lowest is second, etc.

If we didn't care about type safety, we could do this by always inserting a new
item so that it is sorted:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{{-}{-} source: https://github.com/mstksg/inCode/tree/master/code{-}samples/type{-}levels/Level6.hs\#L21{-}L26}

\OtherTok{insertSortedList ::}\NormalTok{ (}\DataTypeTok{Int}\NormalTok{, a) }\OtherTok{{-}\textgreater{}}\NormalTok{ [(}\DataTypeTok{Int}\NormalTok{, a)] }\OtherTok{{-}\textgreater{}}\NormalTok{ [(}\DataTypeTok{Int}\NormalTok{, a)]}
\NormalTok{insertSortedList (p, x) }\OtherTok{=}\NormalTok{ \textbackslash{}}\KeywordTok{case}
\NormalTok{  [] }\OtherTok{{-}\textgreater{}}\NormalTok{ [(p, x)]}
\NormalTok{  (q, y) }\OperatorTok{:}\NormalTok{ ys}
    \OperatorTok{|}\NormalTok{ p }\OperatorTok{\textless{}=}\NormalTok{ q }\OtherTok{{-}\textgreater{}}\NormalTok{ (p, x) }\OperatorTok{:}\NormalTok{ (q, y) }\OperatorTok{:}\NormalTok{ ys}
    \OperatorTok{|} \FunctionTok{otherwise} \OtherTok{{-}\textgreater{}}\NormalTok{ (q, y) }\OperatorTok{:}\NormalTok{ insertSortedList (p, x) ys}
\end{Highlighting}
\end{Shaded}

This method enforces a \emph{local} structure: between every item \texttt{x} and
the next item \texttt{y} in \texttt{x:y:zs}, the priority of \texttt{x} has to
be less than the priority \texttt{y}. Keeping our structure local means we only
need to enforce local invariants.

Writing it all willy nilly type unsafe like this could be good for a single
function, but we're also going to need some more complicated functions. What if
we wanted to ``combine'' (merge) two sorted lists together. Using a normal list,
we don't have any assurances that we have written it correctly, and it's very
easy to mess up. How about we leverage type safety to ask GHC to ensure that our
functions are always correct, and always preserve this local structure? Now
you're thinking in types!

Introducing level 6: enforcing local structure!

But, first, a quick note before we dive in: for the rest of this post, for the
sake of simplicity, let's switch from inductively defined types (like
\texttt{Nat} above) to GHC's built in
\href{https://hackage.haskell.org/package/base/docs/GHC-TypeNats.html}{opaque
\texttt{Nat} type}. You can think of it as essentially the same as the
\texttt{Nat} we wrote above, but \emph{opaque} and provided by the compiler.
Under the hood, it's implemented using machine integers for efficiency. And,
instead of using concrete \texttt{S\ (S\ (S\ Z))} syntax, you'd use abstract
numeric literals, like \texttt{3}. There's a trade-off: because it's opaque, we
can't pattern match on it and create or manipulate our own witnesses --- we are
at the mercy of the API that GHC gives us. We get \texttt{+},
\texttt{\textless{}=}, \texttt{Min}, etc., but in total it's not that extensive.
That's why I never use these without also bringing typechecker plugins
(\emph{\href{https://hackage.haskell.org/package/ghc-typelits-natnormalise}{ghc-typelits-natnormalise}}
and
\emph{\href{https://hackage.haskell.org/package/ghc-typelits-knownnat}{ghc-typelits-knonwnnat}})
to help automatically bring witnesses and equalities and relationships into
scope for us. Everything here could be done using hand-defined witnesses and
types, but we're using TypeNats here just for the sake of example.

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{\{{-}\# OPTIONS\_GHC {-}fplugin GHC.TypeLits.KnownNat.Solver \#{-}\}}
\OtherTok{\{{-}\# OPTIONS\_GHC {-}fplugin GHC.TypeLits.Normalise \#{-}\}}
\end{Highlighting}
\end{Shaded}

With that disclaimer out of the way, let's create our types! Let's make an
\texttt{Entry\ n\ a} type that represents a value of type \texttt{a} with
priority \texttt{n}.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{{-}{-} source: https://github.com/mstksg/inCode/tree/master/code{-}samples/type{-}levels/Level6.hs\#L28{-}L28}

\KeywordTok{newtype} \DataTypeTok{Entry}\NormalTok{ (}\OtherTok{n ::} \DataTypeTok{Nat}\NormalTok{) a }\OtherTok{=} \DataTypeTok{Entry}\NormalTok{ a}
\end{Highlighting}
\end{Shaded}

We'd construct this like \texttt{Entry\ @3\ "hello"}, which produces
\texttt{Entry\ 3\ String}. Again this uses \emph{type application syntax},
\texttt{@3}, that lets us pass in the \emph{type} \texttt{3} to the constructor
\texttt{Entry\ ::\ forall\ n\ a.\ a\ -\textgreater{}\ Entry\ n\ a}.

Now, let's think about what phantom types we want to include in our list. The
fundamental strategy in this, as I learned from
\href{http://strictlypositive.org/}{Conor McBride}'s great writings on this
topic, are:

\begin{itemize}
\tightlist
\item
  Think about what ``type safe operations'' you want to have for your structure
\item
  Add just enough phantom types to perform those operations.
\end{itemize}

In our case, we want to be able to cons an \texttt{Entry\ n\ a} to the start of
a sorted list. To ensure this, we need to know that n is less than or equal to
the list's \emph{current minimum priority}. So, we need our list type to be
\texttt{Sorted\ n\ a}, where \texttt{n} is the \emph{current minimum priority}.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{{-}{-} source: https://github.com/mstksg/inCode/tree/master/code{-}samples/type{-}levels/Level6.hs\#L33{-}L35}

\KeywordTok{data} \DataTypeTok{Sorted}\OtherTok{ ::} \DataTypeTok{Nat} \OtherTok{{-}\textgreater{}} \DataTypeTok{Type} \OtherTok{{-}\textgreater{}} \DataTypeTok{Type} \KeywordTok{where}
  \DataTypeTok{SSingle}\OtherTok{ ::} \DataTypeTok{Entry}\NormalTok{ n a }\OtherTok{{-}\textgreater{}} \DataTypeTok{Sorted}\NormalTok{ n a}
  \DataTypeTok{SCons}\OtherTok{ ::}\NormalTok{ (}\DataTypeTok{KnownNat}\NormalTok{ m, n }\OperatorTok{\textless{}=}\NormalTok{ m) }\OtherTok{=\textgreater{}} \DataTypeTok{Entry}\NormalTok{ n a }\OtherTok{{-}\textgreater{}} \DataTypeTok{Sorted}\NormalTok{ m a }\OtherTok{{-}\textgreater{}} \DataTypeTok{Sorted}\NormalTok{ n a}
\end{Highlighting}
\end{Shaded}

To keep things simple, we are only going to talk about non-empty lists, so the
minimum priority is always defined.

So, a \texttt{Sorted\ n\ a} is either \texttt{SSingle\ (x\ ::\ Entry\ n\ a)},
where the single item is a value of priority \texttt{n}, or
\texttt{SCons\ x\ xs}, where \texttt{x} has priority \texttt{n} and
\texttt{xs\ ::\ Sorted\ m\ a}, where \texttt{n\ \textless{}=\ m}. In our
previous inductive \texttt{Nat}, you could imagine this as
\texttt{SCons\ ::\ SNat\ m\ -\textgreater{}\ LTE\ n\ m\ -\textgreater{}\ Entry\ n\ a\ -\textgreater{}\ Sorted\ m\ a\ -\textgreater{}\ Sorted\ n\ a},
but here we will use GHC's built-in \texttt{\textless{}=} typeclass-based
witness of less-than-or-equal-to-ness.

This works! You should be able to write:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{Entry} \OperatorTok{@}\DecValTok{1} \CharTok{\textquotesingle{}a\textquotesingle{}} \OtherTok{\textasciigrave{}SCons\textasciigrave{}} \DataTypeTok{Entry} \OperatorTok{@}\DecValTok{2} \CharTok{\textquotesingle{}b\textquotesingle{}} \OtherTok{\textasciigrave{}SCons\textasciigrave{}} \DataTypeTok{SSingle}\NormalTok{ (}\DataTypeTok{Entry} \OperatorTok{@}\DecValTok{4} \CharTok{\textquotesingle{}c\textquotesingle{}}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

This creates a valid list where the priorities are all sorted from lowest to
highest. You can now pop using pattern matching, which gives you the lowest
element \emph{by construction}. If you match on \texttt{SCons\ x\ xs}, you
\emph{know} that no entry in \texttt{xs} has a priority lower than \texttt{x}.

Critically, note that creating something out-of-order like the following would
be a compiler error:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{Entry} \OperatorTok{@}\DecValTok{9} \CharTok{\textquotesingle{}a\textquotesingle{}} \OtherTok{\textasciigrave{}SCons\textasciigrave{}} \DataTypeTok{Entry} \OperatorTok{@}\DecValTok{2} \CharTok{\textquotesingle{}b\textquotesingle{}} \OtherTok{\textasciigrave{}SCons\textasciigrave{}} \DataTypeTok{SSingle}\NormalTok{ (}\DataTypeTok{Entry} \OperatorTok{@}\DecValTok{4} \CharTok{\textquotesingle{}c\textquotesingle{}}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Now, the \emph{users} of our priority queue probably won't often care about
having the minimum priority in the type. In this case, we are using the phantom
type to ensure that our data structure is correct by construction, for our own
sake, and also to help us write internal functions in a correct way. So, for
practical end-user usage, we want to existentially wrap out \texttt{n}.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{{-}{-} source: https://github.com/mstksg/inCode/tree/master/code{-}samples/type{-}levels/Level6.hs\#L103{-}L120}

\KeywordTok{data} \DataTypeTok{SomeSorted}\NormalTok{ a }\OtherTok{=} \KeywordTok{forall}\NormalTok{ n}\OperatorTok{.} \DataTypeTok{KnownNat}\NormalTok{ n }\OtherTok{=\textgreater{}} \DataTypeTok{SomeSorted}\NormalTok{ (}\DataTypeTok{Sorted}\NormalTok{ n a)}

\OtherTok{popSomeSorted ::} \DataTypeTok{Sorted}\NormalTok{ n a }\OtherTok{{-}\textgreater{}}\NormalTok{ (}\DataTypeTok{Entry}\NormalTok{ n a, }\DataTypeTok{Maybe}\NormalTok{ (}\DataTypeTok{SomeSorted}\NormalTok{ a))}
\NormalTok{popSomeSorted }\OtherTok{=}\NormalTok{ \textbackslash{}}\KeywordTok{case}
  \DataTypeTok{SSingle}\NormalTok{ x }\OtherTok{{-}\textgreater{}}\NormalTok{ (x, }\DataTypeTok{Nothing}\NormalTok{)}
  \DataTypeTok{SCons}\NormalTok{ x xs }\OtherTok{{-}\textgreater{}}\NormalTok{ (x, }\DataTypeTok{Just}\NormalTok{ (}\DataTypeTok{SomeSorted}\NormalTok{ xs))}
\end{Highlighting}
\end{Shaded}

\texttt{popSomeSorted} takes an \texttt{Sorted\ n\ a} and returns the
\texttt{Entry\ n\ a} promised at the start of it, and then the rest of the list
if there is anything left, eliding the phantom parameter.

Now let's get to the interesting parts where we actually leverage \texttt{n}:
let's write \texttt{insertSortedList}, but the type-safe way!

First of all, what should the type be if we insert an \texttt{Entry\ n\ a} into
a \texttt{Sorted\ m\ a}? If \texttt{n\ \textless{}=\ m}, it would be
\texttt{Sorted\ n\ a}. If \texttt{n\ \textgreater{}\ m}, it should be
\texttt{Sorted\ m\ a}. GHC gives us a type family \texttt{Min\ n\ m}, which
returns the minimum between \texttt{n} and \texttt{m}. So our type should be:

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{insertSorted ::} \DataTypeTok{Entry}\NormalTok{ n a }\OtherTok{{-}\textgreater{}} \DataTypeTok{Sorted}\NormalTok{ m a }\OtherTok{{-}\textgreater{}} \DataTypeTok{Sorted}\NormalTok{ (}\DataTypeTok{Min}\NormalTok{ n m) a}
\end{Highlighting}
\end{Shaded}

To write this, we can use some helper functions: first, to decide \emph{if} we
are in the \texttt{n\ \textless{}=\ m} or the \texttt{n\ \textgreater{}\ m}
case:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{{-}{-} source: https://github.com/mstksg/inCode/tree/master/code{-}samples/type{-}levels/Level6.hs\#L41{-}L51}

\KeywordTok{data} \DataTypeTok{DecideInsert}\OtherTok{ ::} \DataTypeTok{Nat} \OtherTok{{-}\textgreater{}} \DataTypeTok{Nat} \OtherTok{{-}\textgreater{}} \DataTypeTok{Type} \KeywordTok{where}
  \DataTypeTok{DIZ}\OtherTok{ ::}\NormalTok{ (n }\OperatorTok{\textless{}=}\NormalTok{ m, }\DataTypeTok{Min}\NormalTok{ n m }\OperatorTok{\textasciitilde{}}\NormalTok{ n) }\OtherTok{=\textgreater{}} \DataTypeTok{DecideInsert}\NormalTok{ n m}
  \DataTypeTok{DIS}\OtherTok{ ::}\NormalTok{ (m }\OperatorTok{\textless{}=}\NormalTok{ n, }\DataTypeTok{Min}\NormalTok{ n m }\OperatorTok{\textasciitilde{}}\NormalTok{ m) }\OtherTok{=\textgreater{}} \DataTypeTok{DecideInsert}\NormalTok{ n m}

\OtherTok{decideInsert ::} \KeywordTok{forall}\NormalTok{ a b}\OperatorTok{.}\NormalTok{ (}\DataTypeTok{KnownNat}\NormalTok{ a, }\DataTypeTok{KnownNat}\NormalTok{ b) }\OtherTok{=\textgreater{}} \DataTypeTok{DecideInsert}\NormalTok{ a b}
\NormalTok{decideInsert }\OtherTok{=} \KeywordTok{case}\NormalTok{ cmpNat (}\DataTypeTok{Proxy} \OperatorTok{@}\NormalTok{a) (}\DataTypeTok{Proxy} \OperatorTok{@}\NormalTok{b) }\KeywordTok{of}
  \DataTypeTok{LTI} \OtherTok{{-}\textgreater{}} \DataTypeTok{DIZ} \CommentTok{{-}{-} if a \textless{} b, DIZ}
  \DataTypeTok{EQI} \OtherTok{{-}\textgreater{}} \DataTypeTok{DIZ} \CommentTok{{-}{-} if a == b, DIZ}
  \DataTypeTok{GTI} \OtherTok{{-}\textgreater{}} \KeywordTok{case}\NormalTok{ cmpNat (}\DataTypeTok{Proxy} \OperatorTok{@}\NormalTok{b) (}\DataTypeTok{Proxy} \OperatorTok{@}\NormalTok{a) }\KeywordTok{of}
    \DataTypeTok{LTI} \OtherTok{{-}\textgreater{}} \DataTypeTok{DIS} \CommentTok{{-}{-} if a \textgreater{} b, DIZ, except GHC isn\textquotesingle{}t smart enough to know this}
    \DataTypeTok{GTI} \OtherTok{{-}\textgreater{}} \FunctionTok{error} \StringTok{"absurd, we can\textquotesingle{}t have both a \textgreater{} b and b \textgreater{} a"}
\end{Highlighting}
\end{Shaded}

We can use \texttt{decideInsert} to branch on if we are in the case where we
insert the entry at the head or the case where we have to insert it deeper.
\texttt{DecideInsert} here is our witness, and \texttt{decideInsert} constructs
it using \texttt{cmpNat}, provided by GHC to compare two \texttt{Nat}s. We use
\texttt{Proxy\ ::\ Proxy\ n} to tell it what nats we want to compare.
\texttt{KnownNat} is the equivalent of our \texttt{KnownNat} class we wrote from
scratch, but with GHC's TypeNats instead of our custom inductive Nats.

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{cmpNat ::}\NormalTok{ (}\DataTypeTok{KnownNat}\NormalTok{ a, }\DataTypeTok{KnownNat}\NormalTok{ b) }\OtherTok{=\textgreater{}}\NormalTok{ p a }\OtherTok{{-}\textgreater{}}\NormalTok{ p b }\OtherTok{{-}\textgreater{}} \DataTypeTok{OrderingI}\NormalTok{ a b}

\KeywordTok{data} \DataTypeTok{OrderingI}\OtherTok{ ::}\NormalTok{ k }\OtherTok{{-}\textgreater{}}\NormalTok{ k }\OtherTok{{-}\textgreater{}} \DataTypeTok{Type} \KeywordTok{where}
    \DataTypeTok{LTI}\OtherTok{ ::} \CommentTok{{-}{-} in this branch, a \textless{} b}
    \DataTypeTok{EQI}\OtherTok{ ::} \CommentTok{{-}{-} in this branch, a \textasciitilde{} b}
    \DataTypeTok{GTI}\OtherTok{ ::} \CommentTok{{-}{-} in this branch, a \textgreater{} b}
\end{Highlighting}
\end{Shaded}

Note that GHC and our typechecker plugins aren't smart enough to know we can
rule out \texttt{b\ \textgreater{}\ a} if \texttt{a\ \textgreater{}\ b} is true,
so we have to leave an \texttt{error} that we know will never be called. Oh
well. If we were writing our witnesses by hand using inductive types, we could
write this ourselves, but since we are using GHC's Nat, we are limited by what
their API can prove.

Let's start writing our \texttt{insertSorted}:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{{-}{-} source: https://github.com/mstksg/inCode/tree/master/code{-}samples/type{-}levels/Level6.hs\#L64{-}L76}

\OtherTok{insertSorted ::}
  \KeywordTok{forall}\NormalTok{ n m a}\OperatorTok{.}
\NormalTok{  (}\DataTypeTok{KnownNat}\NormalTok{ n, }\DataTypeTok{KnownNat}\NormalTok{ m) }\OtherTok{=\textgreater{}}
  \DataTypeTok{Entry}\NormalTok{ n a }\OtherTok{{-}\textgreater{}}
  \DataTypeTok{Sorted}\NormalTok{ m a }\OtherTok{{-}\textgreater{}}
  \DataTypeTok{Sorted}\NormalTok{ (}\DataTypeTok{Min}\NormalTok{ n m) a}
\NormalTok{insertSorted x }\OtherTok{=}\NormalTok{ \textbackslash{}}\KeywordTok{case}
  \DataTypeTok{SSingle}\NormalTok{ y }\OtherTok{{-}\textgreater{}} \KeywordTok{case}\NormalTok{ decideInsert }\OperatorTok{@}\NormalTok{n }\OperatorTok{@}\NormalTok{m }\KeywordTok{of}
    \DataTypeTok{DIZ} \OtherTok{{-}\textgreater{}} \DataTypeTok{SCons}\NormalTok{ x (}\DataTypeTok{SSingle}\NormalTok{ y)}
    \DataTypeTok{DIS} \OtherTok{{-}\textgreater{}} \DataTypeTok{SCons}\NormalTok{ y (}\DataTypeTok{SSingle}\NormalTok{ x)}
  \DataTypeTok{SCons} \OperatorTok{@}\NormalTok{q y ys }\OtherTok{{-}\textgreater{}} \KeywordTok{case}\NormalTok{ decideInsert }\OperatorTok{@}\NormalTok{n }\OperatorTok{@}\NormalTok{m }\KeywordTok{of}
    \DataTypeTok{DIZ} \OtherTok{{-}\textgreater{}} \DataTypeTok{SCons}\NormalTok{ x (}\DataTypeTok{SCons}\NormalTok{ y ys)}
    \DataTypeTok{DIS} \OtherTok{{-}\textgreater{}}\NormalTok{ sConsMin }\OperatorTok{@}\NormalTok{n }\OperatorTok{@}\NormalTok{q y (insertSorted x ys)}
\end{Highlighting}
\end{Shaded}

The structure is more or less the same as \texttt{insertSortedList}, but now
type safe! We basically use our handy helper function \texttt{decideInsert} to
dictate where we go. I also used a helper function \texttt{sConsMin} to insert
into the recursive case

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{{-}{-} source: https://github.com/mstksg/inCode/tree/master/code{-}samples/type{-}levels/Level6.hs\#L53{-}L62}

\OtherTok{sConsMin ::}
  \KeywordTok{forall}\NormalTok{ q r n a}\OperatorTok{.}
\NormalTok{  (}\DataTypeTok{KnownNat}\NormalTok{ q, }\DataTypeTok{KnownNat}\NormalTok{ r, n }\OperatorTok{\textless{}=}\NormalTok{ q, n }\OperatorTok{\textless{}=}\NormalTok{ r) }\OtherTok{=\textgreater{}}
  \DataTypeTok{Entry}\NormalTok{ n a }\OtherTok{{-}\textgreater{}}
  \DataTypeTok{Sorted}\NormalTok{ (}\DataTypeTok{Min}\NormalTok{ q r) a }\OtherTok{{-}\textgreater{}}
  \DataTypeTok{Sorted}\NormalTok{ n a}
\NormalTok{sConsMin }\OtherTok{=} \KeywordTok{case}\NormalTok{ cmpNat (}\DataTypeTok{Proxy} \OperatorTok{@}\NormalTok{q) (}\DataTypeTok{Proxy} \OperatorTok{@}\NormalTok{r) }\KeywordTok{of}
  \DataTypeTok{LTI} \OtherTok{{-}\textgreater{}} \DataTypeTok{SCons}\OtherTok{ ::} \DataTypeTok{Entry}\NormalTok{ n a }\OtherTok{{-}\textgreater{}} \DataTypeTok{Sorted}\NormalTok{ q a }\OtherTok{{-}\textgreater{}} \DataTypeTok{Sorted}\NormalTok{ n a}
  \DataTypeTok{EQI} \OtherTok{{-}\textgreater{}} \DataTypeTok{SCons}\OtherTok{ ::} \DataTypeTok{Entry}\NormalTok{ n a }\OtherTok{{-}\textgreater{}} \DataTypeTok{Sorted}\NormalTok{ q a }\OtherTok{{-}\textgreater{}} \DataTypeTok{Sorted}\NormalTok{ n a}
  \DataTypeTok{GTI} \OtherTok{{-}\textgreater{}} \DataTypeTok{SCons}\OtherTok{ ::} \DataTypeTok{Entry}\NormalTok{ n a }\OtherTok{{-}\textgreater{}} \DataTypeTok{Sorted}\NormalTok{ r a }\OtherTok{{-}\textgreater{}} \DataTypeTok{Sorted}\NormalTok{ n a}
\end{Highlighting}
\end{Shaded}

\texttt{sConsMin} isn't strictly necessary, but it saves a lot of unnecessary
pattern matching. The reason why we need it is because we \emph{want} to write
\texttt{SCons\ y\ (insertSorted\ x\ ys)} in the last line of
\texttt{insertSorted}. However, in this case, \texttt{SCons} does not have a
well-defined type. It can either be
\texttt{Entry\ n\ -\textgreater{}\ Sorted\ q\ a\ -\textgreater{}\ Sorted\ n\ a}
or
\texttt{Entry\ n\ -\textgreater{}\ Sorted\ r\ a\ -\textgreater{}\ Sorted\ n\ a}.
Haskell requires functions to be specialized at the place we actually \emph{use}
them, so this is no good. We would have to pattern match on \texttt{cmpNat} and
\texttt{LTI}/\texttt{EQI}/\texttt{GTI} in order to know how to specialize
\texttt{SCons}. So, we use \texttt{sConsMin} to wrap this up for clarity.

How did I know this? I basically tried writing it out the full messy way,
bringing in as much witnesses and pattern matching as I could, until I got it to
compile. Then I spent time factoring out the common parts until I got what we
have now!

Note that we use a feature called ``Type Abstractions'' to ``match on'' the
existential type variable \texttt{q} in the pattern \texttt{SCons\ @q\ y\ ys}.
Recall from the definition of \texttt{SCons} that the first type variable is the
minimum priority of the tail.

And just like that, we made our \texttt{insertSortedList} \emph{type-safe}! We
can no longer return an unsorted list: it always inserts sortedly, by
\emph{construction}, enforced by GHC. We did cheat a little with \texttt{error},
that was only because we used GHC's TypeNats\ldots if we used our own inductive
types, all unsafety can be avoided.

Let's write the function to \emph{merge} two sorted lists together. This is
essentially the merge step of a merge sort: take two lists, look at the head of
each one, cons the smaller of the two heads, then recurse.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{{-}{-} source: https://github.com/mstksg/inCode/tree/master/code{-}samples/type{-}levels/Level6.hs\#L78{-}L92}

\OtherTok{mergeSorted ::}
  \KeywordTok{forall}\NormalTok{ n m a}\OperatorTok{.}
\NormalTok{  (}\DataTypeTok{KnownNat}\NormalTok{ n, }\DataTypeTok{KnownNat}\NormalTok{ m) }\OtherTok{=\textgreater{}}
  \DataTypeTok{Sorted}\NormalTok{ n a }\OtherTok{{-}\textgreater{}}
  \DataTypeTok{Sorted}\NormalTok{ m a }\OtherTok{{-}\textgreater{}}
  \DataTypeTok{Sorted}\NormalTok{ (}\DataTypeTok{Min}\NormalTok{ n m) a}
\NormalTok{mergeSorted }\OtherTok{=}\NormalTok{ \textbackslash{}}\KeywordTok{case}
  \DataTypeTok{SSingle}\NormalTok{ x }\OtherTok{{-}\textgreater{}}\NormalTok{ insertSorted x}
  \DataTypeTok{SCons} \OperatorTok{@}\NormalTok{q x xs }\OtherTok{{-}\textgreater{}}\NormalTok{ \textbackslash{}}\KeywordTok{case}
    \DataTypeTok{SSingle}\NormalTok{ y }\OtherTok{{-}\textgreater{}} \KeywordTok{case}\NormalTok{ decideInsert }\OperatorTok{@}\NormalTok{n }\OperatorTok{@}\NormalTok{m }\KeywordTok{of}
      \DataTypeTok{DIZ} \OtherTok{{-}\textgreater{}}\NormalTok{ sConsMin }\OperatorTok{@}\NormalTok{q }\OperatorTok{@}\NormalTok{m x (mergeSorted xs (}\DataTypeTok{SSingle}\NormalTok{ y))}
      \DataTypeTok{DIS} \OtherTok{{-}\textgreater{}} \DataTypeTok{SCons}\NormalTok{ y (}\DataTypeTok{SCons}\NormalTok{ x xs)}
    \DataTypeTok{SCons} \OperatorTok{@}\NormalTok{r y ys }\OtherTok{{-}\textgreater{}} \KeywordTok{case}\NormalTok{ decideInsert }\OperatorTok{@}\NormalTok{n }\OperatorTok{@}\NormalTok{m }\KeywordTok{of}
      \DataTypeTok{DIZ} \OtherTok{{-}\textgreater{}}\NormalTok{ sConsMin }\OperatorTok{@}\NormalTok{q }\OperatorTok{@}\NormalTok{m x (mergeSorted xs (}\DataTypeTok{SCons}\NormalTok{ y ys))}
      \DataTypeTok{DIS} \OtherTok{{-}\textgreater{}}\NormalTok{ sConsMin }\OperatorTok{@}\NormalTok{n }\OperatorTok{@}\NormalTok{r y (mergeSorted (}\DataTypeTok{SCons}\NormalTok{ x xs) ys)}
\end{Highlighting}
\end{Shaded}

Again, this looks a lot like how you would write the normal function to merge
two sorted lists\ldots except this time, it's type-safe! You \emph{can't} return
an unsorted list because the result list has to be sorted \emph{by
construction}.

To wrap it all up, let's write our conversion functions. First, an
\texttt{insertionSort} function that takes a normal non-empty list of
priority-value pairs and throws them all into a \texttt{Sorted}, which (by
construction) is guaranteed to be sorted:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{{-}{-} source: https://github.com/mstksg/inCode/tree/master/code{-}samples/type{-}levels/Level6.hs\#L107{-}L135}

\OtherTok{insertionSort ::}
  \KeywordTok{forall}\NormalTok{ a}\OperatorTok{.}
  \DataTypeTok{NonEmpty}\NormalTok{ (}\DataTypeTok{Natural}\NormalTok{, a) }\OtherTok{{-}\textgreater{}}
  \DataTypeTok{SomeSorted}\NormalTok{ a}
\NormalTok{insertionSort ((k0, x0) }\OperatorTok{:|}\NormalTok{ xs0) }\OtherTok{=}\NormalTok{ withSomeSNat k0 \textbackslash{}(}\DataTypeTok{SNat} \OperatorTok{@}\NormalTok{k) }\OtherTok{{-}\textgreater{}}
\NormalTok{  go xs0 (}\DataTypeTok{SomeSorted}\NormalTok{ (}\DataTypeTok{SSingle}\NormalTok{ (}\DataTypeTok{Entry} \OperatorTok{@}\NormalTok{k x0)))}
  \KeywordTok{where}
\OtherTok{    go ::}\NormalTok{ [(}\DataTypeTok{Natural}\NormalTok{, a)] }\OtherTok{{-}\textgreater{}} \DataTypeTok{SomeSorted}\NormalTok{ a }\OtherTok{{-}\textgreater{}} \DataTypeTok{SomeSorted}\NormalTok{ a}
\NormalTok{    go [] }\OtherTok{=} \FunctionTok{id}
\NormalTok{    go ((k, x) }\OperatorTok{:}\NormalTok{ xs) }\OtherTok{=}\NormalTok{ \textbackslash{}}\KeywordTok{case}
      \DataTypeTok{SomeSorted} \OperatorTok{@}\NormalTok{\_ }\OperatorTok{@}\NormalTok{n ys }\OtherTok{{-}\textgreater{}}\NormalTok{ withSomeSNat k \textbackslash{}(}\DataTypeTok{SNat} \OperatorTok{@}\NormalTok{k) }\OtherTok{{-}\textgreater{}}
\NormalTok{        go xs }\OperatorTok{$}
\NormalTok{          someSortedMin }\OperatorTok{@}\NormalTok{k }\OperatorTok{@}\NormalTok{n }\OperatorTok{$}
\NormalTok{            insertSorted (}\DataTypeTok{Entry} \OperatorTok{@}\NormalTok{k x) ys}

\OtherTok{someSortedMin ::}
  \KeywordTok{forall}\NormalTok{ n m a}\OperatorTok{.}
\NormalTok{  (}\DataTypeTok{KnownNat}\NormalTok{ n, }\DataTypeTok{KnownNat}\NormalTok{ m) }\OtherTok{=\textgreater{}}
  \DataTypeTok{Sorted}\NormalTok{ (}\DataTypeTok{Min}\NormalTok{ n m) a }\OtherTok{{-}\textgreater{}}
  \DataTypeTok{SomeSorted}\NormalTok{ a}
\NormalTok{someSortedMin }\OtherTok{=} \KeywordTok{case}\NormalTok{ cmpNat (}\DataTypeTok{Proxy} \OperatorTok{@}\NormalTok{n) (}\DataTypeTok{Proxy} \OperatorTok{@}\NormalTok{m) }\KeywordTok{of}
  \DataTypeTok{LTI} \OtherTok{{-}\textgreater{}} \DataTypeTok{SomeSorted}
  \DataTypeTok{EQI} \OtherTok{{-}\textgreater{}} \DataTypeTok{SomeSorted}
  \DataTypeTok{GTI} \OtherTok{{-}\textgreater{}} \DataTypeTok{SomeSorted}
\end{Highlighting}
\end{Shaded}

Some things to note:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  We're using the
  \href{https://hackage.haskell.org/package/base/docs/Data-List-NonEmpty.html}{nonempty
  list type} type from \emph{base}, because \texttt{Sorted} always has at least
  one element.
\item
  We use \texttt{withSomeSNat} to turn a \texttt{Natural} into the type-level
  \texttt{n\ ::\ Nat}, the same way we wrote \texttt{withVec} earlier. This is
  just just the function that GHC offers to reify a \texttt{Natural}
  (non-negative \texttt{Integer}) to the type level.
\item
  \texttt{someSortedMin} is used to clean up the implementation, doing the same
  job that \texttt{sConsMin} did.
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ghci}\OperatorTok{\textgreater{}} \KeywordTok{case}\NormalTok{ insertionSort ((}\DecValTok{4}\NormalTok{, }\CharTok{\textquotesingle{}a\textquotesingle{}}\NormalTok{) }\OperatorTok{:|}\NormalTok{ [(}\DecValTok{3}\NormalTok{, }\CharTok{\textquotesingle{}b\textquotesingle{}}\NormalTok{), (}\DecValTok{5}\NormalTok{, }\CharTok{\textquotesingle{}c\textquotesingle{}}\NormalTok{), (}\DecValTok{4}\NormalTok{, }\CharTok{\textquotesingle{}d\textquotesingle{}}\NormalTok{)]) }\KeywordTok{of}
          \DataTypeTok{SomeSorted}\NormalTok{ xs }\OtherTok{{-}\textgreater{}} \FunctionTok{print}\NormalTok{ xs}
\DataTypeTok{SCons} \DataTypeTok{Entry} \OperatorTok{@}\DecValTok{3} \CharTok{\textquotesingle{}b\textquotesingle{}}\NormalTok{ (}\DataTypeTok{SCons} \DataTypeTok{Entry} \OperatorTok{@}\DecValTok{4} \CharTok{\textquotesingle{}d\textquotesingle{}}\NormalTok{ (}\DataTypeTok{SCons} \DataTypeTok{Entry} \OperatorTok{@}\DecValTok{4} \CharTok{\textquotesingle{}a\textquotesingle{}}\NormalTok{ (}\DataTypeTok{SSingle} \DataTypeTok{Entry} \OperatorTok{@}\DecValTok{5} \CharTok{\textquotesingle{}c\textquotesingle{}}\NormalTok{)))}
\end{Highlighting}
\end{Shaded}

Finally, a function to convert back down to a normal non-empty list, using GHC's
\texttt{natVal} to ``demote'' a type-level \texttt{n\ ::\ Nat} to a
\texttt{Natural}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{{-}{-} source: https://github.com/mstksg/inCode/tree/master/code{-}samples/type{-}levels/Level6.hs\#L137{-}L140}

\OtherTok{fromSorted ::} \KeywordTok{forall}\NormalTok{ n a}\OperatorTok{.} \DataTypeTok{KnownNat}\NormalTok{ n }\OtherTok{=\textgreater{}} \DataTypeTok{Sorted}\NormalTok{ n a }\OtherTok{{-}\textgreater{}} \DataTypeTok{NonEmpty}\NormalTok{ (}\DataTypeTok{Natural}\NormalTok{, a)}
\NormalTok{fromSorted }\OtherTok{=}\NormalTok{ \textbackslash{}}\KeywordTok{case}
  \DataTypeTok{SSingle}\NormalTok{ (}\DataTypeTok{Entry}\NormalTok{ x) }\OtherTok{{-}\textgreater{}}\NormalTok{ (natVal (}\DataTypeTok{Proxy} \OperatorTok{@}\NormalTok{n), x) }\OperatorTok{:|}\NormalTok{ []}
  \DataTypeTok{SCons}\NormalTok{ (}\DataTypeTok{Entry}\NormalTok{ x) xs }\OtherTok{{-}\textgreater{}}\NormalTok{ (natVal (}\DataTypeTok{Proxy} \OperatorTok{@}\NormalTok{n), x) }\OperatorTok{NE.\textless{}|}\NormalTok{ fromSorted xs}
\end{Highlighting}
\end{Shaded}

\section{Level 7: Global structure Enforced
List}\label{level-7-global-structure-enforced-list}

\emph{\href{https://github.com/mstksg/inCode/tree/master/code-samples/type-levels/Level7.hs}{Code
available here}}

For our final level, let's imagine a ``weighted list'' of \texttt{(Int,\ a)}
pairs, where each item \texttt{a} has an associated weight or cost. Then,
imagine a ``bounded weighted list'', where the \emph{total cost} must not exceed
some limit value. Think of it as a list of files and their sizes and a maximum
total file size, or a backpack for a character in a video game with a maximum
total carrying weight.

There is a fundamental difference here between this type and our last type: we
want to enforce a \emph{global} invariant (total cannot exceed a limit), and we
can't ``fake'' this using local invariants like last time.

Introducing level 7: enforcing \emph{global} structure! This brings some extra
complexities, similar to the ones we encountered in Level 5 with our
fixed-length lists: whatever phantom type we use to enforce this ``global''
invariant now becomes entangled to the overall structure of our data type
itself.

Let's re-use our \texttt{Entry} type, but interpret an \texttt{Entry\ n\ a} as a
value of type \texttt{a} with a weight \texttt{n}. Now, we'll again ``let
McBride be our guide'' and ask the same question we asked before: what
``type-safe'' operation do we want, and what minimal phantom types do we need to
allow this type-safe operation? In our case, we want to \emph{insert} into our
bounded weighted list in a safe way, to ensure that there is enough room. So, we
need \emph{two} phantom types:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  One phantom type \texttt{lim} to establish the maximum weight of our container
\item
  Another phantom type \texttt{n} to establish the current used capacity of our
  container.
\end{enumerate}

We want \texttt{Bounded\ lim\ n\ a}:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{{-}{-} source: https://github.com/mstksg/inCode/tree/master/code{-}samples/type{-}levels/Level7.hs\#L24{-}L31}

\KeywordTok{data} \DataTypeTok{Bounded}\OtherTok{ ::} \DataTypeTok{Nat} \OtherTok{{-}\textgreater{}} \DataTypeTok{Nat} \OtherTok{{-}\textgreater{}} \DataTypeTok{Type} \OtherTok{{-}\textgreater{}} \DataTypeTok{Type} \KeywordTok{where}
  \DataTypeTok{BNil}\OtherTok{ ::} \DataTypeTok{Bounded}\NormalTok{ lim }\DecValTok{0}\NormalTok{ a}
  \DataTypeTok{BCons} \OtherTok{::}
    \KeywordTok{forall}\NormalTok{ n m lim a}\OperatorTok{.}
\NormalTok{    (}\DataTypeTok{KnownNat}\NormalTok{ m, n }\OperatorTok{+}\NormalTok{ m }\OperatorTok{\textless{}=}\NormalTok{ lim) }\OtherTok{=\textgreater{}}
    \DataTypeTok{Entry}\NormalTok{ n a }\OtherTok{{-}\textgreater{}}
    \DataTypeTok{Bounded}\NormalTok{ lim m a }\OtherTok{{-}\textgreater{}}
    \DataTypeTok{Bounded}\NormalTok{ lim (n }\OperatorTok{+}\NormalTok{ m) a}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  The empty bounded container \texttt{BNil\ ::\ lim\ 0\ a} can satisfy
  \emph{any} \texttt{lim}, and has weight 0.
\item
  If we have a \texttt{Bounded\ lim\ m\ a}, then we can add an
  \texttt{Entry\ n\ a} to get a \texttt{Bounded\ lim\ (m\ +\ n)\ a} provided
  that \texttt{m\ +\ n\ \textless{}=\ lim} using \texttt{BCons}.
\end{itemize}

Let's try this out by seeing how the end user would ``maybe insert'' into a
bounded list of it had enough capacity:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{{-}{-} source: https://github.com/mstksg/inCode/tree/master/code{-}samples/type{-}levels/Level7.hs\#L133{-}L145}

\KeywordTok{data} \DataTypeTok{SomeBounded}\OtherTok{ ::} \DataTypeTok{Nat} \OtherTok{{-}\textgreater{}} \DataTypeTok{Type} \OtherTok{{-}\textgreater{}} \DataTypeTok{Type} \KeywordTok{where}
  \DataTypeTok{SomeBounded}\OtherTok{ ::} \DataTypeTok{KnownNat}\NormalTok{ n }\OtherTok{=\textgreater{}} \DataTypeTok{Bounded}\NormalTok{ lim n a }\OtherTok{{-}\textgreater{}} \DataTypeTok{SomeBounded}\NormalTok{ lim a}

\OtherTok{insertSomeBounded ::}
  \KeywordTok{forall}\NormalTok{ lim n a}\OperatorTok{.}
\NormalTok{  (}\DataTypeTok{KnownNat}\NormalTok{ lim, }\DataTypeTok{KnownNat}\NormalTok{ n) }\OtherTok{=\textgreater{}}
  \DataTypeTok{Entry}\NormalTok{ n a }\OtherTok{{-}\textgreater{}}
  \DataTypeTok{SomeBounded}\NormalTok{ lim a }\OtherTok{{-}\textgreater{}}
  \DataTypeTok{Maybe}\NormalTok{ (}\DataTypeTok{SomeBounded}\NormalTok{ lim a)}
\NormalTok{insertSomeBounded x (}\DataTypeTok{SomeBounded} \OperatorTok{@}\NormalTok{m xs) }\OtherTok{=} \KeywordTok{case}\NormalTok{ cmpNat (}\DataTypeTok{Proxy} \OperatorTok{@}\NormalTok{(n }\OperatorTok{+}\NormalTok{ m)) (}\DataTypeTok{Proxy} \OperatorTok{@}\NormalTok{lim) }\KeywordTok{of}
  \DataTypeTok{LTI} \OtherTok{{-}\textgreater{}} \DataTypeTok{Just} \OperatorTok{$} \DataTypeTok{SomeBounded}\NormalTok{ (}\DataTypeTok{BCons}\NormalTok{ x xs)}
  \DataTypeTok{EQI} \OtherTok{{-}\textgreater{}} \DataTypeTok{Just} \OperatorTok{$} \DataTypeTok{SomeBounded}\NormalTok{ (}\DataTypeTok{BCons}\NormalTok{ x xs)}
  \DataTypeTok{GTI} \OtherTok{{-}\textgreater{}} \DataTypeTok{Nothing}
\end{Highlighting}
\end{Shaded}

First we match on the \texttt{SomeBounded} to see what the current capacity
\texttt{m} is. Then we check using \texttt{cmpNat} to see if the
\texttt{Bounded} can hold \texttt{m\ +\ n}. If it does, we can return
successfully. Note that we define \texttt{SomeBounded} using GADT syntax so we
can precisely control the order of the type variables, so
\texttt{SomeBounded\ @m\ xs} binds \texttt{m} to the capacity of the inner list.

Remember in this case that the \emph{end user} here isn't necessarily using the
phantom types to their advantage (except for \texttt{lim}, which could be
useful). Instead, it's \emph{us} who is going to be using \texttt{n} to ensure
that if we ever \emph{create} any \texttt{Bounded} (or \texttt{SomeBounded}), it
will \emph{always} be within capacity \emph{by construction}.

Now that the usage makes sense, let's jump in and write some type-safe functions
using our fancy phantom types!

First, let's notice that we can always ``resize'' our
\texttt{Bounded\ lim\ n\ a} to a \texttt{Bounded\ lim\textquotesingle{}\ n\ a}
as long as the total usage \texttt{n} fits within the new carrying capacity:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{{-}{-} source: https://github.com/mstksg/inCode/tree/master/code{-}samples/type{-}levels/Level7.hs\#L35{-}L38}

\OtherTok{reBounded ::} \KeywordTok{forall}\NormalTok{ lim lim\textquotesingle{} n a}\OperatorTok{.}\NormalTok{ n }\OperatorTok{\textless{}=}\NormalTok{ lim\textquotesingle{} }\OtherTok{=\textgreater{}} \DataTypeTok{Bounded}\NormalTok{ lim n a }\OtherTok{{-}\textgreater{}} \DataTypeTok{Bounded}\NormalTok{ lim\textquotesingle{} n a}
\NormalTok{reBounded }\OtherTok{=}\NormalTok{ \textbackslash{}}\KeywordTok{case}
  \DataTypeTok{BNil} \OtherTok{{-}\textgreater{}} \DataTypeTok{BNil}
  \DataTypeTok{BCons}\NormalTok{ x xs }\OtherTok{{-}\textgreater{}} \DataTypeTok{BCons}\NormalTok{ x (reBounded xs)}
\end{Highlighting}
\end{Shaded}

Note that we have full type safety here! GHC will prevent us from using
\texttt{reBounded} if we pick a new \texttt{lim} that is \emph{less} than what
the bag currently weighs! You'll also see the general pattern here that changing
any ``global'' properties for our type here will require recursing over the
entire structure to adjust the global property.

How about a function to combine two bags of the same weight? Well, this should
be legal as long as the new combined weight is still within the limit:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{{-}{-} source: https://github.com/mstksg/inCode/tree/master/code{-}samples/type{-}levels/Level7.hs\#L48{-}L56}

\OtherTok{concatBounded ::}
  \KeywordTok{forall}\NormalTok{ n m lim a}\OperatorTok{.}
\NormalTok{  (}\DataTypeTok{KnownNat}\NormalTok{ n, }\DataTypeTok{KnownNat}\NormalTok{ m, }\DataTypeTok{KnownNat}\NormalTok{ lim, n }\OperatorTok{+}\NormalTok{ m }\OperatorTok{\textless{}=}\NormalTok{ lim) }\OtherTok{=\textgreater{}}
  \DataTypeTok{Bounded}\NormalTok{ lim n a }\OtherTok{{-}\textgreater{}}
  \DataTypeTok{Bounded}\NormalTok{ lim m a }\OtherTok{{-}\textgreater{}}
  \DataTypeTok{Bounded}\NormalTok{ lim (n }\OperatorTok{+}\NormalTok{ m) a}
\NormalTok{concatBounded }\OtherTok{=}\NormalTok{ \textbackslash{}}\KeywordTok{case}
  \DataTypeTok{BNil} \OtherTok{{-}\textgreater{}} \FunctionTok{id}
  \DataTypeTok{BCons} \OperatorTok{@}\NormalTok{x }\OperatorTok{@}\NormalTok{xs x xs }\OtherTok{{-}\textgreater{}} \DataTypeTok{BCons}\NormalTok{ x }\OperatorTok{.}\NormalTok{ concatBounded xs}
\end{Highlighting}
\end{Shaded}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\textbf{Aside}

This is completely unrelated to the topic at hand, but if you're a big nerd like
me, you might enjoy the fact that this function makes
\texttt{Bounded\ lim\ n\ a} the \emph{arrows} of a
\href{https://ncatlab.org/nlab/show/category}{Category} whose \emph{objects} are
the natural numbers less than or equal to \texttt{lim}, the identity arrow is
\texttt{BNil}, and arrow composition is \texttt{concatBounded}. Between object
\texttt{n} and \texttt{m}, if \texttt{n\ \textless{}=\ m}, its arrows are values
of type \texttt{Bounded\ lim\ (m\ -\ n)\ a}. Actually wait, it's the same thing
with \texttt{Vec} and \texttt{vconcat} above isn't it? I guess we were moving so
fast that I didn't have time to realize it.

Anyway this is related to the
\href{https://ncatlab.org/nlab/show/preorder}{preorder category}, but not thin.
A thicc preorder category, if you will. Always nice to spot a category out there
in the wild.

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

It should be noted that the reason that \texttt{reBounded} and
\texttt{concatBounded} look so clean so fresh is that we are heavily leveraging
typechecker plugins. But, these are all still possible with normal functions if
we construct the witnesses explicitly.

Now for a function within our business logic, let's write \texttt{takeBounded},
which \emph{constricts} a \texttt{Bounded\ lim\ n\ a} to a
\texttt{Bounded\ lim\textquotesingle{}\ q\ a} with a smaller limit
\texttt{lim\textquotesingle{}}, where \texttt{q} is the weight of \emph{all of
the elements that fit in the new limit}. For example, if we had a bag of limit
15 containing items weighing 4, 3, and 5 (total 12), but we wanted to
\texttt{takeBounded} with a new limit 10, we would take the 4 and 3 items, but
leave behind the 5 item, to get a new total weight of 7.

It'd be nice to have a helper data type to existentially wrap the new \texttt{q}
weight in our return type:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{{-}{-} source: https://github.com/mstksg/inCode/tree/master/code{-}samples/type{-}levels/Level7.hs\#L113{-}L118}

\KeywordTok{data} \DataTypeTok{TakeBounded}\OtherTok{ ::} \DataTypeTok{Nat} \OtherTok{{-}\textgreater{}} \DataTypeTok{Nat} \OtherTok{{-}\textgreater{}} \DataTypeTok{Type} \OtherTok{{-}\textgreater{}} \DataTypeTok{Type} \KeywordTok{where}
  \DataTypeTok{TakeBounded} \OtherTok{::}
    \KeywordTok{forall}\NormalTok{ q lim n a}\OperatorTok{.}
\NormalTok{    (}\DataTypeTok{KnownNat}\NormalTok{ q, q }\OperatorTok{\textless{}=}\NormalTok{ n) }\OtherTok{=\textgreater{}}
    \DataTypeTok{Bounded}\NormalTok{ lim q a }\OtherTok{{-}\textgreater{}}
    \DataTypeTok{TakeBounded}\NormalTok{ lim n a}
\end{Highlighting}
\end{Shaded}

So the type of \texttt{takeBounded} would be:

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{takeBounded ::}
\NormalTok{  (}\DataTypeTok{KnownNat}\NormalTok{ lim, }\DataTypeTok{KnownNat}\NormalTok{ lim\textquotesingle{}, }\DataTypeTok{KnownNat}\NormalTok{ n) }\OtherTok{=\textgreater{}}
  \DataTypeTok{Bounded}\NormalTok{ lim n a }\OtherTok{{-}\textgreater{}}
  \DataTypeTok{TakeBounded}\NormalTok{ lim\textquotesingle{} n a}
\end{Highlighting}
\end{Shaded}

Again I'm going to introduce some helper functions that will make sense soon:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{{-}{-} source: https://github.com/mstksg/inCode/tree/master/code{-}samples/type{-}levels/Level7.hs\#L40{-}L46}

\OtherTok{bConsExpand ::} \DataTypeTok{KnownNat}\NormalTok{ m }\OtherTok{=\textgreater{}} \DataTypeTok{Entry}\NormalTok{ n a }\OtherTok{{-}\textgreater{}} \DataTypeTok{Bounded}\NormalTok{ lim m a }\OtherTok{{-}\textgreater{}} \DataTypeTok{Bounded}\NormalTok{ (n }\OperatorTok{+}\NormalTok{ lim) (n }\OperatorTok{+}\NormalTok{ m) a}
\NormalTok{bConsExpand x xs }\OtherTok{=}\NormalTok{ withBoundedWit xs }\OperatorTok{$} \DataTypeTok{BCons}\NormalTok{ x (reBounded xs)}

\OtherTok{withBoundedWit ::} \DataTypeTok{Bounded}\NormalTok{ lim n a }\OtherTok{{-}\textgreater{}}\NormalTok{ (n }\OperatorTok{\textless{}=}\NormalTok{ lim }\OtherTok{=\textgreater{}}\NormalTok{ r) }\OtherTok{{-}\textgreater{}}\NormalTok{ r}
\NormalTok{withBoundedWit }\OtherTok{=}\NormalTok{ \textbackslash{}}\KeywordTok{case}
  \DataTypeTok{BNil} \OtherTok{{-}\textgreater{}}\NormalTok{ \textbackslash{}x }\OtherTok{{-}\textgreater{}}\NormalTok{ x}
  \DataTypeTok{BCons}\NormalTok{ \_ \_ }\OtherTok{{-}\textgreater{}}\NormalTok{ \textbackslash{}x }\OtherTok{{-}\textgreater{}}\NormalTok{ x}
\end{Highlighting}
\end{Shaded}

From the type, we can see \texttt{bCons} adds a new item while also increasing
the limit:
\texttt{bConsExpand\ ::\ Entry\ n\ a\ -\textgreater{}\ Bounded\ lim\ m\ a\ -\textgreater{}\ Bounded\ (n\ +\ lim)\ (n\ +\ m)\ a}.
This is always safe conceptually because we can always add a new item into any
bag if we increase the limit of the bag:
\texttt{Entry\ 100\ a\ -\textgreater{}\ Bounded\ 5\ 3\ a\ -\textgreater{}\ Bounded\ 105\ 103\ a},
for instance.

Next, you'll notice that if we write this as \texttt{BCons\ x\ (reBounded\ xs)}
alone, we'll get a GHC error complaining that this requires
\texttt{m\ \textless{}=\ lim}. This is something that we \emph{know} has to be
true (by construction), since there isn't any constructor of \texttt{Bounded}
that will give us a total weight \texttt{m} bigger than the limit \texttt{lim}.
However, this requires a bit of witness manipulation for GHC to \emph{know}
this: we have to essentially enumerate over every constructor, and within each
constructor GHC knows that \texttt{m\ \textless{}=\ lim} holds. This is what
\texttt{withBoundedWit} does. We ``know'' \texttt{n\ \textless{}=\ lim}, we just
need to enumerate over the constructors of \texttt{Bounded\ lim\ n\ a} so GHC is
happy in every case.

\texttt{withBoundedWit}'s type might be a little confusing if this is the first
time you've seen an argument of the form
\texttt{(constraint\ =\textgreater{}\ r)}: it takes a
\texttt{Bounded\ lim\ n\ a} and a ``value that is only possible if
\texttt{n\ \textless{}=\ lim}'', and then gives you that value.

With that, we're ready:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{{-}{-} source: https://github.com/mstksg/inCode/tree/master/code{-}samples/type{-}levels/Level7.hs\#L120{-}L131}

\OtherTok{takeBounded ::}
  \KeywordTok{forall}\NormalTok{ lim lim\textquotesingle{} n a}\OperatorTok{.}
\NormalTok{  (}\DataTypeTok{KnownNat}\NormalTok{ lim, }\DataTypeTok{KnownNat}\NormalTok{ lim\textquotesingle{}, }\DataTypeTok{KnownNat}\NormalTok{ n) }\OtherTok{=\textgreater{}}
  \DataTypeTok{Bounded}\NormalTok{ lim n a }\OtherTok{{-}\textgreater{}}
  \DataTypeTok{TakeBounded}\NormalTok{ lim\textquotesingle{} n a}
\NormalTok{takeBounded }\OtherTok{=}\NormalTok{ \textbackslash{}}\KeywordTok{case}
  \DataTypeTok{BNil} \OtherTok{{-}\textgreater{}} \DataTypeTok{TakeBounded} \DataTypeTok{BNil}
  \DataTypeTok{BCons} \OperatorTok{@}\NormalTok{x }\OperatorTok{@}\NormalTok{xs x xs }\OtherTok{{-}\textgreater{}} \KeywordTok{case}\NormalTok{ cmpNat (}\DataTypeTok{Proxy} \OperatorTok{@}\NormalTok{x) (}\DataTypeTok{Proxy} \OperatorTok{@}\NormalTok{lim\textquotesingle{}) }\KeywordTok{of}
    \DataTypeTok{LTI} \OtherTok{{-}\textgreater{}} \KeywordTok{case}\NormalTok{ takeBounded }\OperatorTok{@}\NormalTok{lim }\OperatorTok{@}\NormalTok{(lim\textquotesingle{} }\OperatorTok{{-}}\NormalTok{ x) xs }\KeywordTok{of}
      \DataTypeTok{TakeBounded} \OperatorTok{@}\NormalTok{q ys }\OtherTok{{-}\textgreater{}} \DataTypeTok{TakeBounded} \OperatorTok{@}\NormalTok{(x }\OperatorTok{+}\NormalTok{ q) (bConsExpand x ys)}
    \DataTypeTok{EQI} \OtherTok{{-}\textgreater{}} \DataTypeTok{TakeBounded}\NormalTok{ (}\DataTypeTok{BCons}\NormalTok{ x }\DataTypeTok{BNil}\NormalTok{)}
    \DataTypeTok{GTI} \OtherTok{{-}\textgreater{}} \DataTypeTok{TakeBounded} \DataTypeTok{BNil}
\end{Highlighting}
\end{Shaded}

Thanks to the types, we ensure that the returned bag must contain \emph{at most}
\texttt{lim\textquotesingle{}}!

As an exercise, try writing \texttt{splitBounded}, which is like
\texttt{takeBounded} but also returns the items that were leftover.
\href{https://github.com/mstksg/inCode/tree/master/code-samples/type-levels/Level7.hs\#L99-L111}{Solution
here.}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{{-}{-} source: https://github.com/mstksg/inCode/tree/master/code{-}samples/type{-}levels/Level7.hs\#L91{-}L103}

\KeywordTok{data} \DataTypeTok{SplitBounded}\OtherTok{ ::} \DataTypeTok{Nat} \OtherTok{{-}\textgreater{}} \DataTypeTok{Nat} \OtherTok{{-}\textgreater{}} \DataTypeTok{Nat} \OtherTok{{-}\textgreater{}} \DataTypeTok{Type} \OtherTok{{-}\textgreater{}} \DataTypeTok{Type} \KeywordTok{where}
  \DataTypeTok{SplitBounded} \OtherTok{::}
    \KeywordTok{forall}\NormalTok{ q lim lim\textquotesingle{} n a}\OperatorTok{.}
\NormalTok{    (}\DataTypeTok{KnownNat}\NormalTok{ q, q }\OperatorTok{\textless{}=}\NormalTok{ n) }\OtherTok{=\textgreater{}}
    \DataTypeTok{Bounded}\NormalTok{ lim\textquotesingle{} q a }\OtherTok{{-}\textgreater{}}
    \DataTypeTok{Bounded}\NormalTok{ lim (n }\OperatorTok{{-}}\NormalTok{ q) a }\OtherTok{{-}\textgreater{}}
    \DataTypeTok{SplitBounded}\NormalTok{ lim lim\textquotesingle{} n a}

\OtherTok{splitBounded ::}
  \KeywordTok{forall}\NormalTok{ lim lim\textquotesingle{} n a}\OperatorTok{.}
\NormalTok{  (}\DataTypeTok{KnownNat}\NormalTok{ lim, }\DataTypeTok{KnownNat}\NormalTok{ lim\textquotesingle{}, }\DataTypeTok{KnownNat}\NormalTok{ n) }\OtherTok{=\textgreater{}}
  \DataTypeTok{Bounded}\NormalTok{ lim n a }\OtherTok{{-}\textgreater{}}
  \DataTypeTok{SplitBounded}\NormalTok{ lim lim\textquotesingle{} n a}
\end{Highlighting}
\end{Shaded}

One final example, how about a function that \emph{reverses} the
\texttt{Bounded\ lim\ n\ a}? We're going to write a ``single-pass reverse'',
similar to how it's often written for lists:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{{-}{-} source: https://github.com/mstksg/inCode/tree/master/code{-}samples/type{-}levels/Level7.hs\#L68{-}L73}

\OtherTok{reverseList ::}\NormalTok{ [a] }\OtherTok{{-}\textgreater{}}\NormalTok{ [a]}
\NormalTok{reverseList }\OtherTok{=}\NormalTok{ go []}
  \KeywordTok{where}
\NormalTok{    go res }\OtherTok{=}\NormalTok{ \textbackslash{}}\KeywordTok{case}
\NormalTok{      [] }\OtherTok{{-}\textgreater{}}\NormalTok{ res}
\NormalTok{      x }\OperatorTok{:}\NormalTok{ xs }\OtherTok{{-}\textgreater{}}\NormalTok{ go (x }\OperatorTok{:}\NormalTok{ res) xs}
\end{Highlighting}
\end{Shaded}

Now, reversing a \texttt{Bounded} should be legal, because reversing the order
of the items shouldn't change the total weight. However, we basically ``invert''
the structure of the \texttt{Bounded} type, which, depending on how we set up
our phantom types, could mean a lot of witness reshuffling. Luckily, our
typechecker plugin handles most of it for us in this case, but it exposes one
gap:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{{-}{-} source: https://github.com/mstksg/inCode/tree/master/code{-}samples/type{-}levels/Level7.hs\#L58{-}L89}

\OtherTok{reverseBounded ::}
  \KeywordTok{forall}\NormalTok{ lim n a}\OperatorTok{.}\NormalTok{ (n }\OperatorTok{\textless{}=}\NormalTok{ lim, }\DataTypeTok{KnownNat}\NormalTok{ lim, }\DataTypeTok{KnownNat}\NormalTok{ n) }\OtherTok{=\textgreater{}} \DataTypeTok{Bounded}\NormalTok{ lim n a }\OtherTok{{-}\textgreater{}} \DataTypeTok{Bounded}\NormalTok{ lim n a}
\NormalTok{reverseBounded }\OtherTok{=}\NormalTok{ go }\DataTypeTok{BNil}
  \KeywordTok{where}
\OtherTok{    go ::}
      \KeywordTok{forall}\NormalTok{ m q}\OperatorTok{.}
\NormalTok{      (}\DataTypeTok{KnownNat}\NormalTok{ m, }\DataTypeTok{KnownNat}\NormalTok{ q, m }\OperatorTok{\textless{}=}\NormalTok{ lim, m }\OperatorTok{+}\NormalTok{ q }\OperatorTok{\textless{}=}\NormalTok{ lim) }\OtherTok{=\textgreater{}}
      \DataTypeTok{Bounded}\NormalTok{ lim m a }\OtherTok{{-}\textgreater{}}
      \DataTypeTok{Bounded}\NormalTok{ lim q a }\OtherTok{{-}\textgreater{}}
      \DataTypeTok{Bounded}\NormalTok{ lim (m }\OperatorTok{+}\NormalTok{ q) a}
\NormalTok{    go res }\OtherTok{=}\NormalTok{ \textbackslash{}}\KeywordTok{case}
      \DataTypeTok{BNil} \OtherTok{{-}\textgreater{}}\NormalTok{ res}
      \DataTypeTok{BCons} \OperatorTok{@}\NormalTok{x }\OperatorTok{@}\NormalTok{xs x xs }\OtherTok{{-}\textgreater{}}
\NormalTok{        solveLte }\OperatorTok{@}\NormalTok{m }\OperatorTok{@}\NormalTok{q }\OperatorTok{@}\NormalTok{x }\OperatorTok{@}\NormalTok{lim }\OperatorTok{$}
\NormalTok{          go }\OperatorTok{@}\NormalTok{(x }\OperatorTok{+}\NormalTok{ m) }\OperatorTok{@}\NormalTok{xs (}\DataTypeTok{BCons} \OperatorTok{@}\NormalTok{x }\OperatorTok{@}\NormalTok{m x res) xs}

\OtherTok{solveLte ::}
  \KeywordTok{forall}\NormalTok{ a b c n r}\OperatorTok{.}
\NormalTok{  (}\DataTypeTok{KnownNat}\NormalTok{ a, }\DataTypeTok{KnownNat}\NormalTok{ c, }\DataTypeTok{KnownNat}\NormalTok{ n, a }\OperatorTok{+}\NormalTok{ b }\OperatorTok{\textless{}=}\NormalTok{ n, c }\OperatorTok{\textless{}=}\NormalTok{ b) }\OtherTok{=\textgreater{}}
\NormalTok{  (a }\OperatorTok{+}\NormalTok{ c }\OperatorTok{\textless{}=}\NormalTok{ n }\OtherTok{=\textgreater{}}\NormalTok{ r) }\OtherTok{{-}\textgreater{}}
\NormalTok{  r}
\NormalTok{solveLte x }\OtherTok{=} \KeywordTok{case}\NormalTok{ cmpNat (}\DataTypeTok{Proxy} \OperatorTok{@}\NormalTok{(a }\OperatorTok{+}\NormalTok{ c)) (}\DataTypeTok{Proxy} \OperatorTok{@}\NormalTok{n) }\KeywordTok{of}
  \DataTypeTok{LTI} \OtherTok{{-}\textgreater{}}\NormalTok{ x}
  \DataTypeTok{EQI} \OtherTok{{-}\textgreater{}}\NormalTok{ x}
  \DataTypeTok{GTI} \OtherTok{{-}\textgreater{}} \FunctionTok{error} \StringTok{"absurd: if a + b \textless{}= n and c \textless{} b, the a + c can\textquotesingle{}t \textgreater{} n"}
\end{Highlighting}
\end{Shaded}

Due to how everything gets exposed, we need to prove that if
\texttt{a\ +\ b\ \textless{}=\ n} and \texttt{c\ \textless{}=\ b}, then
\texttt{a\ +\ c\ \textless{}=\ n}. This is always true, but the typechecker
plugin needs a bit of help, and we have to resort to an unsafe operation to get
this to work. However, if we were using our manually constructed inductive types
instead of GHC's opaque ones, we could write this in a type-safe and total way.
We run into these kinds of issues a lot more often with global invariants than
we do with local invariants, because the invariant phantom becomes so entangled
with the structure of our data type.

And\ldots that's about as far as we're going to go with this final level! If
this type of programming with structural invariants is appealing to you, check
out Conor McBride's famous
\href{https://personal.cis.strath.ac.uk/conor.mcbride/Pivotal.pdf}{type-safe
red-black trees in Haskell} paper, or Edwin Brady's
\href{https://www.manning.com/books/type-driven-development-with-idris}{Type-Driven
Development in Idris} for how to structure entire programs around these
principles.

Evident from the fact that Conor's work is in Agda, and Brady's in Idris, you
can tell that in doing this, we are definitely pushing the boundaries of what is
ergonomic to write in Haskell. Well, depending on who you ask, we already zipped
that boundary long ago. Still, there's definitely a certain kind of joy to
defining invariants in your data types and then essentially \emph{proving} to
the compiler that you've followed them. But, most people will be happier just
writing a property test to fuzz the implementation on a non type-safe structure.
And some will be happy with\ldots unit tests. Ha ha ha ha. Good joke right?

Anyway, hope you enjoyed the ride! I hope you found some new ideas for ways to
write your code in the future, or at least found them interesting or
eye-opening. Again, none of the data structures here are presented to be
practically useful as-is --- the point is more to present these typing
principles and mechanics in a fun manner and to inspire a sense of wonder.

Which level is your favorite, and what level do you \emph{wish} you could work
at if things got a little more ergonomic?

\section{Special Thanks}\label{special-thanks}

I am very humbled to be supported by an amazing community, who make it possible
for me to devote time to researching and writing these posts. Very special
thanks to my supporter at the ``Amazing'' level on
\href{https://www.patreon.com/justinle/overview}{patreon}, Josh Vera! :)

\section{Signoff}\label{signoff}

Hi, thanks for reading! You can reach me via email at
\href{mailto:justin@jle.im}{\nolinkurl{justin@jle.im}}, or at twitter at
\href{https://twitter.com/mstk}{@mstk}! This post and all others are published
under the \href{https://creativecommons.org/licenses/by-nc-nd/3.0/}{CC-BY-NC-ND
3.0} license. Corrections and edits via pull request are welcome and encouraged
at \href{https://github.com/mstksg/inCode}{the source repository}.

If you feel inclined, or this post was particularly helpful for you, why not
consider \href{https://www.patreon.com/justinle/overview}{supporting me on
Patreon}, or a \href{bitcoin:3D7rmAYgbDnp4gp4rf22THsGt74fNucPDU}{BTC donation}?
:)

\textbackslash end\{document\}

\end{document}
