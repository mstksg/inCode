\documentclass[]{article}
\usepackage{lmodern}
\usepackage{amssymb,amsmath}
\usepackage{ifxetex,ifluatex}
\usepackage{fixltx2e} % provides \textsubscript
\ifnum 0\ifxetex 1\fi\ifluatex 1\fi=0 % if pdftex
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
\else % if luatex or xelatex
  \ifxetex
    \usepackage{mathspec}
    \usepackage{xltxtra,xunicode}
  \else
    \usepackage{fontspec}
  \fi
  \defaultfontfeatures{Mapping=tex-text,Scale=MatchLowercase}
  \newcommand{\euro}{€}
\fi
% use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
% use microtype if available
\IfFileExists{microtype.sty}{\usepackage{microtype}}{}
\usepackage[margin=1in]{geometry}
\usepackage{color}
\usepackage{fancyvrb}
\newcommand{\VerbBar}{|}
\newcommand{\VERB}{\Verb[commandchars=\\\{\}]}
\DefineVerbatimEnvironment{Highlighting}{Verbatim}{commandchars=\\\{\}}
% Add ',fontsize=\small' for more characters per line
\newenvironment{Shaded}{}{}
\newcommand{\AlertTok}[1]{\textcolor[rgb]{1.00,0.00,0.00}{\textbf{#1}}}
\newcommand{\AnnotationTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{#1}}}}
\newcommand{\AttributeTok}[1]{\textcolor[rgb]{0.49,0.56,0.16}{#1}}
\newcommand{\BaseNTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{#1}}
\newcommand{\BuiltInTok}[1]{\textcolor[rgb]{0.00,0.50,0.00}{#1}}
\newcommand{\CharTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand{\CommentTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textit{#1}}}
\newcommand{\CommentVarTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{#1}}}}
\newcommand{\ConstantTok}[1]{\textcolor[rgb]{0.53,0.00,0.00}{#1}}
\newcommand{\ControlFlowTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{#1}}}
\newcommand{\DataTypeTok}[1]{\textcolor[rgb]{0.56,0.13,0.00}{#1}}
\newcommand{\DecValTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{#1}}
\newcommand{\DocumentationTok}[1]{\textcolor[rgb]{0.73,0.13,0.13}{\textit{#1}}}
\newcommand{\ErrorTok}[1]{\textcolor[rgb]{1.00,0.00,0.00}{\textbf{#1}}}
\newcommand{\ExtensionTok}[1]{#1}
\newcommand{\FloatTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{#1}}
\newcommand{\FunctionTok}[1]{\textcolor[rgb]{0.02,0.16,0.49}{#1}}
\newcommand{\ImportTok}[1]{\textcolor[rgb]{0.00,0.50,0.00}{\textbf{#1}}}
\newcommand{\InformationTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{#1}}}}
\newcommand{\KeywordTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{#1}}}
\newcommand{\NormalTok}[1]{#1}
\newcommand{\OperatorTok}[1]{\textcolor[rgb]{0.40,0.40,0.40}{#1}}
\newcommand{\OtherTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{#1}}
\newcommand{\PreprocessorTok}[1]{\textcolor[rgb]{0.74,0.48,0.00}{#1}}
\newcommand{\RegionMarkerTok}[1]{#1}
\newcommand{\SpecialCharTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand{\SpecialStringTok}[1]{\textcolor[rgb]{0.73,0.40,0.53}{#1}}
\newcommand{\StringTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand{\VariableTok}[1]{\textcolor[rgb]{0.10,0.09,0.49}{#1}}
\newcommand{\VerbatimStringTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand{\WarningTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{#1}}}}
\usepackage{fancyvrb}
\ifxetex
  \usepackage[setpagesize=false, % page size defined by xetex
              unicode=false, % unicode breaks when used with xetex
              xetex]{hyperref}
\else
  \usepackage[unicode=true]{hyperref}
\fi
\hypersetup{breaklinks=true,
            bookmarks=true,
            pdfauthor={Justin Le},
            pdftitle={Enhancing Functor Structures Step-By-Step (Part 2)},
            colorlinks=true,
            citecolor=blue,
            urlcolor=blue,
            linkcolor=magenta,
            pdfborder={0 0 0}}
\urlstyle{same}  % don't use monospace font for urls
% Make links footnotes instead of hotlinks:
\renewcommand{\href}[2]{#2\footnote{\url{#1}}}
\setlength{\parindent}{0pt}
\setlength{\parskip}{6pt plus 2pt minus 1pt}
\setlength{\emergencystretch}{3em}  % prevent overfull lines
\setcounter{secnumdepth}{0}
\VerbatimFootnotes % allows verbatim text in footnotes

\title{Enhancing Functor Structures Step-By-Step (Part 2)}
\author{Justin Le}
\date{August 18, 2020}

\begin{document}
\maketitle

\emph{Originally posted on
\textbf{\href{https://blog.jle.im/entry/enhancing-functor-structures-step-by-step-2.html}{in
Code}}.}

\documentclass[]{}
\usepackage{lmodern}
\usepackage{amssymb,amsmath}
\usepackage{ifxetex,ifluatex}
\usepackage{fixltx2e} % provides \textsubscript
\ifnum 0\ifxetex 1\fi\ifluatex 1\fi=0 % if pdftex
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
\else % if luatex or xelatex
  \ifxetex
    \usepackage{mathspec}
    \usepackage{xltxtra,xunicode}
  \else
    \usepackage{fontspec}
  \fi
  \defaultfontfeatures{Mapping=tex-text,Scale=MatchLowercase}
  \newcommand{\euro}{€}
\fi
% use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
% use microtype if available
\IfFileExists{microtype.sty}{\usepackage{microtype}}{}
\usepackage[margin=1in]{geometry}
\ifxetex
  \usepackage[setpagesize=false, % page size defined by xetex
              unicode=false, % unicode breaks when used with xetex
              xetex]{hyperref}
\else
  \usepackage[unicode=true]{hyperref}
\fi
\hypersetup{breaklinks=true,
            bookmarks=true,
            pdfauthor={},
            pdftitle={},
            colorlinks=true,
            citecolor=blue,
            urlcolor=blue,
            linkcolor=magenta,
            pdfborder={0 0 0}}
\urlstyle{same}  % don't use monospace font for urls
% Make links footnotes instead of hotlinks:
\renewcommand{\href}[2]{#2\footnote{\url{#1}}}
\setlength{\parindent}{0pt}
\setlength{\parskip}{6pt plus 2pt minus 1pt}
\setlength{\emergencystretch}{3em}  % prevent overfull lines
\setcounter{secnumdepth}{0}

\textbackslash begin\{document\}

Welcome to Part 2 of the
\href{https://blog.jle.im/entries/series/+enhancing-functor-structures.html}{``Enhancing
Functor Structures'' series}! Here we are taking a base structure describing a
data type schema and enhancing it step-by-step with new functory capabilities:
first, covariant capabilities (to generate parsers), then contravariant
capabilities (to generate serializers)\ldots who knows what might be in store
next?

Please do check out
\href{https://blog.jle.im/entry/enhancing-functor-structures-step-by-step-1.html}{Part
1} if you haven't already, since this post pretty much jumps straight into
things!

\section{Parsing and Serializing
Invariantly}\label{parsing-and-serializing-invariantly}

As we left off our project, we had done three things:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Started with a simple ADT representing the structure we want to be able to
  express
\item
  Enhanced that simple ADT with Covariant Functor capabilities, in order to
  interpret it as a parser
\item
  Enhanced that original simple ADT with Contravariant Functor, in order to
  interpret it as a serializer.
\end{enumerate}

From this, it seems the next logical step would be to add \emph{both}
enhancements to the same structure!

There are some clear benefits to this --- on the surface, it means we only have
to write code once to get all three things (documentation, parsing, and
serialization). Less code means less bugs!

Even deeper, we can now ensure that our ``serialization'' and ``parsing''
functions are always ``in sync''. If we defined a separate process/type for
serializing and a separate process/type for parsing, then it's possible we might
accidentally make errors in keeping them in sync\ldots one might use a different
tag, or we might make changes to one but not the other during refactoring.
There's a good chance you have been bitten by situations where documentation
becomes out of sync with actual code.

\subsection{Adding Invariance}\label{adding-invariance}

Like before, the main thing we need to change at the fundamental level is
\texttt{Primitive}:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{{-}{-} source: https://github.com/mstksg/inCode/tree/master/code{-}samples/functor{-}structures/invariant.hs\#L39{-}L42}

\KeywordTok{data} \DataTypeTok{Primitive}\NormalTok{ a }\OtherTok{=}
      \DataTypeTok{PString}\NormalTok{ (a }\OtherTok{{-}\textgreater{}} \DataTypeTok{String}\NormalTok{)     (}\DataTypeTok{String}     \OtherTok{{-}\textgreater{}} \DataTypeTok{Maybe}\NormalTok{ a)}
    \OperatorTok{|} \DataTypeTok{PNumber}\NormalTok{ (a }\OtherTok{{-}\textgreater{}} \DataTypeTok{Scientific}\NormalTok{) (}\DataTypeTok{Scientific} \OtherTok{{-}\textgreater{}} \DataTypeTok{Maybe}\NormalTok{ a)}
    \OperatorTok{|} \DataTypeTok{PBool}\NormalTok{   (a }\OtherTok{{-}\textgreater{}} \DataTypeTok{Bool}\NormalTok{)       (}\DataTypeTok{Bool}       \OtherTok{{-}\textgreater{}} \DataTypeTok{Maybe}\NormalTok{ a)}
\end{Highlighting}
\end{Shaded}

We're just basically combining the additions we made to enable parsing with the
additions we made to enable serialization. Our new \texttt{Primitive} type gives
us the capability to do both!

We can say this new \texttt{Primitive} is an
\href{https://hackage.haskell.org/package/invariant/docs/Data-Functor-Invariant.html}{``Invariant''
Functor}: these are functors that give you ``both'' capabilities: interpreting
covariantly \emph{and} contravariantly.

Because we must be able to eventually \emph{use} either covariant or
contravariant interpretation on an invariant functor, the corresponding mapping
function takes functions in both ways in order to support both on
consumption-time.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{class} \DataTypeTok{Invariant}\NormalTok{ f }\KeywordTok{where}
\OtherTok{    invmap ::}\NormalTok{ (a }\OtherTok{{-}\textgreater{}}\NormalTok{ b) }\OtherTok{{-}\textgreater{}}\NormalTok{ (b }\OtherTok{{-}\textgreater{}}\NormalTok{ a) }\OtherTok{{-}\textgreater{}}\NormalTok{ f a }\OtherTok{{-}\textgreater{}}\NormalTok{ f b}
\end{Highlighting}
\end{Shaded}

\subsection{DivAp and DecAlt}\label{divap-and-decalt}

By now, we know the drill. We also need to change our \texttt{RecordType} and
\texttt{SumType} constructors to get the right type of container.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{{-}{-} Covariant Schema}
\CommentTok{{-}{-} source: https://github.com/mstksg/inCode/tree/master/code{-}samples/functor{-}structures/parse.hs\#L25{-}L29}

\KeywordTok{data} \DataTypeTok{Schema}\NormalTok{ a }\OtherTok{=}
      \DataTypeTok{RecordType}\NormalTok{  (}\DataTypeTok{Ap}    \DataTypeTok{Field}\NormalTok{  a)}
    \OperatorTok{|} \DataTypeTok{SumType}\NormalTok{     (}\DataTypeTok{ListF} \DataTypeTok{Choice}\NormalTok{ a)}
    \OperatorTok{|} \DataTypeTok{SchemaLeaf}\NormalTok{  (}\DataTypeTok{Primitive}\NormalTok{ a)}
  \KeywordTok{deriving} \DataTypeTok{Functor}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{{-}{-} Contravariant Schema}
\CommentTok{{-}{-} source: https://github.com/mstksg/inCode/tree/master/code{-}samples/functor{-}structures/serialize.hs\#L21{-}L24}

\KeywordTok{data} \DataTypeTok{Schema}\NormalTok{ a }\OtherTok{=}
      \DataTypeTok{RecordType}\NormalTok{  (}\DataTypeTok{Div} \DataTypeTok{Field}\NormalTok{  a)}
    \OperatorTok{|} \DataTypeTok{SumType}\NormalTok{     (}\DataTypeTok{Dec} \DataTypeTok{Choice}\NormalTok{ a)}
    \OperatorTok{|} \DataTypeTok{SchemaLeaf}\NormalTok{  (}\DataTypeTok{Primitive}\NormalTok{ a)}
\end{Highlighting}
\end{Shaded}

For the covariant \texttt{RecordType}, we used \texttt{Ap\ Field\ a}. For the
contravariant \texttt{RecordType}, we used \texttt{Div\ Field\ a}. Is there a
type that combines \emph{both} \texttt{Ap} and \texttt{Div}?

If we browse around, we see that we have
\emph{\href{https://hackage.haskell.org/package/functor-combinators/docs/Data-Functor-Invariant-DivAp.html}{DivAp}}
from the \emph{functor-combinatotrs} library\ldots which appears to be named to
in a way to invoke the idea of having both \texttt{Ap} and \texttt{Div}
capabilities, combined together.

For the covariant \texttt{SumType}, we used \texttt{ListF\ Choice\ a}. For the
contravariant \texttt{SumType}, we used \texttt{Dec\ Choice\ a}. Is there a type
that combines \emph{both} \texttt{ListF} and \texttt{Dec}?

If we look nearby \texttt{DivAp}, we see the answer:
\emph{\href{https://hackage.haskell.org/package/functor-combinators/docs/Data-Functor-Invariant-DecAlt.html}{DecAlt}}!
It combines both \texttt{ListF} and \texttt{Dec}.

\subsection{Building an Invariant Schema}\label{building-an-invariant-schema}

Let's wire it up:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{{-}{-} source: https://github.com/mstksg/inCode/tree/master/code{-}samples/functor{-}structures/invariant.hs\#L24{-}L42}

\KeywordTok{data} \DataTypeTok{Schema}\NormalTok{ a }\OtherTok{=}
      \DataTypeTok{RecordType}\NormalTok{  (}\DataTypeTok{DivAp}  \DataTypeTok{Field}\NormalTok{  a)}
    \OperatorTok{|} \DataTypeTok{SumType}\NormalTok{     (}\DataTypeTok{DecAlt} \DataTypeTok{Choice}\NormalTok{ a)}
    \OperatorTok{|} \DataTypeTok{SchemaLeaf}\NormalTok{  (}\DataTypeTok{Primitive}\NormalTok{ a)}

\KeywordTok{data} \DataTypeTok{Field}\NormalTok{ a }\OtherTok{=} \DataTypeTok{Field}
\NormalTok{    \{}\OtherTok{ fieldName  ::} \DataTypeTok{String}
\NormalTok{    ,}\OtherTok{ fieldValue ::} \DataTypeTok{Schema}\NormalTok{ a}
\NormalTok{    \}}

\KeywordTok{data} \DataTypeTok{Choice}\NormalTok{ a }\OtherTok{=} \DataTypeTok{Choice}
\NormalTok{    \{}\OtherTok{ choiceName  ::} \DataTypeTok{String}
\NormalTok{    ,}\OtherTok{ choiceValue ::} \DataTypeTok{Schema}\NormalTok{ a}
\NormalTok{    \}}

\KeywordTok{data} \DataTypeTok{Primitive}\NormalTok{ a }\OtherTok{=}
      \DataTypeTok{PString}\NormalTok{ (a }\OtherTok{{-}\textgreater{}} \DataTypeTok{String}\NormalTok{)     (}\DataTypeTok{String}     \OtherTok{{-}\textgreater{}} \DataTypeTok{Maybe}\NormalTok{ a)}
    \OperatorTok{|} \DataTypeTok{PNumber}\NormalTok{ (a }\OtherTok{{-}\textgreater{}} \DataTypeTok{Scientific}\NormalTok{) (}\DataTypeTok{Scientific} \OtherTok{{-}\textgreater{}} \DataTypeTok{Maybe}\NormalTok{ a)}
    \OperatorTok{|} \DataTypeTok{PBool}\NormalTok{   (a }\OtherTok{{-}\textgreater{}} \DataTypeTok{Bool}\NormalTok{)       (}\DataTypeTok{Bool}       \OtherTok{{-}\textgreater{}} \DataTypeTok{Maybe}\NormalTok{ a)}
\end{Highlighting}
\end{Shaded}

Writing a schema using this type is going to be very similar to writing one for
our other schema types:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{{-}{-} source: https://github.com/mstksg/inCode/tree/master/code{-}samples/functor{-}structures/invariant.hs\#L55{-}L72}

\OtherTok{customerSchema ::} \DataTypeTok{Schema} \DataTypeTok{Customer}
\NormalTok{customerSchema }\OtherTok{=} \DataTypeTok{SumType} \OperatorTok{$}
\NormalTok{    swerve (\textbackslash{}}\KeywordTok{case} \DataTypeTok{CPerson}\NormalTok{ x y }\OtherTok{{-}\textgreater{}} \DataTypeTok{Left}\NormalTok{ (x,y); }\DataTypeTok{CBusiness}\NormalTok{ x }\OtherTok{{-}\textgreater{}} \DataTypeTok{Right}\NormalTok{ x)}
\NormalTok{           (}\FunctionTok{uncurry} \DataTypeTok{CPerson}\NormalTok{)}
           \DataTypeTok{CBusiness}
\NormalTok{        (inject }\DataTypeTok{Choice}
\NormalTok{          \{ choiceName  }\OtherTok{=} \StringTok{"Person"}
\NormalTok{          , choiceValue }\OtherTok{=} \DataTypeTok{RecordType} \OperatorTok{$}\NormalTok{ gathered}
\NormalTok{              (inject }\DataTypeTok{Field}\NormalTok{ \{ fieldName }\OtherTok{=} \StringTok{"Name"}\NormalTok{, fieldValue }\OtherTok{=} \DataTypeTok{SchemaLeaf}\NormalTok{ pString \})}
\NormalTok{              (inject }\DataTypeTok{Field}\NormalTok{ \{ fieldName }\OtherTok{=} \StringTok{"Age"}\NormalTok{ , fieldValue }\OtherTok{=} \DataTypeTok{SchemaLeaf}\NormalTok{ pInt    \})}
\NormalTok{          \}}
\NormalTok{        )}
\NormalTok{        (inject }\DataTypeTok{Choice}
\NormalTok{          \{ choiceName  }\OtherTok{=} \StringTok{"Business"}
\NormalTok{          , choiceValue }\OtherTok{=} \DataTypeTok{RecordType} \OperatorTok{$}
\NormalTok{              inject }\DataTypeTok{Field}\NormalTok{ \{ fieldName }\OtherTok{=} \StringTok{"Age"}\NormalTok{ , fieldValue }\OtherTok{=} \DataTypeTok{SchemaLeaf}\NormalTok{ pInt \}}
\NormalTok{          \}}
\NormalTok{        )}
\end{Highlighting}
\end{Shaded}

The main difference is, while \texttt{decide} expects the
\texttt{a\ -\textgreater{}\ Either\ b\ c} splitting function, \texttt{swerve}
(the invariant \texttt{DecAlt} equivalent) expects also the functions to
``recombine'' the \texttt{b} and \texttt{c} back to \texttt{a}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{swerve}
\OtherTok{    ::}\NormalTok{ (a }\OtherTok{{-}\textgreater{}} \DataTypeTok{Either}\NormalTok{ b c)    }\CommentTok{{-}{-} \^{} break into branches}
    \OtherTok{{-}\textgreater{}}\NormalTok{ (b }\OtherTok{{-}\textgreater{}}\NormalTok{ a)             }\CommentTok{{-}{-} \^{} put the branch back into the original input}
    \OtherTok{{-}\textgreater{}}\NormalTok{ (c }\OtherTok{{-}\textgreater{}}\NormalTok{ a)             }\CommentTok{{-}{-} \^{} put the branch back into the original input}
    \OtherTok{{-}\textgreater{}} \DataTypeTok{DecAlt}\NormalTok{ f b           }\CommentTok{{-}{-} \^{} handle first branch}
    \OtherTok{{-}\textgreater{}} \DataTypeTok{DecAlt}\NormalTok{ f c           }\CommentTok{{-}{-} \^{} handle second branch}
    \OtherTok{{-}\textgreater{}} \DataTypeTok{DecAlt}\NormalTok{ f a           }\CommentTok{{-}{-} \^{} overall handler}

\NormalTok{swerve}
\OtherTok{    ::}\NormalTok{ (}\DataTypeTok{Customer} \OtherTok{{-}\textgreater{}} \DataTypeTok{Either}\NormalTok{ (}\DataTypeTok{String}\NormalTok{, }\DataTypeTok{Int}\NormalTok{) }\DataTypeTok{Int}\NormalTok{)   }\CommentTok{{-}{-} \^{} break into branches}
    \OtherTok{{-}\textgreater{}}\NormalTok{ ((}\DataTypeTok{String}\NormalTok{, }\DataTypeTok{Int}\NormalTok{) }\OtherTok{{-}\textgreater{}} \DataTypeTok{Customer}\NormalTok{)              }\CommentTok{{-}{-} \^{} put the CPerson branch back into a Customer}
    \OtherTok{{-}\textgreater{}}\NormalTok{ (}\DataTypeTok{Int} \OtherTok{{-}\textgreater{}} \DataTypeTok{Customer}\NormalTok{)                        }\CommentTok{{-}{-} \^{} put the CBusiness branch back into a Customer}
    \OtherTok{{-}\textgreater{}} \DataTypeTok{DecAlt} \DataTypeTok{Choice}\NormalTok{ (}\DataTypeTok{String}\NormalTok{, }\DataTypeTok{Int}\NormalTok{)              }\CommentTok{{-}{-} \^{} handle CPerson branch}
    \OtherTok{{-}\textgreater{}} \DataTypeTok{DecAlt} \DataTypeTok{Choice} \DataTypeTok{Int}                        \CommentTok{{-}{-} \^{} handle CBusiness branch}
    \OtherTok{{-}\textgreater{}} \DataTypeTok{DecAlt} \DataTypeTok{Choice} \DataTypeTok{Customer}

\CommentTok{{-}{-} compare to what we used last time:}
\NormalTok{decide}
\OtherTok{    ::}\NormalTok{ (}\DataTypeTok{Customer} \OtherTok{{-}\textgreater{}} \DataTypeTok{Either}\NormalTok{ (}\DataTypeTok{String}\NormalTok{, }\DataTypeTok{Int}\NormalTok{) }\DataTypeTok{Int}\NormalTok{)   }\CommentTok{{-}{-} \^{} break into branches}
    \OtherTok{{-}\textgreater{}} \DataTypeTok{Dec} \DataTypeTok{Choice}\NormalTok{ (}\DataTypeTok{String}\NormalTok{, }\DataTypeTok{Int}\NormalTok{)                 }\CommentTok{{-}{-} \^{} handle CPerson branch}
    \OtherTok{{-}\textgreater{}} \DataTypeTok{Dec} \DataTypeTok{Choice} \DataTypeTok{Int}                           \CommentTok{{-}{-} \^{} handle CBusiness branch}
    \OtherTok{{-}\textgreater{}} \DataTypeTok{Dec} \DataTypeTok{Choice} \DataTypeTok{Customer}
\end{Highlighting}
\end{Shaded}

We also note that the invariant version of \texttt{divided} is
\texttt{gathered}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{gathered}
\OtherTok{    ::} \DataTypeTok{DivAp}\NormalTok{ f a          }\CommentTok{{-}{-} \^{} first handler}
    \OtherTok{{-}\textgreater{}} \DataTypeTok{DivAp}\NormalTok{ f b          }\CommentTok{{-}{-} \^{} second handler}
    \OtherTok{{-}\textgreater{}} \DataTypeTok{DivAp}\NormalTok{ f (a, b)     }\CommentTok{{-}{-} \^{} merged handler}

\NormalTok{gathered}
\OtherTok{    ::} \DataTypeTok{DivAp} \DataTypeTok{Field} \DataTypeTok{String}          \CommentTok{{-}{-} \^{} handle the cpName field}
    \OtherTok{{-}\textgreater{}} \DataTypeTok{DivAp} \DataTypeTok{Field} \DataTypeTok{Int}             \CommentTok{{-}{-} \^{} handle the cpAge field}
    \OtherTok{{-}\textgreater{}} \DataTypeTok{DivAp} \DataTypeTok{Field}\NormalTok{ (}\DataTypeTok{String}\NormalTok{, }\DataTypeTok{Int}\NormalTok{)   }\CommentTok{{-}{-} \^{} handle both together}

\CommentTok{{-}{-} compare to what we used last time:}
\NormalTok{divided}
\OtherTok{    ::} \DataTypeTok{Div} \DataTypeTok{Field} \DataTypeTok{String}          \CommentTok{{-}{-} \^{} handle the cpName field}
    \OtherTok{{-}\textgreater{}} \DataTypeTok{Div} \DataTypeTok{Field} \DataTypeTok{Int}             \CommentTok{{-}{-} \^{} handle the cpAge field}
    \OtherTok{{-}\textgreater{}} \DataTypeTok{Div} \DataTypeTok{Field}\NormalTok{ (}\DataTypeTok{String}\NormalTok{, }\DataTypeTok{Int}\NormalTok{)   }\CommentTok{{-}{-} \^{} handle both together}
\end{Highlighting}
\end{Shaded}

\subsection{Using Invariant Schema}\label{using-invariant-schema}

Let's look into writing our interpreters. Luckily, we already did most of the
work in the previous post. Writing \texttt{schemaDoc}, \texttt{schemaParser},
and \texttt{schemaToValue}, we can re-use pretty much all of our code!

The main (unfortunate) difference is that instead of using \texttt{interpret} in
every case, we must use \texttt{runCoDivAp} to run our \texttt{DivAp} in a
covariant setting, and \texttt{runContraDivAp} to run our \texttt{DivAp} in a
contravariant setting (similarly for \texttt{runCoDecAlt} and
\texttt{runContraDecAlt}).\footnote{These are unfortunate consequences of the
  fact that there is no general typeclass that contains both
  \texttt{Applicative} and \texttt{Divisible} together, or no typeclass that
  contains both \texttt{Plus} and \texttt{Conclude} together. If these existed,
  we could just use \texttt{interpret} for all four of those functions.}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{{-}{-} source: https://github.com/mstksg/inCode/tree/master/code{-}samples/functor{-}structures/invariant.hs\#L74{-}L150}

\NormalTok{schemaDoc}
\OtherTok{    ::} \DataTypeTok{String}       \CommentTok{{-}{-} \^{} name}
    \OtherTok{{-}\textgreater{}} \DataTypeTok{Schema}\NormalTok{ x     }\CommentTok{{-}{-} \^{} schema}
    \OtherTok{{-}\textgreater{}} \DataTypeTok{PP.Doc}\NormalTok{ a}
\NormalTok{schemaDoc title }\OtherTok{=}\NormalTok{ \textbackslash{}}\KeywordTok{case}
    \DataTypeTok{RecordType}\NormalTok{ fs }\OtherTok{{-}\textgreater{}}\NormalTok{ PP.vsep [}
\NormalTok{        PP.pretty (}\StringTok{"\{"} \OperatorTok{\textless{}\textgreater{}}\NormalTok{ title }\OperatorTok{\textless{}\textgreater{}} \StringTok{"\}"}\NormalTok{)}
\NormalTok{      , PP.indent }\DecValTok{2} \OperatorTok{.}\NormalTok{ PP.vsep }\OperatorTok{$}
\NormalTok{          htoList (\textbackslash{}fld }\OtherTok{{-}\textgreater{}} \StringTok{"*"} \OperatorTok{PP.\textless{}+\textgreater{}}\NormalTok{ PP.indent }\DecValTok{2}\NormalTok{ (fieldDoc fld)) fs}
\NormalTok{      ]}
    \DataTypeTok{SumType}\NormalTok{ cs    }\OtherTok{{-}\textgreater{}}\NormalTok{ PP.vsep [}
\NormalTok{        PP.pretty (}\StringTok{"("} \OperatorTok{\textless{}\textgreater{}}\NormalTok{ title }\OperatorTok{\textless{}\textgreater{}} \StringTok{")"}\NormalTok{)}
\NormalTok{      , }\StringTok{"Choice of:"}
\NormalTok{      , PP.indent }\DecValTok{2} \OperatorTok{.}\NormalTok{ PP.vsep }\OperatorTok{$}
\NormalTok{          htoList choiceDoc cs}
\NormalTok{      ]}
    \DataTypeTok{SchemaLeaf}\NormalTok{ p  }\OtherTok{{-}\textgreater{}}\NormalTok{ PP.pretty (title }\OperatorTok{\textless{}\textgreater{}} \StringTok{":"}\NormalTok{)}
              \OperatorTok{PP.\textless{}+\textgreater{}}\NormalTok{ primDoc p}
  \KeywordTok{where}
\OtherTok{    fieldDoc ::} \DataTypeTok{Field}\NormalTok{ x }\OtherTok{{-}\textgreater{}} \DataTypeTok{PP.Doc}\NormalTok{ a}
\NormalTok{    fieldDoc (}\DataTypeTok{Field}\NormalTok{ name val) }\OtherTok{=}\NormalTok{ schemaDoc name val}
\OtherTok{    choiceDoc ::} \DataTypeTok{Choice}\NormalTok{ x }\OtherTok{{-}\textgreater{}} \DataTypeTok{PP.Doc}\NormalTok{ a}
\NormalTok{    choiceDoc (}\DataTypeTok{Choice}\NormalTok{ name val) }\OtherTok{=}\NormalTok{ schemaDoc name val}
\OtherTok{    primDoc ::} \DataTypeTok{Primitive}\NormalTok{ x }\OtherTok{{-}\textgreater{}} \DataTypeTok{PP.Doc}\NormalTok{ a}
\NormalTok{    primDoc }\OtherTok{=}\NormalTok{ \textbackslash{}}\KeywordTok{case}
      \DataTypeTok{PString}\NormalTok{ \_ \_ }\OtherTok{{-}\textgreater{}} \StringTok{"string"}
      \DataTypeTok{PNumber}\NormalTok{ \_ \_ }\OtherTok{{-}\textgreater{}} \StringTok{"number"}
      \DataTypeTok{PBool}\NormalTok{   \_ \_ }\OtherTok{{-}\textgreater{}} \StringTok{"bool"}

\NormalTok{schemaParser}
\OtherTok{    ::} \DataTypeTok{Schema}\NormalTok{ a}
    \OtherTok{{-}\textgreater{}} \DataTypeTok{A.Parse} \DataTypeTok{String}\NormalTok{ a}
\NormalTok{schemaParser }\OtherTok{=}\NormalTok{ \textbackslash{}}\KeywordTok{case}
    \DataTypeTok{RecordType}\NormalTok{ fs }\OtherTok{{-}\textgreater{}}\NormalTok{ runCoDivAp  fieldParser  fs}
    \DataTypeTok{SumType}\NormalTok{    cs }\OtherTok{{-}\textgreater{}}\NormalTok{ runCoDecAlt choiceParser cs}
    \DataTypeTok{SchemaLeaf}\NormalTok{ p  }\OtherTok{{-}\textgreater{}}\NormalTok{ primParser p}
  \KeywordTok{where}
\OtherTok{    choiceParser ::} \DataTypeTok{Choice}\NormalTok{ b }\OtherTok{{-}\textgreater{}} \DataTypeTok{A.Parse} \DataTypeTok{String}\NormalTok{ b}
\NormalTok{    choiceParser (}\DataTypeTok{Choice}\NormalTok{ name val) }\OtherTok{=} \KeywordTok{do}
\NormalTok{      tag }\OtherTok{\textless{}{-}}\NormalTok{ A.key }\StringTok{"tag"}\NormalTok{ A.asString}
\NormalTok{      unless (tag }\OperatorTok{==}\NormalTok{ name) }\OperatorTok{$}
\NormalTok{        A.throwCustomError }\StringTok{"Tag does not match"}
\NormalTok{      A.key }\StringTok{"contents"} \OperatorTok{$}\NormalTok{ schemaParser val}
\OtherTok{    fieldParser ::} \DataTypeTok{Field}\NormalTok{ b }\OtherTok{{-}\textgreater{}} \DataTypeTok{A.Parse} \DataTypeTok{String}\NormalTok{ b}
\NormalTok{    fieldParser (}\DataTypeTok{Field}\NormalTok{ name val) }\OtherTok{=}\NormalTok{ A.key (T.pack name) (schemaParser val)}
\OtherTok{    primParser ::} \DataTypeTok{Primitive}\NormalTok{ b }\OtherTok{{-}\textgreater{}} \DataTypeTok{A.Parse} \DataTypeTok{String}\NormalTok{ b}
\NormalTok{    primParser }\OtherTok{=}\NormalTok{ \textbackslash{}}\KeywordTok{case}
      \DataTypeTok{PString}\NormalTok{ \_ f }\OtherTok{{-}\textgreater{}}\NormalTok{ A.withString }\OperatorTok{$}
        \FunctionTok{maybe}\NormalTok{ (}\DataTypeTok{Left} \StringTok{"error validating string"}\NormalTok{) }\DataTypeTok{Right} \OperatorTok{.}\NormalTok{ f}
      \DataTypeTok{PNumber}\NormalTok{ \_ f }\OtherTok{{-}\textgreater{}}\NormalTok{ A.withScientific }\OperatorTok{$}
        \FunctionTok{maybe}\NormalTok{ (}\DataTypeTok{Left} \StringTok{"error validating number"}\NormalTok{) }\DataTypeTok{Right} \OperatorTok{.}\NormalTok{ f}
      \DataTypeTok{PBool}\NormalTok{ \_ f }\OtherTok{{-}\textgreater{}}\NormalTok{ A.withBool }\OperatorTok{$}
        \FunctionTok{maybe}\NormalTok{ (}\DataTypeTok{Left} \StringTok{"error validating bool"}\NormalTok{) }\DataTypeTok{Right} \OperatorTok{.}\NormalTok{ f}

\NormalTok{schemaToValue}
\OtherTok{    ::} \DataTypeTok{Schema}\NormalTok{ a}
    \OtherTok{{-}\textgreater{}}\NormalTok{ a}
    \OtherTok{{-}\textgreater{}} \DataTypeTok{Aeson.Value}
\NormalTok{schemaToValue }\OtherTok{=}\NormalTok{ \textbackslash{}}\KeywordTok{case}
    \DataTypeTok{RecordType}\NormalTok{ fs }\OtherTok{{-}\textgreater{}}\NormalTok{ Aeson.object}
                   \OperatorTok{.}\NormalTok{ getOp (runContraDivAp  fieldToValue  fs)}
    \DataTypeTok{SumType}\NormalTok{    cs }\OtherTok{{-}\textgreater{}}\NormalTok{ getOp (runContraDecAlt choiceToValue cs)}
    \DataTypeTok{SchemaLeaf}\NormalTok{ p  }\OtherTok{{-}\textgreater{}}\NormalTok{ primToValue p}
  \KeywordTok{where}
\OtherTok{    choiceToValue ::} \DataTypeTok{Choice}\NormalTok{ x }\OtherTok{{-}\textgreater{}} \DataTypeTok{Op} \DataTypeTok{Aeson.Value}\NormalTok{ x}
\NormalTok{    choiceToValue (}\DataTypeTok{Choice}\NormalTok{ name val) }\OtherTok{=} \DataTypeTok{Op} \OperatorTok{$}\NormalTok{ \textbackslash{}x }\OtherTok{{-}\textgreater{}}\NormalTok{ Aeson.object}
\NormalTok{      [ }\StringTok{"tag"}      \OperatorTok{Aeson..=}\NormalTok{ T.pack name}
\NormalTok{      , }\StringTok{"contents"} \OperatorTok{Aeson..=}\NormalTok{ schemaToValue val x}
\NormalTok{      ]}
\OtherTok{    fieldToValue ::} \DataTypeTok{Field}\NormalTok{ x }\OtherTok{{-}\textgreater{}} \DataTypeTok{Op}\NormalTok{ [}\DataTypeTok{Aeson.Pair}\NormalTok{] x}
\NormalTok{    fieldToValue (}\DataTypeTok{Field}\NormalTok{ name val) }\OtherTok{=} \DataTypeTok{Op} \OperatorTok{$}\NormalTok{ \textbackslash{}x }\OtherTok{{-}\textgreater{}}
\NormalTok{        [T.pack name }\OperatorTok{Aeson..=}\NormalTok{ schemaToValue val x]}
\OtherTok{    primToValue ::} \DataTypeTok{Primitive}\NormalTok{ x }\OtherTok{{-}\textgreater{}}\NormalTok{ x }\OtherTok{{-}\textgreater{}} \DataTypeTok{Aeson.Value}
\NormalTok{    primToValue }\OtherTok{=}\NormalTok{ \textbackslash{}}\KeywordTok{case}
      \DataTypeTok{PString}\NormalTok{ f \_ }\OtherTok{{-}\textgreater{}} \DataTypeTok{Aeson.String} \OperatorTok{.}\NormalTok{ T.pack }\OperatorTok{.}\NormalTok{ f}
      \DataTypeTok{PNumber}\NormalTok{ f \_ }\OtherTok{{-}\textgreater{}} \DataTypeTok{Aeson.Number} \OperatorTok{.}\NormalTok{ f}
      \DataTypeTok{PBool}\NormalTok{   f \_ }\OtherTok{{-}\textgreater{}} \DataTypeTok{Aeson.Bool} \OperatorTok{.}\NormalTok{ f}
\end{Highlighting}
\end{Shaded}

And there we have it --- a fully functional bidirectional parser schema type
that we assembled step-by-step, adding each piece incrementally and exploring
the space until we found something useful for us. We have a single schema that
can represent documentation, parsing, and serialization in a way that they are
all kept in sync, after writing things only once!

A cute function we could write to tie things together would be one that does a
round-trip, serializing and then parsing, to make sure things worked properly.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{{-}{-} source: https://github.com/mstksg/inCode/tree/master/code{-}samples/functor{-}structures/invariant.hs\#L152{-}L156}

\NormalTok{testRoundTrip}
\OtherTok{    ::} \DataTypeTok{Schema}\NormalTok{ a}
    \OtherTok{{-}\textgreater{}}\NormalTok{ a}
    \OtherTok{{-}\textgreater{}} \DataTypeTok{Either}\NormalTok{ (}\DataTypeTok{A.ParseError} \DataTypeTok{String}\NormalTok{) a}
\NormalTok{testRoundTrip sch }\OtherTok{=}\NormalTok{ A.parseValue (schemaParser sch) }\OperatorTok{.}\NormalTok{ schemaToValue sch}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ghci}\OperatorTok{\textgreater{}}\NormalTok{ testRoundTrip customerSchema (}\DataTypeTok{CPerson} \StringTok{"Sam"} \DecValTok{40}\NormalTok{)}
\DataTypeTok{Right}\NormalTok{ (}\DataTypeTok{CPerson}\NormalTok{ \{cpName }\OtherTok{=} \StringTok{"Sam"}\NormalTok{, cpAge }\OtherTok{=} \DecValTok{40}\NormalTok{\})}
\end{Highlighting}
\end{Shaded}

Looks solid to me!

\section{An Alternative Invariant
Strategy}\label{an-alternative-invariant-strategy}

The thought process ``I want to use both \texttt{Div} and \texttt{Ap}, let's
just look for \texttt{DivAp}'' is kind of nice and straightforward. However,
there's a major downside in using \texttt{DivAp} and \texttt{DecAlt} that make
their ergonomics not so great when building them up.

A major part about what makes \texttt{Ap} and \texttt{ListF} (and, to an extent,
\texttt{Div} and \texttt{Dec}) so nice to use is that they are instances of
popular Haskell typeclasses like \texttt{Applicative} and \texttt{Alternative}
(or \texttt{Plus}) and using \texttt{Applicative} and \texttt{Alternative}
interfaces are pretty common in Haskell. Because of this, they are pretty
comfortable for most Haskellers to use.

However, \texttt{DivAp} and \texttt{DecAlt} aren't really instances of any
commonly used typeclass (aside from \texttt{Invariant}).\footnote{There
  \emph{could} be a typeclass for ``combination of \texttt{Applicative} and
  \texttt{Divisible}'' and ``combination of \texttt{Plus} and
  \texttt{Conclude}'':

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{class} \DataTypeTok{DivisibleApplicative}\NormalTok{ f }\KeywordTok{where}
\OtherTok{  conquerpure ::}\NormalTok{ a }\OtherTok{{-}\textgreater{}}\NormalTok{ f a}
\OtherTok{  divideAp ::}\NormalTok{ (a }\OtherTok{{-}\textgreater{}}\NormalTok{ (b, c)) }\OtherTok{{-}\textgreater{}}\NormalTok{ (b }\OtherTok{{-}\textgreater{}}\NormalTok{ c }\OtherTok{{-}\textgreater{}}\NormalTok{ a) }\OtherTok{{-}\textgreater{}}\NormalTok{ f b }\OtherTok{{-}\textgreater{}}\NormalTok{ f c }\OtherTok{{-}\textgreater{}}\NormalTok{ f a}
\end{Highlighting}
\end{Shaded}

  And every \texttt{Applicative} and \texttt{Divisible} instance would be a
  valid instance of this. However, this doesn't really exist in any common
  Haskell libraries\ldots and I'm not sure it exists anywhere at all.

  Having this typeclass would also give us an \texttt{interpret} that we can use
  for both \texttt{A.Parser\ ErrType} and \texttt{Op\ Aeson.Value}, so we don't
  need the awkward two-different-interpreter situation we had before.} So you
really don't have any nice interface for them other than just using functions
specifically written for them, like \texttt{gather} and \texttt{swerve}, which
may feel ad-hoc.

Luckily, there's another way to achieve the same goals and also be able to take
advantage of our favorite familiar interfaces. We can ``add Contravariance''
directly into \texttt{Ap} itself, using
\href{https://hackage.haskell.org/package/functor-combinators/docs/Data-HFunctor-Route.html\#t:Pre}{\texttt{Pre}}.
This is a trick I first saw used in the
\emph{\href{https://hackage.haskell.org/package/unjson}{unjson}} library.

Recall that \texttt{Ap\ Field\ a} is a collection that contains a bunch of
\texttt{Field\ x}s of different \texttt{x}s, and can be used to covariantly
\emph{produce} an \texttt{a} by combining all of the \texttt{x}s back together.

Now, a value of type:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{Ap}\NormalTok{ (}\DataTypeTok{Pre}\NormalTok{ r }\DataTypeTok{Field}\NormalTok{) a}
\end{Highlighting}
\end{Shaded}

will ``produce'' \texttt{a}s covariantly\ldots but will ``consume'' \texttt{r}s
contravariantly. You can think of the \texttt{Pre\ r} as adding an ``tunnel'' to
guide the \texttt{r} to each \texttt{Field} in the \texttt{Ap}.

Because \texttt{Ap} is \texttt{Ap} (famous for its \texttt{Applicative}
instance), we can use normal Applicative combinators to combine our fake
invariant type:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{pure}\OtherTok{ ::}\NormalTok{ a }\OtherTok{{-}\textgreater{}} \DataTypeTok{Ap}\NormalTok{ (}\DataTypeTok{Pre}\NormalTok{ r }\DataTypeTok{Field}\NormalTok{) a}

\NormalTok{(}\OperatorTok{\textless{}*\textgreater{}}\NormalTok{)}
\OtherTok{    ::} \DataTypeTok{Ap}\NormalTok{ (}\DataTypeTok{Pre}\NormalTok{ r }\DataTypeTok{Field}\NormalTok{) (a }\OtherTok{{-}\textgreater{}}\NormalTok{ b)}
    \OtherTok{{-}\textgreater{}} \DataTypeTok{Ap}\NormalTok{ (}\DataTypeTok{Pre}\NormalTok{ r }\DataTypeTok{Field}\NormalTok{) a}
    \OtherTok{{-}\textgreater{}} \DataTypeTok{Ap}\NormalTok{ (}\DataTypeTok{Pre}\NormalTok{ r }\DataTypeTok{Field}\NormalTok{) b}

\NormalTok{liftA2}
\OtherTok{    ::}\NormalTok{ (a }\OtherTok{{-}\textgreater{}}\NormalTok{ b }\OtherTok{{-}\textgreater{}}\NormalTok{ c)}
    \OtherTok{{-}\textgreater{}} \DataTypeTok{Ap}\NormalTok{ (}\DataTypeTok{Pre}\NormalTok{ r }\DataTypeTok{Field}\NormalTok{) a}
    \OtherTok{{-}\textgreater{}} \DataTypeTok{Ap}\NormalTok{ (}\DataTypeTok{Pre}\NormalTok{ r }\DataTypeTok{Field}\NormalTok{) b}
    \OtherTok{{-}\textgreater{}} \DataTypeTok{Ap}\NormalTok{ (}\DataTypeTok{Pre}\NormalTok{ r }\DataTypeTok{Field}\NormalTok{) c}
\end{Highlighting}
\end{Shaded}

We see that the \texttt{Applicative} combinators will recombine our ``output''
covariant types appropriately, but will keep the ``input'' contravariant type
constant\footnote{This works out because each of the \texttt{Field}s inside
  could work off of the same input type. Remember that
  \texttt{Div\ f\ a\ \textasciitilde{}\ {[}f\ a{]}}, it's just a list of things
  that consume the same \texttt{a}.}

We can construct a value of type \texttt{Ap\ (Pre\ r\ Field)\ a} using
\texttt{injectPre}, which asks us to provide that ``get an \texttt{a} from
\texttt{r}'' function up-front:

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{injectPre ::}\NormalTok{ (r }\OtherTok{{-}\textgreater{}}\NormalTok{ a) }\OtherTok{{-}\textgreater{}}\NormalTok{ f a }\OtherTok{{-}\textgreater{}} \DataTypeTok{Ap}\NormalTok{ (}\DataTypeTok{Pre}\NormalTok{ r f) a}
\end{Highlighting}
\end{Shaded}

How do we interpret out of \texttt{Ap\ (Pre\ r\ f)\ a}? Well, there's a useful
newtype wrapper over \texttt{Pre} called \texttt{PreT} that makes consuming and
interpreting it very clean, by requiring the \texttt{r} and \texttt{a} to be the
same:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{newtype} \DataTypeTok{PreT}\NormalTok{ t f a }\OtherTok{=} \DataTypeTok{PreT}\NormalTok{ (t (}\DataTypeTok{Pre}\NormalTok{ a f) a)}

\CommentTok{{-}{-} | \textasciigrave{}inject\textasciigrave{} works just like it did before with \textasciigrave{}Ap\textasciigrave{} and \textasciigrave{}Div\textasciigrave{}: put that \textasciigrave{}f\textasciigrave{}}
\CommentTok{{-}{-} into a \textasciigrave{}PreT\textasciigrave{}}
\OtherTok{inject ::}\NormalTok{ f a }\OtherTok{{-}\textgreater{}} \DataTypeTok{PreT} \DataTypeTok{Ap}\NormalTok{ f a}

\CommentTok{{-}{-} | interpret for PreT treats \textasciigrave{}PreT Ap f a\textasciigrave{} as if it were just \textasciigrave{}Ap f a\textasciigrave{}, so we}
\CommentTok{{-}{-} interpret into an \textasciigrave{}Applicative\textasciigrave{} context, like we did with the parsers when}
\CommentTok{{-}{-} we used \textasciigrave{}Ap f a\textasciigrave{}.}
\NormalTok{interpret}
\OtherTok{    ::} \DataTypeTok{Applicative}\NormalTok{ g}
    \OtherTok{=\textgreater{}}\NormalTok{ (}\KeywordTok{forall}\NormalTok{ x}\OperatorTok{.}\NormalTok{ f x }\OtherTok{{-}\textgreater{}}\NormalTok{ g x)}
    \OtherTok{{-}\textgreater{}} \DataTypeTok{PreT} \DataTypeTok{Ap}\NormalTok{ f a}
    \OtherTok{{-}\textgreater{}}\NormalTok{ g a}

\CommentTok{{-}{-} | But we can also interpret into a \textasciigrave{}Divisible\textasciigrave{} context!  Just like when we}
\CommentTok{{-}{-} used \textasciigrave{}Div f a\textasciigrave{} to write our serializer!}
\NormalTok{preDivisibleT}
\OtherTok{    ::} \DataTypeTok{Divisible}\NormalTok{ g}
    \OtherTok{=\textgreater{}}\NormalTok{ (}\KeywordTok{forall}\NormalTok{ x}\OperatorTok{.}\NormalTok{ f x }\OtherTok{{-}\textgreater{}}\NormalTok{ g x)}
    \OtherTok{{-}\textgreater{}} \DataTypeTok{PreT} \DataTypeTok{Ap}\NormalTok{ f a}
    \OtherTok{{-}\textgreater{}}\NormalTok{ g a}

\CommentTok{{-}{-} | We can also use htoList like before}
\NormalTok{htoList}
\OtherTok{    ::}\NormalTok{ (}\KeywordTok{forall}\NormalTok{ x}\OperatorTok{.}\NormalTok{ f x }\OtherTok{{-}\textgreater{}}\NormalTok{ b)}
    \OtherTok{{-}\textgreater{}} \DataTypeTok{PreT} \DataTypeTok{Ap}\NormalTok{ f a}
    \OtherTok{{-}\textgreater{}}\NormalTok{ [b]}
\end{Highlighting}
\end{Shaded}

We see that \texttt{interpret} for \texttt{PreT\ Ap\ f\ a} works just like
\texttt{interpret} for \texttt{Ap\ f\ a}; we don't lose any power, it's the same
as always if we wanted to just use \texttt{Ap\ f\ a} covariantly to interpret
into a parser. Exactly what we did when we wrote our parser generation.

But, we also gain \texttt{preDivisibleT}, which lets us \texttt{interpret} into
a contravariant \texttt{Divisible} context! Just like as if we had
\texttt{Div\ f\ a}! This is exactly what we did when we wrote our serializers.

So using \texttt{Pre} and \texttt{PreT}, we get to \emph{assemble} it using our
favorite \texttt{Applicative} combinators\ldots then when we wrap it in
\texttt{PreT}, we get to \emph{interpret} it in whatever way we want by choosing
different interpreters. It's the best of both worlds!

We can do the opposite thing with \texttt{Dec} as well: we can use
\href{https://hackage.haskell.org/package/functor-combinators/docs/Data-HFunctor-Route.html\#t:Post}{\texttt{Post}}
to embed covariant capabilities in \texttt{Dec}.

Recall that \texttt{Div\ Choice\ a} is a collection that contains a bunch of
\texttt{Choice\ x}s of different \texttt{x}s, and can be used to contravariantly
\emph{consume} an \texttt{a} (by sending the \texttt{a} to one of the different
\texttt{Choice\ x}s).

A value of type:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{Dec}\NormalTok{ (}\DataTypeTok{Post}\NormalTok{ r }\DataTypeTok{Choice}\NormalTok{) a}
\end{Highlighting}
\end{Shaded}

will ``consume'' \texttt{a}s contravariantly (like a normal \texttt{Dec}), but
will also produce \texttt{r}s covariantly. You can think of the \texttt{Post\ r}
as adding an ``tunnel'' allowing the output of each \texttt{Choice} to exit out
of the \texttt{Dec}.

This means we can now use normal \texttt{Conclude} contravariant typeclass-based
combinators to combine our fake invariant type:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{decide}
\OtherTok{    ::}\NormalTok{ (a }\OtherTok{{-}\textgreater{}} \DataTypeTok{Either}\NormalTok{ b c)        }\CommentTok{{-}{-} \^{} break into branches}
    \OtherTok{{-}\textgreater{}} \DataTypeTok{Dec}\NormalTok{ (}\DataTypeTok{Post}\NormalTok{ r }\DataTypeTok{Choice}\NormalTok{) b    }\CommentTok{{-}{-} \^{} handle first branch}
    \OtherTok{{-}\textgreater{}} \DataTypeTok{Dec}\NormalTok{ (}\DataTypeTok{Post}\NormalTok{ r }\DataTypeTok{Choice}\NormalTok{) c    }\CommentTok{{-}{-} \^{} handle second branch}
    \OtherTok{{-}\textgreater{}} \DataTypeTok{Dec}\NormalTok{ (}\DataTypeTok{Post}\NormalTok{ r }\DataTypeTok{Choice}\NormalTok{) a    }\CommentTok{{-}{-} \^{} overall handler}
\end{Highlighting}
\end{Shaded}

We see that \texttt{decide} will recombine our ``input'' contravariant types
appropriately, but will keep the ``output'' covariant type constant\footnote{This
  works out because each of the \texttt{Choice}s inside could be embedded into
  the same output type. Remember that we used
  \texttt{List\ f\ a\ \textasciitilde{}\ {[}f\ a{]}} for our contravariant
  choice collection before, just a list of things that produce the same
  \texttt{a}.}.

Again, we can construct a value of type \texttt{Dec\ (Post\ r\ Choice)\ a} using
\texttt{injectPost}, which asks us to provide that ``embed the \texttt{a} in the
\texttt{r}'' function up-front:

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{injectPost ::}\NormalTok{ (a }\OtherTok{{-}\textgreater{}}\NormalTok{ r) }\OtherTok{{-}\textgreater{}}\NormalTok{ f a }\OtherTok{{-}\textgreater{}} \DataTypeTok{Dec}\NormalTok{ (}\DataTypeTok{Post}\NormalTok{ r f) a}
\end{Highlighting}
\end{Shaded}

And again, we have the newtype wrapper \texttt{PostT} that gives us convenient
interpreting functions:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{newtype} \DataTypeTok{PostT}\NormalTok{ t f a }\OtherTok{=} \DataTypeTok{PostT}\NormalTok{ (t (}\DataTypeTok{Post}\NormalTok{ a f) a)}

\CommentTok{{-}{-} | \textasciigrave{}inject\textasciigrave{} works just like it did before with \textasciigrave{}Dec\textasciigrave{} and \textasciigrave{}ListF\textasciigrave{}: put that \textasciigrave{}f\textasciigrave{}}
\CommentTok{{-}{-} into a \textasciigrave{}PostT\textasciigrave{}}
\OtherTok{inject ::}\NormalTok{ f a }\OtherTok{{-}\textgreater{}} \DataTypeTok{PostT} \DataTypeTok{Dec}\NormalTok{ f a}

\CommentTok{{-}{-} | interpret for PostT treats \textasciigrave{}PostT Dec f a\textasciigrave{} as if it were just \textasciigrave{}Dec f a\textasciigrave{}, so we}
\CommentTok{{-}{-} interpret into a \textasciigrave{}Conclude\textasciigrave{} context, like we did with the serializers when}
\CommentTok{{-}{-} we used \textasciigrave{}Dec f a\textasciigrave{}}
\NormalTok{interpret}
\OtherTok{    ::} \DataTypeTok{Conclude}\NormalTok{ g}
    \OtherTok{=\textgreater{}}\NormalTok{ (}\KeywordTok{forall}\NormalTok{ x}\OperatorTok{.}\NormalTok{ f x }\OtherTok{{-}\textgreater{}}\NormalTok{ g x)}
    \OtherTok{{-}\textgreater{}} \DataTypeTok{PostT} \DataTypeTok{Dec}\NormalTok{ f a}
    \OtherTok{{-}\textgreater{}}\NormalTok{ g a}

\CommentTok{{-}{-} | But we can also interpret into a \textasciigrave{}Plus\textasciigrave{} context!  Just like when we}
\CommentTok{{-}{-} used \textasciigrave{}ListF f a\textasciigrave{} to write our parser generation!}
\NormalTok{postPlusT}
\OtherTok{    ::} \DataTypeTok{Plus}\NormalTok{ g}
    \OtherTok{=\textgreater{}}\NormalTok{ (}\KeywordTok{forall}\NormalTok{ x}\OperatorTok{.}\NormalTok{ f x }\OtherTok{{-}\textgreater{}}\NormalTok{ g x)}
    \OtherTok{{-}\textgreater{}} \DataTypeTok{PostT} \DataTypeTok{Choice}\NormalTok{ f a}
    \OtherTok{{-}\textgreater{}}\NormalTok{ g a}

\CommentTok{{-}{-} | We can also use htoList like before}
\NormalTok{htoList}
\OtherTok{    ::}\NormalTok{ (}\KeywordTok{forall}\NormalTok{ x}\OperatorTok{.}\NormalTok{ f x }\OtherTok{{-}\textgreater{}}\NormalTok{ b)}
    \OtherTok{{-}\textgreater{}} \DataTypeTok{PostT} \DataTypeTok{Choice}\NormalTok{ f a}
    \OtherTok{{-}\textgreater{}}\NormalTok{ [b]}
\end{Highlighting}
\end{Shaded}

We get the same benefits as for \texttt{PreT}: if we want to interpret into a
\texttt{Conclude} (like we did for our serializers), we can use
\texttt{interpret}. If we want to interpret into a \texttt{Plus} (like we did
for our parser generation), we can use \texttt{postPlusT}.

With these new tools, we can imagine a different invariant \texttt{Schema} type:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{{-}{-} source: https://github.com/mstksg/inCode/tree/master/code{-}samples/functor{-}structures/routing.hs\#L36{-}L85}

\KeywordTok{data} \DataTypeTok{Schema}\NormalTok{ a }\OtherTok{=}
      \DataTypeTok{RecordType}\NormalTok{  (}\DataTypeTok{PreT}  \DataTypeTok{Ap}  \DataTypeTok{Field}\NormalTok{  a)}
    \OperatorTok{|} \DataTypeTok{SumType}\NormalTok{     (}\DataTypeTok{PostT} \DataTypeTok{Dec} \DataTypeTok{Choice}\NormalTok{ a)}
    \OperatorTok{|} \DataTypeTok{SchemaLeaf}\NormalTok{  (}\DataTypeTok{Primitive}\NormalTok{ a)}

\KeywordTok{data} \DataTypeTok{Field}\NormalTok{ a }\OtherTok{=} \DataTypeTok{Field}
\NormalTok{    \{}\OtherTok{ fieldName  ::} \DataTypeTok{String}
\NormalTok{    ,}\OtherTok{ fieldValue ::} \DataTypeTok{Schema}\NormalTok{ a}
\NormalTok{    \}}

\KeywordTok{data} \DataTypeTok{Choice}\NormalTok{ a }\OtherTok{=} \DataTypeTok{Choice}
\NormalTok{    \{}\OtherTok{ choiceName  ::} \DataTypeTok{String}
\NormalTok{    ,}\OtherTok{ choiceValue ::} \DataTypeTok{Schema}\NormalTok{ a}
\NormalTok{    \}}

\KeywordTok{data} \DataTypeTok{Primitive}\NormalTok{ a }\OtherTok{=}
      \DataTypeTok{PString}\NormalTok{ (a }\OtherTok{{-}\textgreater{}} \DataTypeTok{String}\NormalTok{)     (}\DataTypeTok{String}     \OtherTok{{-}\textgreater{}} \DataTypeTok{Maybe}\NormalTok{ a)}
    \OperatorTok{|} \DataTypeTok{PNumber}\NormalTok{ (a }\OtherTok{{-}\textgreater{}} \DataTypeTok{Scientific}\NormalTok{) (}\DataTypeTok{Scientific} \OtherTok{{-}\textgreater{}} \DataTypeTok{Maybe}\NormalTok{ a)}
    \OperatorTok{|} \DataTypeTok{PBool}\NormalTok{   (a }\OtherTok{{-}\textgreater{}} \DataTypeTok{Bool}\NormalTok{)       (}\DataTypeTok{Bool}       \OtherTok{{-}\textgreater{}} \DataTypeTok{Maybe}\NormalTok{ a)}

\OtherTok{customerSchema ::} \DataTypeTok{Schema} \DataTypeTok{Customer}
\NormalTok{customerSchema }\OtherTok{=} \DataTypeTok{SumType} \OperatorTok{.} \DataTypeTok{PostT} \OperatorTok{$}
\NormalTok{    decide (\textbackslash{}}\KeywordTok{case} \DataTypeTok{CPerson}\NormalTok{ x y }\OtherTok{{-}\textgreater{}} \DataTypeTok{Left}\NormalTok{ (x, y); }\DataTypeTok{CBusiness}\NormalTok{ x }\OtherTok{{-}\textgreater{}} \DataTypeTok{Right}\NormalTok{ x)}
\NormalTok{      (injectPost (}\FunctionTok{uncurry} \DataTypeTok{CPerson}\NormalTok{) }\DataTypeTok{Choice}
\NormalTok{        \{ choiceName }\OtherTok{=} \StringTok{"Person"}
\NormalTok{        , choiceValue }\OtherTok{=} \DataTypeTok{RecordType} \OperatorTok{.} \DataTypeTok{PreT} \OperatorTok{$}\NormalTok{ (,)}
            \OperatorTok{\textless{}$\textgreater{}}\NormalTok{ injectPre }\FunctionTok{fst} \DataTypeTok{Field}\NormalTok{ \{ fieldName }\OtherTok{=} \StringTok{"Name"}\NormalTok{, fieldValue }\OtherTok{=} \DataTypeTok{SchemaLeaf}\NormalTok{ pString \}}
            \OperatorTok{\textless{}*\textgreater{}}\NormalTok{ injectPre }\FunctionTok{snd} \DataTypeTok{Field}\NormalTok{ \{ fieldName }\OtherTok{=} \StringTok{"Age"}\NormalTok{ , fieldValue }\OtherTok{=} \DataTypeTok{SchemaLeaf}\NormalTok{ pInt    \}}
\NormalTok{        \}}
\NormalTok{      )}
\NormalTok{      (injectPost }\DataTypeTok{CBusiness}         \DataTypeTok{Choice}
\NormalTok{        \{ choiceName }\OtherTok{=} \StringTok{"Person"}
\NormalTok{        , choiceValue }\OtherTok{=} \DataTypeTok{RecordType} \OperatorTok{.}\NormalTok{ inject }\OperatorTok{$}
            \DataTypeTok{Field}\NormalTok{ \{ fieldName }\OtherTok{=} \StringTok{"Age"}\NormalTok{ , fieldValue }\OtherTok{=} \DataTypeTok{SchemaLeaf}\NormalTok{ pInt    \}}
\NormalTok{        \}}
\NormalTok{      )}
\end{Highlighting}
\end{Shaded}

Note that to build up \texttt{choiceValue} for \texttt{Person}, we can use our
normal favorite \texttt{Appliciative} combinators, like
\texttt{\textless{}\$\textgreater{}} and \texttt{\textless{}*\textgreater{}}!
And at the top level, we use \texttt{decide} like we did before with our general
contravariant combinators.

All of our running functions look pretty much the same as well:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{{-}{-} source: https://github.com/mstksg/inCode/tree/master/code{-}samples/functor{-}structures/routing.hs\#L87{-}L167}

\NormalTok{schemaDoc}
\OtherTok{    ::} \DataTypeTok{String}       \CommentTok{{-}{-} \^{} name}
    \OtherTok{{-}\textgreater{}} \DataTypeTok{Schema}\NormalTok{ x     }\CommentTok{{-}{-} \^{} schema}
    \OtherTok{{-}\textgreater{}} \DataTypeTok{PP.Doc}\NormalTok{ a}
\NormalTok{schemaDoc title }\OtherTok{=}\NormalTok{ \textbackslash{}}\KeywordTok{case}
    \DataTypeTok{RecordType}\NormalTok{ fs }\OtherTok{{-}\textgreater{}}\NormalTok{ PP.vsep [}
\NormalTok{        PP.pretty (}\StringTok{"\{"} \OperatorTok{\textless{}\textgreater{}}\NormalTok{ title }\OperatorTok{\textless{}\textgreater{}} \StringTok{"\}"}\NormalTok{)}
\NormalTok{      , PP.indent }\DecValTok{2} \OperatorTok{.}\NormalTok{ PP.vsep }\OperatorTok{$}
\NormalTok{          htoList (\textbackslash{}fld }\OtherTok{{-}\textgreater{}} \StringTok{"*"} \OperatorTok{PP.\textless{}+\textgreater{}}\NormalTok{ PP.indent }\DecValTok{2}\NormalTok{ (fieldDoc fld)) fs}
\NormalTok{      ]}
    \DataTypeTok{SumType}\NormalTok{ cs    }\OtherTok{{-}\textgreater{}}\NormalTok{ PP.vsep [}
\NormalTok{        PP.pretty (}\StringTok{"("} \OperatorTok{\textless{}\textgreater{}}\NormalTok{ title }\OperatorTok{\textless{}\textgreater{}} \StringTok{")"}\NormalTok{)}
\NormalTok{      , }\StringTok{"Choice of:"}
\NormalTok{      , PP.indent }\DecValTok{2} \OperatorTok{.}\NormalTok{ PP.vsep }\OperatorTok{$}
\NormalTok{          htoList choiceDoc cs}
\NormalTok{      ]}
    \DataTypeTok{SchemaLeaf}\NormalTok{ p  }\OtherTok{{-}\textgreater{}}\NormalTok{ PP.pretty (title }\OperatorTok{\textless{}\textgreater{}} \StringTok{":"}\NormalTok{)}
              \OperatorTok{PP.\textless{}+\textgreater{}}\NormalTok{ primDoc p}
  \KeywordTok{where}
\OtherTok{    fieldDoc ::} \DataTypeTok{Field}\NormalTok{ x }\OtherTok{{-}\textgreater{}} \DataTypeTok{PP.Doc}\NormalTok{ a}
\NormalTok{    fieldDoc }\DataTypeTok{Field}\NormalTok{\{}\OperatorTok{..}\NormalTok{\} }\OtherTok{=}\NormalTok{ schemaDoc fieldName fieldValue}
\OtherTok{    choiceDoc ::} \DataTypeTok{Choice}\NormalTok{ x }\OtherTok{{-}\textgreater{}} \DataTypeTok{PP.Doc}\NormalTok{ a}
\NormalTok{    choiceDoc }\DataTypeTok{Choice}\NormalTok{\{}\OperatorTok{..}\NormalTok{\} }\OtherTok{=}\NormalTok{ schemaDoc choiceName choiceValue}
\OtherTok{    primDoc ::} \DataTypeTok{Primitive}\NormalTok{ x }\OtherTok{{-}\textgreater{}} \DataTypeTok{PP.Doc}\NormalTok{ a}
\NormalTok{    primDoc }\OtherTok{=}\NormalTok{ \textbackslash{}}\KeywordTok{case}
      \DataTypeTok{PString}\NormalTok{ \_ \_ }\OtherTok{{-}\textgreater{}} \StringTok{"string"}
      \DataTypeTok{PNumber}\NormalTok{ \_ \_ }\OtherTok{{-}\textgreater{}} \StringTok{"number"}
      \DataTypeTok{PBool}\NormalTok{   \_ \_ }\OtherTok{{-}\textgreater{}} \StringTok{"bool"}

\OtherTok{schemaParser ::} \DataTypeTok{Schema}\NormalTok{ a }\OtherTok{{-}\textgreater{}} \DataTypeTok{A.Parse} \DataTypeTok{ErrType}\NormalTok{ a}
\NormalTok{schemaParser }\OtherTok{=}\NormalTok{ \textbackslash{}}\KeywordTok{case}
    \DataTypeTok{RecordType}\NormalTok{ fs }\OtherTok{{-}\textgreater{}}\NormalTok{ interpret fieldParser fs}
    \DataTypeTok{SumType}\NormalTok{    cs }\OtherTok{{-}\textgreater{}}\NormalTok{ postPlusT choiceParser cs}
    \DataTypeTok{SchemaLeaf}\NormalTok{ p  }\OtherTok{{-}\textgreater{}}\NormalTok{ primParser p}
  \KeywordTok{where}
\OtherTok{    fieldParser ::} \DataTypeTok{Field}\NormalTok{ a }\OtherTok{{-}\textgreater{}} \DataTypeTok{A.Parse} \DataTypeTok{String}\NormalTok{ a}
\NormalTok{    fieldParser }\DataTypeTok{Field}\NormalTok{\{}\OperatorTok{..}\NormalTok{\} }\OtherTok{=}\NormalTok{ A.key (T.pack fieldName) (schemaParser fieldValue)}
\OtherTok{    choiceParser ::} \DataTypeTok{Choice}\NormalTok{ a }\OtherTok{{-}\textgreater{}} \DataTypeTok{A.Parse} \DataTypeTok{String}\NormalTok{ a}
\NormalTok{    choiceParser }\DataTypeTok{Choice}\NormalTok{\{}\OperatorTok{..}\NormalTok{\} }\OtherTok{=} \KeywordTok{do}
\NormalTok{      tag }\OtherTok{\textless{}{-}}\NormalTok{ A.key }\StringTok{"tag"}\NormalTok{ A.asString}
\NormalTok{      unless (tag }\OperatorTok{==}\NormalTok{ choiceName) }\OperatorTok{$}
\NormalTok{        A.throwCustomError }\StringTok{"Tag does not match"}
\NormalTok{      A.key }\StringTok{"contents"} \OperatorTok{$}\NormalTok{ schemaParser choiceValue}
\OtherTok{    primParser ::} \DataTypeTok{Primitive}\NormalTok{ a }\OtherTok{{-}\textgreater{}} \DataTypeTok{A.Parse} \DataTypeTok{String}\NormalTok{ a}
\NormalTok{    primParser }\OtherTok{=}\NormalTok{ \textbackslash{}}\KeywordTok{case}
      \DataTypeTok{PString}\NormalTok{ \_ f }\OtherTok{{-}\textgreater{}}\NormalTok{ A.withString }\OperatorTok{$}
        \FunctionTok{maybe}\NormalTok{ (}\DataTypeTok{Left} \StringTok{"error validating string"}\NormalTok{) }\DataTypeTok{Right} \OperatorTok{.}\NormalTok{ f}
      \DataTypeTok{PNumber}\NormalTok{ \_ f }\OtherTok{{-}\textgreater{}}\NormalTok{ A.withScientific }\OperatorTok{$}
        \FunctionTok{maybe}\NormalTok{ (}\DataTypeTok{Left} \StringTok{"error validating number"}\NormalTok{) }\DataTypeTok{Right} \OperatorTok{.}\NormalTok{ f}
      \DataTypeTok{PBool}\NormalTok{ \_ f }\OtherTok{{-}\textgreater{}}\NormalTok{ A.withBool }\OperatorTok{$}
        \FunctionTok{maybe}\NormalTok{ (}\DataTypeTok{Left} \StringTok{"error validating bool"}\NormalTok{) }\DataTypeTok{Right} \OperatorTok{.}\NormalTok{ f}

\NormalTok{schemaToValue}
\OtherTok{    ::} \DataTypeTok{Schema}\NormalTok{ a}
    \OtherTok{{-}\textgreater{}}\NormalTok{ a}
    \OtherTok{{-}\textgreater{}} \DataTypeTok{Aeson.Value}
\NormalTok{schemaToValue }\OtherTok{=}\NormalTok{ \textbackslash{}}\KeywordTok{case}
    \DataTypeTok{RecordType}\NormalTok{ fs }\OtherTok{{-}\textgreater{}}\NormalTok{ Aeson.object }\OperatorTok{.}\NormalTok{ getOp (preDivisibleT fieldToValue fs)}
    \DataTypeTok{SumType}\NormalTok{    cs }\OtherTok{{-}\textgreater{}}\NormalTok{ getOp (interpret choiceToValue cs)}
    \DataTypeTok{SchemaLeaf}\NormalTok{ p  }\OtherTok{{-}\textgreater{}}\NormalTok{ primToValue p}
  \KeywordTok{where}
\OtherTok{    fieldToValue ::} \DataTypeTok{Field}\NormalTok{ a }\OtherTok{{-}\textgreater{}} \DataTypeTok{Op}\NormalTok{ [}\DataTypeTok{Aeson.Pair}\NormalTok{] a}
\NormalTok{    fieldToValue }\DataTypeTok{Field}\NormalTok{\{}\OperatorTok{..}\NormalTok{\} }\OtherTok{=} \DataTypeTok{Op} \OperatorTok{$}\NormalTok{ \textbackslash{}x }\OtherTok{{-}\textgreater{}}
\NormalTok{        [T.pack fieldName }\OperatorTok{Aeson..=}\NormalTok{ schemaToValue fieldValue x]}
\OtherTok{    choiceToValue ::} \DataTypeTok{Choice}\NormalTok{ a }\OtherTok{{-}\textgreater{}} \DataTypeTok{Op} \DataTypeTok{Aeson.Value}\NormalTok{ a}
\NormalTok{    choiceToValue }\DataTypeTok{Choice}\NormalTok{\{}\OperatorTok{..}\NormalTok{\} }\OtherTok{=} \DataTypeTok{Op} \OperatorTok{$}\NormalTok{ \textbackslash{}x }\OtherTok{{-}\textgreater{}}\NormalTok{ Aeson.object}
\NormalTok{        [ }\StringTok{"tag"}      \OperatorTok{Aeson..=}\NormalTok{ T.pack choiceName}
\NormalTok{        , }\StringTok{"contents"} \OperatorTok{Aeson..=}\NormalTok{ schemaToValue choiceValue x}
\NormalTok{        ]}
\OtherTok{    primToValue ::} \DataTypeTok{Primitive}\NormalTok{ a }\OtherTok{{-}\textgreater{}}\NormalTok{ a }\OtherTok{{-}\textgreater{}} \DataTypeTok{Aeson.Value}
\NormalTok{    primToValue }\OtherTok{=}\NormalTok{ \textbackslash{}}\KeywordTok{case}
      \DataTypeTok{PString}\NormalTok{ f \_ }\OtherTok{{-}\textgreater{}}\NormalTok{ \textbackslash{}x }\OtherTok{{-}\textgreater{}} \DataTypeTok{Aeson.String}\NormalTok{ (T.pack (f x))}
      \DataTypeTok{PNumber}\NormalTok{ f \_ }\OtherTok{{-}\textgreater{}}\NormalTok{ \textbackslash{}x }\OtherTok{{-}\textgreater{}} \DataTypeTok{Aeson.Number}\NormalTok{ (f x)}
      \DataTypeTok{PBool}\NormalTok{   f \_ }\OtherTok{{-}\textgreater{}}\NormalTok{ \textbackslash{}x }\OtherTok{{-}\textgreater{}} \DataTypeTok{Aeson.Bool}\NormalTok{   (f x)}
\end{Highlighting}
\end{Shaded}

Using \texttt{DivAp}/\texttt{DecAlt} and \texttt{PreT\ Ap}/\texttt{PostT\ Dec}
are just two separate styles for you to consider if we want to go into combining
\emph{both} covariant production \emph{and} contravariant consumption!

\section{Concluding Thoughts}\label{concluding-thoughts}

If you've come this far, thank you for reading!

The thought process described in this series was pretty much my actual thought
process when writing something similar. I needed to provide documentation, a
json parser, and a json serializer for a collection of data formats that I had.
At first I had written three separate systems, and wrote all three separately
for each format. I struggled with keeping all of them in sync, but everything
clicked when I realized I could combine the documentation generator and the
parser generation. I looked at my serializer system with regret on how it had to
be a separate thing. But then I stared really really hard at it, and all of a
sudden the idea of uniting all three of them became something I realized was
worthwhile.

It really was a truly ``step-by-step'' process\ldots and I think it's pretty
rare that these fully formed united abstractions just pop out of your brain
without going through the process of looking at each individual piece!

In real code this pairing of the covariant and covariant is pretty prevalent. In
another recent situation, I had to deal with ``incoming'' typed sockets
(covariant outputters) and ``outgoing'' typed sockets (contravariant
consumers)\ldots the contexts where you get these sort of opposing dual pairs
comes up a lot. Being able write a functor structure that lets you deal with
them together can save a lot of code, reduce the space for errors, and relieve a
lot of maintenance burden. For example, in the case of sockets, we could even
write:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{{-}{-} | allocate an outgoing socket that only accepts values of your schema}
\OtherTok{makeOutSocket ::} \DataTypeTok{Schema}\NormalTok{ a }\OtherTok{{-}\textgreater{}} \DataTypeTok{IO}\NormalTok{ (}\DataTypeTok{OutSocket}\NormalTok{ a)}

\CommentTok{{-}{-} | allocate an incoming socket that awaits values of your schema}
\OtherTok{makeInSocket ::} \DataTypeTok{Schema}\NormalTok{ a }\OtherTok{{-}\textgreater{}} \DataTypeTok{IO}\NormalTok{ (}\DataTypeTok{InSocket}\NormalTok{ a)}
\end{Highlighting}
\end{Shaded}

Here \texttt{Schema\ a} could represent a data protocol; under this system, you
have the assurance that the protocol of sending a data type over a channel is
always going to be the same as the protocol for receiving data, no matter what
changes you make to your type. And you only have to write the code once, not
twice!

Try to investigate situations in your life where ``structures'' could be more
useful as ``functor structures''\ldots and then maybe see if there's even more
value you could add by enhancing them with more functor-ness!

Hopefully
\emph{\href{https://hackage.haskell.org/package/functor-combinators}{functor-combinators}}
and the \emph{{[}functor combinatorpedia{]}{[}{]}} may be a useful guide along
the way! You don't have to build things ``functor combinator style'' like in
this post (you could make everything from scratch without using
\texttt{Ap}/\texttt{Dec}, etc.), but I have found that thinking in this style
helps guide your search to solutions that already exist (like how we found
\texttt{ListF} by reading about \texttt{Ap}), instead of reinventing the wheel
every time. If anything, it can help you reframe the problem in a way that might
make it more easy to grasp.

Until next time, happy Haskelling!

\section{Special Thanks}\label{special-thanks}

I am very humbled to be supported by an amazing community, who make it possible
for me to devote time to researching and writing these posts. Very special
thanks to my supporter at the ``Amazing'' level on
\href{https://www.patreon.com/justinle/overview}{patreon}, Josh Vera! :)

\section{Signoff}\label{signoff}

Hi, thanks for reading! You can reach me via email at
\href{mailto:justin@jle.im}{\nolinkurl{justin@jle.im}}, or at twitter at
\href{https://twitter.com/mstk}{@mstk}! This post and all others are published
under the \href{https://creativecommons.org/licenses/by-nc-nd/3.0/}{CC-BY-NC-ND
3.0} license. Corrections and edits via pull request are welcome and encouraged
at \href{https://github.com/mstksg/inCode}{the source repository}.

If you feel inclined, or this post was particularly helpful for you, why not
consider \href{https://www.patreon.com/justinle/overview}{supporting me on
Patreon}, or a \href{bitcoin:3D7rmAYgbDnp4gp4rf22THsGt74fNucPDU}{BTC donation}?
:)

\textbackslash end\{document\}

\end{document}
