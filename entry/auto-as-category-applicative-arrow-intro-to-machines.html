<!DOCTYPE HTML>
<html><head><title>Auto as Category, Applicative &amp; Arrow (Intro to Machines/Arrows Part 2) · in Code</title><meta name="description" content="Weblog of Justin Le, covering various adventures in programming and explorations in the worlds of computation physics, and knowledge.
"><meta http-equiv="Content-Type" content="text/html;charset=utf-8"><meta name="viewport" content="width=device-width,initial-scale=1.0"><meta name="flattr:id" content="3p9jqr"><meta property="og:site_name" content="in Code"><meta property="og:description" content="Welcome back! It’s been a while since the last post, admittedly; sorry! In this post we’ll be continuing on from the previous post. In particular, we’re going to be looking at the Auto type as something that is a part of a pretty powerful pattern of abstraction, and try to exploit it to write concise, expressive code using Auto composition and proc notation. We’ll also see first hands the principles of locally stateful composition, and how much more expressive and safe it makes our code. One motivating factor that I will eventually write about is that we can use this to implement the semantics of Functional Reactive Programming, yay! But through this, I hope you can actually see that it is useful for much, much more! As always, feel free to leave a comment if you have any questions, or try to find me on twitter, or drop by the #haskell Freenode IRC channel! (I go by jle`) Note that all of the code in this post can be downloaded (from Auto.hs for the last post, and Auto2.hs for this post’s new material) so you can play along on GHCi, or write your own code using it the concepts and types here :) You can also run it online interactively. A fair warning: at times this post might feel a bit fragmented; but remember that we really are just going to be exploring and getting very familiar with the Auto type and building an intuition. Everything comes to a mini-climax at the end, and a final satisfying one at the next post — kind of like every Part 2 in every trilogy ever, you know? :)"><meta property="og:type" content="article"><meta property="og:title" content="Auto as Category, Applicative &amp; Arrow (Intro to Machines/Arrows Part 2)"><meta property="og:image" content="https://blog.jle.im/img/site_logo.jpg"><meta property="og:locale" content="en_US"><meta property="og:url" content="https://blog.jle.im/entry/auto-as-category-applicative-arrow-intro-to-machines.html"><meta name="twitter:card" content="summary"><meta name="twitter:creator:id" content="mstk"><link rel="author" href="https://plus.google.com/107705320197444500140"><link rel="alternate" type="application/rss+xml" title="in Code (RSS Feed)" href="http://feeds.feedburner.com/incodeblog"><link rel="canonical" href="https://blog.jle.im/entry/auto-as-category-applicative-arrow-intro-to-machines.html"><link href="https://blog.jle.im/favicon.ico" rel="shortcut icon"><link href="https://blog.jle.im/css/toast.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/font.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/main.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/page/entry.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/pygments.css" rel="stylesheet" type="text/css"><script type="text/javascript">var page_data = {};
var disqus_shortname='incode';
</script><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-443711-8', 'jle.im');
ga('send', 'pageview');
</script><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script id="MathJax-script" async="" src="https://cdn.jsdelivr.net/npm/mathjax@3.0.1/es5/tex-mml-chtml.js"></script><script type="text/javascript" src="//ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script><script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5234d67a6b68dcd4"></script><script type="text/javascript" src="https://blog.jle.im/js/page/entry_toc.js"></script><script type="text/javascript" src="https://blog.jle.im/js/disqus_count.js"></script><script type="text/javascript" src="https://blog.jle.im/js/social.js"></script><script type="text/javascript" src="https://blog.jle.im/js/jquery/jquery.toc.js"></script><script type="text/javascript" src="https://blog.jle.im/purescript/entry.js"></script></head><body><div id="fb-root"><script>(function(d, s, id) {
 var js, fjs = d.getElementsByTagName(s)[0];
 if (d.getElementById(id)) return;
 js = d.createElement(s); js.id = id;
 js.src = "//connect.facebook.net/en_US/all.js#xfbml=1&appId=641852699171929";
 fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));
</script></div><div id="header-container"><div id="navbar-container" class="tile"><nav id="navbar-content"><div class="nav-info"><h1 class="site-title"><a href="https://blog.jle.im/" class="nav-title">in Code</a></h1><span class="nav-author">Justin Le</span></div><ul class="nav-links"><li><a href="https://blog.jle.im/">home</a></li><li><a href="https://blog.jle.im/entries.html">archives</a></li><li><a href="https://cv.jle.im">cv</a></li><div class="clear"></div></ul></nav></div><div id="header-content"></div></div><div id="body-container" class="container"><div id="main-container" class="grid"><div class="entry-section unit span-grid" role="main"><article class="tile article"><header><h1 id="title">Auto as Category, Applicative &amp; Arrow (Intro to Machines/Arrows Part 2)</h1><p class="entry-info">by <a class="author" href="https://blog.jle.im/">Justin Le</a><span class="info-separator"> &diams; </span><time datetime="2014-07-14T10:13:43Z" pubdate="" class="pubdate">Monday July 14, 2014</time></p><p><span class="source-info"><a class="source-link" href="https://github.com/mstksg/inCode/tree/master/copy/entries/machines-2.md">Source</a><span class="info-separator"> &diams; </span><a class="source-link" href="https://github.com/mstksg/inCode/tree/gh-pages/entry/auto-as-category-applicative-arrow-intro-to-machines.md">Markdown</a><span class="info-separator"> &diams; </span><a class="source-link" href="https://blog.jle.im/entry/auto-as-category-applicative-arrow-intro-to-machines.tex">LaTeX</a><span class="info-separator"> &diams; </span></span>Posted in <a href="https://blog.jle.im/entries/category/@haskell.html" class="tag-a-category" title="Functional, pure, non-strict, statically and strongly typed, natively
compiled...really just the king of great languages.
">Haskell</a>, <a href="https://blog.jle.im/entries/category/@ramblings.html" class="tag-a-category" title="My slight ramblings on subjects of interest (to me and hopefully to you too!).
Lots of surveys and introducts to new subjects.
">Ramblings</a><span class="info-separator"> &diams; </span><a class="comment-link" href="#disqus_thread">Comments</a></p></header><hr><aside class="contents-container"><h5 id="contents-header">Contents</h5><div id="toc"></div></aside><div class="main-content copy-content"><p>Welcome back! It’s been a while since the last post, admittedly; sorry! In this post we’ll be continuing on from <a href="http://blog.jle.im/entry/intro-to-machines-arrows-part-1-stream-and">the previous post</a>. In particular, we’re going to be looking at the <code>Auto</code> type as something that is a part of a pretty powerful pattern of abstraction, and try to exploit it to write concise, expressive code using Auto composition and proc notation. We’ll also see first hands the principles of locally stateful composition, and how much more expressive and safe it makes our code.</p>
<p>One motivating factor that I will eventually write about is that we can use this to implement the semantics of Functional Reactive Programming, yay! But through this, I hope you can actually see that it is useful for much, much more!</p>
<p>As always, feel free to leave a comment if you have any questions, or try to find me on <a href="https://twitter.com/mstk" title="Twitter">twitter</a>, or drop by the #haskell Freenode IRC channel! (I go by <em>jle`</em>)</p>
<p>Note that all of the code in this post can be downloaded (from <a href="https://github.com/mstksg/inCode/tree/master/code-samples/machines/Auto.hs">Auto.hs</a> for the last post, and <a href="https://github.com/mstksg/inCode/tree/master/code-samples/machines/Auto2.hs">Auto2.hs</a> for this post’s new material) so you can play along on GHCi, or write your own code using it the concepts and types here :) You can also run it <a href="https://www.fpcomplete.com/user/jle/machines">online interactively</a>.</p>
<p>A fair warning: at times this post might feel a bit fragmented; but remember that we really are just going to be exploring and getting very familiar with the Auto type and building an intuition. Everything comes to a mini-climax at the end, and a final satisfying one at the next post — kind of like every Part 2 in every trilogy ever, you know? :)</p>
<h2 id="recap">Recap</h2>
<p>We left off in our last post having looked at <code>Auto</code>:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/machines/Auto.hs#L12-L12</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="co">-- interactive: https://www.fpcomplete.com/user/jle/machines</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">Auto</span> a b <span class="ot">=</span> <span class="dt">ACons</span> {<span class="ot"> runAuto ::</span> a <span class="ot">-&gt;</span> (b, <span class="dt">Auto</span> a b) }</span></code></pre></div>
<p>which we saw as a stream that had an influencing input of type <code>a</code>, an internal, opaque state (a function of the input and of the previous state), and an output “head” of type <code>b</code> (also a function of the input and of the previous state).</p>
<p>And we looked at <a href="https://github.com/mstksg/inCode/tree/master/code-samples/machines/Auto.hs#L46-L54">a simple auto</a> which acted like a constantly incrementing stream, but where you could reset the counter by passing in a <code>Just</code>.</p>
<p>Then we took another approach to looking at this — we thought about Autos as functions “with state”. As in, <code>Auto a b</code> was like a function <code>a -&gt; b</code>, but which had an internal state that updated every time it was called.</p>
<p>We saw this in an auto that <a href="https://github.com/mstksg/inCode/tree/master/code-samples/machines/Auto.hs#L66-L73">returns the sum</a> of everything you have given it.</p>
<p>Autos are “function-like things”…they map or “morph” things of type <code>a</code> to things of type <code>b</code> in some form, just like functions. It looks like we stumbled onto some sort of design pattern. Wouldn’t it be cool if we could treat Autos the same way we treat functions? And reason about them the same way, think about them using the same logic?</p>
<p>What is the <em>essence</em> of function-like-ness?</p>
<h2 id="the-essence-of-function-like-ness">The Essence of Function-like-ness</h2>
<p>I’m going to introduce some formality and call things “function-like-things” <em>morphisms</em> (with some laws). Sometimes you’ll see them called “arrows”, but this is a slightly loaded word as there is an Arrow typeclass in Haskell that doesn’t exactly refer to the same thing.</p>
<p>Here is my claim: the “essence” of this functionlikeness is their ability to <em>compose</em> and “chain”, and the <em>nature</em> of that composition process.</p>
<p>That is, if you have a morphism <code>f</code> from <code>a</code> to <code>b</code>, and a morphism <code>g</code> from <code>b</code> to <code>c</code>, then you can “compose” or “chain” them to get a morphism from <code>a</code> to <code>c</code>.</p>
<p>In Haskell we use the <code>(.)</code> operator for this — to say more formally:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="ot">f     ::</span> morphism a b</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="ot">g     ::</span> morphism b c</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>g <span class="op">.</span><span class="ot"> f ::</span> morphism a c</span></code></pre></div>
<p>Some important aspects of the nature of this composition is that it must “associate”. That means:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>(h <span class="op">.</span> g) <span class="op">.</span> f <span class="op">==</span> h <span class="op">.</span> (g <span class="op">.</span> f)</span></code></pre></div>
<p>Composing the composition of <code>h</code> and <code>g</code> to <code>h</code> should be the same as composing <code>h</code> with the composition of <code>g</code> and <code>f</code>.</p>
<p>The final feature is that there must exist some “identity” morphism that leaves other morphisms unchanged under composition:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="fu">id</span><span class="ot"> ::</span> <span class="dt">Morphism</span> b b</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="fu">id</span> <span class="op">.</span> f  <span class="op">==</span> f</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>g  <span class="op">.</span> <span class="fu">id</span> <span class="op">==</span> g</span></code></pre></div>
<p>It doesn’t really matter what <code>id</code> literally “does” — it only matters that it leaves morphisms unchanged.</p>
<p>And…that’s it!</p>
<h3 id="functions-are-morphisms">Functions are “morphisms”</h3>
<p>We’re just going to take a quick detour verify that normal functions satisfy this new notion of “function-likeness”…so that we aren’t crazy.</p>
<p>In Haskell, our functions are things of type <code>a -&gt; b</code> — a morphism from <code>a</code> to <code>b</code>.</p>
<p>Our composition operator is the familiar <code>(.)</code> from Prelude. You can prove all of the above laws yourself using the definition of <code>(.)</code>:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="ot">(.) ::</span> (b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> c)</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>g <span class="op">.</span> f <span class="ot">=</span> \x <span class="ot">-&gt;</span> g (f x)</span></code></pre></div>
<p>In practice, you can see associativity</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> ((<span class="op">&lt;</span> <span class="dv">20</span>) <span class="op">.</span> (<span class="op">+</span><span class="dv">4</span>)) <span class="op">.</span> (<span class="op">^</span><span class="dv">2</span>) <span class="op">$</span> <span class="dv">4</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="dt">True</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> (<span class="op">&lt;</span> <span class="dv">20</span>) <span class="op">.</span> ((<span class="op">+</span><span class="dv">4</span>) <span class="op">.</span> (<span class="op">^</span><span class="dv">2</span>)) <span class="op">$</span> <span class="dv">4</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a><span class="dt">True</span></span></code></pre></div>
<p>The identity is just Prelude’s <code>id</code>:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="fu">id</span><span class="ot"> ::</span> a <span class="ot">-&gt;</span> a</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="fu">id</span> x <span class="ot">=</span> x</span></code></pre></div>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span>      (<span class="op">*</span><span class="dv">3</span>) <span class="op">$</span> <span class="dv">7</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="dv">21</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> <span class="fu">id</span> <span class="op">.</span> (<span class="op">*</span><span class="dv">3</span>) <span class="op">$</span> <span class="dv">7</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a><span class="dv">21</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> (<span class="op">*</span><span class="dv">3</span>) <span class="op">.</span> <span class="fu">id</span> <span class="op">$</span> <span class="dv">7</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a><span class="dv">21</span></span></code></pre></div>
<div class="note">
<p><strong>Aside</strong></p>
<p>I mean it, you can prove it yourself if you are bored some time :) I’ll start you off with one of the identity laws:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>g <span class="op">.</span> <span class="fu">id</span> <span class="ot">=</span> \x <span class="ot">-&gt;</span> g (<span class="fu">id</span> x)     <span class="co">-- definition of (.)</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>       <span class="ot">=</span> \x <span class="ot">-&gt;</span> g x          <span class="co">-- definition of id</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>       <span class="ot">=</span> g                  <span class="co">-- eta reduction</span></span></code></pre></div>
</div>
<p>So cool…this intuition applies to our actual idea of functions, so we are on a sane track!</p>
<h3 id="autos-are-morphisms">Autos are “morphisms”!</h3>
<p>So we see that functions fit this idea. Let’s jump back to what we were trying to show in the first place — that Autos fit this “idea” of function-like things, or morphisms.</p>
<p>Let’s say I had an <code>f :: Auto a b</code> and a <code>g :: Auto b c</code>. I want to “compose” them — <code>g . f</code>. To get an <code>Auto a c</code>, somehow. What would that even mean?</p>
<p>Well…if we think of <code>f</code> like a stateful function that takes in an <code>a</code> and pops out a <code>b</code>…and <code>g</code> like a stateful function that takes in a <code>b</code> and pops out a <code>c</code>…We can think of <code>g . f</code> as a stateful function that takes in an <code>a</code>, feeds it to <code>f</code>, gets the <code>b</code> that <code>f</code> pops out, feeds that to <code>g</code>, and gets the final <code>c</code> out at the end.</p>
<p>Also, Autos spit out both the result (the <code>c</code>) and the “updated Auto”…so the updated Auto of the composition can just be the composition of the updated Autos!</p>
<p>Enough talk, let’s code! We’ll call our composition operator <code>(~.~)</code>.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/machines/Auto2.hs#L67-L70</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="co">-- interactive: https://www.fpcomplete.com/user/jle/machines</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a><span class="ot">(~.~) ::</span> <span class="dt">Auto</span> b c <span class="ot">-&gt;</span> <span class="dt">Auto</span> a b <span class="ot">-&gt;</span> <span class="dt">Auto</span> a c</span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>g <span class="op">~.~</span> f <span class="ot">=</span> <span class="dt">ACons</span> <span class="op">$</span> \x <span class="ot">-&gt;</span> <span class="kw">let</span> (y, f&#39;) <span class="ot">=</span> runAuto f x</span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>                            (z, g&#39;) <span class="ot">=</span> runAuto g y</span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>                        <span class="kw">in</span>  (z, g&#39; <span class="op">~.~</span> f&#39;)</span></code></pre></div>
<p>And…that should be it! We run the input through first <code>f</code> then <code>g</code>, collecting the “modified <code>f</code> and <code>g</code>”, and returning both of those at the end, composed.</p>
<p>Let’s write a useful helper function so that we have more things to test this out on:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/machines/Auto2.hs#L74-L75</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span class="co">-- interactive: https://www.fpcomplete.com/user/jle/machines</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a><span class="ot">toAuto ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Auto</span> a b</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>toAuto f <span class="ot">=</span> <span class="dt">ACons</span> <span class="op">$</span> \x <span class="ot">-&gt;</span> (f x, toAuto f)</span></code></pre></div>
<p><code>toAuto</code> basically turns a function <code>a -&gt; b</code> into a stateless <code>Auto a b</code>.</p>
<p>Time to test these out!</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> <span class="kw">let</span> doubleA  <span class="ot">=</span> toAuto (<span class="op">*</span><span class="dv">2</span>)<span class="ot">      ::</span> <span class="dt">Auto</span> <span class="dt">Int</span> <span class="dt">Int</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> <span class="kw">let</span> succA    <span class="ot">=</span> toAuto (<span class="op">+</span><span class="dv">1</span>)<span class="ot">      ::</span> <span class="dt">Auto</span> <span class="dt">Int</span> <span class="dt">Int</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> testAuto_ doubleA [<span class="dv">1</span><span class="op">..</span><span class="dv">10</span>]</span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>[<span class="dv">2</span>,<span class="dv">4</span>,<span class="dv">6</span>,<span class="dv">8</span>,<span class="dv">10</span>,<span class="dv">12</span>,<span class="dv">14</span>,<span class="dv">16</span>,<span class="dv">18</span>,<span class="dv">20</span>]</span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> testAuto_ (succA <span class="op">~.~</span> doubleA) [<span class="dv">1</span><span class="op">..</span><span class="dv">10</span>]</span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>[<span class="dv">3</span>,<span class="dv">5</span>,<span class="dv">7</span>,<span class="dv">9</span>,<span class="dv">11</span>,<span class="dv">13</span>,<span class="dv">15</span>,<span class="dv">17</span>,<span class="dv">19</span>,<span class="dv">21</span>]</span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> testAuto_ summer [<span class="dv">5</span>,<span class="dv">1</span>,<span class="dv">9</span>,<span class="dv">2</span>,<span class="op">-</span><span class="dv">3</span>,<span class="dv">4</span>]</span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a>[<span class="dv">5</span>,<span class="dv">6</span>,<span class="dv">15</span>,<span class="dv">17</span>,<span class="dv">14</span>,<span class="dv">18</span>]</span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> testAuto_ (doubleA <span class="op">~.~</span> summer) [<span class="dv">5</span>,<span class="dv">1</span>,<span class="dv">9</span>,<span class="dv">2</span>,<span class="op">-</span><span class="dv">3</span>,<span class="dv">4</span>]</span>
<span id="cb12-14"><a href="#cb12-14" aria-hidden="true" tabindex="-1"></a>[<span class="dv">10</span>,<span class="dv">12</span>,<span class="dv">30</span>,<span class="dv">34</span>,<span class="dv">28</span>,<span class="dv">39</span>]</span>
<span id="cb12-15"><a href="#cb12-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-16"><a href="#cb12-16" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> testAuto_ settableAuto [<span class="dt">Nothing</span>,<span class="dt">Nothing</span>,<span class="dt">Just</span> (<span class="op">-</span><span class="dv">3</span>),<span class="dt">Nothing</span>,<span class="dt">Nothing</span>]</span>
<span id="cb12-17"><a href="#cb12-17" aria-hidden="true" tabindex="-1"></a>[<span class="dv">1</span>,<span class="dv">2</span>,<span class="op">-</span><span class="dv">3</span>,<span class="op">-</span><span class="dv">2</span>,<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb12-18"><a href="#cb12-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-19"><a href="#cb12-19" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> testAuto_ summer [<span class="dv">1</span>,<span class="dv">2</span>,<span class="op">-</span><span class="dv">3</span>,<span class="op">-</span><span class="dv">2</span>,<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb12-20"><a href="#cb12-20" aria-hidden="true" tabindex="-1"></a>[<span class="dv">1</span>,<span class="dv">3</span>,<span class="dv">0</span>,<span class="op">-</span><span class="dv">2</span>,<span class="op">-</span><span class="dv">3</span>]</span>
<span id="cb12-21"><a href="#cb12-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-22"><a href="#cb12-22" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> testAuto_ (summer <span class="op">~.~</span> settableAuto)</span>
<span id="cb12-23"><a href="#cb12-23" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span>     [<span class="dt">Nothing</span>,<span class="dt">Nothing</span>,<span class="dt">Just</span> (<span class="op">-</span><span class="dv">3</span>),<span class="dt">Nothing</span>,<span class="dt">Nothing</span>]</span>
<span id="cb12-24"><a href="#cb12-24" aria-hidden="true" tabindex="-1"></a>[<span class="dv">1</span>,<span class="dv">3</span>,<span class="dv">0</span>,<span class="op">-</span><span class="dv">2</span>,<span class="op">-</span><span class="dv">3</span>]</span></code></pre></div>
<p>And it looks like our Autos really can meaningfully compose!</p>
<p>Well, wait. We need one last thing: the identity Auto:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/machines/Auto2.hs#L78-L79</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a><span class="co">-- interactive: https://www.fpcomplete.com/user/jle/machines</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a><span class="ot">idA ::</span> <span class="dt">Auto</span> a a</span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>idA <span class="ot">=</span> <span class="dt">ACons</span> <span class="op">$</span> \x <span class="ot">-&gt;</span> (x, idA)</span></code></pre></div>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> testAuto_ summer [<span class="dv">5</span>,<span class="dv">1</span>,<span class="dv">9</span>,<span class="dv">2</span>,<span class="op">-</span><span class="dv">3</span>,<span class="dv">4</span>]</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>[<span class="dv">10</span>,<span class="dv">12</span>,<span class="dv">30</span>,<span class="dv">34</span>,<span class="dv">28</span>,<span class="dv">39</span>]</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> testAuto_ (idA <span class="op">~.~</span> summer) [<span class="dv">5</span>,<span class="dv">1</span>,<span class="dv">9</span>,<span class="dv">2</span>,<span class="op">-</span><span class="dv">3</span>,<span class="dv">4</span>]</span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>[<span class="dv">10</span>,<span class="dv">12</span>,<span class="dv">30</span>,<span class="dv">34</span>,<span class="dv">28</span>,<span class="dv">39</span>]</span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> testAuto_ (summer <span class="op">~.~</span> idA) [<span class="dv">5</span>,<span class="dv">1</span>,<span class="dv">9</span>,<span class="dv">2</span>,<span class="op">-</span><span class="dv">3</span>,<span class="dv">4</span>]</span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a>[<span class="dv">10</span>,<span class="dv">12</span>,<span class="dv">30</span>,<span class="dv">34</span>,<span class="dv">28</span>,<span class="dv">39</span>]</span></code></pre></div>
<h3 id="category">Category</h3>
<p>These concepts are actually formalized in the mathematical concept of a “category” — things with objects and morphisms between them, following certain properties (like the ones I mentioned earlier).</p>
<p>In Haskell, we often consider our objects as Haskell types; our usual morphisms is the function arrow, <code>(-&gt;)</code><a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a> — but in this case, it might be interesting to consider a different category — the category of Haskell types and morphisms <code>Auto a b</code>.</p>
<p>In Haskell, we have a typeclass that allows us to do generic operations on all Categories — so now we can basically treat <code>Auto</code>s “as if” they were <code>(-&gt;)</code>. We can literally “abstract over” the idea of a function. Neat, huh?</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Category</span> r <span class="kw">where</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a><span class="ot">    id  ::</span> r a a</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a><span class="ot">    (.) ::</span> r b c <span class="ot">-&gt;</span> r a b <span class="ot">-&gt;</span> r a c</span></code></pre></div>
<p>Basically, with Category, we can “abstract over” function composition and <code>id</code>. That is, instead of <code>(.)</code> being only for composing normal functions…we can use to compose morphisms in any Category, like Auto! We can also write “generic code” that works on <em>all</em> morphisms — not just <code>(-&gt;)</code>! This is like having functions <code>mapM</code> and <code>sequence</code> — which work for <em>all</em> Monads, not just IO or Maybe or something. We can reason about Monads as things on their own, instead of just as isolated instances.</p>
<p>Just be sure to use the correct imports so you don’t have name clashes with the Prelude operators:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Category</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Prelude</span> <span class="kw">hiding</span> (id, (.))</span></code></pre></div>
<p>First, let’s write the <code>(-&gt;)</code> Category instance:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Category</span> (<span class="ot">-&gt;</span>) <span class="kw">where</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>    <span class="fu">id</span>    <span class="ot">=</span> \x <span class="ot">-&gt;</span> x</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>    g <span class="op">.</span> f <span class="ot">=</span> \x <span class="ot">-&gt;</span> g (f x)</span></code></pre></div>
<p>And then our <code>Auto</code> Category instance:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/machines/Auto2.hs#L13-L18</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a><span class="co">-- interactive: https://www.fpcomplete.com/user/jle/machines</span></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Category</span> <span class="dt">Auto</span> <span class="kw">where</span></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>    <span class="fu">id</span>    <span class="ot">=</span> <span class="dt">ACons</span> <span class="op">$</span> \x <span class="ot">-&gt;</span> (x, <span class="fu">id</span>)</span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a>    g <span class="op">.</span> f <span class="ot">=</span> <span class="dt">ACons</span> <span class="op">$</span> \x <span class="ot">-&gt;</span></span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a>              <span class="kw">let</span> (y, f&#39;) <span class="ot">=</span> runAuto f x</span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a>                  (z, g&#39;) <span class="ot">=</span> runAuto g y</span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true" tabindex="-1"></a>              <span class="kw">in</span>  (z, g&#39; <span class="op">.</span> f&#39;)</span></code></pre></div>
<p>And now… we can work with both <code>(-&gt;)</code> and <code>Auto</code> as if they were the “same thing” :)</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/machines/Auto2.hs#L92-L93</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a><span class="co">-- interactive: https://www.fpcomplete.com/user/jle/machines</span></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a><span class="ot">doTwice ::</span> <span class="dt">Category</span> r <span class="ot">=&gt;</span> r a a <span class="ot">-&gt;</span> r a a</span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>doTwice f <span class="ot">=</span> f <span class="op">.</span> f</span></code></pre></div>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> doTwice (<span class="op">*</span><span class="dv">2</span>) <span class="dv">5</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a><span class="dv">20</span></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> testAuto_ (doTwice (toAuto (<span class="op">*</span><span class="dv">2</span>))) [<span class="dv">5</span>]</span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a>[<span class="dv">20</span>]</span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> testAuto_ (doTwice summer) [<span class="dv">5</span>,<span class="dv">1</span>,<span class="dv">9</span>,<span class="dv">2</span>,<span class="op">-</span><span class="dv">3</span>,<span class="dv">4</span>]</span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a>[<span class="dv">5</span>,<span class="dv">11</span>,<span class="dv">26</span>,<span class="dv">43</span>,<span class="dv">57</span>,<span class="dv">61</span>]</span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> <span class="fu">take</span> <span class="dv">6</span> <span class="op">$</span> testAuto_ (doTwice summer) (<span class="fu">repeat</span> <span class="dv">1</span>)</span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true" tabindex="-1"></a>[<span class="dv">1</span>,<span class="dv">3</span>,<span class="dv">6</span>,<span class="dv">10</span>,<span class="dv">15</span>,<span class="dv">21</span>]</span></code></pre></div>
<p>The main cool thing here is that we can now abstract over the “idea” of <code>id</code> and <code>(.)</code>, and now our Autos have basically not only captured the idea of function-ness, but can now literally act like normal functions in our code. I mentioned something similar in an earlier post <a href="http://blog.jle.im/entry/the-list-monadplus-practical-fun-with-monads-part">in MonadPlus</a> — the ability to have a “common language” to talk and abstract over many things is powerful not only for expressiveness but for reasoning and maintainability.</p>
<h2 id="more-typeclasses">More Typeclasses!</h2>
<p>Anyways, we love typeclasses so much. Let’s get more familiar with our Auto type and see what other useful typeclasses it can be :) Not only are these good exercises for understanding our type, we’ll also be using these instances later!</p>
<h3 id="functor">Functor</h3>
<p>Functor is always a fun typeclass! One use case of Functor is as a “producer transformer” — the <code>f a</code> is some “producer of <code>a</code>”. <code>IO a</code> is a computation that produces an <code>a</code>; <code>Reader r a</code> produces an <code>a</code> when given an <code>r</code>.</p>
<p>So if you have <code>f a</code>, we have a handy function <code>fmap</code>:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="fu">fmap</span><span class="ot"> ::</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b</span></code></pre></div>
<p>Which says, “If you have an <code>a -&gt; b</code>, I can turn a producer of <code>a</code>’s into a producer of <code>b</code>’s.”</p>
<p>There are some laws associated with fmap — most importantly that <code>fmap id = id</code>.</p>
<p>Can we turn <code>Auto</code> into a Functor?</p>
<p>…well, no, we can’t. Because <code>fmap :: (a -&gt; b) -&gt; Auto a -&gt; Auto b</code> makes no sense…Auto takes two type parameters, not one.</p>
<p>But we <em>can</em> think of <code>Auto r a</code> as a “producer of <code>a</code>”s, when used with <code>runAuto</code>. Our Functor is <code>Auto r</code>:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="fu">fmap</span><span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Auto</span> r a <span class="ot">-&gt;</span> <span class="dt">Auto</span> r b</span></code></pre></div>
<p>Which says, “Give me any <code>a -&gt; b</code>, and I’ll take an Auto that takes an <code>r</code> and returns an <code>a</code>…and give you an Auto that takes an <code>r</code> and returns a <code>b</code>”.</p>
<p>How can I do that?</p>
<p>Well…for one…I can just “run” the Auto you give me to get the <code>a</code>…and then apply the function to that <code>a</code> to get the <code>b</code>!</p>
<p>For example, if I fmapped <code>show</code> onto <code>summer</code> — if <code>summer</code> was going to output a 1, it will now output a <code>"1"</code>. It turns an <code>Auto Int Int</code> into an <code>Auto Int String</code>!</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/machines/Auto2.hs#L20-L23</span></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a><span class="co">-- interactive: https://www.fpcomplete.com/user/jle/machines</span></span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Functor</span> (<span class="dt">Auto</span> r) <span class="kw">where</span></span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a>    <span class="fu">fmap</span> f a <span class="ot">=</span> <span class="dt">ACons</span> <span class="op">$</span> \x <span class="ot">-&gt;</span></span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true" tabindex="-1"></a>                 <span class="kw">let</span> (y, a&#39;) <span class="ot">=</span> runAuto a x</span>
<span id="cb23-7"><a href="#cb23-7" aria-hidden="true" tabindex="-1"></a>                 <span class="kw">in</span>  (f y, <span class="fu">fmap</span> f a&#39;)</span></code></pre></div>
<div class="sourceCode" id="cb24"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> testAuto_ (<span class="fu">fmap</span> <span class="fu">show</span> summer) [<span class="dv">5</span>,<span class="dv">1</span>,<span class="dv">9</span>,<span class="dv">2</span>,<span class="op">-</span><span class="dv">3</span>,<span class="dv">4</span>]</span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a>[<span class="st">&quot;5&quot;</span>,<span class="st">&quot;6&quot;</span>,<span class="st">&quot;15&quot;</span>,<span class="st">&quot;17&quot;</span>,<span class="st">&quot;14&quot;</span>,<span class="st">&quot;18&quot;</span>]</span></code></pre></div>
<p>Functor, check!</p>
<p>What’s next?</p>
<div class="note">
<p><strong>Aside</strong></p>
<p>If you ever have time, try doing some research on the <a href="https://ocharles.org.uk/blog/guest-posts/2013-12-21-24-days-of-hackage-contravariant.html">Contravariant</a> Functors and <a href="https://ocharles.org.uk/blog/guest-posts/2013-12-22-24-days-of-hackage-profunctors.html">Profunctors</a>. Can you make <code>Auto</code> or <code>Auto r</code> either one of those? Which ones? If not all of them, why not?</p>
</div>
<h3 id="applicative">Applicative</h3>
<p>Everyone knows that the “cool”, <em>hip</em> typeclasses are the classic trio, <a href="http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html">Functor, Applicative, Monad</a>. Let’s just move on right along and go for Applicative.</p>
<p>If we continue the same sort of pattern that we did with Functor (some Functors being producers-kinda), Applicative gives you two things: the ability to “create a new ‘producer’” producing a given value, and the ability to take something that produces a function and something that produces a value and squash it into something that produces the application of the two.</p>
<p>This stuff…is really better said in types.</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Applicative</span> f <span class="kw">where</span></span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a><span class="ot">    pure  ::</span> a <span class="ot">-&gt;</span> f a</span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a><span class="ot">    (&lt;*&gt;) ::</span> f (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b</span></code></pre></div>
<p>In <code>pure</code>, give me an <code>a</code> and I’ll give you a “producer” of that very <code>a</code>. In <code>(&lt;*&gt;)</code>, give me a producer of <code>a -&gt; b</code> and a producer of <code>a</code> and I’ll give you a producer of <code>b</code>.</p>
<p>We can pretty much use this to write our Applicative instance for <code>Auto r</code>.</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/machines/Auto2.hs#L25-L30</span></span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a><span class="co">-- interactive: https://www.fpcomplete.com/user/jle/machines</span></span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Applicative</span> (<span class="dt">Auto</span> r) <span class="kw">where</span></span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a>    <span class="fu">pure</span> y    <span class="ot">=</span> <span class="dt">ACons</span> <span class="op">$</span> \_ <span class="ot">-&gt;</span> (y, <span class="fu">pure</span> y)</span>
<span id="cb26-6"><a href="#cb26-6" aria-hidden="true" tabindex="-1"></a>    af <span class="op">&lt;*&gt;</span> ay <span class="ot">=</span> <span class="dt">ACons</span> <span class="op">$</span> \x <span class="ot">-&gt;</span></span>
<span id="cb26-7"><a href="#cb26-7" aria-hidden="true" tabindex="-1"></a>                  <span class="kw">let</span> (f, af&#39;) <span class="ot">=</span> runAuto af x</span>
<span id="cb26-8"><a href="#cb26-8" aria-hidden="true" tabindex="-1"></a>                      (y, ay&#39;) <span class="ot">=</span> runAuto ay x</span>
<span id="cb26-9"><a href="#cb26-9" aria-hidden="true" tabindex="-1"></a>                  <span class="kw">in</span>  (f y, af&#39; <span class="op">&lt;*&gt;</span> ay&#39;)</span></code></pre></div>
<p>Note that <code>pure</code> gives us a “constant Auto” — an <code>Auto</code> that ignores its input and always just produces the same thing.</p>
<p>The useful thing about Applicative is that it gives us <code>liftA2</code>, which allows us to apply a function “over Applicative”s.</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="ot">liftA2 ::</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> <span class="dt">Auto</span> r a <span class="ot">-&gt;</span> <span class="dt">Auto</span> r b <span class="ot">-&gt;</span> <span class="dt">Auto</span> r c</span></code></pre></div>
<p>That is, it “feeds in” the <code>r</code> input to <em>both</em> the <code>Auto r a</code> and the <code>Auto r b</code>, applies the function to both of the results, and the returns the result.</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> testAuto_ summer [<span class="dv">5</span>,<span class="dv">1</span>,<span class="dv">9</span>,<span class="dv">2</span>,<span class="op">-</span><span class="dv">3</span>,<span class="dv">4</span>]</span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a>[<span class="dv">5</span>,<span class="dv">6</span>,<span class="dv">15</span>,<span class="dv">17</span>,<span class="dv">14</span>,<span class="dv">18</span>]</span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> <span class="kw">let</span> addSumDoub <span class="ot">=</span> liftA2 (<span class="op">+</span>) doubleA summer</span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> testAuto_ addSumDoub [<span class="dv">5</span>,<span class="dv">1</span>,<span class="dv">9</span>,<span class="dv">2</span>,<span class="op">-</span><span class="dv">3</span>,<span class="dv">4</span>]</span>
<span id="cb28-6"><a href="#cb28-6" aria-hidden="true" tabindex="-1"></a>[<span class="dv">15</span>,<span class="dv">8</span>,<span class="dv">33</span>,<span class="dv">21</span>,<span class="dv">8</span>,<span class="dv">26</span>]</span>
<span id="cb28-7"><a href="#cb28-7" aria-hidden="true" tabindex="-1"></a><span class="co">-- [5 + 10, 6 + 2, 15 + 18, 17 + 4, 14 - 6, 18 + 8]</span></span></code></pre></div>
<p>Hopefully by now you’ve seen enough usage of the <code>Auto</code> type and writing <code>Auto</code> combinators that do useful things that you are now Auto experts :) Feel free to press pause here, because we’re going to ramp up to some more unfamiliar abstractions. If you don’t understand some of the examples above, feel free to tinker with them on your own until you are comfortable. And as always, if you have any questions, feel free to leave a comment or drop by the freenode #haskell channel.</p>
<p>Okay, now on to…</p>
<h3 id="monad">Monad</h3>
<p>Sykes!! We’re not going to make a Monad instance :) Even though it is possible, a Monad instance for <code>Auto</code> is remarkably useless. We won’t be using a monadic interface when working with Auto, so forget about it! What are Monads, anyway?</p>
<p>Take <em>that</em>, <a href="http://www.reddit.com/r/programming/comments/25yent/i_like_haskell_because_it_lets_me_live_inside_my/chmj8al">tomtomtom7</a>! :D</p>
<h2 id="arrow">Arrow</h2>
<p>Okay. As it turns out, <code>Category</code> by itself is nice, but for many of the things we will be playing with function composition, it’s just not going to cut it.</p>
<p>As it turns out, we can actually sort of take advantage of a “do notation-like” syntactical sugar construct to perform complex compositions. But in order to do that, we first need to be able to “side chain” compositions. That is, split off values, perform different compositions on both forks, and recombine them. We require sort of basic set of combinators on top of our Category instance.</p>
<p>The Arrow typeclass was invented for just this — a grab-bag of combinators that allow such side-chaining, forking, merging behavior.</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Category</span> r <span class="ot">=&gt;</span> <span class="dt">Arrow</span> r <span class="kw">where</span></span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a><span class="ot">    arr    ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> r a b</span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a><span class="ot">    first  ::</span> r a b <span class="ot">-&gt;</span> r (a, c) (b, c)</span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a><span class="ot">    second ::</span> r a b <span class="ot">-&gt;</span> r (c, a) (c, b)</span>
<span id="cb29-5"><a href="#cb29-5" aria-hidden="true" tabindex="-1"></a><span class="ot">    (***)  ::</span> r a b <span class="ot">-&gt;</span> r c d <span class="ot">-&gt;</span> r (a, c) (b, d)</span>
<span id="cb29-6"><a href="#cb29-6" aria-hidden="true" tabindex="-1"></a><span class="ot">    (&amp;&amp;&amp;)  ::</span> r a b <span class="ot">-&gt;</span> r a c <span class="ot">-&gt;</span> r a (b, c)</span></code></pre></div>
<p>In our case, <code>arr</code> turns any <code>a -&gt; b</code> function into an <code>Auto a b</code>. <code>first</code> turns an <code>Auto a b</code> into an <code>Auto (a, c) (b, c)</code> — an Auto that operates on single values to an Auto that operates only on the first part of a tuple.</p>
<p><code>(***)</code> chains Autos side-by-side: <code>Auto a b -&gt; Auto c d -&gt; Auto (a, c) (b, d)</code>. It basically has each Auto operate on the tuple “in parallel”.</p>
<p><code>(&amp;&amp;&amp;)</code> “forks”. Give an <code>Auto a b</code> and an <code>Auto a c</code>, and it’ll create a “forking” <code>Auto a (b, c)</code>.</p>
<p>Writing the instance is straightforward enough:</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/machines/Auto2.hs#L32-L47</span></span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a><span class="co">-- interactive: https://www.fpcomplete.com/user/jle/machines</span></span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Arrow</span> <span class="dt">Auto</span> <span class="kw">where</span></span>
<span id="cb30-5"><a href="#cb30-5" aria-hidden="true" tabindex="-1"></a>    arr f     <span class="ot">=</span> <span class="dt">ACons</span> <span class="op">$</span> \x <span class="ot">-&gt;</span> (f x, arr f)</span>
<span id="cb30-6"><a href="#cb30-6" aria-hidden="true" tabindex="-1"></a>    first a   <span class="ot">=</span> <span class="dt">ACons</span> <span class="op">$</span> \(x, z) <span class="ot">-&gt;</span></span>
<span id="cb30-7"><a href="#cb30-7" aria-hidden="true" tabindex="-1"></a>                  <span class="kw">let</span> (y, a&#39;) <span class="ot">=</span> runAuto a x</span>
<span id="cb30-8"><a href="#cb30-8" aria-hidden="true" tabindex="-1"></a>                  <span class="kw">in</span>  ((y, z), first a&#39;)</span>
<span id="cb30-9"><a href="#cb30-9" aria-hidden="true" tabindex="-1"></a>    second a  <span class="ot">=</span> <span class="dt">ACons</span> <span class="op">$</span> \(z, x) <span class="ot">-&gt;</span></span>
<span id="cb30-10"><a href="#cb30-10" aria-hidden="true" tabindex="-1"></a>                  <span class="kw">let</span> (y, a&#39;) <span class="ot">=</span> runAuto a x</span>
<span id="cb30-11"><a href="#cb30-11" aria-hidden="true" tabindex="-1"></a>                  <span class="kw">in</span>  ((z, y), second a&#39;)</span>
<span id="cb30-12"><a href="#cb30-12" aria-hidden="true" tabindex="-1"></a>    a1 <span class="op">***</span> a2 <span class="ot">=</span> <span class="dt">ACons</span> <span class="op">$</span> \(x1, x2) <span class="ot">-&gt;</span></span>
<span id="cb30-13"><a href="#cb30-13" aria-hidden="true" tabindex="-1"></a>                  <span class="kw">let</span> (y1, a1&#39;) <span class="ot">=</span> runAuto a1 x1</span>
<span id="cb30-14"><a href="#cb30-14" aria-hidden="true" tabindex="-1"></a>                      (y2, a2&#39;) <span class="ot">=</span> runAuto a2 x2</span>
<span id="cb30-15"><a href="#cb30-15" aria-hidden="true" tabindex="-1"></a>                  <span class="kw">in</span>  ((y1, y2), a1&#39; <span class="op">***</span> a2&#39;)</span>
<span id="cb30-16"><a href="#cb30-16" aria-hidden="true" tabindex="-1"></a>    a1 <span class="op">&amp;&amp;&amp;</span> a2 <span class="ot">=</span> <span class="dt">ACons</span> <span class="op">$</span> \x <span class="ot">-&gt;</span></span>
<span id="cb30-17"><a href="#cb30-17" aria-hidden="true" tabindex="-1"></a>                  <span class="kw">let</span> (y1, a1&#39;) <span class="ot">=</span> runAuto a1 x</span>
<span id="cb30-18"><a href="#cb30-18" aria-hidden="true" tabindex="-1"></a>                      (y2, a2&#39;) <span class="ot">=</span> runAuto a2 x</span>
<span id="cb30-19"><a href="#cb30-19" aria-hidden="true" tabindex="-1"></a>                  <span class="kw">in</span>  ((y1, y2), a1&#39; <span class="op">&amp;&amp;&amp;</span> a2&#39;)</span></code></pre></div>
<div class="note">
<p><strong>Aside</strong></p>
<p>We can also just take a shortcut and implement these in terms of combinators we have already written from different typeclasses:</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Arrow</span> <span class="dt">Auto</span> <span class="kw">where</span></span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a>    arr f     <span class="ot">=</span> <span class="fu">fmap</span> f <span class="fu">id</span></span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a>    first a   <span class="ot">=</span> liftA2 (,) (a  <span class="op">.</span> arr <span class="fu">fst</span>) (arr <span class="fu">snd</span>)</span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true" tabindex="-1"></a>    second a  <span class="ot">=</span> liftA2 (,) (arr <span class="fu">fst</span>)      (a  <span class="op">.</span> arr <span class="fu">snd</span>)</span>
<span id="cb31-5"><a href="#cb31-5" aria-hidden="true" tabindex="-1"></a>    a1 <span class="op">***</span> a2 <span class="ot">=</span> liftA2 (,) (a1 <span class="op">.</span> arr <span class="fu">fst</span>) (a2 <span class="op">.</span> arr <span class="fu">snd</span>)</span>
<span id="cb31-6"><a href="#cb31-6" aria-hidden="true" tabindex="-1"></a>    a1 <span class="op">&amp;&amp;&amp;</span> a2 <span class="ot">=</span> (a1 <span class="op">***</span> a2) <span class="op">.</span> arr (\x <span class="ot">-&gt;</span> (x, x))</span></code></pre></div>
<p>Remember, <code>id</code> is the identity Auto… and <code>fmap f</code> applies <code>f</code> “after” the identity. So this makes sense.</p>
<p><code>first</code> is a little trickier; we are using <code>liftA2 (,)</code> on two Autos, kind of like we used before. <code>liftA2</code> says “run these two Autos in parallel on the same input, and then at the end, <code>(,)</code>-up their results.”</p>
<p>The first of those two autos is <code>a . arr fst</code> — get the first thing in the tuple, and then chain the <code>a</code> auto onto it. The second of those two autos just simply extracts out the second part of the tuple.</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="ot">a           ::</span> <span class="dt">Auto</span> a b</span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a>arr<span class="ot"> fst     ::</span> <span class="dt">Auto</span> (a, c) a</span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true" tabindex="-1"></a>a <span class="op">.</span> arr<span class="ot"> fst ::</span> <span class="dt">Auto</span> (a, c) b</span>
<span id="cb32-5"><a href="#cb32-5" aria-hidden="true" tabindex="-1"></a>arr<span class="ot"> snd     ::</span> <span class="dt">Auto</span> (a, c) c</span>
<span id="cb32-6"><a href="#cb32-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-7"><a href="#cb32-7" aria-hidden="true" tabindex="-1"></a>liftA2 (,) (a <span class="op">.</span> arr <span class="fu">fst</span>) (arr <span class="fu">snd</span>)<span class="ot"> ::</span> <span class="dt">Auto</span> (a, c) (b, c)</span></code></pre></div>
<p>What does this show? Well, that <code>Arrow</code> really isn’t anything too special…it’s really just what we already had — a <code>Category</code> with <code>Applicative</code>. But we are able to define more efficient instances, and also sort of look at the problem in a “different way”.</p>
</div>
<p>What we have here isn’t really anything too mystical. It’s just some basic combinators. And like the aside says, we didn’t introduce any “new power” — anything we could “do” with Auto using Arrow, we could already do with Category and Applicative.</p>
<p>The main point is just that we have these neat combinators to chain things in more useful and expressive ways — something very important when we eventually go into AFRP.</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> <span class="kw">let</span> sumDoub <span class="ot">=</span> summer <span class="op">&amp;&amp;&amp;</span> doubleA</span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> testAuto_ sumDoub [<span class="dv">5</span>,<span class="dv">1</span>,<span class="dv">9</span>,<span class="dv">2</span>,<span class="op">-</span><span class="dv">3</span>,<span class="dv">4</span>]</span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a>[(<span class="dv">5</span>, <span class="dv">10</span>), (<span class="dv">6</span>, <span class="dv">2</span>), (<span class="dv">15</span>, <span class="dv">18</span>), (<span class="dv">17</span>, <span class="dv">4</span>), (<span class="dv">14</span>, <span class="op">-</span><span class="dv">6</span>), (<span class="dv">18</span>, <span class="dv">8</span>)]</span></code></pre></div>
<p>As we’ll see, the <em>real</em> benefit of Arrow will be in the syntactical sugar it provides, analogous to Monad’s do-blocks.</p>
<h4 id="arrowchoice">ArrowChoice</h4>
<p>Another useful set of combinators is the <code>ArrowChoice</code> typeclass, which provides:</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a><span class="ot">left  ::</span> <span class="dt">Auto</span> a b <span class="ot">-&gt;</span> <span class="dt">Auto</span> (<span class="dt">Either</span> a c) (<span class="dt">Either</span> b c)</span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a><span class="ot">right ::</span> <span class="dt">Auto</span> a b <span class="ot">-&gt;</span> <span class="dt">Auto</span> (<span class="dt">Either</span> c a) (<span class="dt">Either</span> c b)</span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a><span class="ot">(+++) ::</span> <span class="dt">Auto</span> a b <span class="ot">-&gt;</span> <span class="dt">Auto</span> c d <span class="ot">-&gt;</span> <span class="dt">Auto</span> (<span class="dt">Either</span> a c) (<span class="dt">Either</span> b d)</span>
<span id="cb34-4"><a href="#cb34-4" aria-hidden="true" tabindex="-1"></a><span class="ot">(|||) ::</span> <span class="dt">Auto</span> a c <span class="ot">-&gt;</span> <span class="dt">Auto</span> b c <span class="ot">-&gt;</span> <span class="dt">Auto</span> (<span class="dt">Either</span> a b) c</span></code></pre></div>
<p>If you look really closely…<code>left</code> is kinda like <code>first</code>; <code>right</code> is kinda like <code>second</code>…<code>(+++)</code> is kinda like <code>(***)</code>, and <code>(|||)</code> is like a backwards <code>(&amp;&amp;&amp;)</code>.</p>
<p>If <code>Arrow</code> allows computations to be “side-chained”, <code>ArrowChoice</code> allows computations to be “skipped/ignored”.</p>
<p>We’ll instance <code>left</code>, which applies the given <code>Auto</code> on every <code>Left</code> input, and passes any <code>Right</code> input along unchanged; the <code>Auto</code> isn’t stepped or anything. The rest of the methods can be implemented in terms of <code>left</code> and <code>arr</code>.</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/machines/Auto2.hs#L49-L56</span></span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a><span class="co">-- interactive: https://www.fpcomplete.com/user/jle/machines</span></span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-4"><a href="#cb35-4" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">ArrowChoice</span> <span class="dt">Auto</span> <span class="kw">where</span></span>
<span id="cb35-5"><a href="#cb35-5" aria-hidden="true" tabindex="-1"></a>    left a <span class="ot">=</span> <span class="dt">ACons</span> <span class="op">$</span> \x <span class="ot">-&gt;</span></span>
<span id="cb35-6"><a href="#cb35-6" aria-hidden="true" tabindex="-1"></a>                 <span class="kw">case</span> x <span class="kw">of</span></span>
<span id="cb35-7"><a href="#cb35-7" aria-hidden="true" tabindex="-1"></a>                   <span class="dt">Left</span> l  <span class="ot">-&gt;</span></span>
<span id="cb35-8"><a href="#cb35-8" aria-hidden="true" tabindex="-1"></a>                     <span class="kw">let</span> (l&#39;, a&#39;) <span class="ot">=</span> runAuto a l</span>
<span id="cb35-9"><a href="#cb35-9" aria-hidden="true" tabindex="-1"></a>                     <span class="kw">in</span>  (<span class="dt">Left</span> l&#39;, left a&#39;)</span>
<span id="cb35-10"><a href="#cb35-10" aria-hidden="true" tabindex="-1"></a>                   <span class="dt">Right</span> r <span class="ot">-&gt;</span></span>
<span id="cb35-11"><a href="#cb35-11" aria-hidden="true" tabindex="-1"></a>                     (<span class="dt">Right</span> r, left a)</span></code></pre></div>
<p>We’ll see <code>ArrowChoice</code> used in the upcoming syntactic sugar construct, enabling for if/then/else’s and case statements. Don’t worry about it for now if you don’t understand it.</p>
<h3 id="proc-notation">Proc Notation</h3>
<p>So finally, here is the <em>real</em> reason Arrow is useful. It’s actually a pretty well-kept secret, but…just like Monad enables <em>do notation</em> syntactical sugar, Arrow enables <em>proc notation</em> syntactical sugar. Which is probably cooler.</p>
<p>Not gonna lie.</p>
<p>A lot of AFRP and a lot of what we’re going to be doing will pretty much rely on proc notation to be able to express complex compositions…rather elegantly.</p>
<p>Proc notation consists of lines of “arrows”:</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a>arrow <span class="op">-&lt;</span> x</span></code></pre></div>
<p>which says “feed <code>x</code> through the Arrow <code>arrow</code>”.</p>
<p>Like in monadic do-blocks, you can also “bind” the result, to be used later in the block:</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a>y <span class="ot">&lt;-</span> arrow <span class="op">-&lt;</span> x</span></code></pre></div>
<p>Which says “feed <code>x</code> through the Arrow <code>arrow</code>, and name the result <code>y</code>”.</p>
<p>Hey! It looks like a little ASCII arrow! Cute, huh?</p>
<p>The last line of a proc do block is the “return”/result of the block, like in monadic do-blocks.</p>
<p>Let’s write our first proc block; one that emulates our <code>liftA2 (+) doubleA summer</code>:</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a><span class="ot">doubSummer ::</span> <span class="dt">Auto</span> <span class="dt">Int</span> <span class="dt">Int</span></span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true" tabindex="-1"></a>doubSummer <span class="ot">=</span> proc x <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb38-3"><a href="#cb38-3" aria-hidden="true" tabindex="-1"></a>    summed  <span class="ot">&lt;-</span> summer  <span class="op">-&lt;</span> x</span>
<span id="cb38-4"><a href="#cb38-4" aria-hidden="true" tabindex="-1"></a>    doubled <span class="ot">&lt;-</span> doubleA <span class="op">-&lt;</span> x</span>
<span id="cb38-5"><a href="#cb38-5" aria-hidden="true" tabindex="-1"></a>    <span class="fu">id</span> <span class="op">-&lt;</span> summed <span class="op">+</span> doubled</span></code></pre></div>
<p>In the last line, we want to “return” <code>summed + double</code>; we have to put an Arrow command there, so we can just feed <code>summed + double</code> through <code>id</code>, to have it pop out at the end.</p>
<p>You can think of <code>id</code> like <code>return</code> in normal do notation.</p>
<h4 id="simple-useful-example">Simple useful example</h4>
<p>How about an <code>Auto (Either Int Int) (Int, Int)</code>, which maintains <em>two</em> internal counters. You increment the first one with an input of <code>Left x</code>, and you increment the second one with an input of <code>Right x</code>. The output is the state of both counters.</p>
<p>We could write this “from scratch”, using explicit recursion:</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/machines/Auto2.hs#L102-L109</span></span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true" tabindex="-1"></a><span class="co">-- interactive: https://www.fpcomplete.com/user/jle/machines</span></span>
<span id="cb39-3"><a href="#cb39-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-4"><a href="#cb39-4" aria-hidden="true" tabindex="-1"></a><span class="ot">dualCounterR ::</span> <span class="dt">Auto</span> (<span class="dt">Either</span> <span class="dt">Int</span> <span class="dt">Int</span>) (<span class="dt">Int</span>, <span class="dt">Int</span>)</span>
<span id="cb39-5"><a href="#cb39-5" aria-hidden="true" tabindex="-1"></a>dualCounterR <span class="ot">=</span> dualCounterWith (<span class="dv">0</span>, <span class="dv">0</span>)</span>
<span id="cb39-6"><a href="#cb39-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb39-7"><a href="#cb39-7" aria-hidden="true" tabindex="-1"></a>    dualCounterWith (x, y) <span class="ot">=</span> <span class="dt">ACons</span> <span class="op">$</span> \inp <span class="ot">-&gt;</span></span>
<span id="cb39-8"><a href="#cb39-8" aria-hidden="true" tabindex="-1"></a>                               <span class="kw">let</span> newC <span class="ot">=</span> <span class="kw">case</span> inp <span class="kw">of</span></span>
<span id="cb39-9"><a href="#cb39-9" aria-hidden="true" tabindex="-1"></a>                                            <span class="dt">Left</span> i  <span class="ot">-&gt;</span> (x <span class="op">+</span> i, y)</span>
<span id="cb39-10"><a href="#cb39-10" aria-hidden="true" tabindex="-1"></a>                                            <span class="dt">Right</span> i <span class="ot">-&gt;</span> (x, y <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb39-11"><a href="#cb39-11" aria-hidden="true" tabindex="-1"></a>                               <span class="kw">in</span>  (newC, dualCounterWith newC)</span></code></pre></div>
<p>But we all know in Haskell that explicit recursion is usually a sign of bad design and is best avoided whenever possible. So many potential places for bugs!</p>
<p>Let’s try writing the same thing using Auto composition:</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/machines/Auto2.hs#L112-L116</span></span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a><span class="co">-- interactive: https://www.fpcomplete.com/user/jle/machines</span></span>
<span id="cb40-3"><a href="#cb40-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-4"><a href="#cb40-4" aria-hidden="true" tabindex="-1"></a><span class="ot">dualCounterC ::</span> <span class="dt">Auto</span> (<span class="dt">Either</span> <span class="dt">Int</span> <span class="dt">Int</span>) (<span class="dt">Int</span>, <span class="dt">Int</span>)</span>
<span id="cb40-5"><a href="#cb40-5" aria-hidden="true" tabindex="-1"></a>dualCounterC <span class="ot">=</span> (summer <span class="op">***</span> summer) <span class="op">.</span> arr wrap</span>
<span id="cb40-6"><a href="#cb40-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb40-7"><a href="#cb40-7" aria-hidden="true" tabindex="-1"></a>    wrap (<span class="dt">Left</span> i)  <span class="ot">=</span> (i, <span class="dv">0</span>)</span>
<span id="cb40-8"><a href="#cb40-8" aria-hidden="true" tabindex="-1"></a>    wrap (<span class="dt">Right</span> i) <span class="ot">=</span> (<span class="dv">0</span>, i)</span></code></pre></div>
<p>That’s a bit more succinct, but I think the proc notation is much nicer!</p>
<div class="sourceCode" id="cb41"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/machines/Auto2.hs#L119-L127</span></span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true" tabindex="-1"></a><span class="co">-- interactive: https://www.fpcomplete.com/user/jle/machines</span></span>
<span id="cb41-3"><a href="#cb41-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-4"><a href="#cb41-4" aria-hidden="true" tabindex="-1"></a><span class="ot">dualCounterP ::</span> <span class="dt">Auto</span> (<span class="dt">Either</span> <span class="dt">Int</span> <span class="dt">Int</span>) (<span class="dt">Int</span>, <span class="dt">Int</span>)</span>
<span id="cb41-5"><a href="#cb41-5" aria-hidden="true" tabindex="-1"></a>dualCounterP <span class="ot">=</span> proc inp <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb41-6"><a href="#cb41-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> (add1, add2) <span class="ot">=</span> <span class="kw">case</span> inp <span class="kw">of</span> <span class="dt">Left</span> i  <span class="ot">-&gt;</span> (i, <span class="dv">0</span>)</span>
<span id="cb41-7"><a href="#cb41-7" aria-hidden="true" tabindex="-1"></a>                                   <span class="dt">Right</span> i <span class="ot">-&gt;</span> (<span class="dv">0</span>, i)</span>
<span id="cb41-8"><a href="#cb41-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-9"><a href="#cb41-9" aria-hidden="true" tabindex="-1"></a>    sum1 <span class="ot">&lt;-</span> summer <span class="op">-&lt;</span> add1</span>
<span id="cb41-10"><a href="#cb41-10" aria-hidden="true" tabindex="-1"></a>    sum2 <span class="ot">&lt;-</span> summer <span class="op">-&lt;</span> add2</span>
<span id="cb41-11"><a href="#cb41-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-12"><a href="#cb41-12" aria-hidden="true" tabindex="-1"></a>    <span class="fu">id</span> <span class="op">-&lt;</span> (sum1, sum2)</span></code></pre></div>
<p>It’s a bit more verbose…but I think it’s much clearer what’s going on, right?</p>
<div class="sourceCode" id="cb42"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> testAuto_ dualCounterP [<span class="dt">Right</span> <span class="dv">1</span>, <span class="dt">Left</span> <span class="dv">2</span>, <span class="dt">Right</span> (<span class="op">-</span><span class="dv">4</span>), <span class="dt">Left</span> <span class="dv">10</span>, <span class="dt">Right</span> <span class="dv">3</span>]</span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true" tabindex="-1"></a>[(<span class="dv">0</span>, <span class="dv">1</span>), (<span class="dv">2</span>, <span class="dv">1</span>), (<span class="dv">2</span>, <span class="op">-</span><span class="dv">3</span>), (<span class="dv">12</span>, <span class="op">-</span><span class="dv">3</span>), (<span class="dv">12</span>, <span class="dv">0</span>)]</span></code></pre></div>
<h4 id="proc-shines">Proc shines</h4>
<p>And let’s say we wanted another constraint. Let’s say that…for the <code>Left</code> case, every <em>other</em> time it’s a Left, <em>ignore the value</em> and don’t add anything. That is, every second, fourth, sixth <code>Left i</code> input should ignore the <code>i</code> and not add anything.</p>
<p>How would we do this in the explicit recursive case? Why — well, adding another component to the “explicit state” tuple, and dealing with that when necessary.</p>
<p>I don’t even know how to begin writing it in a readable way using arrow composition.</p>
<p>But the proc notation? Piece of cake!</p>
<div class="sourceCode" id="cb43"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/machines/Auto2.hs#L148-L160</span></span>
<span id="cb43-2"><a href="#cb43-2" aria-hidden="true" tabindex="-1"></a><span class="co">-- interactive: https://www.fpcomplete.com/user/jle/machines</span></span>
<span id="cb43-3"><a href="#cb43-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-4"><a href="#cb43-4" aria-hidden="true" tabindex="-1"></a><span class="ot">dualCounterSkipP ::</span> <span class="dt">Auto</span> (<span class="dt">Either</span> <span class="dt">Int</span> <span class="dt">Int</span>) (<span class="dt">Int</span>, <span class="dt">Int</span>)</span>
<span id="cb43-5"><a href="#cb43-5" aria-hidden="true" tabindex="-1"></a>dualCounterSkipP <span class="ot">=</span> proc inp <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb43-6"><a href="#cb43-6" aria-hidden="true" tabindex="-1"></a>    (add1, add2) <span class="ot">&lt;-</span> <span class="kw">case</span> inp <span class="kw">of</span></span>
<span id="cb43-7"><a href="#cb43-7" aria-hidden="true" tabindex="-1"></a>                      <span class="dt">Left</span> i <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb43-8"><a href="#cb43-8" aria-hidden="true" tabindex="-1"></a>                        count <span class="ot">&lt;-</span> summer <span class="op">-&lt;</span> <span class="dv">1</span></span>
<span id="cb43-9"><a href="#cb43-9" aria-hidden="true" tabindex="-1"></a>                        <span class="fu">id</span> <span class="op">-&lt;</span> (<span class="kw">if</span> <span class="fu">odd</span> count <span class="kw">then</span> i <span class="kw">else</span> <span class="dv">0</span>, <span class="dv">0</span>)</span>
<span id="cb43-10"><a href="#cb43-10" aria-hidden="true" tabindex="-1"></a>                      <span class="dt">Right</span> i <span class="ot">-&gt;</span></span>
<span id="cb43-11"><a href="#cb43-11" aria-hidden="true" tabindex="-1"></a>                        <span class="fu">id</span> <span class="op">-&lt;</span> (<span class="dv">0</span>, i)</span>
<span id="cb43-12"><a href="#cb43-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-13"><a href="#cb43-13" aria-hidden="true" tabindex="-1"></a>    sum1 <span class="ot">&lt;-</span> summer <span class="op">-&lt;</span> add1</span>
<span id="cb43-14"><a href="#cb43-14" aria-hidden="true" tabindex="-1"></a>    sum2 <span class="ot">&lt;-</span> summer <span class="op">-&lt;</span> add2</span>
<span id="cb43-15"><a href="#cb43-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-16"><a href="#cb43-16" aria-hidden="true" tabindex="-1"></a>    <span class="fu">id</span> <span class="op">-&lt;</span> (sum1, sum2)</span></code></pre></div>
<div class="sourceCode" id="cb44"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> testAuto_ dualCounterP [<span class="dt">Right</span> <span class="dv">1</span>, <span class="dt">Left</span> <span class="dv">2</span>, <span class="dt">Right</span> (<span class="op">-</span><span class="dv">4</span>), <span class="dt">Left</span> <span class="dv">10</span>, <span class="dt">Right</span> <span class="dv">3</span>]</span>
<span id="cb44-2"><a href="#cb44-2" aria-hidden="true" tabindex="-1"></a>[(<span class="dv">0</span>, <span class="dv">1</span>), (<span class="dv">2</span>, <span class="dv">1</span>), (<span class="dv">2</span>, <span class="op">-</span><span class="dv">3</span>), (<span class="dv">2</span>, <span class="op">-</span><span class="dv">3</span>), (<span class="dv">2</span>, <span class="dv">0</span>)]</span></code></pre></div>
<p>And that’s something to write home about :)</p>
<h3 id="locally-stateful-composition">Locally Stateful Composition</h3>
<p>The last example highlights something very significant about Autos and their Arrow-based composition: Autos with composition allow you to make <em>locally stateful compositions</em>.</p>
<p>What if we had done the above using some sort of state monad, or doing the explicit recursion?</p>
<p>We’d have carried the “entire” state in the parameter:</p>
<div class="sourceCode" id="cb45"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/machines/Auto2.hs#L136-L145</span></span>
<span id="cb45-2"><a href="#cb45-2" aria-hidden="true" tabindex="-1"></a><span class="co">-- interactive: https://www.fpcomplete.com/user/jle/machines</span></span>
<span id="cb45-3"><a href="#cb45-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-4"><a href="#cb45-4" aria-hidden="true" tabindex="-1"></a><span class="ot">dualCounterSkipR ::</span> <span class="dt">Auto</span> (<span class="dt">Either</span> <span class="dt">Int</span> <span class="dt">Int</span>) (<span class="dt">Int</span>, <span class="dt">Int</span>)</span>
<span id="cb45-5"><a href="#cb45-5" aria-hidden="true" tabindex="-1"></a>dualCounterSkipR <span class="ot">=</span> counterFrom ((<span class="dv">0</span>, <span class="dv">0</span>), <span class="dv">1</span>)</span>
<span id="cb45-6"><a href="#cb45-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb45-7"><a href="#cb45-7" aria-hidden="true" tabindex="-1"></a>    counterFrom ((x, y), s) <span class="ot">=</span></span>
<span id="cb45-8"><a href="#cb45-8" aria-hidden="true" tabindex="-1"></a>      <span class="dt">ACons</span> <span class="op">$</span> \inp <span class="ot">-&gt;</span></span>
<span id="cb45-9"><a href="#cb45-9" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> newCS <span class="ot">=</span> <span class="kw">case</span> inp <span class="kw">of</span></span>
<span id="cb45-10"><a href="#cb45-10" aria-hidden="true" tabindex="-1"></a>                      <span class="dt">Left</span> i  <span class="op">|</span> <span class="fu">odd</span> s     <span class="ot">-&gt;</span> ((x <span class="op">+</span> i, y), s <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb45-11"><a href="#cb45-11" aria-hidden="true" tabindex="-1"></a>                              <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">-&gt;</span> ((x    , y), s <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb45-12"><a href="#cb45-12" aria-hidden="true" tabindex="-1"></a>                      <span class="dt">Right</span> i             <span class="ot">-&gt;</span> ((x, y <span class="op">+</span> i), s    )</span>
<span id="cb45-13"><a href="#cb45-13" aria-hidden="true" tabindex="-1"></a>        <span class="kw">in</span>  (<span class="fu">fst</span> newCS, counterFrom newCS)</span></code></pre></div>
<p>Not only is it a real mess and pain — and somewhere where bugs are rife to pop up — note the entire state is contained in one thing. That means everything has access to it; all access is sort of haphazard and ad-hoc, as well. Note that the <code>Right</code> case can do whatever it wants with the <code>s</code>. It has access to it, can read it, act on it, modify it…anything it wants! We can’t really “enforce” that the <code>Right</code> case can’t touch the <code>s</code>, without putting in more complicated work/overhead.</p>
<p>In the proc example…the <code>s</code> is a <code>summer</code> that is “locked inside” the <code>Left</code> branch. <code>Right</code> branch stuff can’t touch it.</p>
<p>In fact, all of the <code>summers</code> keep their own state, independently from each other. Nothing can really modify their state except for themselves, if they chose to. Less room for bugs, too, in adding, because you already know that <code>summer</code> works.</p>
<p>This property — that every single component maintains its own internal state — is, in my opinion, one of the most significant aspects of this whole game with Auto and Category and Arrow etc. Every component minds its own state.</p>
<p>And also — if we wanted to “add a new component” to the state, like we did, we don’t have to really change anything besides just plopping it on. In the explicit recursion example, we needed to go in and <em>change the state type</em> to “make room” for the new state. We needed to pretty much refactor the entire thing!</p>
<p>This really demonstrates the core principles of what <em>composability</em> and <em>modularity</em> even really <em>mean</em>.</p>
<h4 id="a-quick-gotcha">A Quick Gotcha</h4>
<p>Remember that with proc notation, you are really just composing and building up a giant <code>Auto</code>. Each individual <code>Auto</code> that you compose has to already be known at “composition time”. (That is, before you ever “run” it, the structure of the <code>Auto</code> is known and fixed).</p>
<p>This means that you can’t use bindings from <em>proc</em> blocks to form the <code>Auto</code>s that you are composing:</p>
<div class="sourceCode" id="cb46"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a>foo <span class="ot">=</span> proc x <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb46-2"><a href="#cb46-2" aria-hidden="true" tabindex="-1"></a>    y <span class="ot">&lt;-</span> auto1 <span class="op">-&lt;</span> x</span>
<span id="cb46-3"><a href="#cb46-3" aria-hidden="true" tabindex="-1"></a>    auto2 y <span class="op">-&lt;</span> y</span></code></pre></div>
<p>This won’t work. That’s because this is really supposed to be a composition of <code>auto1</code> and <code>auto2 y</code>. But what is <code>auto2 y</code>? <code>y</code> doesn’t even exist when you are making the compositions! <code>y</code> is just a name we gave to the output of <code>auto1</code>, in the process of our stepping it. <code>y</code> doesn’t exist until we “step” <code>foo</code>…so can’t use <code>auto2 y</code> in the process of composing <code>foo</code>.</p>
<p>To see more clearly, see what we’d do if we tried to write <code>foo</code> as a compositino:<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a></p>
<div class="sourceCode" id="cb47"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a>foo <span class="ot">=</span> auto2 y <span class="op">.</span> auto1</span></code></pre></div>
<p>Where does the <code>y</code> come from?!</p>
<p>Hopefully from this it is clear to see that it doesn’t make sense to use what you bind/name in <em>proc</em> notation to actually “create” the <code>Arrow</code> you are using.</p>
<p>Remember, <em>proc</em> notation is <code>result &lt;- arrow -&lt; input</code>. The <code>arrow</code> part has to already be known before everything even starts, so you can’t use things you bind to determine it :)</p>
<h2 id="moving-on">Moving on</h2>
<p>Welp, hopefully by now you are experts at working with the Auto machine, and understanding it as “function-like things”. You’ve gotten deep and intimate by instancing some common typeclasses.</p>
<p>Then you saw Arrow, and understood how Auto fits into the Arrow abstraction. And then you learned about proc notation, and how…everything just…fits together. And you can declare some nice computations/compositions in a way that looks a lot like monadic do blocks.</p>
<p>We saw how complex compositions — and complex recursions — now look really pretty and nice in proc-do notation.</p>
<p>And then we saw an extension of the “opaque state” concept we learned last time — <em>locally stateful compositions</em>. Using Auto composition and the Arrow instance, we can now combine Autos with local state together…and they all maintain and keep track of their own state. No more “global state”, like before — every individual component only minds what it knows, and nothing else. And that this is really what “composability” really is all about.</p>
<p>Up next, we will transition from Auto to the Wire abstraction, which is sort of like an Auto with more features.</p>
<p>And then we will be on our way! :D</p>
<h3 id="exercises">Exercises</h3>
<p>Yeah, I know that a lot of this post was pretty abstract…finding ways to make this post immediately useful with applications was one of the reasons why it took so long for me to get it out, after the last one.</p>
<p>That being said, there are some things you can try out test your understanding before Part 3 :)</p>
<ol type="1">
<li><p>Write the <a href="https://ocharles.org.uk/blog/guest-posts/2013-12-22-24-days-of-hackage-profunctors.html">Profunctor</a> instance mentioned above; look at the Functor instance we wrote as a reference. And hey, how about <code>Strong</code> and <code>Choice</code>, too?</p></li>
<li><p>Try writing the various Autos we wrote last time at the end using composition and proc notation instead of explicit recursion. Feel free to define your own “primitives” if you find that you must.</p>
<p>Some of these might be trickier than others!</p>
<p>Note that some of these can be done with just a straight-up <code>autoFold</code>, for the entire thing. While this is neat and all, it might be more useful to practice the principles of <em>local statefulness</em>, and try to break things up into as many primitives as possible; always try to avoid keeping every part of your state in one giant <code>autoFold</code> parameter.</p>
<ul>
<li><p><em>Rolling average</em>: You should be able to do this with just <code>autoFold</code> and the right proc block. You can even do it with straight up composition, but it’s a bit less clean.</p></li>
<li><p><em>onFor</em>: You should be able to do this with <code>settableAuto</code> (or something like that), and some nice proc routing with if/then/elses.</p></li>
<li><p><em>autoMap</em>: This should also be doable with <code>autoFold</code>; although there isn’t much state to separate out, so this example isn’t as interesting. It might be more fun to use this one as a component of a larger <code>Auto</code>, and see what you can use it for!</p></li>
</ul></li>
</ol>
<section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes">
<hr />
<ol>
<li id="fn1"><p>Remember, we can write <code>a -&gt; b</code> as <code>(-&gt;) a b</code>; like other operators, <code>(-&gt;)</code> can be used both infix and prefix.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p>This was originally a typo but I like the word so much that I’m just going to leave it in here.<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section></div><footer><hr><div class="copy-content"><p>Hi, thanks for reading! You can reach me via email at <a href="mailto:justin@jle.im" class="email">justin@jle.im</a>, or at twitter at <a href="https://twitter.com/mstk">@mstk</a>! This post and all others are published under the <a href="https://creativecommons.org/licenses/by-nc-nd/3.0/">CC-BY-NC-ND 3.0</a> license. Corrections and edits via pull request are welcome and encouraged at <a href="https://github.com/mstksg/inCode">the source repository</a>.</p>
<p>If you feel inclined, or this post was particularly helpful for you, why not consider <a href="https://www.patreon.com/justinle/overview">supporting me on Patreon</a>, or a <a href="bitcoin:3D7rmAYgbDnp4gp4rf22THsGt74fNucPDU">BTC donation</a>? :)</p></div><div class="clear"></div><ul class="entry-series"><li><div>This entry is a part of a series called <b>&quot;Intro to Machines and Arrows&quot;</b>.  Find the rest of the entries in this series at its <a href="https://blog.jle.im/entries/series/+intro-to-machines-and-arrows.html" class="tag-a-series" title="+Intro to Machines and Arrows"> series history</a>.</div></li></ul><ul class="tag-list"><li><a href="https://blog.jle.im/entries/tagged/arrows.html" class="tag-a-tag">#arrows</a></li><li><a href="https://blog.jle.im/entries/tagged/auto-machines.html" class="tag-a-tag">#auto-machines</a></li><li><a href="https://blog.jle.im/entries/tagged/haskell.html" class="tag-a-tag">#haskell</a></li><li><a href="https://blog.jle.im/entries/tagged/machines.html" class="tag-a-tag">#machines</a></li><li><a href="https://blog.jle.im/entries/category/@haskell.html" class="tag-a-category">@HASKELL</a></li><li><a href="https://blog.jle.im/entries/category/@ramblings.html" class="tag-a-category">@RAMBLINGS</a></li><li><a href="https://blog.jle.im/entries/series/+intro-to-machines-and-arrows.html" class="tag-a-series">+Intro to Machines and Arrows</a></li></ul><aside class="social-buttons"><div class="addthis_toolbox addthis_default_style addthis-buttons"><a class="addthis_button_facebook_like" fb:like:layout="button_count"></a><a class="addthis_button_tweet"></a><a class="addthis_button_google_plusone" g:plusone:size="medium"></a><a class="addthis_counter addthis_pill_style"></a></div><div class="custom-social-buttons"><div class="custom-social-button"><a href="https://www.reddit.com/submit" onclick="window.location = &#39;https://www.reddit.com/submit?url=&#39;+ encodeURIComponent(window.location); return false"><img src="https://www.reddit.com/static/spreddit7.gif" alt="submit to reddit"></a></div></div></aside><nav class="next-prev-links"><ul><li class="prev-entry-link">&larr; <a href="https://blog.jle.im/entry/pipes-streaming-huffman-compression-in-haskell-part-3.html">Pipes: Streaming Huffman Compression in Haskell (Part 3)</a> (Previous)</li><li class="next-entry-link">(Next) <a href="https://blog.jle.im/entry/first-class-statements.html">First-Class &quot;Statements&quot;</a> &rarr;</li></ul></nav></footer></article><div class="post-entry"><div class="tile"><div id="disqus_thread"></div><script type="text/javascript">var disqus_config = function () {
    this.page.url = 'https://blog.jle.im/entry/auto-as-category-applicative-arrow-intro-to-machines.html';
    this.page.identifier = 'machines-2';
};
(function() {
    var d = document, s = d.createElement('script');
    s.src = '//incode.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
})();
</script><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a><br></noscript><a href="http://disqus.com" class="dsq-brlink">Comments powered by <span class="logo-disqus">Disqus</span></a></div></div></div></div></div><div id="footer-container"><div id="footer-content"><div class="tile"><div class="footer-copyright">&copy; 2020 Justin Le <span class="license-link">(<a href="https://creativecommons.org/licenses/by-nc-nd/3.0/" class="license">CC-BY-NC-ND 3.0</a>)</span></div><div class="footer-follow social-follows"><ul class="social-follows-list"><li><ul class="social-follows-list-social"><li><a class="social-follow-twitter" title="Follow me on Twitter!" href="https://twitter.com/intent/user?user_id=mstk" onclick="window.open(
  &#39;http://twitter.com/intent/user?user_id=907281&#39;,
  &#39;facebook-share-dialog&#39;,
  &#39;width=550,height=520&#39;);
return false;
">Twitter</a></li><li><a class="social-follow-github" title="Fork me on Github!" href="https://github.com/mstksg">Github</a></li><li><a class="social-follow-twitch" title="Watch me on Twitch!" href="https://www.twitch.tv/justin_l">Twitch</a></li><li><a class="social-follow-patreon" title="Support me on Patreon!" href="https://www.patreon.com/justinle/overview">Patreon</a></li><li><a class="social-follow-gplus" title="Add me on Google+!" href="https://plus.google.com/+JustinLe">Google+</a></li><li><a class="social-follow-keybase" title="Track me on Keybase!" href="https://keybase.io/mstksg">Keybase</a></li><li><a class="social-follow-linkedin" title="Connect with me on LinkedIn!" href="https://linkedin.com/in/lejustin">LinkedIn</a></li><li><a class="social-follow-bitcoin" title="Donate via bitcoin!" href="bitcoin:3D7rmAYgbDnp4gp4rf22THsGt74fNucPDU">Bitcoin</a></li></ul></li><li><ul class="social-follows-list-site"><li><a class="social-follow-rss" title="Subscribe to my RSS Feed!" href="http://feeds.feedburner.com/incodeblog">RSS</a></li><li><a class="social-follow-email" title="Subscribe to the mailing list!" href="https://feedburner.google.com/fb/a/mailverify?loc=en_US&amp;uri=incodeblog">Mailing list</a></li></ul></li></ul></div></div></div></div></body></html>